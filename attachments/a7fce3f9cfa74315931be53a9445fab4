diff -aruw dmd62/backend/cdef.h dmd63/backend/cdef.h
--- dmd62/backend/cdef.h	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/cdef.h	2010-08-09 14:33:14.000000000 -0400
@@ -137,9 +137,9 @@
 #ifndef CDEF_H
 #define CDEF_H  1
 
-#define VERSION "8.52.5"        // for banner and imbedding in .OBJ file
-#define VERSIONHEX "0x852"      // for __DMC__ macro
-#define VERSIONINT 0x852        // for precompiled headers and DLL version
+#define VERSION "8.53.0"        // for banner and imbedding in .OBJ file
+#define VERSIONHEX "0x853"      // for __DMC__ macro
+#define VERSIONINT 0x853        // for precompiled headers and DLL version
 
 
 /***********************************
@@ -407,7 +407,7 @@
 /* Take advantage of machines that can store a word, lsb first  */
 #if _M_I86              // if Intel processor
 #define TOWORD(ptr,val) (*(unsigned short *)(ptr) = (unsigned short)(val))
-#define TOLONG(ptr,val) (*(unsigned long *)(ptr) = (unsigned long)(val))
+#define TOLONG(ptr,val) (*(unsigned *)(ptr) = (unsigned)(val))
 #else
 #define TOWORD(ptr,val) (((ptr)[0] = (unsigned char)(val)),\
                          ((ptr)[1] = (unsigned char)((val) >> 8)))
@@ -428,8 +428,8 @@
 typedef signed char     targ_schar;
 typedef short           targ_short;
 typedef unsigned short  targ_ushort;
-typedef long            targ_long;
-typedef unsigned long   targ_ulong;
+typedef int             targ_long;
+typedef unsigned        targ_ulong;
 #if LONGLONG
 typedef long long               targ_llong;
 typedef unsigned long long      targ_ullong;
@@ -444,8 +444,8 @@
 // Extract most significant register from constant
 #define MSREG(p)        ((REGSIZE == 2) ? (p) >> 16 : ((sizeof(targ_llong) == 8) ? (p) >> 32 : 0))
 
-typedef long            targ_int;
-typedef unsigned long   targ_uns;
+typedef int             targ_int;
+typedef unsigned        targ_uns;
 
 /* Sizes of base data types in bytes */
 
@@ -477,8 +477,13 @@
 #define FPTRSIZE        tysize[TYfptr]
 #define REGMASK         0xFFFF
 
+#if TARGET_LINUX
+typedef targ_llong      targ_ptrdiff_t; /* ptrdiff_t for target machine  */
+typedef targ_ullong     targ_size_t;    /* size_t for the target machine */
+#else
 typedef targ_int        targ_ptrdiff_t; /* ptrdiff_t for target machine  */
 typedef targ_uns        targ_size_t;    /* size_t for the target machine */
+#endif
 
 /* Enable/disable various features
    (Some features may no longer work the old way when compiled out,
@@ -554,15 +559,9 @@
 #define KEEPBITFIELDS 0 /* 0 means code generator cannot handle bit fields, */
                         /* so replace them with shifts and masks        */
 
-#if TARGET_OSX
-#define STACKALIGN      16
-#else
-#define STACKALIGN      0
-#endif
-
-#define REGMAX  10      // registers are numbered 0..10
+#define REGMAX  29      // registers are numbered 0..10
 
-typedef unsigned long   tym_t;          // data type big enough for type masks
+typedef unsigned        tym_t;          // data type big enough for type masks
 typedef int             SYMIDX;         // symbol table index
 
 #if 0
@@ -715,7 +714,7 @@
 /* CFGX: flags ignored in precompiled headers
  * CFGY: flags copied from precompiled headers into current config
  */
-    unsigned long flags;
+    unsigned flags;
 #define CFGuchar        1       // chars are unsigned
 #define CFGsegs         2       // new code seg for each far func
 #define CFGtrace        4       // output trace functions
@@ -729,7 +728,7 @@
 #define CFGnoinlines    0x1000  // do not inline functions
 #define CFGnowarning    0x8000  // disable warnings
 #define CFGX    (CFGnowarning)
-    unsigned long flags2;
+    unsigned flags2;
 #define CFG2comdat      1       // use initialized common blocks
 #define CFG2nodeflib    2       // no default library imbedded in OBJ file
 #define CFG2browse      4       // generate browse records
@@ -749,7 +748,7 @@
 #define CFGX2   (CFG2warniserr | CFG2phuse | CFG2phgen | CFG2phauto | \
                  CFG2once | CFG2hdrdebug | CFG2noobj | CFG2noerrmax | \
                  CFG2expand | CFG2nodeflib)
-    unsigned long flags3;
+    unsigned flags3;
 #define CFG3ju          1       // char == unsigned char
 #define CFG3eh          4       // generate exception handling stuff
 #define CFG3strcod      8       // strings are placed in code segment
@@ -779,7 +778,7 @@
 #define CFG3pic         0x80000 // position independent code
 #define CFGX3   (CFG3strcod | CFG3ptrchk)
 
-    unsigned long flags4;
+    unsigned flags4;
 #define CFG4speed       1       // optimized for speed
 #define CFG4space       2       // optimized for space
 #define CFG4optimized   (CFG4speed | CFG4space)
@@ -816,7 +815,7 @@
                          CFG4enumoverload | CFG4implicitfromvoid | \
                          CFG4wchar_is_long | CFG4underscore)
 
-    unsigned long flags5;
+    unsigned flags5;
 #define CFG5debug       1       // compile in __debug code
 #define CFG5in          2       // compile in __in code
 #define CFG5out         4       // compile in __out code
@@ -859,7 +858,7 @@
 struct LIST;
 struct elem;
 
-typedef unsigned short regm_t;  // Register mask type
+typedef unsigned regm_t;        // Register mask type
 struct immed_t
 {   targ_int value[REGMAX];     // immediate values in registers
     regm_t mval;                // Mask of which values in regimmed.value[] are valid
@@ -977,9 +976,9 @@
 #define UNIXFIELDS
 #endif
 
-typedef unsigned long SYMFLGS;
+typedef unsigned SYMFLGS;
 #if MARS
-#define SYM_PREDEF_SZ 35
+#define SYM_PREDEF_SZ 40
 #else
 #define SYM_PREDEF_SZ 22
 #endif
diff -aruw dmd62/backend/cg87.c dmd63/backend/cg87.c
--- dmd62/backend/cg87.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/cg87.c	2010-08-09 14:33:14.000000000 -0400
@@ -1,5 +1,5 @@
 // Copyright (C) 1987-1995 by Symantec
-// Copyright (C) 2000-2009 by Digital Mars
+// Copyright (C) 2000-2010 by Digital Mars
 // All Rights Reserved
 // http://www.digitalmars.com
 // Written by Walter Bright
@@ -97,26 +97,26 @@
  */
 
 code *ndp_fstp(code *c, int i, tym_t ty)
-{
+{   unsigned grex = I64 ? (REX_W << 16) : 0;
     switch (tybasic(ty))
     {
         case TYfloat:
         case TYifloat:
         case TYcfloat:
-            c = genc1(c,0xD9,modregrm(2,3,BPRM),FLndp,i); // FSTP m32real i[BP]
+            c = genc1(c,0xD9,grex | modregrm(2,3,BPRM),FLndp,i); // FSTP m32real i[BP]
             break;
 
         case TYdouble:
         case TYdouble_alias:
         case TYidouble:
         case TYcdouble:
-            c = genc1(c,0xDD,modregrm(2,3,BPRM),FLndp,i); // FSTP m64real i[BP]
+            c = genc1(c,0xDD,grex | modregrm(2,3,BPRM),FLndp,i); // FSTP m64real i[BP]
             break;
 
         case TYldouble:
         case TYildouble:
         case TYcldouble:
-            c = genc1(c,0xDB,modregrm(2,7,BPRM),FLndp,i); // FSTP m80real i[BP]
+            c = genc1(c,0xDB,grex | modregrm(2,7,BPRM),FLndp,i); // FSTP m80real i[BP]
             break;
 
         default:
@@ -126,26 +126,26 @@
 }
 
 code *ndp_fld(code *c, int i, tym_t ty)
-{
+{   unsigned grex = I64 ? (REX_W << 16) : 0;
     switch (tybasic(ty))
     {
         case TYfloat:
         case TYifloat:
         case TYcfloat:
-            c = genc1(c,0xD9,modregrm(2,0,BPRM),FLndp,i);
+            c = genc1(c,0xD9,grex | modregrm(2,0,BPRM),FLndp,i);
             break;
 
         case TYdouble:
         case TYdouble_alias:
         case TYidouble:
         case TYcdouble:
-            c = genc1(c,0xDD,modregrm(2,0,BPRM),FLndp,i);
+            c = genc1(c,0xDD,grex | modregrm(2,0,BPRM),FLndp,i);
             break;
 
         case TYldouble:
         case TYildouble:
         case TYcldouble:
-            c = genc1(c,0xDB,modregrm(2,5,BPRM),FLndp,i); // FLD m80real i[BP]
+            c = genc1(c,0xDB,grex | modregrm(2,5,BPRM),FLndp,i); // FLD m80real i[BP]
             break;
 
         default:
@@ -445,16 +445,12 @@
 {   code *c;
 
     // Look on 8087 stack
-    int i;
-
-    i = cse_get(e, 0);
+    int i = cse_get(e, 0);
 
     if (tycomplex(e->Ety))
-    {   unsigned sz;
-        int j;
-
-        sz = tysize(e->Ety);
-        j = cse_get(e, sz / 2);
+    {
+        unsigned sz = tysize(e->Ety);
+        int j = cse_get(e, sz / 2);
         if (i >= 0 && j >= 0)
         {
             c = push87();
@@ -484,6 +480,7 @@
     return c;
 }
 
+
 /**************************
  * Generate code to deal with floatreg.
  */
@@ -494,7 +491,8 @@
         reflocal = TRUE;
         if ((opcode & 0xF8) == 0xD8)
             c = genfwait(c);
-        return genc1(c,opcode,modregrm(2,reg,BPRM),FLfltreg,offset);
+        unsigned grex = I64 ? (REX_W << 16) : 0;
+        return genc1(c,opcode,grex | modregxrm(2,reg,BPRM),FLfltreg,offset);
 }
 
 /*******************************
@@ -759,21 +757,18 @@
     if (*pretregs & mST0 && retregs & (mBP | ALLREGS))
     {
         assert(sz <= DOUBLESIZE);
-        if (I32)
+        if (!I16)
         {
 
             if (*pretregs & mPSW)
             {   // Set flags
-                regm_t r;
-
-                r = retregs | mPSW;
+                regm_t r = retregs | mPSW;
                 c1 = fixresult(e,retregs,&r);
             }
             c2 = push87();
-            if (sz == REGSIZE)
-            {   unsigned reg;
-
-                reg = findreg(retregs);
+            if (sz == REGSIZE || (I64 && sz == 4))
+            {
+                unsigned reg = findreg(retregs);
                 c2 = genfltreg(c2,0x89,reg,0);          // MOV fltreg,reg
                 genfltreg(c2,0xD9,0,0);                 // FLD float ptr fltreg
             }
@@ -813,7 +808,7 @@
         c2 = allocreg(pretregs,&reg,(sz == FLOATSIZE) ? TYfloat : TYdouble);
         if (sz == FLOATSIZE)
         {
-            if (I32)
+            if (!I16)
                 c2 = genfltreg(c2,0x8B,reg,0);
             else
             {   c2 = genfltreg(c2,0x8B,reg,REGSIZE);
@@ -822,7 +817,7 @@
         }
         else
         {
-            if (I32)
+            if (!I16)
             {   c2 = genfltreg(c2,0x8B,reg,REGSIZE);
                 genfltreg(c2,0x8B,findreglsw(*pretregs),0);
             }
@@ -1398,9 +1393,8 @@
     note87(e1,0,0);
 
     if (config.flags4 & CFG4fdivcall && e->Eoper == OPdiv)
-    {   regm_t retregs;
-
-        retregs = mST0;
+    {
+        regm_t retregs = mST0;
         c2 = load87(e2,0,&retregs,e1,-1);
         c2 = cat(c2,makesure87(e1,0,1,0));
         if (op == 7)                    // if reverse divide
@@ -1426,9 +1420,7 @@
          *              jp      FM1                     // continue till ST < ST1
          *              fstp    ST(1)                   // leave remainder on stack
          */
-        regm_t retregs;
-
-        retregs = mST0;
+        regm_t retregs = mST0;
         c2 = load87(e2,0,&retregs,e1,-1);
         c2 = cat(c2,makesure87(e1,0,1,0));      // now have x,y on stack; need y,x
         if (!reverse)                           // if not reverse modulo
@@ -1530,7 +1522,7 @@
             cs.Iflags = CFwait;
         else
             cs.Iflags = 0;
-        cs.Ijty = 0;
+        cs.Irex = 0;
         opr = oprev[op + 1];
         ty = tybasic(e->Ety);
         if ((ty == TYldouble || ty == TYildouble) &&
@@ -1609,7 +1601,7 @@
                     cs.Iop = ESC(mf1,0);
                     if (ADDFWAIT())
                         cs.Iflags |= CFwait;
-                    if (I32)
+                    if (!I16)
                         cs.Iflags &= ~CFopsize;
                     if (op != -1)
                     {   cs.Irm |= modregrm(0,op,0);
@@ -1648,7 +1640,7 @@
                     cs.Iop = 0xDF;
                     if (ADDFWAIT())
                         cs.Iflags |= CFwait;
-                    if (I32)
+                    if (!I16)
                         cs.Iflags &= ~CFopsize;
                     c = cat(c,push87());
                     cs.Irm |= modregrm(0,5,0);
@@ -1887,7 +1879,7 @@
         // Doesn't work if ST(0) gets saved to the stack by getlvalue()
         c2 = loadea(e->E1,&cs,op1,op2,0,0,0);
 #else
-        cs.Ijty = 0;
+        cs.Irex = 0;
         cs.Iflags = 0;
         cs.Iop = op1;
         if (*pretregs & (mST0 | ALLREGS | mBP)) // if want result on stack too
@@ -1924,7 +1916,8 @@
             c2 = gen(c2, &cs);
         }
 #endif
-#if LNGDBLSIZE == 16
+        if (tysize[TYldouble] == 16)
+        {
         /* This deals with the fact that 10 byte reals really
          * occupy 16 bytes by zeroing the extra 6 bytes.
          */
@@ -1942,7 +1935,7 @@
             cs.Iflags &= ~CFopsize;
             c2 = gen(c2, &cs);
         }
-#endif
+        }
 #endif
         c2 = genfwait(c2);
         freenode(e->E1);
@@ -1967,7 +1960,7 @@
 
         assert(e->Eoper == OPeq);
         cs.Iflags = ADDFWAIT() ? CFwait : 0;
-        cs.Ijty = 0;
+        cs.Irex = 0;
         retregs = mST01 | (*pretregs & mPSW);
         c1 = codelem(e->E2,&retregs,FALSE);
         ty1 = tybasic(e->E1->Ety);
@@ -2004,7 +1997,7 @@
         if (*pretregs & mST01)
         {
             cs.Iflags = 0;
-            cs.Ijty = 0;
+            cs.Irex = 0;
             cs.Iop = op1;
             c2 = getlvalue(&cs, e->E1, 0);
             cs.IEVoffset1 += sz;
@@ -2039,7 +2032,8 @@
             c2 = gen(c2, &cs);                  // MOV EA+22,0
         }
 #endif
-#if LNGDBLSIZE == 16
+        if (tysize[TYldouble] == 16)
+        {
         if (op1 == 0xDB)
         {
             cs.Iop = 0xC7;                      // MOV EA+10,0
@@ -2062,7 +2056,7 @@
             cs.Iflags &= ~CFopsize;
             c2 = gen(c2, &cs);
         }
-#endif
+        }
         c2 = genfwait(c2);
         freenode(e->E1);
         return cat3(c1,c2,fixresult_complex87(e,mST01 | mPSW,pretregs));
@@ -2297,7 +2291,7 @@
     cl = getlvalue(&cs,e->E1,0);
     cl = cat(cl,makesure87(e->E2,0,0,0));
     cs.Iflags |= ADDFWAIT() ? CFwait : 0;
-    if (I32)
+    if (!I16)
         cs.Iflags &= ~CFopsize;
 
     c = push87();
@@ -2409,7 +2403,7 @@
         cl = cat(cl,makesure87(e->E2,0,1,0));
     }
     cs.Iflags |= ADDFWAIT() ? CFwait : 0;
-    if (I32)
+    if (!I16)
         cs.Iflags &= ~CFopsize;
 
     switch (e->Eoper)
@@ -2597,7 +2591,7 @@
         case OPdivass:
             c = push87();
             c = cat(c, push87());
-            idxregs = idxregm(cs.Irm,cs.Isib);  // mask of index regs used
+            idxregs = idxregm(&cs);             // mask of index regs used
             if (ty1 == TYcldouble)
             {
                 cs.Iop = 0xDB;
@@ -2668,9 +2662,10 @@
     sz = tysize[tyml];
 
     cl = getlvalue(&cs,e1,0);
-    cr = modEA(cs.Irm);
+    cr = modEA(&cs);
     cs.Irm |= modregrm(0,6,0);
     cs.Iop = 0x80;
+    cs.Irex = 0;
 #if LNGDBLSIZE > 10
     if (tyml == TYldouble || tyml == TYildouble)
         cs.IEVoffset1 += 10 - 1;
@@ -2734,7 +2729,7 @@
         assert(*pretregs);
         cl = getlvalue(&cs,e->E1,0);
         cs.Iflags |= ADDFWAIT() ? CFwait : 0;
-        if (I32)
+        if (!I16)
             cs.Iflags &= ~CFopsize;
         ty1 = tybasic(e->E1->Ety);
         switch (ty1)
@@ -2821,6 +2816,7 @@
         tym = e->Ety;
         sz = tysize(tym);
         szoff = sz;
+        unsigned grex = I64 ? REX_W << 16 : 0;
 
         switch (e->Eoper)
         {   case OPd_s16:
@@ -2847,7 +2843,7 @@
                 assert(0);
         }
 
-        if (!I32)                       // C may change the default control word
+        if (I16)                       // C may change the default control word
         {
             if (clib == CLIBdblllng)
             {   retregs = I32 ? DOUBLEREGS_32 : DOUBLEREGS_16;
@@ -2883,17 +2879,17 @@
             if (szpush == REGSIZE)
                 c1 = gen1(c1,0x50 + AX);                // PUSH EAX
             else
-                c1 = genc2(c1,0x81,modregrm(3,5,SP), szpush);   // SUB ESP,12
+                c1 = genc2(c1,0x81,grex | modregrm(3,5,SP), szpush);   // SUB ESP,12
             c1 = genfwait(c1);
-            genc1(c1,0xD9,modregrm(2,7,4) + 256*modregrm(4,4,SP),FLconst,szoff); // FSTCW szoff[ESP]
+            genc1(c1,0xD9,grex | modregrm(2,7,4) + 256*modregrm(0,4,SP),FLconst,szoff); // FSTCW szoff[ESP]
 
             c1 = genfwait(c1);
 
             if (config.flags3 & CFG3pic)
             {
-                genc(c1,0xC7,modregrm(2,0,4) + 256*modregrm(4,4,SP),FLconst,szoff+2,FLconst,CW_roundto0); // MOV szoff+2[ESP], CW_roundto0
+                genc(c1,0xC7,grex | modregrm(2,0,4) + 256*modregrm(0,4,SP),FLconst,szoff+2,FLconst,CW_roundto0); // MOV szoff+2[ESP], CW_roundto0
                 code_orflag(c1, CFopsize);
-                genc1(c1,0xD9,modregrm(2,5,4) + 256*modregrm(4,4,SP),FLconst,szoff+2); // FLDCW szoff+2[ESP]
+                genc1(c1,0xD9,grex | modregrm(2,5,4) + 256*modregrm(0,4,SP),FLconst,szoff+2); // FLDCW szoff+2[ESP]
             }
             else
                 c1 = genrnd(c1, CW_roundto0);   // FLDCW roundto0
@@ -2901,7 +2897,7 @@
             pop87();
 
             c1 = genfwait(c1);
-            gen2sib(c1,mf,modregrm(0,rf,4),modregrm(4,4,SP));                   // FISTP [ESP]
+            gen2sib(c1,mf,grex | modregrm(0,rf,4),modregrm(0,4,SP));                   // FISTP [ESP]
 
             retregs = *pretregs & (ALLREGS | mBP);
             if (!retregs)
@@ -2909,17 +2905,17 @@
             c2 = allocreg(&retregs,&reg,tym);
 
             c2 = genfwait(c2);                                                          // FWAIT
-            c2 = genc1(c2,0xD9,modregrm(2,5,4) + 256*modregrm(4,4,SP),FLconst,szoff);   // FLDCW szoff[ESP]
+            c2 = genc1(c2,0xD9,grex | modregrm(2,5,4) + 256*modregrm(0,4,SP),FLconst,szoff);   // FLDCW szoff[ESP]
 
             if (szoff > REGSIZE)
             {   szpush -= REGSIZE;
-                c2 = gen1(c2,0x58 + findreglsw(retregs));       // POP lsw
+                c2 = genpop(c2,findreglsw(retregs));       // POP lsw
             }
             szpush -= REGSIZE;
-            c2 = gen1(c2,0x58 + reg);                           // POP reg
+            c2 = genpop(c2,reg);                           // POP reg
 
             if (szpush)
-                genc2(c2,0x81,modregrm(3,0,SP), szpush);        // ADD ESP,4
+                genc2(c2,0x81,grex | modregrm(3,0,SP), szpush);        // ADD ESP,4
             c2 = cat(c2,fixresult(e,retregs,pretregs));
         }
         else
@@ -3179,7 +3175,7 @@
         code cs;
         cs.Iop = 0xD9;
         cs.Iflags = CFoff;
-        cs.Ijty = 0;
+        cs.Irex = 0;
         cs.IEVsym1 = rnddir;
         cs.IFL1 = rnddir->Sfl;
         cs.IEVoffset1 = 0;
diff -aruw dmd62/backend/cg.c dmd63/backend/cg.c
--- dmd62/backend/cg.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/cg.c	2010-08-09 14:33:14.000000000 -0400
@@ -41,7 +41,7 @@
         Poff,Aoff;              // comsubexps, params, regs, autos
 
 /* The following are initialized for the 8088. cod3_set386() will
-   change them if generating code for the 386.
+ * change them if generating code for the 386, cod3_set64() for 64 bit code.
  */
 int     BPRM = 6;               /* R/M value for [BP] or [EBP]          */
 regm_t  fregsaved = mBP | mSI | mDI;    // mask of registers saved across
@@ -53,3 +53,9 @@
 
 symbol *localgot;               // reference to GOT for this function
 symbol *tls_get_addr_sym;       // function __tls_get_addr
+
+#if TARGET_OSX
+int STACKALIGN = 16;
+#else
+int STACKALIGN = 0;
+#endif
diff -aruw dmd62/backend/cgcod.c dmd63/backend/cgcod.c
--- dmd62/backend/cgcod.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/cgcod.c	2010-08-09 14:33:14.000000000 -0400
@@ -36,7 +36,6 @@
 STATIC code * loadcse(elem *,unsigned,regm_t);
 STATIC void blcodgen(block *);
 STATIC void cgcod_eh();
-STATIC int numbitsset(regm_t);
 STATIC code * cse_save(regm_t ms);
 STATIC int cse_simple(elem *e,int i);
 STATIC code * comsub(elem *,regm_t *);
@@ -140,6 +139,8 @@
         ALLREGS = ALLREGS_INIT;
         BYTEREGS = value;
     }
+    if (I64)
+        ALLREGS = mAX|mBX|mCX|mDX|mSI|mDI| mR8|mR9|mR10|mR11|mR12|mR13|mR14|mR15;
 #endif
     allregs = ALLREGS;
     if (0 && config.flags3 & CFG3pic)
@@ -194,8 +195,7 @@
 #endif
         msavereg = 0;
     nretblocks = 0;
-    mfuncreg = fregsaved;
-//  mfuncreg = mBP|mES|ALLREGS;         // so we can see which are used
+    mfuncreg = fregsaved;               // so we can see which are used
                                         // (bit is cleared each time
                                         //  we use one)
     for (b = startblock; b; b = b->Bnext)
@@ -946,7 +946,7 @@
         case BCjcatch:
             // Mark all registers as destroyed. This will prevent
             // register assignments to variables used in catch blocks.
-            c = cat(c,getregs(I32 ? allregs : (ALLREGS | mES)));
+            c = cat(c,getregs((I32 | I64) ? allregs : (ALLREGS | mES)));
 #if 0 && TARGET_LINUX
             if (config.flags3 & CFG3pic && !(allregs & mBX))
             {
@@ -1357,10 +1357,10 @@
         stack = NULL;
         for (c = b->Bcode; c; c = code_next(c))
         {
-            if (c->Iop == ESCAPE)
+            if ((c->Iop & 0xFF) == ESCAPE)
             {
                 c1 = NULL;
-                switch (c->Iop2)
+                switch (c->Iop & 0xFF00)
                 {
                     case ESCctor:
 //printf("ESCctor\n");
@@ -1396,7 +1396,7 @@
                             }
                             else
                             {   except_pair_append(c,idx - 1);
-                                c->Iop2 = ESCoffset;
+                                c->Iop = ESCAPE | ESCoffset;
                             }
                         }
                         except_release();
@@ -1509,8 +1509,11 @@
         case TYsptr:
         case TYcptr:
             return mAX;
+
         case TYfloat:
         case TYifloat:
+            if (I64)
+                return mXMM0;
             if (config.exe & EX_flat)
                 return mST0;
         case TYlong:
@@ -1521,27 +1524,40 @@
         case TYfptr:
         case TYhptr:
             return mDX | mAX;
+
+        case TYcent:
+        case TYucent:
+            assert(I64);
+            return mDX | mAX;
+
         case TYvptr:
             return mDX | mBX;
+
         case TYdouble:
         case TYdouble_alias:
         case TYidouble:
+            if (I64)
+                return mXMM0;
             if (config.exe & EX_flat)
                 return mST0;
             return DOUBLEREGS;
+
         case TYllong:
         case TYullong:
-            return I32 ? mDX | mAX : DOUBLEREGS;
+            return I64 ? mAX : (I32 ? mDX | mAX : DOUBLEREGS);
+
         case TYldouble:
         case TYildouble:
             return mST0;
 
         case TYcfloat:
 #if TARGET_LINUX || TARGET_OSX || TARGET_FREEBSD || TARGET_SOLARIS
-            if (tybasic(tyf) == TYnfunc)
+            if (I32 && tybasic(tyf) == TYnfunc)
                 return mDX | mAX;
 #endif
         case TYcdouble:
+            if (I64)
+                return mXMM0 | mXMM1;
         case TYcldouble:
             return mST01;
 
@@ -1558,7 +1574,7 @@
  * Count the number of bits set in a register mask.
  */
 
-STATIC int numbitsset(regm_t regm)
+int numbitsset(regm_t regm)
 {   int n;
 
     n = 0;
@@ -1584,13 +1600,27 @@
 #ifdef DEBUG
 #define findreg(regm) findreg((regm),__LINE__,__FILE__)
 #endif
-{ int i;
-
-  for (i = 0; i < REGMAX; i++)
-        if (mask[i] & regm)
+{
+#ifdef DEBUG
+    regm_t regmsave = regm;
+#endif
+    int i = 0;
+    while (1)
+    {
+        if (!(regm & 0xF))
+        {
+            regm >>= 4;
+            i += 4;
+            if (!regm)
+                break;
+        }
+        if (regm & 1)
                 return i;
+        regm >>= 1;
+        i++;
+    }
 #ifdef DEBUG
-  printf("findreg(x%x, line=%d, file='%s')\n",regm,line,file);
+  printf("findreg(x%x, line=%d, file='%s')\n",regmsave,line,file);
   fflush(stdout);
 #endif
   assert(0);
@@ -1606,7 +1636,7 @@
  */
 
 void freenode(elem *e)
-{ register unsigned i;
+{ unsigned i;
 
   elem_debug(e);
   //dbg_printf("freenode(%p) : comsub = %d, count = %d\n",e,e->Ecomsub,e->Ecount);
@@ -1763,7 +1793,7 @@
 #endif
         tym = tybasic(tym);
         size = tysize[tym];
-        *pretregs &= mES | allregs;
+        *pretregs &= mES | allregs | XMMREGS;
         retregs = *pretregs;
         if ((retregs & regcon.mvar) == retregs) // if exactly in reg vars
         {
@@ -1871,7 +1901,7 @@
             reg = (msreg == ES) ? lsreg : msreg;
             retregs = mask[msreg] | mask[lsreg];
         }
-        else if (!I32 && (tym == TYdouble || tym == TYdouble_alias))
+        else if (I16 && (tym == TYdouble || tym == TYdouble_alias))
         {
 #ifdef DEBUG
             if (retregs != DOUBLEREGS)
@@ -1884,7 +1914,7 @@
         {
 #ifdef DEBUG
             WRTYxx(tym);
-            printf("\nallocreg: fil %s lin %d, regcon.mvar x%x msavereg x%x *pretregs x%x, reg %d, tym x%lx\n",
+            printf("\nallocreg: fil %s lin %d, regcon.mvar x%x msavereg x%x *pretregs x%x, reg %d, tym x%x\n",
                 file,line,regcon.mvar,msavereg,*pretregs,*preg,tym);
 #endif
             assert(0);
@@ -1945,7 +1975,7 @@
  */
 
 STATIC code * cse_save(regm_t ms)
-{   register unsigned reg,i,op;
+{   unsigned reg,i,op;
     code *c = NULL;
     regm_t regm;
 
@@ -2027,7 +2057,7 @@
                 {   reg = 0;            // the real reg number
                     op = 0x8C;          // segment reg mov
                 }
-                c = genc1(c,op,modregrm(2,reg,BPRM),FLcs,(targ_uns) i);
+                c = genc1(c,op,modregxrm(2, reg, BPRM),FLcs,(targ_uns) i);
                 reflocal = TRUE;
             }
         }
@@ -2076,7 +2106,7 @@
     int sz;
 
     sz = tysize[tybasic(e->Ety)];
-    if (I32 &&                                  // don't bother with 16 bit code
+    if (!I16 &&                                  // don't bother with 16 bit code
         e->Eoper == OPadd &&
         sz == REGSIZE &&
         e->E2->Eoper == OPconst &&
@@ -2100,7 +2130,7 @@
         sz <= REGSIZE &&
         e->E1->Eoper == OPvar &&
         isregvar(e->E1,&regm,&reg) &&
-        (I32 || regm & IDXREGS) &&
+        (I32 || I64 || regm & IDXREGS) &&
         !(e->E1->EV.sp.Vsym->Sflags & SFLspill)
        )
     {
@@ -2134,7 +2164,7 @@
   if (e->Ecount && e->Ecomsub)
   {
         //printf("cssave(e = %p, regm = x%x, opsflag = %d)\n", e, regm, opsflag);
-        if (!opsflag && pass != PASSfinal && I32)
+        if (!opsflag && pass != PASSfinal && (I32 || I64))
             return;
 
         //printf("cssave(e = %p, regm = x%x, opsflag = x%x)\n", e, regm, opsflag);
@@ -2190,7 +2220,7 @@
         if (e->Ecount == e->Ecomsub)    /* elem is a CSE that needs     */
                                         /* to be generated              */
         {
-            if (I32 && pass == PASSfinal && sz <= REGSIZE)
+            if ((I32 || I64) && pass == PASSfinal && sz <= REGSIZE)
             {
                 // Do it only if at least 2 registers are available
                 regm_t m;
@@ -2338,7 +2368,7 @@
                             retregs = allregs;
                         c = allocreg(&retregs,&reg,tym);
                         cr = &csextab[i].csimple;
-                        NEWREG(cr->Irm,reg);
+                        cr->setReg(reg);
                         c = gen(c,cr);
                         goto L10;
                     }
@@ -2350,7 +2380,7 @@
                         {                       // CMP cs[BP],0
                             c = genc(NULL,0x81 ^ byte,modregrm(2,7,BPRM),
                                         FLcs,i, FLconst,(targ_uns) 0);
-                            if (REGSIZE == 4 && sz == 2)
+                            if (I32 && sz == 2)
                                 c->Iflags |= CFopsize;
                         }
                         else
@@ -2360,7 +2390,7 @@
                                     retregs = BYTEREGS;
                             c = allocreg(&retregs,&reg,tym);
                                             // MOV reg,cs[BP]
-                            c = genc1(c,0x8B,modregrm(2,reg,BPRM),FLcs,(targ_uns) i);
+                            c = genc1(c,0x8B,modregxrm(2,reg,BPRM),FLcs,(targ_uns) i);
                         L10:
                             regcon.cse.mval |= mask[reg]; // cs is in a reg
                             regcon.cse.value[reg] = e;
@@ -2429,7 +2459,7 @@
   }
   else if (tym == TYdouble || tym == TYdouble_alias)    // double
   {
-        assert(!I32);
+        assert(I16);
         if (((csemask | emask) & DOUBLEREGS_16) == DOUBLEREGS_16)
         {
             for (reg = AX; reg != -1; reg = dblreg[reg])
@@ -2449,7 +2479,7 @@
   else
   {
 #if DEBUG
-        printf("e = %p, tym = x%lx\n",e,tym);
+        printf("e = %p, tym = x%x\n",e,tym);
 #endif
         assert(0);
   }
@@ -2506,7 +2536,7 @@
                 {       op = 0x8E;
                         reg = 0;
                 }
-                return genc1(c,op,modregrm(2,reg,BPRM),FLcs,(targ_uns) i);
+                return genc1(c,op,modregxrm(2,reg,BPRM),FLcs,(targ_uns) i);
         }
   }
 #if DEBUG
@@ -2631,6 +2661,8 @@
                 case TYulong:
                 case TYllong:
                 case TYullong:
+                case TYcent:
+                case TYucent:
 #if !TARGET_FLAT
                 case TYfptr:
                 case TYhptr:
@@ -2668,7 +2700,7 @@
 const char *regm_str(regm_t rm)
 {
     #define NUM 4
-    #define SMAX 30
+    #define SMAX 64
     static char str[NUM][SMAX + 1];
     static int i;
     char *p;
@@ -2688,7 +2720,7 @@
         i = 0;
     s = p;
     *p = 0;
-    for (j = 0; j < 16; j++)
+    for (j = 0; j < 23; j++)
     {
         if (mask[j] & rm)
         {
diff -aruw dmd62/backend/cgcs.c dmd63/backend/cgcs.c
--- dmd62/backend/cgcs.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/cgcs.c	2010-08-09 14:33:14.000000000 -0400
@@ -470,14 +470,14 @@
     hash = e->Ety + op;
 #endif
     if (!OTleaf(op))
-    {   hash += (int) e->E1;
+    {   hash += (size_t) e->E1;
         if (OTbinary(op))
-                hash += (int) e->E2;
+                hash += (size_t) e->E2;
     }
     else
     {   hash += e->EV.Vint;
         if (op == OPvar || op == OPrelconst)
-                hash += (int) e->EV.sp.Vsym;
+                hash += (size_t) e->EV.sp.Vsym;
     }
     return hash;
 }
diff -aruw dmd62/backend/cgen.c dmd63/backend/cgen.c
--- dmd62/backend/cgen.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/cgen.c	2010-08-09 14:33:14.000000000 -0400
@@ -1,5 +1,5 @@
 // Copyright (C) 1985-1998 by Symantec
-// Copyright (C) 2000-2009 by Digital Mars
+// Copyright (C) 2000-2010 by Digital Mars
 // All Rights Reserved
 // http://www.digitalmars.com
 // Written by Walter Bright
@@ -52,6 +52,28 @@
 }
 
 /*****************************
+ * Set rex bits on last code in list.
+ */
+
+void code_orrex(code *c,unsigned rex)
+{
+    if (rex && c)
+    {   while (c->next)
+            c = c->next;
+        c->Irex |= rex;
+    }
+}
+
+/**************************************
+ * Set the opcode fields in cs.
+ */
+code *setOpcode(code *c, code *cs, unsigned op)
+{
+    cs->Iop = op;
+    return c;
+}
+
+/*****************************
  * Concatenate two code lists together. Return pointer to result.
  */
 
@@ -135,13 +157,14 @@
 #ifdef DEBUG                            /* this is a high usage routine */
     assert(cs);
 #endif
+    assert(I64 || cs->Irex == 0);
     ce = code_calloc();
     *ce = *cs;
     if (config.flags4 & CFG4optimized &&
         ce->IFL2 == FLconst &&
         (ce->Iop == 0x81 || ce->Iop == 0x80) &&
         reghasvalue((ce->Iop == 0x80) ? BYTEREGS : ALLREGS,ce->IEV2.Vlong,&reg) &&
-        !(ce->Iflags & CFopsize && !I32)
+        !(ce->Iflags & CFopsize && I16)
        )
     {   // See if we can replace immediate instruction with register instruction
         static unsigned char regop[8] =
@@ -149,7 +172,7 @@
 
 //printf("replacing 0x%02x, val = x%lx\n",ce->Iop,ce->IEV2.Vlong);
         ce->Iop = regop[(ce->Irm & modregrm(0,7,0)) >> 3] | (ce->Iop & 1);
-        ce->Irm = (ce->Irm & modregrm(3,0,7)) | modregrm(0,reg,0);
+        code_newreg(ce, reg);
     }
     code_next(ce) = CNIL;
     if (c)
@@ -180,13 +203,8 @@
 
   cstart = ce = code_calloc();
   /*cxcalloc++;*/
-  if (op > 0xFF)
-  {     ce->Iop = op >> 8;
-        ce->Iop2 = op & 0xFF;
-  }
-  else
         ce->Iop = op;
-  ce->Irm = rm;
+  ce->Iea = rm;
   if (c)
   {     cstart = c;
         while (code_next(c)) c = code_next(c);  /* find end of list     */
@@ -203,6 +221,9 @@
   ce->Iop = op;
   ce->Irm = rm;
   ce->Isib = sib;
+  ce->Irex = (rm | (sib & (REX_B << 16))) >> 16;
+  if (sib & (REX_R << 16))
+        ce->Irex |= REX_X;
   if (c)
   {     cstart = c;
         while (code_next(c)) c = code_next(c);  /* find end of list     */
@@ -212,15 +233,31 @@
 }
 
 code *genregs(code *c,unsigned op,unsigned dstreg,unsigned srcreg)
-{ return gen2(c,op,modregrm(3,dstreg,srcreg)); }
+{ return gen2(c,op,modregxrmx(3,dstreg,srcreg)); }
 
 code *gentstreg(code *c,unsigned t)
 {
-    c = gen2(c,0x85,modregrm(3,t,t));   // TEST t,t
+    c = gen2(c,0x85,modregxrmx(3,t,t));   // TEST t,t
     code_orflag(c,CFpsw);
     return c;
 }
 
+code *genpush(code *c, unsigned reg)
+{
+    c = gen1(c, 0x50 + (reg & 7));
+    if (reg & 8)
+        code_orrex(c, REX_B);
+    return c;
+}
+
+code *genpop(code *c, unsigned reg)
+{
+    c = gen1(c, 0x58 + (reg & 7));
+    if (reg & 8)
+        code_orrex(c, REX_B);
+    return c;
+}
+
 /********************************
  * Generate an ASM sequence.
  */
@@ -258,6 +295,8 @@
                         c = genregs(c,0x8C,0,to);
                 else
                         c = genregs(c,0x89,from,to);
+                if (I64)
+                        code_orrex(c, REX_W);
         }
         return c;
 }
@@ -271,9 +310,9 @@
     code *cj;
     code *cnop;
 
-    cs.Iop = op;
+    cs.Iop = op & 0xFF;
     cs.Iflags = 0;
-    cs.Ijty = 0;
+    cs.Irex = 0;
     if (op != JMP)                      /* if not already long branch   */
           cs.Iflags = CFjmp16;          /* assume long branch for op = 0x7x */
     cs.IFL2 = fltarg;                   /* FLblock (or FLcode)          */
@@ -310,13 +349,12 @@
     return cat(c,cj);
 }
 
-code *gencs(code *c,unsigned op,unsigned rm,unsigned FL2,symbol *s)
+code *gencs(code *c,unsigned op,unsigned ea,unsigned FL2,symbol *s)
 {   code cs;
 
     cs.Iop = op;
-    cs.Irm = rm;
+    cs.Iea = ea;
     cs.Iflags = 0;
-    cs.Ijty = 0;
     cs.IFL2 = FL2;
     cs.IEVsym2 = s;
     cs.IEVoffset2 = 0;
@@ -324,20 +362,14 @@
     return gen(c,&cs);
 }
 
-code *genc2(code *c,unsigned op,unsigned rm,targ_uns EV2)
+code *genc2(code *c,unsigned op,unsigned ea,targ_size_t EV2)
 {   code cs;
 
-    if (op > 0xFF)
-    {   cs.Iop = op >> 8;
-        cs.Iop2 = op & 0xFF;
-    }
-    else
         cs.Iop = op;
-    cs.Irm = rm;
+    cs.Iea = ea;
     cs.Iflags = CFoff;
-    cs.Ijty = 0;
     cs.IFL2 = FLconst;
-    cs.IEV2.Vuns = EV2;
+    cs.IEV2.Vsize_t = EV2;
     return gen(c,&cs);
 }
 
@@ -345,18 +377,15 @@
  * Generate code.
  */
 
-code *genc1(code *c,unsigned op,unsigned rm,unsigned FL1,targ_uns EV1)
+code *genc1(code *c,unsigned op,unsigned ea,unsigned FL1,targ_size_t EV1)
 {   code cs;
 
     assert(FL1 < FLMAX);
-    assert(op < 256);
     cs.Iop = op;
-    cs.Irm = rm;
-    cs.Isib = rm >> 8;
     cs.Iflags = CFoff;
-    cs.Ijty = 0;
+    cs.Iea = ea;
     cs.IFL1 = FL1;
-    cs.IEV1.Vuns = EV1;
+    cs.IEV1.Vsize_t = EV1;
     return gen(c,&cs);
 }
 
@@ -364,21 +393,18 @@
  * Generate code.
  */
 
-code *genc(code *c,unsigned op,unsigned rm,unsigned FL1,targ_uns EV1,unsigned FL2,targ_uns EV2)
+code *genc(code *c,unsigned op,unsigned ea,unsigned FL1,targ_size_t EV1,unsigned FL2,targ_size_t EV2)
 {   code cs;
 
     assert(FL1 < FLMAX);
-    assert(op < 256);
     cs.Iop = op;
-    cs.Irm = rm;
-    cs.Isib = rm >> 8;
+    cs.Iea = ea;
     cs.Iflags = CFoff;
-    cs.Ijty = 0;
     cs.IFL1 = FL1;
-    cs.IEV1.Vuns = EV1;
+    cs.IEV1.Vsize_t = EV1;
     assert(FL2 < FLMAX);
     cs.IFL2 = FL2;
-    cs.IEV2.Vuns = EV2;
+    cs.IEV2.Vsize_t = EV2;
     return gen(c,&cs);
 }
 
@@ -398,13 +424,13 @@
         case 5:
             cs.Iop = LEA;
             cs.Iflags = 0;
-            cs.Ijty = 0;
+            cs.Irex = 0;
             buildEA(&cs,r2,r2,4,0);
-            cs.Irm |= modregrm(0,r1,0);
+            cs.orReg(r1);
             c = gen(c,&cs);
             break;
         default:
-            c = genc2(c,0x69,modregrm(3,r1,r2),imm);    // IMUL r1,r2,imm
+            c = genc2(c,0x69,modregxrmx(3,r1,r2),imm);    // IMUL r1,r2,imm
             break;
     }
     return c;
@@ -424,10 +450,9 @@
     printf("genlinnum(Sfilptr = %p, Slinnum = %u)\n", srcpos.Sfilptr, srcpos.Slinnum);
 #endif
 #endif
-    cs.Iop = ESCAPE;
-    cs.Iop2 = ESClinnum;
+    cs.Iop = ESCAPE | ESClinnum;
     cs.Iflags = 0;
-    cs.Ijty = 0;
+    cs.Irex = 0;
     cs.IFL1 = 0;
     cs.IFL2 = 0;
     cs.IEV2.Vsrcpos = srcpos;
@@ -460,12 +485,11 @@
 code *genadjesp(code *c, int offset)
 {   code cs;
 
-    if (I32 && offset)
+    if (!I16 && offset)
     {
-        cs.Iop = ESCAPE;
-        cs.Iop2 = ESCadjesp;
+        cs.Iop = ESCAPE | ESCadjesp;
         cs.Iflags = 0;
-        cs.Ijty = 0;
+        cs.Irex = 0;
         cs.IEV2.Vint = offset;
         return gen(c,&cs);
     }
@@ -512,24 +536,26 @@
  * Else
  *      don't care about flags
  * If flags & 1 then byte move
- * If flags & 2 then short move (for 386)
+ * If flags & 2 then short move (for I32 and I64)
  * If flags & 4 then don't disturb unused portion of register
+ * If flags & 16 then reg is a byte register AL..BH
+ * If flags & 64 then 64 bit move (I64 only)
  * Returns:
  *      code (if any) generated
  */
 
-code *movregconst(code *c,unsigned reg,targ_int value,regm_t flags)
+code *movregconst(code *c,unsigned reg,targ_size_t value,regm_t flags)
 {   unsigned r;
     regm_t regm;
     regm_t mreg;
-    targ_int regv;
+    targ_size_t regv;
 
 #define genclrreg(a,r) genregs(a,0x31,r,r)
 
     regm = regcon.immed.mval & mask[reg];
     regv = regcon.immed.value[reg];
 
-    if (flags & 1)
+    if (flags & 1)      // 8 bits
     {   unsigned msk;
 
         value &= 0xFF;
@@ -539,11 +565,14 @@
         if (regm && (regv & 0xFF) == value)
             goto L2;
 
-        if ((reg & 4) && regcon.immed.mval & mask[reg & 3] &&
+        if (flags & 16 && reg & 4 &&    // if an H byte register
+            regcon.immed.mval & mask[reg & 3] &&
             (((regv = regcon.immed.value[reg & 3]) >> 8) & 0xFF) == value)
             goto L2;
 
-        // Avoid byte register loads on Pentium Pro and Pentium II
+        /* Avoid byte register loads on Pentium Pro and Pentium II
+         * to avoid dependency stalls.
+         */
         if (config.flags4 & CFG4speed &&
             config.target_cpu >= TARGET_PentiumPro && !(flags & 4))
             goto L3;
@@ -558,7 +587,7 @@
                 {   c = genregs(c,0x8A,reg,r);          // MOV regL,rL
                     goto L2;
                 }
-                if (((regcon.immed.value[r] >> 8) & 0xFF) == value)
+                if (r < 4 && ((regcon.immed.value[r] >> 8) & 0xFF) == value)
                 {   c = genregs(c,0x8A,reg,r | 4);      // MOV regL,rH
                     goto L2;
                 }
@@ -568,7 +597,8 @@
 
         if (value == 0 && !(flags & 8))
         {
-            if (!(flags & 4) && !(reg & 4))
+            if (!(flags & 4) &&                 // if we can set the whole register
+                !(flags & 16 && reg & 4))       // and reg is not an H register
             {   c = genregs(c,0x31,reg,reg);    // XOR reg,reg
                 regimmed_set(reg,value);
                 regv = 0;
@@ -578,24 +608,27 @@
             flags &= ~mPSW;                     // flags already set by XOR
         }
         else
-            c = genc2(c,0xC6,modregrm(3,0,reg),value);  /* MOV regL,value */
+            c = genc2(c,0xC6,modregrmx(3,0,reg),value);  /* MOV regL,value */
     L2:
         if (flags & mPSW)
             genregs(c,0x84,reg,reg);            // TEST regL,regL
 
         if (regm)
-            regimmed_set(reg,(regv & 0xFFFFFF00) | value);
-        else if ((reg & 4) && regcon.immed.mval & mask[reg & 3])
-            regimmed_set((reg & 3),(regv & 0xFFFF00FF) | (value << 8));
+            // Set just the 'L' part of the register value
+            regimmed_set(reg,(regv & ~(targ_size_t)0xFF) | value);
+        else if (flags & 16 && reg & 4 && regcon.immed.mval & mask[reg & 3])
+            // Set just the 'H' part of the register value
+            regimmed_set((reg & 3),(regv & ~(targ_size_t)0xFF00) | (value << 8));
         return c;
     }
 L3:
-    if (!I32)
+    if (I16)
         value = (targ_short) value;             /* sign-extend MSW      */
+    else if (I32)
+        value = (targ_int) value;
 
-    if (I32 && flags & 2)
-    {   code *c1;
-
+    if (!I16 && flags & 2)                      // load 16 bit value
+    {
         value &= 0xFFFF;
         if (value == 0)
             goto L1;
@@ -603,21 +636,30 @@
         {
             if (flags & mPSW)
                 goto L1;
-            c1 = genc2(CNIL,0xC7,modregrm(3,0,reg),value); /* MOV reg,value */
-            c1->Iflags |= CFopsize;
+            code *c1 = genc2(CNIL,0xC7,modregrmx(3,0,reg),value); // MOV reg,value
+            c1->Iflags |= CFopsize;             // yes, even for I64
             c = cat(c,c1);
             if (regm)
-                regimmed_set(reg,(regv & 0xFFFF0000) | value);
+                // High bits of register are not affected by 16 bit load
+                regimmed_set(reg,(regv & ~(targ_size_t)0xFFFF) | value);
         }
         return c;
     }
 L1:
 
     /* If we already have the right value in the right register */
-    if (regm && regv == value)
+    if (regm && (regv & 0xFFFFFFFF) == (value & 0xFFFFFFFF) && !(flags & 64))
     {   if (flags & mPSW)
             c = gentstreg(c,reg);
     }
+    else if (flags & 64 && regm && regv == value)
+    {   // Look at the full 64 bits
+        if (flags & mPSW)
+        {
+            c = gentstreg(c,reg);
+            code_orrex(c, REX_W);
+        }
+    }
     else
     {
         if (flags & mPSW)
@@ -625,16 +667,31 @@
             switch (value)
             {   case 0:
                     c = genclrreg(c,reg);
+                    if (flags & 64)
+                        code_orrex(c, REX_W);
                     break;
                 case 1:
+                    if (I64)
+                        goto L4;
                     c = genclrreg(c,reg);
                     goto inc;
                 case -1:
+                    if (I64)
+                        goto L4;
                     c = genclrreg(c,reg);
                     goto dec;
                 default:
-                    c = genc2(c,0xC7,modregrm(3,0,reg),value); /* MOV reg,value */
+                L4:
+                    if (flags & 64)
+                    {
+                        c = genc2(c,0xC7,(REX_W << 16) | modregrmx(3,0,reg),value); // MOV reg,value64
+                        gentstreg(c,reg);
+                        code_orrex(c, REX_W);
+                    }
+                    else
+                    {   c = genc2(c,0xC7,modregrmx(3,0,reg),value); /* MOV reg,value */
                     gentstreg(c,reg);
+                    }
                     break;
             }
         }
@@ -656,7 +713,7 @@
                         goto done;
                     }
                 }
-                else
+                else if (I16)
                 {
                     if (reg == AX &&
                         (targ_short) value == (signed char) regv)
@@ -675,13 +732,15 @@
             }
             if (value == 0 && !(flags & 8) && config.target_cpu >= TARGET_80486)
             {   c = genclrreg(c,reg);           // CLR reg
+                if (flags & 64)
+                    code_orrex(c, REX_W);
                 goto done;
             }
 
-            if (regm && !(flags & 8))
+            if (!I64 && regm && !(flags & 8))
             {   if (regv + 1 == value ||
                     /* Catch case of (0xFFFF+1 == 0) for 16 bit compiles */
-                    (!I32 && (targ_short)(regv + 1) == (targ_short)value))
+                    (I16 && (targ_short)(regv + 1) == (targ_short)value))
                 {
                 inc:
                     c = gen1(c,0x40 + reg);     /* INC reg              */
@@ -700,17 +759,22 @@
             for (mreg = regcon.immed.mval; mreg; mreg >>= 1)
             {
 #ifdef DEBUG
-                assert(I32 || regcon.immed.value[r] == (targ_short)regcon.immed.value[r]);
+                assert(!I16 || regcon.immed.value[r] == (targ_short)regcon.immed.value[r]);
 #endif
                 if (mreg & 1 && regcon.immed.value[r] == value)
                 {   c = genmovreg(c,reg,r);
+                    if (flags & 64)
+                        code_orrex(c, REX_W);
                     goto done;
                 }
                 r++;
             }
 
             if (value == 0 && !(flags & 8))
-                c = genclrreg(c,reg);           // CLR reg
+            {   c = genclrreg(c,reg);           // CLR reg
+                if (flags & 64)
+                    code_orrex(c, REX_W);
+            }
             else
             {   /* See if we can just load a byte       */
                 if (regm & BYTEREGS &&
@@ -721,12 +785,16 @@
                     {   c = movregconst(c,reg,value,(flags & 8) |4|1);  // load regL
                         return c;
                     }
-                    if ((regv & 0xFFFF00FF) == (value & 0xFFFF00FF))
-                    {   c = movregconst(c,4|reg,value >> 8,(flags & 8) |4|1); // load regH
+                    if (regm & (mAX|mBX|mCX|mDX) &&
+                        (regv & ~(targ_size_t)0xFF00) == (value & ~(targ_size_t)0xFF00))
+                    {   c = movregconst(c,4|reg,value >> 8,(flags & 8) |4|1|16); // load regH
                         return c;
                     }
                 }
-                c = genc2(c,0xC7,modregrm(3,0,reg),value); /* MOV reg,value */
+                if (flags & 64)
+                    c = genc2(c,0xC7,(REX_W << 16) | modregrmx(3,0,reg),value); // MOV reg,value64
+                else
+                    c = genc2(c,0xC7,modregrmx(3,0,reg),value); // MOV reg,value
             }
         }
     done:
@@ -740,7 +808,7 @@
  * If so, return !=0 and set *preg to which register it is.
  */
 
-bool reghasvalue(regm_t regm,targ_int value,unsigned *preg)
+bool reghasvalue(regm_t regm,targ_size_t value,unsigned *preg)
 {   unsigned r;
     regm_t mreg;
 
@@ -764,7 +832,7 @@
  *      *preg   the register selected
  */
 
-code *regwithvalue(code *c,regm_t regm,targ_int value,unsigned *preg,regm_t flags)
+code *regwithvalue(code *c,regm_t regm,targ_size_t value,unsigned *preg,regm_t flags)
 {   unsigned reg;
 
     if (!preg)
diff -aruw dmd62/backend/cgreg.c dmd63/backend/cgreg.c
--- dmd62/backend/cgreg.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/cgreg.c	2010-08-09 14:33:14.000000000 -0400
@@ -1,5 +1,5 @@
 // Copyright (C) 1985-1998 by Symantec
-// Copyright (C) 2000-2009 by Digital Mars
+// Copyright (C) 2000-2010 by Digital Mars
 // All Rights Reserved
 // http://www.digitalmars.com
 // Written by Walter Bright
@@ -28,6 +28,12 @@
 #include        "tassert.h"
 
 STATIC void el_weights(int bi,elem *e,unsigned weight);
+
+#ifndef __DMC__
+#undef __cdecl
+#define __cdecl
+#endif
+
 static int __cdecl weight_compare(const void *e1,const void *e2);
 
 static int nretblocks;
@@ -68,9 +74,7 @@
     // Make adjustments to symbols we might stick in registers
     for (int i = 0; i < globsym.top; i++)
     {   unsigned sz;
-        symbol *s;
-
-        s = globsym.tab[i];
+        symbol *s = globsym.tab[i];
 
         if (s->Srange)
             s->Srange = vec_realloc(s->Srange,dfotop);
@@ -80,8 +84,8 @@
             !s->Srange ||
             (sz = type_size(s->Stype)) == 0 ||
             (tysize(s->ty()) == -1) ||
-            (!I32 && sz > REGSIZE) ||
-            (I32 && tyfloating(s->ty()))
+            (I16 && sz > REGSIZE) ||
+            ((I32 || I64) && tyfloating(s->ty()))
            )
         {
             s->Sflags &= ~GTregcand;
@@ -563,11 +567,11 @@
                                         // working for us
         cs.Iop ^= (sz == 1);
         c = getlvalue(&cs,e,keepmsk);
-        cs.Irm |= modregrm(0,s->Sreglsw,0);
+        cs.orReg(s->Sreglsw);
         c = gen(c,&cs);
         if (sz > REGSIZE)
         {
-            NEWREG(cs.Irm,s->Sregmsw);
+            cs.setReg(s->Sregmsw);
             getlvalue_msw(&cs);
             c = gen(c,&cs);
         }
@@ -661,11 +665,11 @@
                                         // working for us
         cs.Iop ^= (sz == 1);
         c = getlvalue(&cs,e,keepmsk);
-        cs.Irm |= modregrm(0,s->Sreglsw,0);
+        cs.orReg(s->Sreglsw);
         c = gen(c,&cs);
         if (sz > REGSIZE)
         {
-            NEWREG(cs.Irm,s->Sregmsw);
+            cs.setReg(s->Sregmsw);
             getlvalue_msw(&cs);
             c = gen(c,&cs);
         }
@@ -902,18 +906,8 @@
             continue;
         }
 
-        // For pointer types, try to pick index register first
-        static char seqidx[] = {BX,SI,DI,AX,CX,DX,BP,NOREG};
-        // Otherwise, try to pick index registers last
-        static char sequence[] = {AX,CX,DX,BX,SI,DI,BP,NOREG};
-#if 0
-        static char seqlsw[] = {AX,BX,SI,NOREG};
-        static char seqmsw[] = {CX,DX,DI};
-#else
-        static char seqlsw[] = {AX,BX,SI,DI,NOREG};
-        static char seqmsw[] = {CX,DX};
-#endif
         char *pseq;
+        char *pseqmsw = NULL;
 
         ty = s->ty();
         sz = tysize(ty);
@@ -926,10 +920,51 @@
             }
         #endif
 
-        if (I32)
-            pseq = (sz == REGSIZE * 2) ? seqlsw : sequence;
+        if (I64)
+        {
+            if (sz == REGSIZE * 2)
+            {
+                static char seqmsw[] = {CX,DX,NOREG};
+                static char seqlsw[] = {AX,BX,SI,DI,NOREG};
+                pseq = seqlsw;
+                pseqmsw = seqmsw;
+            }
         else
-            pseq = typtr(ty) ? seqidx : sequence;
+            {   // R10 is reserved for the static link
+                static char sequence[] = {AX,CX,DX,SI,DI,R8,R9,R11,BX,R12,R13,R14,R15,BP,NOREG};
+                pseq = sequence;
+            }
+        }
+        else if (I32)
+        {
+            if (sz == REGSIZE * 2)
+            {
+                static char seqlsw[] = {AX,BX,SI,DI,NOREG};
+                static char seqmsw[] = {CX,DX,NOREG};
+                pseq = seqlsw;
+                pseqmsw = seqmsw;
+            }
+            else
+            {
+                static char sequence[] = {AX,CX,DX,BX,SI,DI,BP,NOREG};
+                pseq = sequence;
+            }
+        }
+        else
+        {   assert(I16);
+            if (typtr(ty))
+            {
+                // For pointer types, try to pick index register first
+                static char seqidx[] = {BX,SI,DI,AX,CX,DX,BP,NOREG};
+                pseq = seqidx;
+            }
+            else
+            {
+                // Otherwise, try to pick index registers last
+                static char sequence[] = {AX,CX,DX,BX,SI,DI,BP,NOREG};
+                pseq = sequence;
+            }
+        }
 
         u.benefit = 0;
         for (int i = 0; pseq[i] != NOREG; i++)
@@ -970,9 +1005,10 @@
                 {   unsigned regj;
 
                     for (regj = 0; 1; regj++)
-                    {   if (regj == arraysize(seqmsw))
+                    {
+                        regmsw = pseqmsw[regj];
+                        if (regmsw == NOREG)
                             goto Ltried;
-                        regmsw = seqmsw[regj];
                         if (regmsw == reg)
                             continue;
                         #ifdef DEBUG
@@ -1006,7 +1042,7 @@
     }
 
     // See if any registers have become available that we can use.
-    if (I32 && !flag && (mfuncreg & ~fregsaved) & ALLREGS &&
+    if ((I32 || I64) && !flag && (mfuncreg & ~fregsaved) & ALLREGS &&
         !(funcsym_p->Sflags & SFLexit))
     {
         for (int i = 0; i < globsym.top; i++)
diff -aruw dmd62/backend/cgsched.c dmd63/backend/cgsched.c
--- dmd62/backend/cgsched.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/cgsched.c	2010-08-09 14:33:14.000000000 -0400
@@ -60,13 +60,13 @@
 #define CIFLnostage     4       // don't stage these instructions
 #define CIFLpush        8       // it's a push we can swap around
 
-    unsigned long r;    // read mask
-    unsigned long w;    // write mask
-    unsigned long a;    // registers used in addressing mode
+    unsigned r;         // read mask
+    unsigned w;         // write mask
+    unsigned a;         // registers used in addressing mode
     unsigned char reg;  // reg field of modregrm byte
     unsigned char uops; // Pentium Pro micro-ops
     unsigned sibmodrm;  // (sib << 8) + mod__rm byte
-    long spadjust;      // if !=0, then amount ESP changes as a result of this
+    unsigned spadjust;  // if !=0, then amount ESP changes as a result of this
                         // instruction being executed
     int fpuadjust;      // if !=0, then amount FPU stack changes as a result
                         // of this instruction being executed
@@ -90,6 +90,7 @@
     //printf("scratch = x%02x\n",scratch);
     if (config.target_scheduler >= TARGET_80486)
     {
+        if (!I64)
         *pc = peephole(*pc,0);
         if (I32)                        // forget about 16 bit code
         {
@@ -152,15 +153,16 @@
  * For each opcode, determine read [0] and written [1] masks.
  */
 
-#define F       mPSW            // flags
-#define EA      0x10000
-#define R       0x20000         // register (reg of modregrm field)
-#define N       0x40000         // other things modified, not swappable
-#define B       0x80000         // it's a byte operation
-#define C       0x100000        // floating point flags
-#define S       mST0            // floating point stack
+#define EA      0x100000
+#define R       0x200000        // register (reg of modregrm field)
+#define N       0x400000        // other things modified, not swappable
+#define B       0x800000        // it's a byte operation
+#define C       0x1000000       // floating point flags
+#define mMEM    0x2000000       // memory
+#define S       0x4000000       // floating point stack
+#define F       0x8000000       // flags
 
-static unsigned long oprw[256][2] =
+static unsigned oprw[256][2] =
 {
         // 00
         EA|R|B, F|EA|B,         // ADD
@@ -487,7 +489,7 @@
  * Same thing, but for groups.
  */
 
-static unsigned long grprw[8][8][2] =
+static unsigned grprw[8][8][2] =
 {
         // Grp 1
         EA,     F|EA,           // ADD
@@ -547,7 +549,7 @@
  *          [1] = write
  */
 
-static unsigned long grpf1[8][8][2] =
+static unsigned grpf1[8][8][2] =
 {
         // 0xD8
         EA|S,   S|C,    // FADD  float
@@ -776,7 +778,9 @@
     int op;
     int op2;
 
-    op = c->Iop;
+    op = c->Iop & 0xFF;
+    if ((c->Iop & 0xFF00) == 0x0F00)
+        op = 0x0F;
     n = insuops[op];
     if (!n)                             // if special case
     {   unsigned char irm,mod,reg,rm;
@@ -981,7 +985,7 @@
                 break;
 
             case 0x0F:
-                op2 = c->Iop2;
+                op2 = c->Iop & 0xFF;
                 if ((op2 & 0xF0) == 0x80)       // Jcc
                 {   n = 1;
                     break;
@@ -1023,7 +1027,9 @@
     // Of course, with Intel this is *never* simple, and Intel's
     // documentation is vague about the specifics.
 
-    op = c->Iop;
+    op = c->Iop & 0xFF;
+    if ((c->Iop & 0xFF00) == 0x0F00)
+        op = 0x0F;
     pc = pentcycl[op];
     a32 = I32;
     if (c->Iflags & CFaddrsize)
@@ -1035,7 +1041,7 @@
     switch (op)
     {
         case 0x0F:                              // 2 byte opcode
-            if ((c->Iop2 & 0xF0) == 0x80)       // if Jcc
+            if ((c->Iop & 0xF0) == 0x80)        // if Jcc
                 pc = PV | PF;
             break;
 
@@ -1176,13 +1182,15 @@
     unsigned char irm,mod,reg,rm;
     unsigned a32;
     int pc;
-    unsigned long r,w;
+    unsigned r,w;
     int sz = I32 ? 4 : 2;
 
     ci->r = 0;
     ci->w = 0;
     ci->a = 0;
-    op = c->Iop;
+    op = c->Iop & 0xFF;
+    if ((c->Iop & 0xFF00) == 0x0F00)
+        op = 0x0F;
     //printf("\tgetinfo %x, op %x \n",c,op);
     pc = pentcycl[op];
     a32 = I32;
@@ -1310,10 +1318,10 @@
             break;
 
         case 0x0F:
-            op2 = c->Iop2;
+            op2 = c->Iop & 0xFF;
             if ((op2 & 0xF0) == 0x80)           // if Jxx instructions
             {
-                ci->r = mPSW | N;
+                ci->r = F | N;
                 ci->w = N;
                 goto Lret;
             }
@@ -1659,9 +1667,9 @@
 STATIC int pair_test(Cinfo *cu,Cinfo *cv)
 {   unsigned pcu;
     unsigned pcv;
-    unsigned long r1,w1;
-    unsigned long r2,w2;
-    unsigned long x;
+    unsigned r1,w1;
+    unsigned r2,w2;
+    unsigned x;
 
     pcu = cu->pair;
     if (!(pcu & PU))
@@ -1704,7 +1712,7 @@
  */
 
 STATIC int pair_agi(Cinfo *c1,Cinfo *c2)
-{   unsigned long x;
+{   unsigned x;
 
     x = c1->w & c2->a;
     return x && !(x == mSP && c1->pair & c2->pair & PE);
@@ -1759,7 +1767,7 @@
         if (c->Iflags & (CFtarg | CFtarg2))
             break;
         if (!(c->Iop == NOP ||
-              (c->Iop == ESCAPE && c->Iop2 == ESClinnum)))
+              c->Iop == (ESCAPE | ESClinnum)))
             break;
     }
     return c;
@@ -1790,8 +1798,8 @@
 {   code *c;
     code *c1;
     code *c2;
-    unsigned long r1,w1,a1;
-    unsigned long r2,w2,a2;
+    unsigned r1,w1,a1;
+    unsigned r2,w2,a2;
     int sz1,sz2;
     int i = 0;
     int delay_clocks;
@@ -1869,12 +1877,12 @@
         // If other than the memory reference is a conflict
         if (w1 & r2 & ~mMEM || (r1 | w1) & w2 & ~mMEM)
         {   if (i) printf("\t1\n");
-            if (i) printf("r1=%lx, w1=%lx, a1=%lx, sz1=%d, r2=%lx, w2=%lx, a2=%lx, sz2=%d\n",r1,w1,a1,sz1,r2,w2,a2,sz2);
+            if (i) printf("r1=%x, w1=%x, a1=%x, sz1=%d, r2=%x, w2=%x, a2=%x, sz2=%d\n",r1,w1,a1,sz1,r2,w2,a2,sz2);
             goto Lconflict;
         }
 
         // If referring to distinct types, then no dependency
-        if (c1->Ijty && c2->Ijty && c1->Ijty != c2->Ijty)
+        if (c1->Irex && c2->Irex && c1->Irex != c2->Irex)
             goto Lswap;
 
         ifl1 = c1->IFL1;
@@ -1882,7 +1890,7 @@
 
         // Special case: Allow indexed references using registers other than
         // ESP and EBP to be swapped with PUSH instructions
-        if (((c1->Iop & 0xF8) == 0x50 ||        // PUSH reg
+        if (((c1->Iop & ~7) == 0x50 ||          // PUSH reg
              c1->Iop == 0x6A ||                 // PUSH imm8
              c1->Iop == 0x68 ||                 // PUSH imm16/imm32
              (c1->Iop == 0xFF && ci1->reg == 6) // PUSH EA
@@ -1902,7 +1910,7 @@
 
         // Special case: Allow indexed references using registers other than
         // ESP and EBP to be swapped with PUSH instructions
-        if (((c2->Iop & 0xF8) == 0x50 ||        // PUSH reg
+        if (((c2->Iop & ~7) == 0x50 ||          // PUSH reg
              c2->Iop == 0x6A ||                 // PUSH imm8
              c2->Iop == 0x68 ||                 // PUSH imm16/imm32
              (c2->Iop == 0xFF && ci2->reg == 6) // PUSH EA
@@ -2297,7 +2305,7 @@
 
         // Look for special case swap
         if (movesp &&
-            (cit->c->Iop & 0xF8) == 0x50 &&             // if PUSH reg1
+            (cit->c->Iop & ~7) == 0x50 &&               // if PUSH reg1
             (cit->c->Iop & 7) != reg2 &&                // if reg1 != reg2
             ((signed char)c->IEVpointer1) >= -cit->spadjust
            )
@@ -2520,7 +2528,7 @@
                     break;
 
             if (i >= j && tbl[i - j] &&
-                   (tbl[i - j]->c->Iop & 0xF8) == 0x50 &&       // if PUSH reg1
+                   (tbl[i - j]->c->Iop & ~7) == 0x50 &&       // if PUSH reg1
                    (tbl[i - j]->c->Iop & 7) != reg2 &&  // if reg1 != reg2
                    (signed char)c->IEVpointer1 >= REGSIZE)
             {
@@ -2662,7 +2670,7 @@
             if (c->Iflags & (CFtarg | CFtarg2))
                 break;
             if (!(c->Iop == NOP ||
-                  (c->Iop == ESCAPE && c->Iop2 == ESClinnum) ||
+                  c->Iop == (ESCAPE | ESClinnum) ||
                   c->Iflags & iflags))
                 break;
         }
@@ -2686,7 +2694,7 @@
     sch.initialize(0);                  // initialize scheduling table
     while (c)
     {
-        if ((c->Iop == NOP || c->Iop == ESCAPE || c->Iflags & CFclassinit) &&
+        if ((c->Iop == NOP || (c->Iop & 0xFF) == ESCAPE || c->Iflags & CFclassinit) &&
             !(c->Iflags & (CFtarg | CFtarg2)))
         {   code *cn;
 
@@ -2849,7 +2857,7 @@
 
         // Do:
         //      PUSH    reg
-        if (I32 && (c->Iop & 0xF8) == 0x50)
+        if (I32 && (c->Iop & ~7) == 0x50)
         {   unsigned reg = c->Iop & 7;
 
             //  MOV     [ESP],reg       =>      NOP
diff -aruw dmd62/backend/cod1.c dmd63/backend/cod1.c
--- dmd62/backend/cod1.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/cod1.c	2010-08-09 14:33:14.000000000 -0400
@@ -14,6 +14,7 @@
 
 #include        <stdio.h>
 #include        <string.h>
+#include        <stdlib.h>
 #include        <time.h>
 #include        "cc.h"
 #include        "el.h"
@@ -43,7 +44,7 @@
 int isscaledindex(elem *e)
 {   targ_uns ss;
 
-    assert(I32);
+    assert(!I16);
     while (e->Eoper == OPcomma)
         e = e->E2;
     if (!(e->Eoper == OPshl && !e->Ecount &&
@@ -149,9 +150,10 @@
 void buildEA(code *c,int base,int index,int scale,targ_size_t disp)
 {   unsigned char rm;
     unsigned char sib;
+    unsigned char rex = 0;
 
     sib = 0;
-    if (I32)
+    if (!I16)
     {   unsigned ss;
 
         assert(index != SP);
@@ -171,7 +173,9 @@
             else
             {
                 rm  = modregrm(0,0,4);
-                sib = modregrm(ss,index,5);
+                sib = modregrm(ss,index & 7,5);
+                if (index & 8)
+                    rex |= REX_X;
             }
         }
         else if (index == -1)
@@ -182,12 +186,19 @@
                 sib = modregrm(0,4,SP);
             }
             else
-                rm = modregrm(2,0,base);
+            {   rm = modregrm(2,0,base & 7);
+                if (base & 8)
+                    rex |= REX_B;
+            }
         }
         else
         {
             rm  = modregrm(2,0,4);
-            sib = modregrm(ss,index,base);
+            sib = modregrm(ss,index & 7,base & 7);
+            if (index & 8)
+                rex |= REX_X;
+            if (base & 8)
+                rex |= REX_B;
         }
     }
     else
@@ -212,6 +223,7 @@
     }
     c->Irm = rm;
     c->Isib = sib;
+    c->Irex = rex;
     c->IFL1 = FLconst;
     c->IEV1.Vuns = disp;
 }
@@ -223,11 +235,9 @@
  */
 
 void andregcon(con_t *pregconsave)
-{   int i;
-    regm_t m;
-
-    m = ~1;
-    for (i = 0; i < REGMAX; i++)
+{
+    regm_t m = ~1;
+    for (int i = 0; i < REGMAX; i++)
     {   if (pregconsave->cse.value[i] != regcon.cse.value[i])
             regcon.cse.mval &= m;
         if (pregconsave->immed.value[i] != regcon.immed.value[i])
@@ -312,21 +322,32 @@
  * Gen a save/restore sequence for mask of registers.
  */
 
-void gensaverestore(regm_t regm,code **csave,code **crestore)
-{   code *cs1;
-    code *cs2;
-    int i;
+void gensaverestore2(regm_t regm,code **csave,code **crestore)
+{
+    code *cs1 = *csave;
+    code *cs2 = *crestore;
 
-    cs1 = NULL;
-    cs2 = NULL;
+    //printf("gensaverestore2(%x)\n", regm);
     regm &= mBP | mES | ALLREGS;
-    for (i = 0; regm; i++)
+    for (int i = 0; regm; i++)
     {
         if (regm & 1)
         {
-            assert(i != ES);                    // fix later
-            cs1 = gen1(cs1,0x50 + i);
-            cs2 = cat(gen1(NULL,0x58 + i),cs2);
+            if (i == ES)
+            {
+                cs1 = gen1(cs1, 0x06);                  // PUSH ES
+                cs2 = cat(gen1(CNIL, 0x07),cs2);        // POP  ES
+            }
+            else
+            {
+                cs1 = gen1(cs1,0x50 + (i & 7));         // PUSH i
+                code *c = gen1(NULL, 0x58 + (i & 7));   // POP  i
+                if (i & 8)
+                {   code_orrex(cs1, REX_B);
+                    code_orrex(c, REX_B);
+                }
+                cs2 = cat(c,cs2);
+            }
         }
         regm >>= 1;
     }
@@ -334,6 +355,13 @@
     *crestore = cs2;
 }
 
+void gensaverestore(regm_t regm,code **csave,code **crestore)
+{
+    *csave = NULL;
+    *crestore = NULL;
+    gensaverestore2(regm, csave, crestore);
+}
+
 /****************************************
  * Clean parameters off stack.
  * Input:
@@ -356,7 +384,6 @@
         else
 #endif
         {   regm_t scratchm = 0;
-            unsigned r;
 
             if (numpara == REGSIZE && config.flags4 & CFG4space)
             {
@@ -364,11 +391,15 @@
             }
 
             if (scratchm)
-            {   c = cat(c,allocreg(&scratchm,&r,TYint));
+            {   unsigned r;
+                c = cat(c,allocreg(&scratchm,&r,TYint));
                 c = gen1(c,0x58 + r);           // POP r
             }
             else
-                c = genc2(c,0x81,modregrm(3,0,SP),numpara); // ADD SP,numpara
+            {   c = genc2(c,0x81,modregrm(3,0,SP),numpara); // ADD SP,numpara
+                if (I64)
+                    code_orrex(c, REX_W);
+            }
         }
         stackpush -= numpara;
         c = genadjesp(c,-numpara);
@@ -376,6 +407,7 @@
     return c;
 }
 
+
 /*********************************
  * Generate code for a logical expression.
  * Input:
@@ -389,15 +421,14 @@
  */
 
 code *logexp(elem *e,int jcond,unsigned fltarg,code *targ)
-{ code *cc,*c,*ce,*cnop;
+{ code *c,*ce,*cnop;
   regm_t retregs;
   unsigned op;
-  int no87;
 
   //printf("logexp(e = %p, jcond = %d)\n", e, jcond);
-  no87 = (jcond & 2) == 0;
+  int no87 = (jcond & 2) == 0;
   _chkstack();
-  cc = docommas(&e);            /* scan down commas                     */
+  code *cc = docommas(&e);            // scan down commas
   cgstate.stackclean++;
 
   if (EOP(e) && !e->Ecount)     /* if operator and not common sub */
@@ -454,13 +485,11 @@
                 goto Lretc;
 
             case OPcond:
-            {   code *cnop2;
-                con_t regconold;
-
-                cnop2 = gennop(CNIL);   /* addresses of start of leaves */
+            {
+                code *cnop2 = gennop(CNIL);   // addresses of start of leaves
                 cnop = gennop(CNIL);
                 c = logexp(e->E1,FALSE,FLcode,cnop2);   /* eval condition */
-                regconold = regcon;
+                con_t regconold = regcon;
                 ce = logexp(e->E2->E1,jcond,fltarg,targ);
                 ce = genjmp(ce,JMP,FLcode,(block *) cnop); /* skip second leaf */
 
@@ -478,10 +507,12 @@
         }
   }
 
-  /* Special code for signed long compare       */
+  /* Special code for signed long compare.
+   * Not necessary for I64 until we do cents.
+   */
   if (OTrel2(e->Eoper) &&               /* if < <= >= >                 */
       !e->Ecount &&
-      ( (!I32 && tybasic(e->E1->Ety) == TYlong  && tybasic(e->E2->Ety) == TYlong) ||
+      ( (I16 && tybasic(e->E1->Ety) == TYlong  && tybasic(e->E2->Ety) == TYlong) ||
         ( I32 && tybasic(e->E1->Ety) == TYllong && tybasic(e->E2->Ety) == TYllong))
      )
   {
@@ -504,6 +535,7 @@
   return c;
 }
 
+
 /******************************
  * Routine to aid in setting things up for gen().
  * Look for common subexpression.
@@ -520,28 +552,23 @@
  *      pointer to code generated
  */
 
-code *loadea(elem *e,code __ss *cs,unsigned op,unsigned reg,targ_size_t offset,
+code *loadea(elem *e,code *cs,unsigned op,unsigned reg,targ_size_t offset,
         regm_t keepmsk,regm_t desmsk)
-{ unsigned i;
-  regm_t rm;
-  tym_t tym;
+{
   code *c,*cg,*cd;
 
 #ifdef DEBUG
   if (debugw)
-    printf("loadea: e=%p cs=%p op=x%x reg=%d offset=%ld keepmsk=x%x desmsk=x%x\n",
-            e,cs,op,reg,offset,keepmsk,desmsk);
+    printf("loadea: e=%p cs=%p op=x%x reg=%d offset=%lld keepmsk=x%x desmsk=x%x\n",
+            e,cs,op,reg,(unsigned long long)offset,keepmsk,desmsk);
 #endif
 
   assert(e);
   cs->Iflags = 0;
-  cs->Ijty = 0;
+  cs->Irex = 0;
   cs->Iop = op;
-  if (I32 && op >= 0x100)               /* if 2 byte opcode             */
-  {     cs->Iop = op >> 8;
-        cs->Iop2 = op;
-  }
-  tym = e->Ety;
+  tym_t tym = e->Ety;
+  int sz = tysize(tym);
 
   /* Determine if location we want to get is in a register. If so,      */
   /* substitute the register for the EA.                                */
@@ -552,14 +579,12 @@
       op != 0x8D && op != 0xC4 &&       /* and not an LEA or LES        */
       (op != 0xFF || reg != 3) &&       /* and not CALLF MEM16          */
       (op & 0xFFF8) != 0xD8)            // and not 8087 opcode
-  {     int sz;
-
+  {
         assert(!EOP(e));                /* can't handle this            */
-        rm = regcon.cse.mval & ~regcon.cse.mops & ~regcon.mvar; /* possible regs                */
-        sz = tysize(tym);
-        if (sz > REGSIZE)
+        regm_t rm = regcon.cse.mval & ~regcon.cse.mops & ~regcon.mvar; // possible regs
+        if (sz > REGSIZE)               // value is in 2 or 4 registers
         {
-                if (!I32 && sz == 8)
+                if (I16 && sz == 8)     // value is in 4 registers
                 {       static regm_t rmask[4] = { mDX,mCX,mBX,mAX };
                         rm &= rmask[offset >> 1];
                 }
@@ -569,7 +594,7 @@
                 else
                         rm &= mLSW;             /* only low words       */
         }
-        for (i = 0; rm; i++)
+        for (unsigned i = 0; rm; i++)
         {       if (mask[i] & rm)
                 {       if (regcon.cse.value[i] == e && // if register has elem
                             /* watch out for a CWD destroying DX        */
@@ -580,10 +605,18 @@
                                 {       if (op != 0x8B)
                                             goto L1;    /* not a load   */
                                         cs->Iop = 0x8C; /* MOV reg,ES   */
-                                        cs->Irm = modregrm(3,0,reg);
+                                        cs->Irm = modregrm(3,0,reg & 7);
+                                        if (reg & 8)
+                                            code_orrex(cs, REX_B);
+                                }
+                                else    // XXX reg,i
+                                {
+                                    cs->Irm = modregrm(3,reg & 7,i & 7);
+                                    if (reg & 8)
+                                        code_orrex(cs, REX_R);
+                                    if (i & 8)
+                                        code_orrex(cs, REX_B);
                                 }
-                                else    /* XXX reg,i                    */
-                                        cs->Irm = modregrm(3,reg,i);
                                 c = CNIL;
                                 goto L2;
                         }
@@ -598,8 +631,8 @@
         getlvalue_msw(cs);
   else
         cs->IEVoffset1 += offset;
-  cs->Irm |= modregrm(0,reg,0);         /* OR in reg field              */
-  if (I32)
+  code_newreg(cs, reg);                         // OR in reg field
+  if (!I16)
   {
       if (reg == 6 && op == 0xFF ||             /* don't PUSH a word    */
           op == 0x0FB7 || op == 0x0FBF ||       /* MOVZX/MOVSX          */
@@ -616,17 +649,29 @@
   cd = CNIL;
   if (op == 0xF7 && desmsk == (mAX|mDX))        /* if we need to fix DX */
   {     if (reg == 7)                           /* if IDIV              */
-                cd = gen1(cd,0x99);             /* CWD                  */
-        else if (reg == 6)                      /* if DIV               */
-                cd = genregs(cd,0x33,DX,DX);    /* CLR DX               */
+        {   cd = gen1(cd,0x99);                 // CWD
+            if (I64 && sz == 8)
+                code_orrex(cd, REX_W);
+        }
+        else if (reg == 6)                      // if DIV
+        {   cd = genregs(cd,0x33,DX,DX);        // XOR DX,DX
+            if (I64 && sz == 8)
+                code_orrex(cd, REX_W);
+        }
   }
 
   // Eliminate MOV reg,reg
-  if ((cs->Iop & 0xFC) == 0x88 &&
-      (cs->Irm & 0xC7) == modregrm(3,0,reg))
+  if ((cs->Iop & ~3) == 0x88 &&
+      (cs->Irm & 0xC7) == modregrm(3,0,reg & 7))
+  {
+        unsigned r = cs->Irm & 7;
+        if (cs->Irex & REX_B)
+            r |= 8;
+        if (r == reg)
         cs->Iop = NOP;
+  }
 
-  return cat4(c,cg,cd,gen(CNIL,cs));
+  return cat4(c,cg,cd,gen(NULL,cs));
 }
 
 /**************************
@@ -635,33 +680,43 @@
 
 unsigned getaddrmode(regm_t idxregs)
 {
-    unsigned reg;
     unsigned mode;
 
-    if (I32)
-    {   reg = findreg(idxregs & (ALLREGS | mBP));
-        mode = modregrm(2,0,reg);
-    }
-    else
+    if (I16)
     {
         mode =  (idxregs & mBX) ? modregrm(2,0,7) :     /* [BX] */
                 (idxregs & mDI) ? modregrm(2,0,5):      /* [DI] */
                 (idxregs & mSI) ? modregrm(2,0,4):      /* [SI] */
                                   (assert(0),1);
     }
+    else
+    {   unsigned reg = findreg(idxregs & (ALLREGS | mBP));
+        mode = modregrmx(2,0,reg);
+    }
     return mode;
 }
 
+void setaddrmode(code *c, regm_t idxregs)
+{
+    unsigned mode = getaddrmode(idxregs);
+    c->Irm = mode & 0xFF;
+    c->Irex &= ~REX_B;
+    c->Irex |= mode >> 16;
+}
+
 /**********************************************
  */
 
 void getlvalue_msw(code *c)
 {
     if (c->IFL1 == FLreg)
-    {   unsigned regmsw;
-
-        regmsw = c->IEVsym1->Sregmsw;
-        c->Irm = (c->Irm & ~7) | regmsw;
+    {
+        unsigned regmsw = c->IEVsym1->Sregmsw;
+        c->Irm = (c->Irm & ~7) | (regmsw & 7);
+        if (regmsw & 8)
+            c->Irex |= REX_B;
+        else
+            c->Irex &= ~REX_B;
     }
     else
         c->IEVoffset1 += REGSIZE;
@@ -673,10 +728,13 @@
 void getlvalue_lsw(code *c)
 {
     if (c->IFL1 == FLreg)
-    {   unsigned reglsw;
-
-        reglsw = c->IEVsym1->Sreglsw;
-        c->Irm = (c->Irm & ~7) | reglsw;
+    {
+        unsigned reglsw = c->IEVsym1->Sreglsw;
+        c->Irm = (c->Irm & ~7) | (reglsw & 7);
+        if (reglsw & 8)
+            c->Irex |= REX_B;
+        else
+            c->Irex &= ~REX_B;
     }
     else
         c->IEVoffset1 -= REGSIZE;
@@ -695,7 +753,7 @@
  *              if (keepmsk & RMload), this will be a read operation only
  */
 
-code *getlvalue(code __ss *pcs,elem *e,regm_t keepmsk)
+code *getlvalue(code *pcs,elem *e,regm_t keepmsk)
 { regm_t idxregs;
   unsigned fl,f,opsave;
   code *c;
@@ -704,10 +762,8 @@
   elem *e12;
   bool e1isadd,e1free;
   unsigned reg;
-  tym_t ty;
   tym_t e1ty;
   symbol *s;
-  unsigned sz;
 
   //printf("getlvalue(e = %p)\n",e);
   //elem_print(e);
@@ -723,13 +779,16 @@
         fl = FLoper;
   pcs->IFL1 = fl;
   pcs->Iflags = CFoff;                  /* only want offsets            */
-  pcs->Ijty = 0;
+  pcs->Irex = 0;
   pcs->IEVoffset1 = 0;
-  ty = e->Ety;
+
+  tym_t ty = e->Ety;
+  unsigned sz = tysize(ty);
   if (tyfloating(ty))
         obj_fltused();
-  sz = tysize(ty);
-  if (I32 && sz == SHORTSIZE)
+  else if (I64 && sz == 8)
+        pcs->Irex |= REX_W;
+  if (!I16 && sz == SHORTSIZE)
         pcs->Iflags |= CFopsize;
   if (ty & mTYvolatile)
         pcs->Iflags |= CFvolatile;
@@ -745,7 +804,7 @@
         if (e->Eoper == OPvar && fl == FLgot)
         {
             code *c1;
-            int saveop = pcs->Iop;
+            unsigned saveop = pcs->Iop;
             idxregs = allregs & ~keepmsk;       // get a scratch register
             c = allocreg(&idxregs,&reg,TYptr);
             pcs->Irm = modregrm(2,reg,BX);      // BX has GOT
@@ -815,9 +874,9 @@
             int ssi;
 
             /*assert(datafl[f]);*/              /* what if addr of func? */
-            if (I32)
+            if (!I16)
             {   /* Any register can be an index register        */
-                idxregs = allregs & ~keepmsk;
+                regm_t idxregs = allregs & ~keepmsk;
                 assert(idxregs);
 
                 /* See if e1->E1 can be a scaled index  */
@@ -839,7 +898,9 @@
                     {
                         t = stackfl[f] ? 2 : 0;
                         pcs->Irm = modregrm(t,0,4);
-                        pcs->Isib = modregrm(ss,reg,5);
+                        pcs->Isib = modregrm(ss,reg & 7,5);
+                        if (reg & 8)
+                            pcs->Irex |= REX_X;
                     }
                 }
                 else if ((e11->Eoper == OPmul || e11->Eoper == OPshl) &&
@@ -849,15 +910,12 @@
                         )
                 {
                     regm_t scratchm;
-                    unsigned r;
-                    int ss1;
                     int ss2;
-                    char ssflags;
 
 #if 0 && TARGET_LINUX
                     assert(f != FLgot && f != FLgotoff);
 #endif
-                    ssflags = ssindex_array[ssi].ssflags;
+                    char ssflags = ssindex_array[ssi].ssflags;
                     if (ssflags & SSFLnobp && stackfl[f])
                         goto L6;
 
@@ -865,15 +923,18 @@
                     c = scodelem(e11->E1,&idxregs,keepmsk,TRUE);
                     reg = findreg(idxregs);
 
-                    ss1 = ssindex_array[ssi].ss1;
+                    int ss1 = ssindex_array[ssi].ss1;
                     if (ssflags & SSFLlea)
                     {
                         assert(!stackfl[f]);
                         pcs->Irm = modregrm(2,0,4);
-                        pcs->Isib = modregrm(ss1,reg,reg);
+                        pcs->Isib = modregrm(ss1,reg & 7,reg & 7);
+                        if (reg & 8)
+                            pcs->Irex |= REX_X | REX_B;
                     }
                     else
                     {   int rbase;
+                        unsigned r;
 
                         scratchm = ALLREGS & ~keepmsk;
                         c = cat(c,allocreg(&scratchm,&r,TYint));
@@ -889,12 +950,17 @@
                             {   static unsigned imm32[4] = {1+1,2+1,4+1,8+1};
 
                                 // IMUL r,BP,imm32
-                                c = genc2(c,0x69,modregrm(3,r,BP),imm32[ss1]);
+                                c = genc2(c,0x69,modregxrm(3,r,BP),imm32[ss1]);
                                 goto L7;
                             }
                         }
 
-                        c = gen2sib(c,0x8D,modregrm(t,r,4),modregrm(ss1,reg,rbase));
+                        c = gen2sib(c,0x8D,modregxrm(t,r,4),modregrm(ss1,reg & 7,rbase & 7));
+                        if (reg & 8)
+                            code_orrex(c, REX_X);
+                        if (rbase & 8)
+                            code_orrex(c, REX_B);
+
                         if (ssflags & SSFLnobase1)
                         {   code_last(c)->IFL1 = FLconst;
                             code_last(c)->IEV1.Vuns = 0;
@@ -910,7 +976,11 @@
                             assert(rbase != BP);
                         }
                         pcs->Irm = modregrm(t,0,4);
-                        pcs->Isib = modregrm(ssindex_array[ssi].ss2,r,rbase);
+                        pcs->Isib = modregrm(ssindex_array[ssi].ss2,r & 7,rbase & 7);
+                        if (r & 8)
+                            code_orrex(pcs, REX_X);
+                        if (rbase & 8)
+                            code_orrex(pcs, REX_B);
                     }
                     freenode(e11->E2);
                     freenode(e11);
@@ -920,7 +990,7 @@
                  L6:
                     /* Load index register with result of e11   */
                     c = scodelem(e11,&idxregs,keepmsk,TRUE);
-                    pcs->Irm = getaddrmode(idxregs);
+                    setaddrmode(pcs, idxregs);
 #if 0 && TARGET_LINUX
                     if (e12->EV.sp.Vsym->Sfl == FLgot || e12->EV.sp.Vsym->Sfl == FLgotoff)
                     {
@@ -937,8 +1007,10 @@
                     else
 #endif
                     if (stackfl[f])             /* if we need [EBP] too */
-                    {
-                        pcs->Isib = modregrm(0,pcs->Irm,BP);
+                    {   unsigned idx = pcs->Irm & 7;
+                        if (pcs->Irex & REX_B)
+                            pcs->Irex = (pcs->Irex & ~REX_B) | REX_X;
+                        pcs->Isib = modregrm(0,idx,BP);
                         pcs->Irm = modregrm(2,0,4);
                     }
                 }
@@ -995,19 +1067,19 @@
                 opsave = pcs->Iop;
                 flagsave = pcs->Iflags;
                 pcs->Iop = 0x8D;
-                pcs->Irm |= modregrm(0,reg,0);
-                if (I32)
+                code_newreg(pcs, reg);
+                if (!I16)
                     pcs->Iflags &= ~CFopsize;
                 c = gen(c,pcs);                 /* LEA idxreg,EA        */
                 cssave(e1,idxregs,TRUE);
-                if (I32)
+                if (!I16)
                     pcs->Iflags = flagsave;
                 if (stackfl[f] && (config.wflags & WFssneds))   // if pointer into stack
                     pcs->Iflags |= CFss;        // add SS: override
                 pcs->Iop = opsave;
                 pcs->IFL1 = FLoffset;
                 pcs->IEV1.Vuns = 0;
-                pcs->Irm = getaddrmode(idxregs);
+                setaddrmode(pcs, idxregs);
             }
             freenode(e12);
             if (e1free)
@@ -1019,9 +1091,11 @@
 
         /* The rest of the cases could be a far pointer */
 
-        idxregs = (I32 ? allregs : IDXREGS) & ~keepmsk; /* only these can be index regs */
+        idxregs = (I16 ? IDXREGS : allregs) & ~keepmsk; // only these can be index regs
         assert(idxregs);
-        if (I32 && sz == REGSIZE && keepmsk & RMstore)
+        if (!I16 &&
+            (sz == REGSIZE || (I64 && sz == 4)) &&
+            keepmsk & RMstore)
             idxregs |= regcon.mvar;
 
 #if !TARGET_FLAT
@@ -1068,17 +1142,19 @@
                 e1free = TRUE;
                 goto L4;
             }
-            if (I32 && (ss = isscaledindex(e11)) != 0)
+            if (!I16 && (ss = isscaledindex(e11)) != 0)
             {   // (v * scale) + const
                 c = cdisscaledindex(e11,&idxregs,keepmsk);
                 reg = findreg(idxregs);
                 pcs->Irm = modregrm(0,0,4);
-                pcs->Isib = modregrm(ss,reg,5);
+                pcs->Isib = modregrm(ss,reg & 7,5);
+                if (reg & 8)
+                    pcs->Irex |= REX_X;
             }
             else
             {
                 c = scodelem(e11,&idxregs,keepmsk,TRUE); // load index reg
-                pcs->Irm = getaddrmode(idxregs);
+                setaddrmode(pcs, idxregs);
             }
             goto Lptr;
         }
@@ -1087,7 +1163,7 @@
          *      EA = [v1][v2]
          */
 
-        if (I32 && e1isadd && (!e1->Ecount || !e1free) &&
+        if (!I16 && e1isadd && (!e1->Ecount || !e1free) &&
             tysize[e1ty] == REGSIZE)
         {   code *c2;
             regm_t idxregs2;
@@ -1136,7 +1212,11 @@
             base = findreg(idxregs);
             index = findreg(idxregs2);
             pcs->Irm  = modregrm(2,0,4);
-            pcs->Isib = modregrm(ss,index,base);
+            pcs->Isib = modregrm(ss,index & 7,base & 7);
+            if (index & 8)
+                pcs->Irex |= REX_X;
+            if (base & 8)
+                pcs->Irex |= REX_B;
             if (e1free) freenode(e1);
             goto Lptr;
         }
@@ -1151,7 +1231,7 @@
 
         assert(e1free);
         c = scodelem(e1,&idxregs,keepmsk,TRUE); /* load index register  */
-        pcs->Irm = getaddrmode(idxregs);
+        setaddrmode(pcs, idxregs);
     Lptr:
         if (config.flags3 & CFG3ptrchk)
             cod3_ptrchk(&c,pcs,keepmsk);        // validate pointer code
@@ -1182,7 +1262,9 @@
             {
                 if (sz == REGSIZE)      // could this be (sz <= REGSIZE) ?
                 {
-                    pcs->Irm = modregrm(3,0,s->Spreg);
+                    pcs->Irm = modregrm(3,0,s->Spreg & 7);
+                    if (s->Spreg & 8)
+                        pcs->Irex |= REX_B;
                     regcon.used |= mask[s->Spreg];
                     break;
                 }
@@ -1199,11 +1281,23 @@
         if (s->Sident[0] == '_' && memcmp(s->Sident + 1,"tls_array",10) == 0)
         {
 #if TARGET_LINUX || TARGET_FREEBSD || TARGET_SOLARIS
-            // Rewrite as GS:[0000]
+            // Rewrite as GS:[0000], or FS:[0000] for 64 bit
+            if (I64)
+            {
+                pcs->Irm = modregrm(0, 0, 4);
+                pcs->Isib = modregrm(0, 4, 5);  // don't use [RIP] addressing
+                pcs->IFL1 = FLconst;
+                pcs->IEV1.Vuns = 0;
+                pcs->Iflags = CFfs;
+            }
+            else
+            {
             pcs->Irm = modregrm(0, 0, BPRM);
             pcs->IFL1 = FLconst;
             pcs->IEV1.Vuns = 0;
             pcs->Iflags = CFgs;
+            }
+            break;
 #else
             pcs->Iflags |= CFfs;                // add FS: override
 #endif
@@ -1230,9 +1324,12 @@
             {   refparam = TRUE;
                 reflocal = TRUE;        // kludge to set up prolog
             }
-            pcs->Irm = modregrm(3,0,s->Sreglsw);
+            pcs->Irm = modregrm(3,0,s->Sreglsw & 7);
+            if (s->Sreglsw & 8)
+                pcs->Irex |= REX_B;
             if (e->EV.sp.Voffset == 1 && sz == 1)
             {   assert(s->Sregm & BYTEREGS);
+                assert(s->Sreglsw < 4);
                 pcs->Irm |= 4;                  // use 2nd byte of register
             }
             else
@@ -1243,8 +1340,12 @@
             pcs->Iflags |= CFcs | CFoff;
         }
 #if TARGET_LINUX || TARGET_OSX || TARGET_FREEBSD || TARGET_SOLARIS
-//      if (fl == FLtlsdata || s->ty() & mTYthread)
-//          pcs->Iflags |= CFgs;
+        if (I64 && config.flags3 & CFG3pic &&
+            (fl == FLtlsdata || s->ty() & mTYthread))
+        {
+            pcs->Iflags |= CFopsize;
+            pcs->Irex = 0x48;
+        }
 #endif
         pcs->IEVsym1 = s;
         pcs->IEVoffset1 = e->EV.sp.Voffset;
@@ -1264,9 +1365,8 @@
 #if MARS
         assert(0);
 #else
-    {   unsigned u;
-
-        u = s->Sreglsw;
+    {
+        unsigned u = s->Sreglsw;
         c = getregs(pseudomask[u]);
         pcs->Irm = modregrm(3,0,pseudoreg[u] & 7);
         break;
@@ -1278,22 +1378,20 @@
         if (config.exe & EX_flat)
             goto L3;
     Lfardata:
-    {   regm_t regm;
-        code *c1;
-
-        regm = ALLREGS & ~keepmsk;              /* need scratch register */
-        c1 = allocreg(&regm,&reg,TYint);
+    {
+        regm_t regm = ALLREGS & ~keepmsk;       // need scratch register
+        code *c1 = allocreg(&regm,&reg,TYint);
         /* MOV mreg,seg of symbol       */
         c = gencs(CNIL,0xB8 + reg,0,FLextern,s);
         c->Iflags = CFseg;
-        c = gen2(c,0x8E,modregrm(3,0,reg));     /* MOV ES,reg           */
+        c = gen2(c,0x8E,modregrmx(3,0,reg));     /* MOV ES,reg           */
         c = cat3(c1,getregs(mES),c);
         pcs->Iflags |= CFes | CFoff;            /* ES segment override  */
         goto L3;
     }
 
     case FLstack:
-        assert(I32);
+        assert(!I16);
         pcs->Irm = modregrm(2,0,4);
         pcs->Isib = modregrm(0,4,SP);
         pcs->IEVsym1 = s;
@@ -1445,6 +1543,7 @@
                 assert(j < 8);
             }
             else                        /* else use stack               */
+#if 0
             {   int push,pop;
 
                 stackchanged = 1;
@@ -1460,6 +1559,13 @@
                 cs1 = gen1(cs1,push);                   /* PUSH i       */
                 cs2 = cat(gen1(CNIL,pop),cs2);          /* POP i        */
             }
+#else
+            {
+                stackchanged = 1;
+                adjesp += REGSIZE;
+                gensaverestore2(mask[i], &cs1, &cs2);
+            }
+#endif
             cs3 = cat(getregs(mi),cs3);
             tosave &= ~mi;
         }
@@ -1475,17 +1581,17 @@
             sz = -(adjesp & (STACKALIGN - 1)) & (STACKALIGN - 1);
         else
             sz = -(adjesp & 7) & 7;
-        if (calledafunc && I32 && sz && (STACKALIGN == 16 || config.flags4 & CFG4stackalign))
-        {   code *cx;
-
+        if (calledafunc && !I16 && sz && (STACKALIGN == 16 || config.flags4 & CFG4stackalign))
+        {
+            unsigned grex = I64 ? REX_W << 16 : 0;
             regm_t mval_save = regcon.immed.mval;
             regcon.immed.mval = 0;      // prevent reghasvalue() optimizations
                                         // because c hasn't been executed yet
-            cs1 = genc2(cs1,0x81,modregrm(3,5,SP),sz);  // SUB ESP,sz
+            cs1 = genc2(cs1,0x81,grex | modregrm(3,5,SP),sz);  // SUB ESP,sz
             regcon.immed.mval = mval_save;
             cs1 = genadjesp(cs1, sz);
 
-            cx = genc2(CNIL,0x81,modregrm(3,0,SP),sz);  // ADD ESP,sz
+            code *cx = genc2(CNIL,0x81,grex | modregrm(3,0,SP),sz);  // ADD ESP,sz
             cx = genadjesp(cx, -sz);
             cs2 = cat(cx, cs2);
         }
@@ -1505,6 +1611,7 @@
   return cat4(cs1,c,cs3,cs2);
 }
 
+
 /*****************************
  * Given an opcode and EA in cs, generate code
  * for each floating register in turn.
@@ -1512,9 +1619,10 @@
  *      tym     either TYdouble or TYfloat
  */
 
-code *fltregs(code __ss *pcs,tym_t tym)
+code *fltregs(code *pcs,tym_t tym)
 {   code *c;
 
+    assert(!I64);
     tym = tybasic(tym);
     if (I32)
     {
@@ -1556,6 +1664,7 @@
     return c;
 }
 
+
 /*****************************
  * Given a result in registers, test it for TRUE or FALSE.
  * Will fail if TYfptr and the reg is ES!
@@ -1564,29 +1673,27 @@
  */
 
 code *tstresult(regm_t regm,tym_t tym,unsigned saveflag)
-{ code *ce;
-  unsigned reg;
+{
   unsigned scrreg;                      /* scratch register             */
-  unsigned sz;
   regm_t scrregm;
 
 #ifdef DEBUG
   if (!(regm & (mBP | ALLREGS)))
-        printf("tstresult(regm = x%x, tym = x%lx, saveflag = %d)\n",
+        printf("tstresult(regm = x%x, tym = x%x, saveflag = %d)\n",
             regm,tym,saveflag);
 #endif
   assert(regm & (mBP | ALLREGS));
   tym = tybasic(tym);
-  ce = CNIL;
-  reg = findreg(regm);
-  sz = tysize[tym];
+  code *ce = CNIL;
+  unsigned reg = findreg(regm);
+  unsigned sz = tysize[tym];
   if (sz == 1)
   {     assert(regm & BYTEREGS);
         return genregs(ce,0x84,reg,reg);        // TEST regL,regL
   }
   if (sz <= REGSIZE)
   {
-    if (I32)
+    if (!I16)
     {
         if (tym == TYfloat)
         {   if (saveflag)
@@ -1597,11 +1704,13 @@
                 reg = scrreg;
             }
             ce = cat(ce,getregs(mask[reg]));
-            return gen2(ce,0xD1,modregrm(3,4,reg)); /* SHL reg,1        */
+            return gen2(ce,0xD1,modregrmx(3,4,reg)); // SHL reg,1
         }
         ce = gentstreg(ce,reg);                 // TEST reg,reg
-        if (tysize[tym] == SHORTSIZE)
+        if (sz == SHORTSIZE)
             ce->Iflags |= CFopsize;             /* 16 bit operands      */
+        else if (sz == 8)
+            code_orrex(ce, REX_W);
     }
     else
         ce = gentstreg(ce,reg);                 // TEST reg,reg
@@ -1620,8 +1729,7 @@
             if (I32)
             {
                 if (tyfv(tym))
-                {   c = genregs(CNIL,0x0F,scrreg,reg);
-                    c->Iop2 = 0xB7;                     /* MOVZX scrreg,msreg   */
+                {   c = genregs(CNIL,0x0FB7,scrreg,reg); // MOVZX scrreg,msreg
                     ce = cat(ce,c);
                 }
                 else
@@ -1680,6 +1788,7 @@
   return ce;
 }
 
+
 /******************************
  * Given the result of an expression is in retregs,
  * generate necessary code to return result in *pretregs.
@@ -1711,14 +1820,14 @@
   c = CNIL;
   sz = tysize[tym];
   if (sz == 1)
-  {     unsigned reg;
-
+  {
         assert(retregs & BYTEREGS);
-        reg = findreg(retregs);
+        unsigned reg = findreg(retregs);
         if (e->Eoper == OPvar &&
             e->EV.sp.Voffset == 1 &&
             e->EV.sp.Vsym->Sfl == FLreg)
         {
+            assert(reg < 4);
             if (forccs)
                 c = gen2(c,0x84,modregrm(3,reg | 4,reg | 4));   // TEST regH,regH
             forccs = 0;
@@ -1727,13 +1836,12 @@
   if ((retregs & forregs) == retregs)   /* if already in right registers */
         *pretregs = retregs;
   else if (forregs)             /* if return the result in registers    */
-  {     unsigned opsflag;
-
+  {
         if (forregs & (mST01 | mST0))
             return fixresult87(e,retregs,pretregs);
         ce = CNIL;
-        opsflag = FALSE;
-        if (!I32 && sz == 8)
+        unsigned opsflag = FALSE;
+        if (I16 && sz == 8)
         {   if (forregs & mSTACK)
             {   assert(retregs == DOUBLEREGS_16);
                 /* Push floating regs   */
@@ -1806,11 +1914,7 @@
 int clib_inited = 0;            // != 0 if initialized
 
 code *callclib(elem *e,unsigned clib,regm_t *pretregs,regm_t keepmask)
-{ code *c,*cpop;
-  regm_t retregs;
-  symbol *s;
-  int i;
-
+{
 #if TARGET_LINUX || TARGET_OSX || TARGET_FREEBSD || TARGET_SOLARIS
   static symbol lib[] =
   {
@@ -2082,7 +2186,7 @@
   {
         assert(sizeof(lib) / sizeof(lib[0]) == CLIBMAX);
         assert(sizeof(info) / sizeof(info[0]) == CLIBMAX);
-        for (i = 0; i < CLIBMAX; i++)
+        for (int i = 0; i < CLIBMAX; i++)
         {   lib[i].Stype = tsclib;
 #if MARS
             lib[i].Sxtrnnum = 0;
@@ -2090,7 +2194,7 @@
 #endif
         }
 
-        if (I32)
+        if (!I16)
         {   /* Adjust table for 386     */
             lib[CLIBdbllng].Sregsaved  = Z(DOUBLEREGS_32);
             lib[CLIBlngdbl].Sregsaved  = Z(DOUBLEREGS_32);
@@ -2117,12 +2221,14 @@
 #undef Z
 
   assert(clib < CLIBMAX);
-  s = &lib[clib];
+  symbol *s = &lib[clib];
   assert(I32 || !(info[clib].flags & INF32));
-  cpop = CNIL;
-  c = getregs((~s->Sregsaved & (mES | mBP | ALLREGS)) & ~keepmask); // mask of regs destroyed
+  code *cpop = CNIL;
+  code *c = getregs((~s->Sregsaved & (mES | mBP | ALLREGS)) & ~keepmask); // mask of regs destroyed
   keepmask &= ~s->Sregsaved;
-  int npushed = 0;
+    int npushed = numbitsset(keepmask);
+    gensaverestore2(keepmask, &c, &cpop);
+#if 0
   while (keepmask)
   {     unsigned keepreg;
 
@@ -2140,12 +2246,13 @@
                 npushed++;
         }
   }
+#endif
 
     c = cat(c, save87regs(info[clib].push87));
-    for (i = 0; i < info[clib].push87; i++)
+    for (int i = 0; i < info[clib].push87; i++)
         c = cat(c, push87());
 
-    for (i = 0; i < info[clib].pop87; i++)
+    for (int i = 0; i < info[clib].pop87; i++)
         pop87();
 
   if (config.target_cpu >= TARGET_80386 && clib == CLIBlmul && !I32)
@@ -2169,14 +2276,19 @@
             if (npush & (STACKALIGN - 1))
             {   nalign = STACKALIGN - (npush & (STACKALIGN - 1));
                 c = genc2(c,0x81,modregrm(3,5,SP),nalign); // SUB ESP,nalign
+                if (I64)
+                    code_orrex(c, REX_W);
             }
         }
         c = gencs(c,(LARGECODE) ? 0x9A : 0xE8,0,FLfunc,s);      // CALL s
         if (nalign)
-            c = genc2(c,0x81,modregrm(3,0,SP),nalign); // ADD ESP,nalign
+        {   c = genc2(c,0x81,modregrm(3,0,SP),nalign); // ADD ESP,nalign
+            if (I64)
+                code_orrex(c, REX_W);
+        }
         calledafunc = 1;
 
-        if (!I32 &&                                     // bug in Optlink
+        if (I16 &&                                   // bug in Optlink for weak references
             config.flags3 & CFG3wkfloat &&
             (info[clib].flags & (INFfloat | INFwkdone)) == INFfloat)
         {   info[clib].flags |= INFwkdone;
@@ -2184,9 +2296,9 @@
             obj_wkext(s,rtlsym[RTLSYM_INTONLY]);
         }
   }
-  if (!I32)
+    if (I16)
         stackpush -= info[clib].pop;
-  retregs = I32 ? info[clib].retregs32 : info[clib].retregs16;
+    regm_t retregs = I16 ? info[clib].retregs16 : info[clib].retregs32;
   return cat(cat(c,cpop),fixresult(e,retregs,pretregs));
 }
 
@@ -2210,17 +2322,17 @@
   c = CNIL;
   keepmsk = 0;
   if (OTbinary(e->Eoper))               // if parameters
-  {     unsigned stackalign = REGSIZE;
-        elem *ep;
-        elem *en;
-        regm_t retregs;
-        tym_t tyf;
-
-        if (I32)
         {
-            tyf = tybasic(e->E1->Ety);
+        if (I16)
+        {
+            c = cat(c, params(e->E2,2));   // push parameters
+        }
+        else if (I32)
+        {
+            unsigned stackalign = REGSIZE;
+            tym_t tyf = tybasic(e->E1->Ety);
 
-            // First compute numpara, the total pushed on the stack
+            // First compute numpara, the total bytes pushed on the stack
             switch (tyf)
             {   case TYf16func:
                     stackalign = 2;
@@ -2228,6 +2340,7 @@
                 case TYmfunc:
                 case TYjfunc:
                     // last parameter goes into register
+                    elem *ep;
                     for (ep = e->E2; ep->Eoper == OPparam; ep = ep->E2)
                     {
                         numpara += paramsize(ep->E1,stackalign);
@@ -2257,6 +2370,8 @@
             {
                 numalign = STACKALIGN - ((numpara + stackpush) & (STACKALIGN - 1));
                 c = genc2(NULL,0x81,modregrm(3,5,SP),numalign); // SUB ESP,numalign
+                if (I64)
+                    code_orrex(c, REX_W);
                 c = genadjesp(c, numalign);
                 stackpush += numalign;
                 stackpushsave += numalign;
@@ -2265,21 +2380,21 @@
             switch (tyf)
             {   case TYf16func:
                     stackalign = 2;
-                    break;
+                    goto Ldefault2;
                 case TYmfunc:   // last parameter goes into ECX
                     preg = CX;
                     goto L1;
                 case TYjfunc:   // last parameter goes into EAX
                     preg = AX;
                     goto L1;
-
                 L1:
+                {   elem *ep;
+                    elem *en;
                     for (ep = e->E2; ep->Eoper == OPparam; ep = en)
                     {
                         c = cat(c,params(ep->E1,stackalign));
                         en = ep->E2;
                         freenode(ep);
-                        ep = en;
                     }
                     if (tyf == TYjfunc &&
                         // This must match type_jparam()
@@ -2291,18 +2406,18 @@
                         c = cat(c,params(ep,stackalign));
                         goto Lret;
                     }
-                    keepmsk = mask[preg];
-                    retregs = keepmsk;
+                    // preg is the register to put the parameter ep in
+                    keepmsk = mask[preg];       // don't change preg when evaluating func address
+                    regm_t retregs = keepmsk;
                     if (ep->Eoper == OPstrthis)
-                    {   code *c1;
-                        code *c2;
-                        unsigned np;
+                    {   code *c2;
 
-                        c1 = getregs(retregs);
+                        code *c1 = getregs(retregs);
                         // LEA preg,np[ESP]
-                        np = stackpush - ep->EV.Vuns;   // stack delta to parameter
-                        c2 = genc1(CNIL,0x8D,modregrm(2,preg,4),FLconst,np);
-                        c2->Isib = modregrm(0,4,SP);
+                        unsigned np = stackpush - ep->EV.Vuns;   // stack delta to parameter
+                        c2 = genc1(CNIL,0x8D,(modregrm(0,4,SP) << 8) | modregrm(2,preg,4),FLconst,np);
+                        if (I64)
+                            code_orrex(c2, REX_W);
                         c = cat3(c,c1,c2);
                     }
                     else
@@ -2311,8 +2426,132 @@
                     }
                     goto Lret;
             }
-        }
+                default:
+                Ldefault2:
         c = cat(c, params(e->E2,stackalign));   // push parameters
+                    break;
+            }
+        }
+        else
+        {   assert(I64);
+
+            struct Parameter { elem *e; int reg; };
+
+            #ifdef DEBUG
+            #define PARAMETERS_DIM 3
+            #else
+            #define PARAMETERS_DIM 10
+            #endif
+            Parameter parameters_tmp[PARAMETERS_DIM];
+            Parameter *parameters = parameters_tmp;
+            size_t parameters_dim = PARAMETERS_DIM;
+
+            // Load up parameters[]
+            elem *ep;
+            elem *en;
+            int np = 0;
+            for (ep = e->E2; ep->Eoper == OPparam; ep = en)
+            {
+                if (np + 1 == parameters_dim)   // if not space for 2 more
+                {   // Grow parameters[]
+                    parameters_dim = np + 16;
+                    Parameter *p = (Parameter *)alloca(parameters_dim * sizeof(Parameter));
+                    parameters = (Parameter *)memcpy(p, parameters, np * sizeof(Parameter));
+                }
+                parameters[np++].e = ep->E1;
+                en = ep->E2;
+                freenode(ep);
+            }
+            parameters[np++].e = ep;
+
+            unsigned stackalign = REGSIZE;
+            tym_t tyf = tybasic(e->E1->Ety);
+
+            // Compute numpara, the total bytes pushed on the stack
+            int r = 0;
+            int xmmcnt = XMM0;
+            for (int i = np; --i >= 0;)
+            {
+                static const unsigned char argregs[6] = { DI,SI,DX,CX,R8,R9 };
+                elem *ep = parameters[i].e;
+                tym_t ty = ep->Ety;
+                if (r < sizeof(argregs)/sizeof(argregs[0]))     // if more arg regs
+                {
+                    if (
+                        // This must match type_jparam()
+                        ty64reg(ty) ||
+                        ((tybasic(ty) == TYstruct || tybasic(ty) == TYarray) &&
+                         ep->Enumbytes <= REGSIZE && ep->Enumbytes != 3 && ep->Enumbytes)
+                        )
+                    {
+                        parameters[i].reg = argregs[r];
+                        r++;
+                        continue;       // goes in register, not stack
+                    }
+                }
+                if (xmmcnt < XMM7)
+                {
+                    if (tyfloating(ty) && tysize(ty) <= 8)
+                    {
+                        parameters[i].reg = xmmcnt;
+                        xmmcnt++;
+                        continue;       // goes in register, not stack
+                    }
+                }
+                parameters[i].reg = -1;         // -1 means no register
+                numpara += paramsize(ep,stackalign);
+            }
+            assert((numpara & (REGSIZE - 1)) == 0);
+            assert((stackpush & (REGSIZE - 1)) == 0);
+
+            /* Adjust start of the stack so after all args are pushed,
+             * the stack will be aligned.
+             */
+            if (STACKALIGN == 16 && (numpara + stackpush) & (STACKALIGN - 1))
+            {
+                numalign = STACKALIGN - ((numpara + stackpush) & (STACKALIGN - 1));
+                c = genc2(NULL,0x81,(REX_W << 16) | modregrm(3,5,SP),numalign); // SUB ESP,numalign
+                c = genadjesp(c, numalign);
+                stackpush += numalign;
+                stackpushsave += numalign;
+            }
+
+            /* Parameters go into the registers RDI,RSI,RDX,RCX,R8,R9
+             * float and double parameters go into XMM0..XMM7
+             * For variadic functions, count of XMM registers used goes in AL
+             */
+            for (int i = 0; i < np; i++)
+            {
+                elem *ep = parameters[i].e;
+                int preg = parameters[i].reg;
+                if (preg == -1)
+                    c = cat(c,params(ep,stackalign));
+                else
+                {
+                    // Goes in register preg, not stack
+                    regm_t retregs = mask[preg];
+                    if (ep->Eoper == OPstrthis)
+                    {
+                        code *c1 = getregs(retregs);
+                        // LEA preg,np[ESP]
+                        unsigned np = stackpush - ep->EV.Vuns;   // stack delta to parameter
+                        code *c2 = genc1(CNIL,0x8D,(REX_W << 16) |
+                                             (modregrm(0,4,SP) << 8) |
+                                              modregxrm(2,preg,4), FLconst,np);
+                        c = cat3(c,c1,c2);
+                    }
+                    else
+                    {   code *cp = scodelem(ep,&retregs,keepmsk,FALSE);
+                        c = cat(c,cp);
+                    }
+                    keepmsk |= retregs;      // don't change preg when evaluating func address
+                }
+            }
+            if (e->Eflags & EFLAGS_variadic)
+            {   movregconst(c,AX,xmmcnt - XMM0,1);
+                keepmsk |= mAX;
+            }
+        }
     }
     else
     {
@@ -2323,6 +2562,8 @@
         {
             numalign = STACKALIGN - ((stackpush) & (STACKALIGN - 1));
             c = genc2(NULL,0x81,modregrm(3,5,SP),numalign); // SUB ESP,numalign
+            if (I64)
+                code_orrex(c, REX_W);
             c = genadjesp(c, numalign);
             stackpush += numalign;
             stackpushsave += numalign;
@@ -2331,14 +2572,14 @@
     }
 Lret:
     cgstate.stackclean--;
-    if (I32)
+    if (I16)
+        numpara = stackpush - stackpushsave;
+    else
     {
         if (numpara != stackpush - stackpushsave)
             printf("numpara = %d, stackpush = %d, stackpushsave = %d\n", numpara, stackpush, stackpushsave);
         assert(numpara == stackpush - stackpushsave);
     }
-    else
-        numpara = stackpush - stackpushsave;
     return cat(c,funccall(e,numpara,numalign,pretregs,keepmsk));
 }
 
@@ -2349,16 +2590,15 @@
 {
     code *c1;
     code *c2;
-    unsigned np;
-    unsigned reg;
 
     assert(tysize(e->Ety) == REGSIZE);
-    reg = findreg(*pretregs & allregs);
+    unsigned reg = findreg(*pretregs & allregs);
     c1 = getregs(mask[reg]);
     // LEA reg,np[ESP]
-    np = stackpush - e->EV.Vuns;        // stack delta to parameter
-    c2 = genc1(CNIL,0x8D,modregrm(2,reg,4),FLconst,np);
-    c2->Isib = modregrm(0,4,SP);
+    unsigned np = stackpush - e->EV.Vuns;        // stack delta to parameter
+    c2 = genc1(CNIL,0x8D,(modregrm(0,4,SP) << 8) | modregxrm(2,reg,4),FLconst,np);
+    if (I64)
+        code_orrex(c2, REX_W);
     return cat3(c1,c2,fixresult(e,mask[reg],pretregs));
 }
 
@@ -2418,6 +2658,8 @@
             makeitextern(s);
             c1 = cat(c1,getregs(mCX));
             c1 = genc(c1,0x8D,modregrm(2,CX,BPRM),FLallocatmp,0,0,0);  // LEA CX,&localsize[BP]
+            if (I64)
+                code_orrex(c1, REX_W);
             usedalloca = 2;             // new way
 #else
             usedalloca = 1;             // old way
@@ -2450,11 +2692,23 @@
             ce->Iflags |= farfunc ? (CFseg | CFoff) : (CFselfrel | CFoff);
 #if TARGET_LINUX
             if (s == tls_get_addr_sym)
-            {   /* Append a NOP so GNU linker has patch room
+            {
+                if (I32)
+                {
+                    /* Append a NOP so GNU linker has patch room
                  */
                 ce = gen1(ce, 0x90);            // NOP
                 code_orflag(ce, CFvolatile);    // don't schedule it
             }
+                else
+                {   /* Prepend 66 66 48 so GNU linker has patch room
+                     */
+                    assert(I64);
+                    ce->Irex = REX | REX_W;
+                    ce = cat(gen1(CNIL, 0x66), ce);
+                    ce = cat(gen1(CNIL, 0x66), ce);
+                }
+            }
 #endif
         }
         ce = cat(c1,ce);
@@ -2472,7 +2726,7 @@
         assert(e1->Eoper == OPind);
         e11 = e1->E1;
         e11ty = tybasic(e11->Ety);
-        assert(I32 || (e11ty == (farfunc ? TYfptr : TYnptr)));
+        assert(!I16 || (e11ty == (farfunc ? TYfptr : TYnptr)));
 
         /* if we can't use loadea()     */
         if ((EOP(e11) || e11->Eoper == OPconst) &&
@@ -2506,7 +2760,7 @@
             {
              LF2:
                 reg = findreg(retregs);
-                ce = gen2(ce,0xFF,modregrm(3,2,reg));   /* CALL reg     */
+                ce = gen2(ce,0xFF,modregrmx(3,2,reg));   /* CALL reg     */
             }
         }
         else
@@ -2567,7 +2821,8 @@
     retregs = regmask(e->Ety, tym1);
 
     // If stack needs cleanup
-    if (OTbinary(e->Eoper) && !typfunc(tym1) &&
+    if (OTbinary(e->Eoper) &&
+        (!typfunc(tym1) || I64) &&
       !(s && s->Sflags & SFLexit))
     {
         if (tym1 == TYhfunc)
@@ -2688,6 +2943,8 @@
   if (tyfloating(tym))
         obj_fltused();
 
+  int grex = I64 ? REX_W << 16 : 0;
+
   /* sz = number of bytes pushed        */
   if (tyscalar(tym))
         szb = size(tym);
@@ -2706,7 +2963,7 @@
 
   c = CNIL;
   cs.Iflags = 0;
-  cs.Ijty = 0;
+  cs.Irex = 0;
   switch (e->Eoper)
   {
 #if SCPP
@@ -2715,7 +2972,7 @@
         e1 = e->E1;
         c = docommas(&e1);              /* skip over any comma expressions */
 
-        c = genc2(c,0x81,modregrm(3,5,SP),sz); /* SUB SP,sizeof(struct) */
+        c = genc2(c,0x81,grex | modregrm(3,5,SP),sz); // SUB SP,sizeof(struct)
         stackpush += sz;
         genadjesp(c,sz);
 
@@ -2735,13 +2992,17 @@
         retregs = allregs;
         c = allocreg(&retregs,&reg,TYoffset);
         c = genregs(c,0x89,SP,reg);             // MOV reg,SP
+        if (I64)
+            code_orrex(c, REX_W);
         np = stackpush - e->EV.Vuns;            // stack delta to parameter
-        c = genc2(c,0x81,modregrm(3,0,reg),np); // ADD reg,np
+        c = genc2(c,0x81,grex | modregrmx(3,0,reg),np); // ADD reg,np
         if (sz > REGSIZE)
         {   c = gen1(c,0x16);                   // PUSH SS
             stackpush += REGSIZE;
         }
-        c = gen1(c,0x50 + reg);                 // PUSH reg
+        c = gen1(c,0x50 + (reg & 7));           // PUSH reg
+        if (reg & 8)
+            code_orrex(c, REX_B);
         stackpush += REGSIZE;
         genadjesp(c,sz);
         ce = CNIL;
@@ -2772,11 +3033,11 @@
                 seg = 0;                /* assume no seg override       */
                 retregs = sz ? IDXREGS : 0;
                 doneoff = FALSE;
-                if (I32 && sz & 2)      /* if odd number of words to push */
+                if (!I16 && sz & 2)     // if odd number of words to push
                 {   pushsize = 2;
                     op16 = 1;
                 }
-                else if (!I32 && config.target_cpu >= TARGET_80386 && (sz & 3) == 0)
+                else if (I16 && config.target_cpu >= TARGET_80386 && (sz & 3) == 0)
                 {   pushsize = 4;       // push DWORDs at a time
                     op16 = 1;
                 }
@@ -2860,18 +3121,18 @@
                         assert(0);
                 }
                 reg = findreglsw(retregs);
-                rm = I32 ? regtorm32[reg] : regtorm[reg];
+                rm = I16 ? regtorm[reg] : regtorm32[reg];
                 if (op16)
                     seg |= CFopsize;            // operand size
                 if (npushes <= 4)
                 {
                     assert(!doneoff);
                     for (c2 = CNIL; npushes > 1; npushes--)
-                    {   c2 = genc1(c2,0xFF,modregrm(2,6,rm),FLconst,pushsize * (npushes - 1));  // PUSH [reg]
+                    {   c2 = genc1(c2,0xFF,modregrmx(2,6,rm),FLconst,pushsize * (npushes - 1));  // PUSH [reg]
                         code_orflag(c2,seg);
                         genadjesp(c2,pushsize);
                     }
-                    c3 = gen2(CNIL,0xFF,modregrm(0,6,rm));      // PUSH [reg]
+                    c3 = gen2(CNIL,0xFF,modregrmx(0,6,rm));     // PUSH [reg]
                     c3->Iflags |= seg;
                     genadjesp(c3,pushsize);
                     ce = cat4(cc,c1,c2,c3);
@@ -2886,11 +3147,11 @@
                     {   /* This disgusting thing should be done when    */
                         /* reg is loaded. Too lazy to fix it now.       */
                                                         /* ADD reg,sz-2 */
-                        c2 = genc2(c2,0x81,modregrm(3,0,reg),sz-pushsize);
+                        c2 = genc2(c2,0x81,grex | modregrmx(3,0,reg),sz-pushsize);
                     }
-                    c3 = gen2(CNIL,0xFF,modregrm(0,6,rm));      // PUSH [reg]
+                    c3 = gen2(CNIL,0xFF,modregrmx(0,6,rm));      // PUSH [reg]
                     c3->Iflags |= seg | CFtarg2;
-                    genc2(c3,0x81,modregrm(3,5,reg),pushsize);  // SUB reg,2
+                    genc2(c3,0x81,grex | modregrmx(3,5,reg),pushsize);  // SUB reg,2
                     size = ((seg & CFSEG) ? -8 : -7) - op16;
                     if (code_next(c3)->Iop != 0x81)
                         size++;
@@ -3001,7 +3262,8 @@
             }
             else
             {   c = cat(c,offsetinreg(e,&retregs));
-                c = gen1(c,0x50+findreg(retregs)); /* PUSH reg          */
+                unsigned reg = findreg(retregs);
+                c = genpush(c,reg);             // PUSH reg
                 genadjesp(c,REGSIZE);
             }
             goto ret;
@@ -3010,10 +3272,9 @@
         {
             stackpush += sz;
             if (tysize[tym] == tysize[TYfptr])
-            {   code *c1;
-
+            {
                 /* PUSH SEG e   */
-                c1 = gencs(CNIL,0x68,0,FLextern,s);
+                code *c1 = gencs(CNIL,0x68,0,FLextern,s);
                 c1->Iflags = CFseg;
                 genadjesp(c1,REGSIZE);
                 c = cat(c,c1);
@@ -3045,7 +3306,7 @@
         {   int regsize = REGSIZE;
             unsigned flag = 0;
 
-            if (!I32 && config.target_cpu >= TARGET_80386 && sz > 2 &&
+            if (I16 && config.target_cpu >= TARGET_80386 && sz > 2 &&
                 !e->Ecount)
             {   regsize = 4;
                 flag |= CFopsize;
@@ -3101,7 +3362,7 @@
         if (config.target_cpu >= TARGET_80286)
 //       && (e->Ecount == 0 || e->Ecount != e->Ecomsub))
         {   pushi = 1;
-            if (!I32 && config.target_cpu >= TARGET_80386 && i >= 4)
+            if (I16 && config.target_cpu >= TARGET_80386 && i >= 4)
             {   regsize = 4;
                 flag = CFopsize;
             }
@@ -3130,7 +3391,7 @@
             {
                 ce = regwithvalue(ce,allregs,value,&reg,0);
             Preg:
-                ce = gen1(ce,0x50 + reg);               /* PUSH reg     */
+                ce = genpush(ce,reg);         // PUSH reg
             }
             code_orflag(ce,flag);                       /* operand size */
         } while (i);
@@ -3150,7 +3411,7 @@
             c = cat(c,codelem(e,&retregs,FALSE));
             stackpush += sz;
             c = genadjesp(c,sz);
-            c = genc2(c,0x81,modregrm(3,5,SP),sz);      /* SUB SP,sz    */
+            c = genc2(c,0x81,grex | modregrm(3,5,SP),sz);      // SUB SP,sz
             switch (tym)
             {
                 case TYfloat:
@@ -3178,15 +3439,14 @@
                 default:
                     assert(0);
             }
-            if (I32)
+            if (!I16)
             {
                 c1 = NULL;
                 c2 = NULL;
                 if (tycomplex(tym))
                 {
                     // FSTP sz/2[ESP]
-                    c2 = genc1(CNIL,op,modregrm(2,r,4),FLconst,sz/2);
-                    c2->Isib = modregrm(0,4,SP);
+                    c2 = genc1(CNIL,op,(modregrm(0,4,SP) << 8) | modregxrm(2,r,4),FLconst,sz/2);
                     pop87();
                 }
                 pop87();
@@ -3218,18 +3478,19 @@
       stackpush += sz;
   if (sz <= REGSIZE)
   {
-        c = gen1(c,0x50+findreg(retregs));      /* PUSH reg             */
+        c = genpush(c,findreg(retregs));        // PUSH reg
         genadjesp(c,REGSIZE);
   }
   else if (sz == REGSIZE * 2)
-  {     c = gen1(c,0x50+findregmsw(retregs)); /* PUSH msreg             */
-        gen1(c,0x50+findreglsw(retregs));         /* PUSH lsreg         */
+  {     c = genpush(c,findregmsw(retregs));     // PUSH msreg
+        genpush(c,findreglsw(retregs));         // PUSH lsreg
         genadjesp(c,sz);
   }
 ret:
   return cat(cp,c);
 }
 
+
 /*******************************
  * Get offset portion of e, and store it in an index
  * register. Return mask of index register in *pretregs.
@@ -3266,6 +3527,7 @@
     return c;
 }
 
+
 /******************************
  * Generate code to load data into registers.
  */
@@ -3300,7 +3562,7 @@
   }
   sz = tysize[tym];
   cs.Iflags = 0;
-  cs.Ijty = 0;
+  cs.Irex = 0;
   if (*pretregs == mPSW)
   {
         regm = allregs;
@@ -3311,11 +3573,11 @@
         }
         else if (sz <= REGSIZE)
         {
-            if (I32 && (tym == TYfloat || tym == TYifloat))
+            if (!I16 && (tym == TYfloat || tym == TYifloat))
             {   c = allocreg(&regm,&reg,TYoffset);      /* get a register */
                 ce = loadea(e,&cs,0x8B,reg,0,0,0);      // MOV reg,data
                 c = cat(c,ce);
-                ce = gen2(CNIL,0xD1,modregrm(3,4,reg)); /* SHL reg,1      */
+                ce = gen2(CNIL,0xD1,modregrmx(3,4,reg)); /* SHL reg,1      */
                 c = cat(c,ce);
             }
             else
@@ -3326,11 +3588,13 @@
 
                 // Convert to TEST instruction if EA is a register
                 // (to avoid register contention on Pentium)
-                if ((c->Iop & 0xFE) == 0x38 &&
+                if ((c->Iop & ~1) == 0x38 &&
                     (c->Irm & modregrm(3,0,0)) == modregrm(3,0,0)
                    )
                 {   c->Iop = (c->Iop & 1) | 0x84;
-                    c->Irm = (c->Irm & modregrm(3,0,7)) | modregrm(0,c->Irm & 7,0);
+                    code_newreg(c, c->Irm & 7);
+                    if (c->Irex & REX_B)
+                        c->Irex = (c->Irex & ~REX_B) | REX_R;
                 }
             }
         }
@@ -3375,7 +3639,7 @@
   }
   /* not for flags only */
   flags = *pretregs & mPSW;             /* save original                */
-  forregs = *pretregs & (mBP | ALLREGS | mES);
+  forregs = *pretregs & (mBP | ALLREGS | mES | XMMREGS);
   if (*pretregs & mSTACK)
         forregs |= DOUBLEREGS;
   if (e->Eoper == OPconst)
@@ -3391,11 +3655,13 @@
         {
             if (sz == 1)
                 flags |= 1;
-            else if (I32 && sz == SHORTSIZE &&
+            else if (!I16 && sz == SHORTSIZE &&
                      !(mask[reg] & regcon.mvar) &&
                      !(config.flags4 & CFG4speed)
                     )
                 flags |= 2;
+            if (sz == 8)
+                flags |= 64;
             ce = movregconst(CNIL,reg,e->EV.Vint,flags);
             flags = 0;                          // flags are already set
         }
@@ -3475,7 +3741,7 @@
         }
 #endif
         assert(forregs & BYTEREGS);
-        if (I32)
+        if (!I16)
             c = cat(c,loadea(e,&cs,0x8A,reg,0,0,0));    // MOV regL,data
         else
         {   nregm = tyuns(tym) ? BYTEREGS : mAX;
@@ -3491,6 +3757,13 @@
             }
         }
     }
+    else if (forregs & XMMREGS)
+    {
+        assert(sz == 4 || sz == 8);             // float or double
+        unsigned op = (sz == 4) ? 0xF30F10 : 0xF20F10;
+        ce = loadea(e,&cs,op,reg,0,RMload,0); // MOVSS/MOVSD reg,data
+        c = cat(c,ce);
+    }
     else if (sz <= REGSIZE)
     {
         ce = loadea(e,&cs,0x8B,reg,0,RMload,0); // MOV reg,data
diff -aruw dmd62/backend/cod2.c dmd63/backend/cod2.c
--- dmd62/backend/cod2.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/cod2.c	2010-08-09 14:33:14.000000000 -0400
@@ -36,34 +36,52 @@
  * Index is rm of modregrm field.
  */
 
-regm_t idxregm(unsigned rm,unsigned sib)
+regm_t idxregm(code *c)
 {
     static const unsigned char idxsib[8] = { mAX,mCX,mDX,mBX,0,mBP,mSI,mDI };
     static const unsigned char idxrm[8] = {mBX|mSI,mBX|mDI,mSI,mDI,mSI,mDI,0,mBX};
-    regm_t idxm;
 
-    idxm = 0;
+    unsigned rm = c->Irm;
+    regm_t idxm = 0;
     if ((rm & 0xC0) != 0xC0)            /* if register is not the destination */
     {
-        if (I32)
+        if (I16)
+            idxm = idxrm[rm & 7];
+        else
         {
             if ((rm & 7) == 4)          /* if sib byte                  */
             {
-                idxm = idxsib[(sib >> 3) & 7];  /* scaled index reg     */
+                unsigned sib = c->Isib;
+                unsigned idxreg = (sib >> 3) & 7;
+                if (c->Irex & REX_X)
+                {   idxreg |= 8;
+                    idxm = mask[idxreg];  // scaled index reg
+                }
+                else
+                    idxm = idxsib[idxreg];  // scaled index reg
                 if ((sib & 7) == 5 && (rm & 0xC0) == 0)
                     ;
                 else
-                    idxm |= idxsib[sib & 7];
-            }
+                {   unsigned base = sib & 7;
+                    if (c->Irex & REX_B)
+                        idxm |= mask[base | 8];
             else
-                idxm |= idxsib[rm & 7];
+                        idxm |= idxsib[base];
+                }
         }
         else
-            idxm = idxrm[rm & 7];
+            {   unsigned base = rm & 7;
+                if (c->Irex & REX_B)
+                    idxm |= mask[base | 8];
+                else
+                    idxm |= idxsib[base];
+            }
+        }
     }
     return idxm;
 }
 
+
 #if TARGET_WINDOS
 /***************************
  * Gen code for call to floating point routine.
@@ -105,23 +123,21 @@
 }
 #endif
 
+
 /*****************************
  * Handle operators which are more or less orthogonal
  * ( + - & | ^ )
  */
 
 code *cdorth(elem *e,regm_t *pretregs)
-{ tym_t ty,ty1,ty2;
+{ tym_t ty1;
   regm_t retregs,rretregs,posregs;
-  unsigned reg,rreg,op1,op2,mode,test,byte;
+  unsigned reg,rreg,op1,op2,mode;
   int rval;
-  code *c,*cg,*cl,*cr,cs;
-  targ_int i;
+  code *c,*cg,*cl;
+  targ_size_t i;
   elem *e1,*e2;
   int numwords;                         /* # of words to be operated on */
-  unsigned char word;                   /* if word operands             */
-  int e2oper;
-  unsigned sz;
   static int nest;
 
   //printf("cdorth(e = %p, *pretregs = %s)\n",e,regm_str(*pretregs));
@@ -141,16 +157,17 @@
         return opdouble(e,pretregs,(e->Eoper == OPadd) ? CLIBdadd
                                                        : CLIBdsub);
 #endif
-  ty2 = tybasic(e2->Ety);
-  e2oper = e2->Eoper;
-  ty = tybasic(e->Ety);
-  sz = tysize[ty];
-  byte = (sz == 1);
-  word = (I32 && sz == SHORTSIZE) ? CFopsize : 0;
+  tym_t ty2 = tybasic(e2->Ety);
+  int e2oper = e2->Eoper;
+  tym_t ty = tybasic(e->Ety);
+  unsigned sz = tysize[ty];
+  unsigned byte = (sz == 1);
+  unsigned char word = (!I16 && sz == SHORTSIZE) ? CFopsize : 0;
+  unsigned test = FALSE;                // assume we destroyed lvalue
+  code cs;
   cs.Iflags = 0;
-  cs.Ijty = 0;
-  test = FALSE;                         /* assume we destroyed lvalue   */
-  cr = CNIL;                            /* initialize                   */
+  cs.Irex = 0;
+  code *cr = CNIL;
 
   switch (e->Eoper)
   {     case OPadd:     mode = 0;
@@ -177,7 +194,7 @@
 
   /* Compute number of words to operate on.                             */
   numwords = 1;
-  if (I32)
+  if (!I16)
   {     /* Cannot operate on longs and then do a 'paint' to a far       */
         /* pointer, because far pointers are 48 bits and longs are 32.  */
         /* Therefore, numwords can never be 2.                          */
@@ -201,14 +218,19 @@
   {
         // Handle the case of (var & const)
         if (e2->Eoper == OPconst)
-        {   targ_int value;
-
+        {
             c = getlvalue(&cs,e1,0);
-            value = e2->EV.Vint;
+            targ_size_t value = e2->EV.Vpointer;
             if (sz == 2)
                 value &= 0xFFFF;
+            else if (sz == 4)
+                value &= 0xFFFFFFFF;
             if (reghasvalue(byte ? BYTEREGS : ALLREGS,value,&reg))
                 goto L11;
+            if (sz == 8)
+            {
+                assert(value == (int)value);    // sign extend imm32
+            }
             op1 = 0xF7;
             cs.IEV2.Vint = value;
             cs.IFL2 = FLconst;
@@ -220,7 +242,7 @@
         {
             c = getlvalue(&cs,e1,0);
         L11:
-            cs.Irm |= modregrm(0,reg,0);
+            code_newreg(&cs, reg);
         L10:
             cs.Iop = op1 ^ byte;
             cs.Iflags |= word | CFpsw;
@@ -234,38 +256,37 @@
   if (e->Eoper == OPadd &&
       !(*pretregs & mPSW) &&            /* flags aren't set by LEA      */
       !nest &&                          // could cause infinite recursion if e->Ecount
-      sz == REGSIZE)                    // far pointers aren't handled
-  {     int e1oper;
-
+      (sz == REGSIZE || (I64 && sz == 4)))  // far pointers aren't handled
+  {
         // Handle the case of (e + &var)
-        e1oper = e1->Eoper;
+        int e1oper = e1->Eoper;
         if ((e2oper == OPrelconst && (config.target_cpu >= TARGET_Pentium || (!e2->Ecount && stackfl[el_fl(e2)])))
                 || // LEA costs too much for simple EAs on older CPUs
             (e2oper == OPconst && (e1->Eoper == OPcall || e1->Eoper == OPcallns) && !(*pretregs & mAX)) ||
-            (I32 && (isscaledindex(e1) || isscaledindex(e2))) ||
-            (I32 && e1oper == OPvar && e1->EV.sp.Vsym->Sfl == FLreg && (e2oper == OPconst || (e2oper == OPvar && e2->EV.sp.Vsym->Sfl == FLreg))) ||
+            (!I16 && (isscaledindex(e1) || isscaledindex(e2))) ||
+            (!I16 && e1oper == OPvar && e1->EV.sp.Vsym->Sfl == FLreg && (e2oper == OPconst || (e2oper == OPvar && e2->EV.sp.Vsym->Sfl == FLreg))) ||
             (e2oper == OPconst && e1oper == OPeq && e1->E1->Eoper == OPvar) ||
-            (I32 && e2oper == OPrelconst && !e1->Ecount &&
+            (!I16 && e2oper == OPrelconst && !e1->Ecount &&
              (e1oper == OPmul || e1oper == OPshl) &&
              e1->E2->Eoper == OPconst &&
              ssindex(e1oper,e1->E2->EV.Vuns)
             ) ||
-            (I32 && e1->Ecount)
+            (!I16 && e1->Ecount)
            )
-        {   int inc;
-
-            inc = e->Ecount != 0;
+        {
+            int inc = e->Ecount != 0;
             nest += inc;
             c = getlvalue(&cs,e,0);
             nest -= inc;
+            unsigned reg;
             c = cat(c,allocreg(pretregs,&reg,ty));
             cs.Iop = 0x8D;
-            cs.Irm |= modregrm(0,reg,0);
+            code_newreg(&cs, reg);
             return gen(c,&cs);          /* LEA reg,EA                   */
         }
 
         // Handle the case of ((e + c) + e2)
-        if (I32 &&
+        if (!I16 &&
             e1oper == OPadd &&
             (e1->E2->Eoper == OPconst || e2oper == OPconst) &&
             !e1->Ecount
@@ -300,9 +321,8 @@
                 e11->E2->Eoper == OPconst &&
                 !e11->Ecount
                )
-            {   targ_size_t co1;
-
-                co1 = el_tolong(e11->E2);
+            {
+                targ_size_t co1 = el_tolong(e11->E2);
                 if (e11->Eoper == OPshl)
                 {
                     if (co1 > 3)
@@ -334,10 +354,14 @@
                 goto L13;
             }
             else
-            {   regm_t regm;
+            {
             L13:
+                regm_t regm;
                 if (e11->Eoper == OPvar && isregvar(e11,&regm,&reg1))
                 {
+                    if (tysize[tybasic(e11->Ety)]<= REGSIZE)
+                        retregs = mask[reg1]; // only want the LSW
+                    else
                     retregs = regm;
                     c1 = NULL;
                     freenode(e11);
@@ -347,14 +371,16 @@
             }
             rretregs = ALLREGS & ~retregs;
             c2 = scodelem(ebase,&rretregs,retregs,TRUE);
-            {   regm_t sregs;
-
-                sregs = *pretregs & ~rretregs;
+            {
+                regm_t sregs = *pretregs & ~rretregs;
                 if (!sregs)
                     sregs = ALLREGS & ~rretregs;
                 c3 = allocreg(&sregs,&reg,ty);
             }
 
+            assert((retregs & (retregs - 1)) == 0); // must be only one register
+            assert((rretregs & (rretregs - 1)) == 0); // must be only one register
+
             reg1 = findreg(retregs);
             reg2 = findreg(rretregs);
 
@@ -365,11 +391,13 @@
                 {   static unsigned imm32[4] = {1+1,2+1,4+1,8+1};
 
                     // IMUL reg,imm32
-                    c = genc2(CNIL,0x69,modregrm(3,reg,reg1),imm32[ss]);
+                    c = genc2(CNIL,0x69,modregxrm(3,reg,BP),imm32[ss]);
                 }
                 else
                 {   // LEA reg,[reg1*ss][reg1]
-                    c = gen2sib(CNIL,0x8D,modregrm(0,reg,4),modregrm(ss,reg1,reg1));
+                    c = gen2sib(CNIL,0x8D,modregxrm(0,reg,4),modregrm(ss,reg1 & 7,reg1 & 7));
+                    if (reg1 & 8)
+                        code_orrex(c, REX_X | REX_B);
                 }
                 reg1 = reg;
                 ss = ss2;                               // use *2 for scale
@@ -379,10 +407,16 @@
             c = cat4(c1,c2,c3,c);
 
             cs.Iop = 0x8D;                      // LEA reg,c[reg1*ss][reg2]
-            cs.Irm = modregrm(2,reg,4);
-            cs.Isib = modregrm(ss,reg1,reg2);
+            cs.Irm = modregrm(2,reg & 7,4);
+            cs.Isib = modregrm(ss,reg1 & 7,reg2 & 7);
             cs.Iflags = CFoff;
-            cs.Ijty = 0;
+            cs.Irex = 0;
+            if (reg & 8)
+                cs.Irex |= REX_R;
+            if (reg1 & 8)
+                cs.Irex |= REX_X;
+            if (reg2 & 8)
+                cs.Irex |= REX_B;
             cs.IFL1 = FLconst;
             cs.IEV1.Vuns = edisp->EV.Vuns;
 
@@ -505,9 +539,8 @@
                  isregvar(e1,&regm,NULL) &&
                  regm != retregs &&
                  tysize[ty1] == tysize[ty2])
-        {   elem *es;
-
-            es = e1;
+        {
+            elem *es = e1;
             e1 = e2;
             e2 = es;
         }
@@ -542,9 +575,11 @@
                 }
                 else
                 {   c = genregs(c,op1,reg,rreg);
-                    if (I32 && *pretregs & mPSW)
+                    if (!I16 && *pretregs & mPSW)
                         c->Iflags |= word;
                 }
+                if (I64 && sz == 8)
+                    code_orrex(c, REX_W);
         }
         else /* numwords == 2 */                /* ADD lsreg,lsrreg     */
         {
@@ -581,7 +616,7 @@
             goto L2;
         if (numwords == 1)
         {
-                i = e2->EV.Vint;
+                i = e2->EV.Vpointer;
                 if (word)
                 {
                     if (!(*pretregs & mPSW) &&
@@ -603,7 +638,11 @@
                 }
                 else
                     cs.Iop = 0x81;
-                cs.Irm = modregrm(3,mode,reg);
+                cs.Irm = modregrm(3,mode&7,reg&7);
+                if (mode & 8)
+                    cs.Irex |= REX_R;
+                if (reg & 8)
+                    cs.Irex |= REX_B;
                 cs.IFL2 = (e2->Eoper == OPconst) ? FLconst : el_fl(e2);
                 /* Modify instruction for special cases */
                 switch (e->Eoper)
@@ -617,8 +656,8 @@
                         else
                             break;
                         cs.Iop = (0x40 | iop | reg) ^ byte;
-                        if (byte && *pretregs & mPSW)
-                        {   cs.Irm = modregrm(3,0,reg) | iop;
+                        if ((byte && *pretregs & mPSW) || I64)
+                        {   cs.Irm = modregrm(3,0,reg & 7) | iop;
                             cs.Iop = 0xFF;
                         }
                         break;
@@ -673,13 +712,12 @@
         c = loadea(e2,&cs,op1,
                 ((numwords == 2) ? findreglsw(retregs) : reg),
                 0,retregs,retregs);
-        if (I32 && word)
+        if (!I16 && word)
         {   if (*pretregs & mPSW)
                 code_orflag(c,word);
             else
-            {   code *ce;
-
-                ce = code_last(c);
+            {
+                code *ce = code_last(c);
                 ce->Iflags &= ~word;
             }
         }
@@ -713,6 +751,7 @@
   return cat4(cl,cr,cg,c);
 }
 
+
 /*****************************
  * Handle multiply, divide, modulo and remquo.
  * Note that modulo isn't defined for doubles.
@@ -739,7 +778,7 @@
 
     keepregs = 0;
     cs.Iflags = 0;
-    cs.Ijty = 0;
+    cs.Irex = 0;
     c = cg = cr = CNIL;                         // initialize
     e2 = e->E2;
     e1 = e->E1;
@@ -748,6 +787,8 @@
     byte = tybyte(e->Ety) != 0;
     uns = tyuns(tyml) || tyuns(e2->Ety);
     oper = e->Eoper;
+    unsigned rex = (I64 && sz == 8) ? REX_W : 0;
+    unsigned grex = rex << 16;
 
     if (tyfloating(tyml))
 #if TARGET_LINUX || TARGET_OSX || TARGET_FREEBSD || TARGET_SOLARIS
@@ -756,7 +797,7 @@
         return opdouble(e,pretregs,(oper == OPmul) ? CLIBdmul : CLIBddiv);
 #endif
 
-    opunslng = I32 ? OPu32_64 : OPu16_32;
+    opunslng = I16 ? OPu16_32 : OPu32_64;
     switch (oper)
     {
         case OPmul:
@@ -830,7 +871,7 @@
             cr = scodelem(e2->E1,&rretregs,retregs,TRUE); // get rvalue
             cg = getregs(mAX | mDX);
             rreg = findreg(rretregs);
-            cg = gen2(cg,0xF7,modregrm(3,op,rreg)); // OP AX,rreg
+            cg = gen2(cg,0xF7,grex | modregrmx(3,op,rreg)); // OP AX,rreg
         }
         freenode(e->E1);
         freenode(e2);
@@ -886,7 +927,8 @@
             goto L3;
         }
 
-        if (oper != OPmul && e2factor == 10 && sz == REGSIZE &&
+        if (oper != OPmul && e2factor == 10 &&
+            (!I16 && sz == 4) &&
             config.flags4 & CFG4speed && !uns)
         {
             /* R1 / 10
@@ -912,7 +954,7 @@
             cg = getregs(regm | mDX | mAX);
 
             cg = movregconst(cg, AX, 0x66666667, 0);    // MOV EAX,0x66666667
-            cg = gen2(cg,0xF7,modregrm(3,5,reg));       // IMUL R1
+            cg = gen2(cg,0xF7,modregrmx(3,5,reg));      // IMUL R1
             genmovreg(cg, AX, reg);                     // MOV EAX,R1
             genc2(cg,0xC1,modregrm(3,7,AX),31);         // SAR EAX,31
             genc2(cg,0xC1,modregrm(3,7,DX),2);          // SAR EDX,2
@@ -925,13 +967,13 @@
 
                 case OPmod:
                     genmulimm(cg,AX,DX,10);             // IMUL EAX,EDX,10
-                    gen2(cg,0x2B,modregrm(3,reg,AX));   // SUB R1,EAX
+                    gen2(cg,0x2B,modregxrm(3,reg,AX));  // SUB R1,EAX
                     resreg = regm;
                     break;
 
                 case OPremquo:
                     genmulimm(cg,AX,DX,10);             // IMUL EAX,EDX,10
-                    gen2(cg,0x2B,modregrm(3,reg,AX));   // SUB R1,EAX
+                    gen2(cg,0x2B,modregxrm(3,reg,AX));  // SUB R1,EAX
                     genmovreg(cg, AX, DX);              // MOV EAX,EDX
                     genmovreg(cg, DX, reg);             // MOV EDX,R1
                     resreg = mDX | mAX;
@@ -957,7 +999,7 @@
             if (!resreg)
                 resreg = retregs;
 
-            if (I32)
+            if (!I16)
             {   // See if we can use an LEA instruction
                 int ss2 = 0;
                 int shift;
@@ -985,12 +1027,9 @@
                     L4:
                     {
 #if 1
-                        regm_t regm;
-                        int r;
-
-                        regm = byte ? BYTEREGS : ALLREGS;               // don't use EBP
+                        regm_t regm = byte ? BYTEREGS : ALLREGS;        // don't use EBP
                         cl = codelem(e->E1,&regm,TRUE);
-                        r = findreg(regm);
+                        unsigned r = findreg(regm);
 
                         if (ss2)
                         {   // Don't use EBP
@@ -1000,17 +1039,19 @@
                         }
                         cg = allocreg(&resreg,&reg,tyml);
 
-                        c = gen2sib(CNIL,0x8D,modregrm(0,reg,4),
-                                              modregrm(ss,r,r));
+                        c = gen2sib(CNIL,0x8D,grex | modregxrm(0,reg,4),
+                                              modregxrmx(ss,r,r));
                         if (ss2)
                         {
-                            gen2sib(c,0x8D,modregrm(0,reg,4),
-                                           modregrm(ss2,reg,5));
+                            gen2sib(c,0x8D,grex | modregxrm(0,reg,4),
+                                           modregxrm(ss2,reg,5));
                             code_last(c)->IFL1 = FLconst;
                             code_last(c)->IEV1.Vint = 0;
                         }
                         else if (!(e2factor & 1))    // if even factor
-                            genregs(c,0x03,reg,reg); // ADD reg,reg
+                        {   genregs(c,0x03,reg,reg); // ADD reg,reg
+                            code_orrex(c,rex);
+                        }
                         cg = cat(cg,c);
                         goto L3;
 #else
@@ -1045,30 +1086,30 @@
                     case 26:    shift = 0;
                                 goto L5;
                     L5:
-                    {           regm_t sregm;
-                                unsigned sreg;
-
+                    {
                                 // Don't use EBP
                                 resreg &= ~mBP;
                                 if (!resreg)
                                     resreg = retregs;
                                 cl = allocreg(&resreg,&reg,TYint);
 
-                                sregm = ALLREGS & ~resreg;
+                                regm_t sregm = ALLREGS & ~resreg;
                                 cl = cat(cl,codelem(e->E1,&sregm,FALSE));
-                                sreg = findreg(sregm);
+                                unsigned sreg = findreg(sregm);
                                 cg = getregs(resreg | sregm);
                                 // LEA reg,[sreg * 4][sreg]
                                 // SHL sreg,shift
                                 // LEA reg,[sreg * 8][reg]
-                                c = gen2sib(CNIL,0x8D,modregrm(0,reg,4),
-                                                      modregrm(2,sreg,sreg));
+                                c = gen2sib(CNIL,0x8D,grex | modregxrm(0,reg,4),
+                                                      modregxrmx(2,sreg,sreg));
                                 if (shift)
-                                    genc2(c,0xC1,modregrm(3,4,sreg),shift);
-                                gen2sib(c,0x8D,modregrm(0,reg,4),
-                                                      modregrm(3,sreg,reg));
+                                    genc2(c,0xC1,grex | modregrmx(3,4,sreg),shift);
+                                gen2sib(c,0x8D,grex | modregxrm(0,reg,4),
+                                                      modregxrmx(3,sreg,reg));
                                 if (!(e2factor & 1))         // if even factor
-                                    genregs(c,0x03,reg,reg); // ADD reg,reg
+                                {   genregs(c,0x03,reg,reg); // ADD reg,reg
+                                    code_orrex(c,rex);
+                                }
                                 cg = cat(cg,c);
                                 goto L3;
                     }
@@ -1080,12 +1121,13 @@
             cg = allocreg(&resreg,&rreg,e->Ety);
 
             /* IMUL reg,imm16   */
-            cg = genc2(cg,0x69,modregrm(3,rreg,reg),e2factor);
+            cg = genc2(cg,0x69,grex | modregxrmx(3,rreg,reg),e2factor);
             goto L3;
         }
 
         // Special code for signed divide or modulo by power of 2
-        if (sz == REGSIZE && (oper == OPdiv || oper == OPmod) && !uns &&
+        if ((sz == REGSIZE || (I64 && sz == 4)) &&
+            (oper == OPdiv || oper == OPmod) && !uns &&
             (pow2 = ispow2(e2factor)) != -1 &&
             !(config.target_cpu < TARGET_80286 && pow2 != 1 && oper == OPdiv)
            )
@@ -1098,19 +1140,25 @@
                 // L1: sar     eax,1
 
                 code *cnop;
-                unsigned reg;
 
                 retregs = allregs;
                 cl = codelem(e->E1,&retregs,FALSE);     // eval left leaf
-                reg = findreg(retregs);
+                unsigned reg = findreg(retregs);
                 freenode(e2);
                 cg = getregs(retregs);
                 cg = gentstreg(cg,reg);                 // TEST reg,reg
+                code_orrex(cg, rex);
                 cnop = gennop(CNIL);
                 genjmp(cg,JNS,FLcode,(block *)cnop);    // JNS cnop
+                if (I64)
+                {
+                    gen2(cg,0xFF,modregrmx(3,0,reg));       // INC reg
+                    code_orrex(cg,rex);
+                }
+                else
                 gen1(cg,0x40 + reg);                    // INC reg
                 cg = cat(cg,cnop);
-                gen2(cg,0xD1,modregrm(3,7,reg));        // SAR reg,1
+                gen2(cg,0xD1,grex | modregrmx(3,7,reg));        // SAR reg,1
                 resreg = retregs;
                 goto L3;
             }
@@ -1118,16 +1166,17 @@
             freenode(e2);
             cg = getregs(mAX | mDX);            // trash these regs
             cg = gen1(cg,0x99);                         // CWD
+            code_orrex(cg, rex);
             if (pow2 == 1)
             {
                 if (oper == OPdiv)
-                {   gen2(cg,0x2B,modregrm(3,AX,DX));    // SUB AX,DX
-                    gen2(cg,0xD1,modregrm(3,7,AX));     // SAR AX,1
+                {   gen2(cg,0x2B,grex | modregrm(3,AX,DX));    // SUB AX,DX
+                    gen2(cg,0xD1,grex | modregrm(3,7,AX));     // SAR AX,1
                 }
                 else // OPmod
-                {   gen2(cg,0x33,modregrm(3,AX,DX));    // XOR AX,DX
-                    genc2(cg,0x81,modregrm(3,4,AX),1);  // AND AX,1
-                    gen2(cg,0x03,modregrm(3,DX,AX));    // ADD DX,AX
+                {   gen2(cg,0x33,grex | modregrm(3,AX,DX));    // XOR AX,DX
+                    genc2(cg,0x81,grex | modregrm(3,4,AX),1);  // AND AX,1
+                    gen2(cg,0x03,grex | modregrm(3,DX,AX));    // ADD DX,AX
                 }
             }
             else
@@ -1135,18 +1184,18 @@
 
                 m = (1 << pow2) - 1;
                 if (oper == OPdiv)
-                {   genc2(cg,0x81,modregrm(3,4,DX),m);  // AND DX,m
-                    gen2(cg,0x03,modregrm(3,AX,DX));    // ADD AX,DX
+                {   genc2(cg,0x81,grex | modregrm(3,4,DX),m);  // AND DX,m
+                    gen2(cg,0x03,grex | modregrm(3,AX,DX));    // ADD AX,DX
                     // Be careful not to generate this for 8088
                     assert(config.target_cpu >= TARGET_80286);
-                    genc2(cg,0xC1,modregrm(3,7,AX),pow2); // SAR AX,pow2
+                    genc2(cg,0xC1,grex | modregrm(3,7,AX),pow2); // SAR AX,pow2
                 }
                 else // OPmod
-                {   gen2(cg,0x33,modregrm(3,AX,DX));    // XOR AX,DX
-                    gen2(cg,0x2B,modregrm(3,AX,DX));    // SUB AX,DX
-                    genc2(cg,0x81,modregrm(3,4,AX),m);  // AND AX,mask
-                    gen2(cg,0x33,modregrm(3,AX,DX));    // XOR AX,DX
-                    gen2(cg,0x2B,modregrm(3,AX,DX));    // SUB AX,DX
+                {   gen2(cg,0x33,grex | modregrm(3,AX,DX));    // XOR AX,DX
+                    gen2(cg,0x2B,grex | modregrm(3,AX,DX));    // SUB AX,DX
+                    genc2(cg,0x81,grex | modregrm(3,4,AX),m);  // AND AX,mask
+                    gen2(cg,0x33,grex | modregrm(3,AX,DX));    // XOR AX,DX
+                    gen2(cg,0x2B,grex | modregrm(3,AX,DX));    // SUB AX,DX
                     resreg = mAX;
                 }
             }
@@ -1164,13 +1213,16 @@
         if (sz <= REGSIZE)
         {   cg = getregs(mAX | mDX);            /* trash these regs     */
             if (op == 7)                        /* signed divide        */
-                cg = gen1(cg,0x99);             /* CWD                  */
+            {   cg = gen1(cg,0x99);             // CWD
+                code_orrex(cg,rex);
+            }
             else if (op == 6)                   /* unsigned divide      */
-            {   cg = movregconst(cg,DX,0,0);    // MOV DX,0
+            {
+                cg = movregconst(cg,DX,0,(sz == 8) ? 64 : 0);    // MOV DX,0
                 cg = cat(cg,getregs(mDX));
             }
             rreg = findreg(rretregs);
-            cg = gen2(cg,0xF7 ^ byte,modregrm(3,op,rreg)); /* OP AX,rreg */
+            cg = gen2(cg,0xF7 ^ byte,grex | modregrmx(3,op,rreg)); // OP AX,rreg
         L3:
             c = fixresult(e,resreg,pretregs);
         }
@@ -1200,7 +1252,7 @@
         break;
     case OPvar:
     L1:
-        if (I32 && sz <= REGSIZE)
+        if (!I16 && sz <= REGSIZE)
         {
             if (oper == OPmul && sz > 1)        /* no byte version      */
             {
@@ -1259,6 +1311,7 @@
   return cat4(cl,cr,cg,c);
 }
 
+
 /***************************
  * Handle OPnot and OPbool.
  * Generate:
@@ -1292,6 +1345,8 @@
 
     op = e->Eoper;
     sz = tysize(e1->Ety);
+    unsigned rex = (I64 && sz == 8) ? REX_W : 0;
+    unsigned grex = rex << 16;
     if (!tyfloating(e1->Ety))
     {
     if (sz <= REGSIZE && e1->Eoper == OPvar)
@@ -1299,7 +1354,7 @@
 
         c = getlvalue(&cs,e1,0);
         freenode(e1);
-        if (I32 && sz == 2)
+        if (!I16 && sz == 2)
             cs.Iflags |= CFopsize;
 
         retregs = *pretregs & (ALLREGS | mBP);
@@ -1315,7 +1370,7 @@
                 cs.IEV2.Vint = 0;
             }
             cs.Iop ^= (sz == 1);
-            cs.Irm |= modregrm(0,reg,0);
+            code_newreg(&cs,reg);
             c = gen(c,&cs);                             // CMP e1,0
 
             retregs &= BYTEREGS;
@@ -1332,7 +1387,7 @@
             {
                 iop = 0x0F94;   // SETZ rm8
             }
-            c1 = gen2(c1,iop,modregrm(3,0,reg));
+            c1 = gen2(c1,iop,grex | modregrmx(3,0,reg));
             if (op == OPbool)
                 *pretregs &= ~mPSW;
             goto L4;
@@ -1347,7 +1402,7 @@
             cs.IEV2.Vint = 1;
         }
         cs.Iop ^= (sz == 1);
-        cs.Irm |= modregrm(0,reg,0);
+        code_newreg(&cs,reg);
         c = gen(c,&cs);                         // CMP e1,1
 
         c1 = allocreg(&retregs,&reg,TYint);
@@ -1364,17 +1419,23 @@
         c = codelem(e->E1,&retregs,FALSE);
         reg = findreg(retregs);
         c1 = getregs(retregs);
-        c1 = gen2(c1,0xF7 ^ (sz == 1),modregrm(3,3,reg));       // NEG reg
+        c1 = gen2(c1,0xF7 ^ (sz == 1),grex | modregrmx(3,3,reg));   // NEG reg
         code_orflag(c1,CFpsw);
         if (I32 && sz == SHORTSIZE)
             code_orflag(c1,CFopsize);
     L2:
         c1 = genregs(c1,0x19,reg,reg);                  // SBB reg,reg
+        code_orrex(c1, rex);
         // At this point, reg==0 if e1==0, reg==-1 if e1!=0
         if (op == OPnot)
+        {
+            if (I64)
+                gen2(c1,0xFF,grex | modregrmx(3,0,reg));    // INC reg
+            else
             gen1(c1,0x40 + reg);                        // INC reg
+        }
         else
-            gen2(c1,0xF7,modregrm(3,3,reg));            // NEG reg
+            gen2(c1,0xF7,grex | modregrmx(3,3,reg));    // NEG reg
         if (*pretregs & mPSW)
         {   code_orflag(c1,CFpsw);
             *pretregs &= ~mPSW;         // flags are always set anyway
@@ -1387,6 +1448,8 @@
   ctrue = gennop(CNIL);
   c = logexp(e->E1,(op == OPnot) ? FALSE : TRUE,FLcode,ctrue);
   forflags = *pretregs & mPSW;
+  if (I64 && sz == 8)
+        forflags |= 64;
   assert(tysize(e->Ety) <= REGSIZE);            // result better be int
   cfalse = allocreg(pretregs,&reg,e->Ety);      // allocate reg for result
   for (c1 = cfalse; c1; c1 = code_next(c1))
@@ -1400,6 +1463,7 @@
   return c;
 }
 
+
 /************************
  * Complement operator
  */
@@ -1415,6 +1479,8 @@
         return codelem(e->E1,pretregs,FALSE);
   tym = tybasic(e->Ety);
   sz = tysize[tym];
+  unsigned rex = (I64 && sz == 8) ? REX_W : 0;
+  unsigned grex = rex << 16;
   possregs = (sz == 1) ? BYTEREGS : allregs;
   retregs = *pretregs & possregs;
   if (retregs == 0)
@@ -1435,6 +1501,7 @@
         reg = (sz <= REGSIZE) ? findreg(retregs) : findregmsw(retregs);
         op = (sz == 1) ? 0xF6 : 0xF7;
         c = genregs(CNIL,op,2,reg);             // NOT reg
+        code_orrex(c, rex);
         if (sz == 2 * REGSIZE)
         {   reg = findreglsw(retregs);
             genregs(c,op,2,reg);                // NOT reg+1
@@ -1465,7 +1532,9 @@
     c1 = codelem(e->E1,&retregs,FALSE);
     cg = getregs(retregs);              // retregs will be destroyed
     reg = findreg(retregs);
-    c = gen2(CNIL,0x0FC8 + reg,0);      // BSWAP reg
+    c = gen2(CNIL,0x0FC8 + (reg & 7),0);      // BSWAP reg
+    if (reg & 8)
+        code_orrex(c, REX_B);
     return cat4(c1,cg,c,fixresult(e,retregs,pretregs));
 }
 
@@ -1505,6 +1574,8 @@
   psw = *pretregs & mPSW;               /* save PSW bit                 */
   op1 = e1->Eoper;
   sz1 = tysize(e1->Ety);
+  unsigned rex = (I64 && sz1 == 8) ? REX_W : 0;
+  unsigned grex = rex << 16;
   jop = jmpopcode(e1);
 
   if (!OTrel(op1) && e1 == e21 &&
@@ -1574,17 +1645,17 @@
         }
 
         if (v1 == 0 && v2 == -1L)
-            c = gen2(c,0xF6 + (opcode & 1),modregrm(3,2,reg));  // NOT reg
+            c = gen2(c,0xF6 + (opcode & 1),grex | modregrmx(3,2,reg));  // NOT reg
         else
         {
             v1 -= v2;
-            c = genc2(c,opcode,modregrm(3,4,reg),v1);   // AND reg,v1-v2
-            if (v2 == 1)
+            c = genc2(c,opcode,grex | modregrmx(3,4,reg),v1);   // AND reg,v1-v2
+            if (v2 == 1 && !I64)
                 gen1(c,0x40 + reg);                     // INC reg
-            else if (v2 == -1L)
+            else if (v2 == -1L && !I64)
                 gen1(c,0x48 + reg);                     // DEC reg
             else
-                genc2(c,opcode,modregrm(3,0,reg),v2);   // ADD reg,v2
+                genc2(c,opcode,grex | modregrmx(3,0,reg),v2);   // ADD reg,v2
         }
 
         freenode(e21);
@@ -1614,7 +1685,7 @@
         retregs = *pretregs & (ALLREGS | mBP);
         if (retregs & ~regcon.mvar)
             retregs &= ~regcon.mvar;    // don't disturb register variables
-        c = regwithvalue(c,retregs,e21->EV.Vint,&reg,8);
+        c = regwithvalue(c,retregs,e21->EV.Vint,&reg,sz1 == 8 ? 64|8 : 8);
         retregs = mask[reg];
 
         c = cat(c,cse_flush(1));                // flush CSE's to memory
@@ -1649,12 +1720,11 @@
 
         // This is necessary so that any cleanup code on one branch
         // is redone on the other branch.
-        cs.Iop = ESCAPE;
-        cs.Iop2 = ESCmark2;
+        cs.Iop = ESCAPE | ESCmark2;
         cs.Iflags = 0;
-        cs.Ijty = 0;
+        cs.Irex = 0;
         c1 = cat(gen(CNIL,&cs),c1);
-        cs.Iop2 = ESCrelease2;
+        cs.Iop = ESCAPE | ESCrelease2;
         c1 = gen(c1,&cs);
   }
 #endif
@@ -1728,11 +1798,12 @@
   unsigned reg;
   code *c;
   code *cl,*cr,*cg,*cnop1,*cnop2,*cnop3;
-  register code *c1;
+  code *c1;
   con_t regconsave;
   unsigned stackpushsave;
   int jcond;
   elem *e2;
+  unsigned sz = tysize(e->Ety);
 
   /* We can trip the assert with the following:                         */
   /*    if ( (b<=a) ? (c<b || a<=c) : c>=a )                            */
@@ -1767,7 +1838,7 @@
   }
   cnop2 = gennop(CNIL);
   if (tybasic(e2->Ety) == TYbool &&
-      tysize(e->Ety) == tysize(e2->Ety) &&
+      sz == tysize(e2->Ety) &&
       !(*pretregs & mPSW) &&
       e2->Eoper == OPcall)
   {
@@ -1778,7 +1849,7 @@
         // stack depth should not change when evaluating E2
         assert(stackpush == stackpushsave);
 
-        assert(tysize(e->Ety) <= REGSIZE);      // result better be int
+        assert(sz <= 4);                                        // result better be int
         retregs = *pretregs & allregs;
         cnop1 = cat(cnop1,allocreg(&retregs,&reg,TYint));       // allocate reg for result
         cg = genjmp(NULL,JMP,FLcode,(block *) cnop2);           // JMP cnop2
@@ -1798,7 +1869,7 @@
   /* stack depth should not change when evaluating E2   */
   assert(stackpush == stackpushsave);
 
-  assert(tysize(e->Ety) <= REGSIZE);    // result better be int
+  assert(sz <= 4);                      // result better be int
   retregs = *pretregs & (ALLREGS | mBP);
   if (!retregs) retregs = ALLREGS;      // if mPSW only
   cg = allocreg(&retregs,&reg,TYint);   // allocate reg for result
@@ -1816,6 +1887,7 @@
   return c;
 }
 
+
 /*********************
  * Generate code for shift left or shift right (OPshl,OPshr,OPashr).
  */
@@ -1845,6 +1917,8 @@
   assert(!tyfloating(tyml));
   uns = tyuns(tyml);
   oper = e->Eoper;
+    unsigned rex = (I64 && sz == 8) ? REX_W : 0;
+    unsigned grex = rex << 16;
 
 #if SCPP
   // Do this until the rest of the compiler does OPshr/OPashr correctly
@@ -1880,7 +1954,7 @@
     case OPconst:
         e2isconst = TRUE;               /* e2 is a constant             */
         shiftcnt = e2->EV.Vint;         /* get shift count              */
-        if ((I32 && sz <= REGSIZE) ||
+        if ((!I16 && sz <= REGSIZE) ||
             shiftcnt <= 4 ||            /* if sequence of shifts        */
             (sz == 2 &&
                 (shiftcnt == 8 || config.target_cpu >= TARGET_80286)) ||
@@ -1929,8 +2003,9 @@
                 }
 
                 // See if we should use LEA reg,xxx instead of shift
-                if (I32 && shiftcnt >= 1 && shiftcnt <= 3 &&
-                    sz == REGSIZE && oper == OPshl &&
+                if (!I16 && shiftcnt >= 1 && shiftcnt <= 3 &&
+                    (sz == REGSIZE || (I64 && sz == 4)) &&
+                    oper == OPshl &&
                     e1->Eoper == OPvar &&
                     !(*pretregs & mPSW) &&
                     config.flags4 & CFG4speed
@@ -1945,7 +2020,7 @@
                         cl = allocreg(&retregs,&resreg,e->Ety);
                         buildEA(&cs,-1,reg,1 << shiftcnt,0);
                         cs.Iop = 0x8D;
-                        cs.Irm |= modregrm(0,resreg,0);
+                        code_newreg(&cs,resreg);
                         cs.Iflags = 0;
                         cg = gen(NULL,&cs);             // LEA resreg,[reg * ss]
                         freenode(e1);
@@ -1970,17 +2045,17 @@
                     {
                         /* SHL resreg,shiftcnt  */
                         assert(!(sz == 1 && (mask[resreg] & ~BYTEREGS)));
-                        c = genc2(CNIL,0xC1 ^ byte,modregrm(3,s1,resreg),shiftcnt);
+                        c = genc2(CNIL,0xC1 ^ byte,grex | modregxrmx(3,s1,resreg),shiftcnt);
                         if (shiftcnt == 1)
                             c->Iop += 0x10;     /* short form of shift  */
                         // See if we need operand size prefix
-                        if (I32 && oper != OPshl && sz == 2)
+                        if (!I16 && oper != OPshl && sz == 2)
                             c->Iflags |= CFopsize;
                         if (forccs)
                             c->Iflags |= CFpsw;         // need flags result
                     }
                     else if (shiftcnt == 8)
-                    {   if (!(retregs & BYTEREGS))
+                    {   if (!(retregs & BYTEREGS) || resreg >= 4)
                         {
                             cl = cat(cl,cg);
                             goto L1;
@@ -1995,6 +2070,7 @@
 
                         if (oper == OPshl)
                         {       /* MOV regH,regL        XOR regL,regL   */
+                                assert(resreg < 4 && !rex);
                                 c = genregs(CNIL,0x8A,resreg+4,resreg);
                                 genregs(c,0x32,resreg,resreg);
                         }
@@ -2077,7 +2153,7 @@
         {
             cr = scodelem(e2,&rretregs,retregs,FALSE); /* get rvalue */
             cg = getregs(retregs);      /* trash these regs             */
-            c = gen2(CNIL,0xD3 ^ byte,modregrm(3,s1,resreg)); /* Sxx resreg,CX */
+            c = gen2(CNIL,0xD3 ^ byte,grex | modregrmx(3,s1,resreg)); /* Sxx resreg,CX */
 
             // Note that a shift by CL does not set the flags if
             // CL == 0. If e2 is a constant, we know it isn't 0
@@ -2276,6 +2352,7 @@
   return cat4(cl,cr,cg,c);
 }
 
+
 /***************************
  * Perform a 'star' reference (indirection).
  */
@@ -2319,7 +2396,7 @@
   c = getlvalue(&cs,e,RMload);          // get addressing mode
   if (*pretregs == 0)
         return c;
-  idxregs = idxregm(cs.Irm,cs.Isib);    /* mask of index regs used      */
+  idxregs = idxregm(&cs);               // mask of index regs used
   c = cat(c,fixresult(e,idxregs,pretregs));
   return c;
 #endif
@@ -2333,17 +2410,17 @@
   if (*pretregs == 0)
         return c;
 
-  idxregs = idxregm(cs.Irm,cs.Isib);    /* mask of index regs used      */
+  idxregs = idxregm(&cs);               // mask of index regs used
 
   if (*pretregs == mPSW)
   {
-        if (I32 && tym == TYfloat)
+        if (!I16 && tym == TYfloat)
         {       retregs = ALLREGS & ~idxregs;
                 c = cat(c,allocreg(&retregs,&reg,TYfloat));
                 cs.Iop = 0x8B;
-                cs.Irm |= modregrm(0,reg,0);
-                ce = gen(CNIL,&cs);                     /* MOV reg,lsw  */
-                gen2(ce,0xD1,modregrm(3,4,reg));        /* SHL reg,1    */
+                code_newreg(&cs,reg);
+                ce = gen(CNIL,&cs);                     // MOV reg,lsw
+                gen2(ce,0xD1,modregrmx(3,4,reg));       // SHL reg,1
         }
         else if (sz <= REGSIZE)
         {
@@ -2353,11 +2430,10 @@
                 cs.IEV2.Vint = 0;
                 ce = gen(CNIL,&cs);             /* CMP [idx],0          */
         }
-        else if (I32 && sz == REGSIZE + 2)      // if far pointer
+        else if (!I16 && sz == REGSIZE + 2)      // if far pointer
         {       retregs = ALLREGS & ~idxregs;
                 c = cat(c,allocreg(&retregs,&reg,TYint));
-                cs.Iop = 0x0F;
-                cs.Iop2 = 0xB7;
+                cs.Iop = 0x0FB7;
                 cs.Irm |= modregrm(0,reg,0);
                 getlvalue_msw(&cs);
                 ce = gen(CNIL,&cs);             /* MOVZX reg,msw        */
@@ -2417,7 +2493,7 @@
             while (i >= 0);
             goto L3;
         }
-        if (!I32 && sz == 8)
+        if (I16 && sz == 8)
             retregs = DOUBLEREGS_16;
 
         /* Watch out for loading an lptr from an lptr! We must have     */
@@ -2432,7 +2508,7 @@
         if (sz <= REGSIZE)
         {
                 cs.Iop = 0x8B ^ byte;
-        L2:     cs.Irm |= modregrm(0,reg,0);
+        L2:     code_newreg(&cs,reg);
                 ce = gen(CNIL,&cs);     /* MOV reg,[idx]                */
         }
         else if ((tym == TYfptr || tym == TYhptr) && retregs & mES)
@@ -2511,7 +2587,7 @@
                 gen(ce,&cs);
             }
         }
-        else if (!I32 && sz == 8)
+        else if (I16 && sz == 8)
         {
                 assert(reg == AX);
                 cs.Iop = 0x8B;
@@ -2584,8 +2660,6 @@
 
 code *cdstrlen( elem *e, regm_t *pretregs)
 {   code *c1,*c2,*c3,*c4;
-    regm_t retregs;
-    tym_t ty1;
 
     /* Generate strlen in CX:
         LES     DI,e1
@@ -2596,8 +2670,8 @@
         DEC     CX
      */
 
-    retregs = mDI;
-    ty1 = e->E1->Ety;
+    regm_t retregs = mDI;
+    tym_t ty1 = e->E1->Ety;
     if (!tyreg(ty1))
         retregs |= mES;
     c1 = codelem(e->E1,&retregs,FALSE);
@@ -2605,14 +2679,20 @@
     /* Make sure ES contains proper segment value       */
     c2 = cod2_setES(ty1);
 
+    unsigned char rex = I64 ? REX_W : 0;
+
     c3 = getregs_imm(mAX | mCX);
     c3 = movregconst(c3,AX,0,1);                /* MOV AL,0             */
-    c3 = movregconst(c3,CX,-1,0);               /* MOV CX,-1            */
+    c3 = movregconst(c3,CX,-1LL,I64 ? 64 : 0);  // MOV CX,-1
     c3 = cat(c3,getregs(mDI|mCX));
     c3 = gen1(c3,0xF2);                         /* REPNE                        */
     gen1(c3,0xAE);                              /* SCASB                */
     genregs(c3,0xF7,2,CX);                      /* NOT CX               */
-    c4 = gen1(CNIL,0x48 + CX);                  /* DEC CX               */
+    code_orrex(c3,rex);
+    if (I64)
+        c4 = gen2(CNIL,0xFF,(rex << 16) | modregrm(3,1,CX));  // DEC reg
+    else
+        c4 = gen1(CNIL,0x48 + CX);              // DEC CX
 
     if (*pretregs & mPSW)
     {
@@ -2622,15 +2702,13 @@
     return cat6(c1,c2,c3,c4,fixresult(e,mCX,pretregs),CNIL);
 }
 
+
 /*********************************
  * Generate code for strcmp(s1,s2) intrinsic.
  */
 
 code *cdstrcmp( elem *e, regm_t *pretregs)
 {   code *c1,*c1a,*c2,*c3,*c4;
-    regm_t retregs1;
-    regm_t retregs;
-    tym_t ty1,ty2;
     char need_DS;
     int segreg;
 
@@ -2653,14 +2731,14 @@
     L1:
     */
 
-    retregs1 = mSI;
-    ty1 = e->E1->Ety;
+    regm_t retregs1 = mSI;
+    tym_t ty1 = e->E1->Ety;
     if (!tyreg(ty1))
         retregs1 |= mCX;
     c1 = codelem(e->E1,&retregs1,FALSE);
 
-    retregs = mDI;
-    ty2 = e->E2->Ety;
+    regm_t retregs = mDI;
+    tym_t ty2 = e->E2->Ety;
     if (!tyreg(ty2))
         retregs |= mES;
     c1 = cat(c1,scodelem(e->E2,&retregs,retregs1,FALSE));
@@ -2669,6 +2747,8 @@
     c2 = cod2_setES(ty2);
     c3 = getregs_imm(mAX | mCX);
 
+    unsigned char rex = I64 ? REX_W : 0;
+
     /* Load DS with right value */
     switch (tybasic(ty1))
     {
@@ -2701,12 +2781,14 @@
     }
 
     c3 = movregconst(c3,AX,0,0);                /* MOV AX,0             */
-    c3 = movregconst(c3,CX,-1,0);               /* MOV CX,-1            */
+    c3 = movregconst(c3,CX,-1LL,I64 ? 64 : 0);  // MOV CX,-1
     c3 = cat(c3,getregs(mSI|mDI|mCX));
     c3 = gen1(c3,0xF2);                         /* REPNE                        */
     gen1(c3,0xAE);                              /* SCASB                */
     genregs(c3,0xF7,2,CX);                      /* NOT CX               */
+    code_orrex(c3,rex);
     genregs(c3,0x2B,DI,CX);                     /* SUB DI,CX            */
+    code_orrex(c3,rex);
     gen1(c3,0xF3);                              /* REPE                 */
     gen1(c3,0xA6);                              /* CMPSB                */
     if (need_DS)
@@ -2717,7 +2799,8 @@
         genjmp(c3,JE,FLcode,(block *) c4);      /* JE L1                */
         c3 = cat(c3,getregs(mAX));
         genregs(c3,0x1B,AX,AX);                 /* SBB AX,AX            */
-        genc2(c3,0x81,modregrm(3,3,AX),(targ_uns)-1);   /* SBB AX,-1            */
+        code_orrex(c3,rex);
+        genc2(c3,0x81,(rex << 16) | modregrm(3,3,AX),(targ_uns)-1);   // SBB AX,-1
     }
 
     *pretregs &= ~mPSW;
@@ -2730,13 +2813,8 @@
 
 code *cdmemcmp(elem *e,regm_t *pretregs)
 {   code *c1,*c2,*c3,*c4;
-    regm_t retregs1;
-    regm_t retregs;
-    regm_t retregs3;
-    tym_t ty1,ty2;
     char need_DS;
     int segreg;
-    elem *e1;
 
     /*
         MOV     SI,s1                   ;get destination pointer (s1)
@@ -2754,26 +2832,26 @@
     L1:
     */
 
-    e1 = e->E1;
+    elem *e1 = e->E1;
     assert(e1->Eoper == OPparam);
 
     // Get s1 into DX:SI
-    retregs1 = mSI;
-    ty1 = e1->E1->Ety;
+    regm_t retregs1 = mSI;
+    tym_t ty1 = e1->E1->Ety;
     if (!tyreg(ty1))
         retregs1 |= mDX;
     c1 = codelem(e1->E1,&retregs1,FALSE);
 
     // Get s2 into ES:DI
-    retregs = mDI;
-    ty2 = e1->E2->Ety;
+    regm_t retregs = mDI;
+    tym_t ty2 = e1->E2->Ety;
     if (!tyreg(ty2))
         retregs |= mES;
     c1 = cat(c1,scodelem(e1->E2,&retregs,retregs1,FALSE));
     freenode(e1);
 
     // Get nbytes into CX
-    retregs3 = mCX;
+    regm_t retregs3 = mCX;
     c1 = cat(c1,scodelem(e->E2,&retregs3,retregs | retregs1,FALSE));
 
     /* Make sure ES contains proper segment value       */
@@ -2871,19 +2949,23 @@
     ty2 = tybasic(e->E2->Ety);
     if (!tyreg(ty2))
         retregs |= mES;
+    unsigned char rex = I64 ? REX_W : 0;
     c1 = codelem(e->E2,&retregs,FALSE);
 
     /* Make sure ES contains proper segment value       */
     c2 = cod2_setES(ty2);
     c3 = getregs_imm(mAX | mCX);
     c3 = movregconst(c3,AX,0,1);                /* MOV AL,0             */
-    c3 = movregconst(c3,CX,-1,0);               /* MOV CX,-1            */
+    c3 = movregconst(c3,CX,-1,I64?64:0);        // MOV CX,-1
     c3 = cat(c3,getregs(mAX|mCX|mSI|mDI));
     c3 = gen1(c3,0xF2);                         /* REPNE                        */
     gen1(c3,0xAE);                              /* SCASB                */
     genregs(c3,0xF7,2,CX);                      /* NOT CX               */
+    code_orrex(c3,rex);
     genregs(c3,0x2B,DI,CX);                     /* SUB DI,CX            */
+    code_orrex(c3,rex);
     genmovreg(c3,SI,DI);                        /* MOV SI,DI            */
+    code_orrex(c3,rex);
 
     /* Load DS with right value */
     switch (ty2)
@@ -2931,7 +3013,9 @@
     if (need_DS)
         c4 = gen1(c4,0x1F);                     /* POP DS               */
     if (*pretregs)
-        c4 = genmovreg(c4,AX,DI);               /* MOV AX,DI            */
+    {   c4 = genmovreg(c4,AX,DI);               /* MOV AX,DI            */
+        code_orrex(c4,rex);
+    }
     c4 = gen1(c4,0xF3);                         /* REP                  */
     gen1(c4,0xA4);                              /* MOVSB                */
 
@@ -2995,6 +3079,8 @@
         retregs1 |= mES;
     c1 = cat(c1,scodelem(e->E1,&retregs1,retregs2 | retregs3,FALSE));
 
+    unsigned char rex = I64 ? REX_W : 0;
+
     /* Make sure ES contains proper segment value       */
     c2 = cod2_setES(ty1);
 
@@ -3033,6 +3119,7 @@
     if (*pretregs)                              // if need return value
     {   c3 = cat(c3,getregs(mAX));
         c3 = genmovreg(c3,AX,DI);
+        code_orrex(c3, rex);
     }
 
     if (0 && I32 && config.flags4 & CFG4speed)
@@ -3070,10 +3157,10 @@
     {
         c3 = cat(c3,getregs(mSI | mDI | mCX));
         if (!I32 && config.flags4 & CFG4speed)          // if speed optimization
-        {   c3 = gen2(c3,0xD1,modregrm(3,5,CX));        // SHR CX,1
+        {   c3 = gen2(c3,0xD1,(rex << 16) | modregrm(3,5,CX));        // SHR CX,1
             gen1(c3,0xF3);                              // REPE
             gen1(c3,0xA5);                              // MOVSW
-            gen2(c3,0x11,modregrm(3,CX,CX));            // ADC CX,CX
+            gen2(c3,0x11,(rex << 16) | modregrm(3,CX,CX));            // ADC CX,CX
         }
         c3 = gen1(c3,0xF3);                             // REPE
         gen1(c3,0xA4);                                  // MOVSB
@@ -3083,6 +3170,7 @@
     return cat4(c1,c2,c3,fixresult(e,mES|mAX,pretregs));
 }
 
+
 /*********************************
  * Generate code for memset(s,val,n) intrinsic.
  *      (s OPmemset (n OPparam val))
@@ -3101,25 +3189,29 @@
     unsigned remainder;
     targ_uns numbytes,numwords;
     int op;
-    targ_uns value;
+    targ_size_t value;
 
     //printf("cdmemset(*pretregs = x%x)\n", *pretregs);
     e1 = e->E1;
     e2 = e->E2;
     assert(e2->Eoper == OPparam);
 
+    unsigned char rex = I64 ? REX_W : 0;
+
     if (e2->E2->Eoper == OPconst)
     {
         value = el_tolong(e2->E2);
         value &= 0xFF;
         value |= value << 8;
         value |= value << 16;
+        value |= value << 32;
     }
 
     if (e2->E1->Eoper == OPconst)
     {
         numbytes = el_tolong(e2->E1);
-        if (numbytes <= REP_THRESHOLD && I32 && // doesn't work for 16 bits
+        if (numbytes <= REP_THRESHOLD &&
+            !I16 &&                     // doesn't work for 16 bits
             e2->E2->Eoper == OPconst)
         {
             targ_uns offset = 0;
@@ -3133,34 +3225,42 @@
                 switch (numbytes)
                 {
                     case 4:                     // MOV [reg],imm32
-                        c3 = genc2(CNIL,0xC7,modregrm(0,0,reg),value);
+                        c3 = genc2(CNIL,0xC7,modregrmx(0,0,reg),value);
                         goto fixres;
                     case 2:                     // MOV [reg],imm16
-                        c3 = genc2(CNIL,0xC7,modregrm(0,0,reg),value);
+                        c3 = genc2(CNIL,0xC7,modregrmx(0,0,reg),value);
                         c3->Iflags = CFopsize;
                         goto fixres;
                     case 1:                     // MOV [reg],imm8
-                        c3 = genc2(CNIL,0xC6,modregrm(0,0,reg),value);
+                        c3 = genc2(CNIL,0xC6,modregrmx(0,0,reg),value);
                         goto fixres;
                 }
             }
 
-            c1 = regwithvalue(c1, BYTEREGS & ~retregs1, value, &vreg, 0);
+            c1 = regwithvalue(c1, BYTEREGS & ~retregs1, value, &vreg, I64 ? 64 : 0);
             freenode(e2->E2);
             freenode(e2);
 
             while (numbytes >= REGSIZE)
             {                           // MOV dword ptr offset[reg],vreg
-                c2 = gen2(CNIL,0x89,modregrm(2,vreg,reg));
+                c2 = gen2(CNIL,0x89,(rex << 16) | modregxrmx(2,vreg,reg));
                 c2->IEVoffset1 = offset;
                 c2->IFL1 = FLconst;
                 numbytes -= REGSIZE;
                 offset += REGSIZE;
                 c3 = cat(c3,c2);
             }
+            if (numbytes & 4)
+            {                           // MOV dword ptr offset[reg],vreg
+                c2 = gen2(CNIL,0x89,modregxrmx(2,vreg,reg));
+                c2->IEVoffset1 = offset;
+                c2->IFL1 = FLconst;
+                offset += 4;
+                c3 = cat(c3,c2);
+            }
             if (numbytes & 2)
             {                           // MOV word ptr offset[reg],vreg
-                c2 = gen2(CNIL,0x89,modregrm(2,vreg,reg));
+                c2 = gen2(CNIL,0x89,modregxrmx(2,vreg,reg));
                 c2->IEVoffset1 = offset;
                 c2->IFL1 = FLconst;
                 c2->Iflags = CFopsize;
@@ -3169,7 +3269,7 @@
             }
             if (numbytes & 1)
             {                           // MOV byte ptr offset[reg],vreg
-                c2 = gen2(CNIL,0x88,modregrm(2,vreg,reg));
+                c2 = gen2(CNIL,0x88,modregxrmx(2,vreg,reg));
                 c2->IEVoffset1 = offset;
                 c2->IFL1 = FLconst;
                 c3 = cat(c3,c2);
@@ -3181,13 +3281,13 @@
 
     // Get nbytes into CX
     retregs2 = mCX;
-    if (I32 && e2->E1->Eoper == OPconst && e2->E2->Eoper == OPconst)
+    if (!I16 && e2->E1->Eoper == OPconst && e2->E2->Eoper == OPconst)
     {
         remainder = numbytes & (REGSIZE - 1);
         numwords  = numbytes / REGSIZE;         // number of words
         op = 0xAB;                              // moving by words
         c1 = getregs(mCX);
-        c1 = movregconst(c1,CX,numwords,0);     // # of bytes/words
+        c1 = movregconst(c1,CX,numwords,I64?64:0);     // # of bytes/words
     }
     else
     {
@@ -3199,9 +3299,9 @@
     // Get val into AX
 
     retregs3 = mAX;
-    if (I32 && e2->E2->Eoper == OPconst)
+    if (!I16 && e2->E2->Eoper == OPconst)
     {
-        c1 = regwithvalue(c1, mAX, value, NULL, 0);
+        c1 = regwithvalue(c1, mAX, value, NULL, I64?64:0);
         freenode(e2->E2);
     }
     else
@@ -3235,10 +3335,11 @@
     if (*pretregs)                              // if need return value
     {   c3 = getregs(mBX);
         c3 = genmovreg(c3,BX,DI);
+        code_orrex(c3,rex);
     }
 
     c3 = cat(c3,getregs(mDI | mCX));
-    if (!I32 && config.flags4 & CFG4speed)      // if speed optimization
+    if (I16 && config.flags4 & CFG4speed)      // if speed optimization
     {
         c3 = cat(c3,getregs(mAX));
         c3 = gen2(c3,0x8A,modregrm(3,AH,AL));   // MOV AH,AL
@@ -3251,19 +3352,27 @@
 
     c3 = gen1(c3,0xF3);                         // REP
     gen1(c3,op);                                // STOSD
+    if (remainder & 4)
+    {
+        code *ctmp;
+        ctmp = gen2(CNIL,0x89,modregrmx(2,AX,reg));
+        ctmp->IFL1 = FLconst;
+        c3 = cat(c3,ctmp);
+    }
     if (remainder & 2)
     {
         code *ctmp;
-        ctmp = gen2(CNIL,0x89,modregrm(2,AX,reg));
+        ctmp = gen2(CNIL,0x89,modregrmx(2,AX,reg));
         ctmp->Iflags = CFopsize;
+        ctmp->IEVoffset1 = remainder & 4;
         ctmp->IFL1 = FLconst;
         c3 = cat(c3,ctmp);
     }
     if (remainder & 1)
     {
         code *ctmp;
-        ctmp = gen2(CNIL,0x88,modregrm(2,AX,reg));
-        ctmp->IEVoffset1 = (remainder & 2) ? 2 : 0;
+        ctmp = gen2(CNIL,0x88,modregrmx(2,AX,reg));
+        ctmp->IEVoffset1 = remainder & ~1;
         ctmp->IFL1 = FLconst;
         c3 = cat(c3,ctmp);
     }
@@ -3355,7 +3464,8 @@
   elem *e1 = e->E1,*e2 = e->E2;
   int segreg;
 
-  numbytes = e->Enumbytes;              /* # of bytes in structure/union */
+    numbytes = e->Enumbytes;              // # of bytes in structure/union
+    unsigned char rex = I64 ? REX_W : 0;
 
     //printf("cdstreq(e = %p, *pretregs = x%x)\n", e, *pretregs);
 
@@ -3451,6 +3561,7 @@
   if (numbytes <= REGSIZE * (6 + (REGSIZE == 4)))
   {     while (numbytes >= REGSIZE)
         {   c3 = gen1(c3,0xA5);         /* MOVSW                        */
+            code_orrex(c3, rex);
             numbytes -= REGSIZE;
         }
         //if (numbytes)
@@ -3497,7 +3608,7 @@
     {   /* ES:DI points past what we want       */
         regm_t retregs;
 
-        genc2(c3,0x81,modregrm(3,5,DI),e->Enumbytes);   /* SUB DI,numbytes */
+        genc2(c3,0x81,(rex << 16) | modregrm(3,5,DI),e->Enumbytes);   // SUB DI,numbytes
         retregs = mDI;
         if (*pretregs & mMSW && !(config.exe & EX_flat))
             retregs |= mES;
@@ -3506,6 +3617,7 @@
     return cat3(c1,c2,c3);
 }
 
+
 /**********************
  * Get the address of.
  * Is also called by cdstreq() to set up pointer to a structure.
@@ -3625,12 +3737,12 @@
 code *getoffset(elem *e,unsigned reg)
 { code cs;
   code *c;
-  enum FL fl;
 
   cs.Iflags = 0;
-  cs.Ijty = 0;
+  unsigned char rex = 0;
+  cs.Irex = rex;
   assert(e->Eoper == OPvar || e->Eoper == OPrelconst);
-  fl = el_fl(e);
+  enum FL fl = el_fl(e);
   switch (fl)
   {
     case FLdatseg:
@@ -3643,7 +3755,26 @@
 
     case FLtlsdata:
 #if TARGET_LINUX || TARGET_OSX || TARGET_FREEBSD || TARGET_SOLARIS
-    {   /* Generate:
+    {
+      L5:
+        if (I64 && config.flags3 & CFG3pic)
+        {
+            /* Generate:
+             *   LEA DI,s@TLSGD[RIP]
+             */
+            assert(reg == DI);
+            code css;
+            css.Irex = REX | REX_W;
+            css.Iop = 0x8D;             // LEA
+            css.Irm = modregrm(0,DI,5);
+            css.Iflags = CFopsize;
+            css.IFL1 = fl;
+            css.IEVsym1 = e->EV.sp.Vsym;
+            css.IEVoffset1 = e->EV.sp.Voffset;
+            c = gen(NULL, &css);
+            return c;
+        }
+        /* Generate:
          *      MOV reg,GS:[00000000]
          *      ADD reg, offset s@TLS_LE
          * for locals, and for globals:
@@ -3651,7 +3782,6 @@
          *      ADD reg, s@TLS_IE
          * note different fixup
          */
-      L5:
         int stack = 0;
         c = NULL;
         if (reg == STACK)
@@ -3663,30 +3793,34 @@
         }
 
         code css;
+        css.Irex = rex;
         css.Iop = 0x8B;
-        css.Irm = modregrm(0, reg, BPRM);
+        css.Irm = modregrm(0, 0, BPRM);
+        code_newreg(&css, reg);
         css.Iflags = CFgs;
-        css.Ijty = 0;
         css.IFL1 = FLconst;
         css.IEV1.Vuns = 0;
         c = gen(c, &css);               // MOV reg,GS:[00000000]
 
         if (e->EV.sp.Vsym->Sclass == SCstatic || e->EV.sp.Vsym->Sclass == SClocstat)
         {   // ADD reg, offset s
+            cs.Irex = rex;
             cs.Iop = 0x81;
-            cs.Irm = modregrm(3,0,reg);
+            cs.Irm = modregrm(3,0,reg & 7);
+            if (reg & 8)
+                cs.Irex |= REX_B;
             cs.Iflags = CFoff;
-            css.Ijty = 0;
             cs.IFL2 = fl;
             cs.IEVsym2 = e->EV.sp.Vsym;
             cs.IEVoffset2 = e->EV.sp.Voffset;
         }
         else
         {   // ADD reg, s
+            cs.Irex = rex;
             cs.Iop = 0x03;
-            cs.Irm = modregrm(0,reg,BPRM);
+            cs.Irm = modregrm(0,0,BPRM);
+            code_newreg(&cs, reg);
             cs.Iflags = CFoff;
-            css.Ijty = 0;
             cs.IFL1 = fl;
             cs.IEVsym1 = e->EV.sp.Vsym;
             cs.IEVoffset1 = e->EV.sp.Voffset;
@@ -3695,7 +3829,9 @@
 
         if (stack)
         {
-            c = gen1(c,0x50 + reg);                     /* PUSH reg     */
+            c = gen1(c,0x50 + (reg & 7));      // PUSH reg
+            if (reg & 8)
+                code_orrex(c, REX_B);
             c = genadjesp(c,REGSIZE);
             stackchanged = 1;
         }
@@ -3731,7 +3867,18 @@
             c = genadjesp(NULL,REGSIZE);
         }
         else
-        {   cs.Iop = 0xB8 + reg;        /* MOV reg,immed16              */
+        {   cs.Iop = 0xB8 + (reg & 7);  // MOV reg,immed16
+            if (reg & 8)
+                cs.Irex |= REX_B;
+            if (I64 && config.flags3 & CFG3pic)
+            {   // LEA reg,immed32[RIP]
+                cs.Irex |= REX_W;
+                cs.Iop = 0x8D;
+                cs.Irm = modregrm(0,reg & 7,5);
+                cs.IFL1 = fl;
+                cs.IEVsym1 = cs.IEVsym2;
+                cs.IEVoffset1 = cs.IEVoffset2;
+            }
             c = NULL;
         }
         cs.Iflags = CFoff;              /* want offset only             */
@@ -3779,7 +3926,9 @@
             c = allocreg(&retregs,&reg,TYoffset);
             reg = findreg(retregs);
             c = cat(c,loadea(e,&cs,0x8D,reg,0,0,0));    /* LEA reg,EA   */
-            c = gen1(c,0x50 + reg);                     /* PUSH reg     */
+            c = gen1(c,0x50 + (reg & 7));               // PUSH reg
+            if (reg & 8)
+                code_orrex(c, REX_B);
             c = genadjesp(c,REGSIZE);
             stackchanged = 1;
         }
@@ -3796,6 +3945,7 @@
   return c;
 }
 
+
 /******************
  * Negate, sqrt operator
  */
@@ -3817,9 +3967,10 @@
   if (tyfloating(tyml))
   {     if (tycomplex(tyml))
             return neg_complex87(e, pretregs);
-        if (config.inline8087 && ((*pretregs & (ALLREGS | mBP)) == 0 || e->Eoper == OPsqrt))
+        if (config.inline8087 &&
+            ((*pretregs & (ALLREGS | mBP)) == 0 || e->Eoper == OPsqrt || I64))
                 return neg87(e,pretregs);
-        retregs = (!I32 && sz == 8) ? DOUBLEREGS_16 : ALLREGS;
+        retregs = (I16 && sz == 8) ? DOUBLEREGS_16 : ALLREGS;
         c1 = codelem(e->E1,&retregs,FALSE);
         c1 = cat(c1,getregs(retregs));
         if (I32)
@@ -3841,11 +3992,11 @@
   c1 = codelem(e->E1,&retregs,FALSE);
   cg = getregs(retregs);                /* retregs will be destroyed    */
   if (sz <= REGSIZE)
-  {     unsigned reg;
-
-        reg = findreg(retregs);
-        c = gen2(CNIL,0xF7 ^ byte,modregrm(3,3,reg));   /* NEG reg      */
-        if (I32 && tysize[tyml] == SHORTSIZE && *pretregs & mPSW)
+  {
+        unsigned reg = findreg(retregs);
+        unsigned rex = (I64 && sz == 8) ? REX_W : 0;
+        c = gen2(CNIL,0xF7 ^ byte,(rex << 16) | modregrmx(3,3,reg));   // NEG reg
+        if (!I16 && tysize[tyml] == SHORTSIZE && *pretregs & mPSW)
             c->Iflags |= CFopsize | CFpsw;
         *pretregs &= mBP | ALLREGS;             // flags already set
   }
@@ -3863,6 +4014,7 @@
   return cat4(c1,cg,c,fixresult(e,retregs,pretregs));
 }
 
+
 /******************
  * Absolute value operator
  */
@@ -3873,14 +4025,14 @@
   int reg;
   tym_t tyml;
   code *c,*c1,*cg;
-  int sz;
 
   if (*pretregs == 0)
         return codelem(e->E1,pretregs,FALSE);
   tyml = tybasic(e->E1->Ety);
-  sz = tysize[tyml];
+  int sz = tysize[tyml];
+  unsigned rex = (I64 && sz == 8) ? REX_W : 0;
   if (tyfloating(tyml))
-  {     if (config.inline8087 && (*pretregs & (ALLREGS | mBP)) == 0)
+  {     if (config.inline8087 && ((*pretregs & (ALLREGS | mBP)) == 0 || I64))
                 return neg87(e,pretregs);
         retregs = (!I32 && sz == 8) ? DOUBLEREGS_16 : ALLREGS;
         c1 = codelem(e->E1,&retregs,FALSE);
@@ -3917,12 +4069,13 @@
 
         cg = cat(cg,getregs(mDX));
         reg = findreg(retregs);
-        if (I32 && sz == SHORTSIZE)
+        if (!I16 && sz == SHORTSIZE)
             cg = gen1(cg,0x98);                         // CWDE
         cg = gen1(cg,0x99);                             // CWD
-        gen2(cg,0x33 ^ byte,modregrm(3,AX,DX));         // XOR EAX,EDX
-        c = gen2(CNIL,0x2B ^ byte,modregrm(3,AX,DX));   // SUB EAX,EDX
-        if (I32 && sz == SHORTSIZE && *pretregs & mPSW)
+        code_orrex(cg, rex);
+        gen2(cg,0x33 ^ byte,(rex << 16) | modregrm(3,AX,DX));         // XOR EAX,EDX
+        c = gen2(CNIL,0x2B ^ byte,(rex << 16) | modregrm(3,AX,DX));   // SUB EAX,EDX
+        if (!I16 && sz == SHORTSIZE && *pretregs & mPSW)
             c->Iflags |= CFopsize | CFpsw;
         if (*pretregs & mPSW)
             c->Iflags |= CFpsw;
@@ -3977,6 +4130,7 @@
   tyml = tybasic(e->E1->Ety);
   sz = tysize[tyml];
   e2 = e->E2;
+  unsigned rex = (I64 && sz == 8) ? REX_W : 0;
 
   if (tyfloating(tyml))
   {
@@ -3988,7 +4142,7 @@
         assert(sz <= 8);
         c1 = getlvalue(&cs,e->E1,DOUBLEREGS);
         freenode(e->E1);
-        idxregs = idxregm(cs.Irm,cs.Isib); /* mask of index regs used   */
+        idxregs = idxregm(&cs);         // mask of index regs used
         cs.Iop = 0x8B;                  /* MOV DOUBLEREGS,EA            */
         c2 = fltregs(&cs,tyml);
         stackchanged = 1;
@@ -4083,30 +4237,32 @@
   possregs = byte ? BYTEREGS : allregs;
   c1 = getlvalue(&cs,e->E1,0);
   freenode(e->E1);
-  idxregs = idxregm(cs.Irm,cs.Isib);    /* mask of index regs used      */
+  idxregs = idxregm(&cs);       // mask of index regs used
   if (sz <= REGSIZE && *pretregs == mPSW && (cs.Irm & 0xC0) == 0xC0 &&
-      (I32 || (idxregs & (mBX | mSI | mDI | mBP))))
+      (!I16 || (idxregs & (mBX | mSI | mDI | mBP))))
   {     // Generate:
         //      TEST    reg,reg
         //      LEA     reg,n[reg]      // don't affect flags
         int rm;
 
         reg = cs.Irm & 7;
+        if (cs.Irex & REX_B)
+            reg |= 8;
         cs.Iop = 0x85 ^ byte;
-        cs.Irm |= modregrm(0,reg,0);
+        code_newreg(&cs, reg);
         cs.Iflags |= CFpsw;
         c2 = gen(NULL,&cs);             // TEST reg,reg
 
         // If lvalue is a register variable, we must mark it as modified
-        c3 = modEA(cs.Irm);
+        c3 = modEA(&cs);
 
         n = e2->EV.Vint;
         if (op == OPpostdec)
             n = -n;
         rm = reg;
-        if (!I32)
+        if (I16)
             rm = regtorm[reg];
-        c4 = genc1(NULL,0x8D,modregrm(2,reg,rm),FLconst,n);     // LEA reg,n[reg]
+        c4 = genc1(NULL,0x8D,(rex << 16) | modregxrmx(2,reg,rm),FLconst,n); // LEA reg,n[reg]
         return cat4(c1,c2,c3,c4);
   }
   else if (sz <= REGSIZE || tyfv(tyml))
@@ -4128,15 +4284,16 @@
                 }
         }
         c2 = allocreg(&retregs,&reg,TYint);
-        cs.Irm |= modregrm(0,reg,0);
+        code_newreg(&cs, reg);
         c3 = gen(CNIL,&cs);                     /* MOV reg,EA   */
         cs2 = cs;
 
         /* If lvalue is a register variable, we must mark it as modified */
-        c3 = cat(c3,modEA(cs.Irm));
+        c3 = cat(c3,modEA(&cs));
 
         cs.Iop = 0x81 ^ byte;
         cs.Irm &= ~modregrm(0,7,0);             /* reg field = 0        */
+        cs.Irex &= ~REX_R;
         if (op == OPpostdec)
                 cs.Irm |= modregrm(0,5,0);      /* SUB                  */
         cs.IFL2 = FLconst;
@@ -4170,7 +4327,11 @@
             config.flags4 & CFG4speed)
         {
             // Replace EA in cs with reg
-            cs.Irm = (cs.Irm & ~modregrm(3,0,7)) | modregrm(3,0,reg);
+            cs.Irm = (cs.Irm & ~modregrm(3,0,7)) | modregrm(3,0,reg & 7);
+            if (reg & 8)
+            {   cs.Irex &= ~REX_R;
+                cs.Irex |= REX_B;
+            }
             gen(c3,&cs);                        // ADD/SUB reg,const
 
             // Reverse MOV direction
@@ -4372,13 +4533,12 @@
                 if (config.exe == EX_NT)
                     usednteh |= NTEHcleanup;
 #endif
-                cs.Iop = ESCAPE;
-                cs.Iop2 = ESCmark;
+                cs.Iop = ESCAPE | ESCmark;
                 cs.Iflags = 0;
-                cs.Ijty = 0;
+                cs.Irex = 0;
                 c = gen(CNIL,&cs);
                 c = cat(c,codelem(e->E2,pretregs,FALSE));
-                cs.Iop2 = ESCrelease;
+                cs.Iop = ESCAPE | ESCrelease;
                 gen(c,&cs);
             }
             freenode(e->E1);
@@ -4410,10 +4570,9 @@
         usednteh |= NTEHcleanup;
 #endif
     assert(*pretregs == 0);
-    cs.Iop = ESCAPE;
-    cs.Iop2 = ESCctor;
+    cs.Iop = ESCAPE | ESCctor;
     cs.Iflags = 0;
-    cs.Ijty = 0;
+    cs.Irex = 0;
     cs.IFL1 = FLctor;
     cs.IEV1.Vtor = e;
     c = gen(CNIL,&cs);
@@ -4442,10 +4601,9 @@
         usednteh |= NTEHcleanup;
 #endif
     assert(*pretregs == 0);
-    cs.Iop = ESCAPE;
-    cs.Iop2 = ESCdtor;
+    cs.Iop = ESCAPE | ESCdtor;
     cs.Iflags = 0;
-    cs.Ijty = 0;
+    cs.Irex = 0;
     cs.IFL1 = FLdtor;
     cs.IEV1.Vtor = e;
     c = gen(CNIL,&cs);
@@ -4498,14 +4656,15 @@
     code *c;
     code *cs;
 
-    assert(I32);
+    assert(!I16);
     retregs = *pretregs;
     if ((retregs & allregs) == 0)
         retregs |= allregs;
     c = codelem(e->E1,&retregs,FALSE);
     scratch = allregs & ~retregs;
     cs = allocreg(&scratch,&reg,TYint);
-    cs = genc1(cs,0x8B,modregrm(2,reg,findreg(retregs)),FLconst,0);     // MOV reg,0[e]
+    unsigned rex = I64 ? REX_W : 0;
+    cs = genc1(cs,0x8B,(rex << 16) | modregxrmx(2,reg,findreg(retregs)),FLconst,0); // MOV reg,0[e]
     return cat3(c,cs,fixresult(e,retregs,pretregs));
 }
 
diff -aruw dmd62/backend/cod3.c dmd63/backend/cod3.c
--- dmd62/backend/cod3.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/cod3.c	2010-08-09 14:33:14.000000000 -0400
@@ -1,5 +1,5 @@
 // Copyright (C) 1984-1998 by Symantec
-// Copyright (C) 2000-2009 by Digital Mars
+// Copyright (C) 2000-2010 by Digital Mars
 // All Rights Reserved
 // http://www.digitalmars.com
 // Written by Walter Bright
@@ -36,9 +36,11 @@
 #endif
 
 extern targ_size_t retsize;
+STATIC void pinholeopt_unittest();
 STATIC void do8bit (enum FL,union evc *);
 STATIC void do16bit (enum FL,union evc *,int);
 STATIC void do32bit (enum FL,union evc *,int);
+STATIC void do64bit (enum FL,union evc *,int);
 
 static int hasframe;            /* !=0 if this function has a stack frame */
 static targ_size_t Foff;        // BP offset of floating register
@@ -65,7 +67,7 @@
 struct fixlist
 {   symbol      *Lsymbol;       // symbol we don't know about
     int         Lseg;           // where the fixup is going (CODE or DATA, never UDATA)
-    short       Lflags;         // CFxxxx
+    int         Lflags;         // CFxxxx
     targ_size_t Loffset;        // addr of reference to symbol
     targ_size_t Lval;           // value to add into location
 #if TARGET_OSX
@@ -216,17 +218,13 @@
 int cod3_EA(code *c)
 {   unsigned ins;
 
-    switch (c->Iop)
-    {   case ESCAPE:
+    unsigned op1 = c->Iop & 0xFF;
+    if (op1 == ESCAPE)
             ins = 0;
-            break;
-        case 0x0F:
-            ins = inssize2[c->Iop2];
-            break;
-        default:
-            ins = inssize[c->Iop];
-            break;
-    }
+    else if ((c->Iop & 0xFF00) == 0x0F00)
+        ins = inssize2[op1];
+    else
+        ins = inssize[op1];
     return ins & M;
 }
 
@@ -276,6 +274,19 @@
 
 void cod3_set64()
 {
+    inssize[0xA0] = T|5;                // MOV AL,mem
+    inssize[0xA1] = T|5;                // MOV RAX,mem
+    inssize[0xA2] = T|5;                // MOV mem,AL
+    inssize[0xA3] = T|5;                // MOV mem,RAX
+    BPRM = 5;                           // [RBP] addressing mode
+    fregsaved = mBP | mBX | mR12 | mR13 | mR14 | mR15 | mES;      // saved across function calls
+    FLOATREGS = FLOATREGS_64;
+    FLOATREGS2 = FLOATREGS2_64;
+    DOUBLEREGS = DOUBLEREGS_64;
+    STACKALIGN = 16;
+
+    for (unsigned i = 0x80; i < 0x90; i++)
+        inssize2[i] = W|T|6;
 }
 
 /*********************************
@@ -356,29 +367,16 @@
         if (val > vmax) vmax = val;
         if (val < vmin) vmin = val;
         if (REGSIZE == 2)
-        {   unsigned short ms;
-
-#if __DMC__
-            ms = ((unsigned short *)&val)[1];
-#else
-            ms = (val >> 16) & 0xFFFF;
-#endif
+        {
+            unsigned short ms = (val >> 16) & 0xFFFF;
             if (n == 0)
                 msw = ms;
             else if (msw != ms)
                 mswsame = 0;
         }
         else // REGSIZE == 4
-        {   targ_ulong ms;
-
-#if __DMC__
-            /* This statement generates garbage for ms under g++,
-             * I don't know why.
-             */
-            ms = ((targ_ulong *)&val)[1];
-#else
-            ms = (val >> 32) & 0xFFFFFFFF;
-#endif
+        {
+            targ_ulong ms = (val >> 32) & 0xFFFFFFFF;
             if (n == 0)
                 msw = ms;
             else if (msw != ms)
@@ -389,9 +387,48 @@
     //dbg_printf("vmax = x%lx, vmin = x%lx, vmax-vmin = x%lx\n",vmax,vmin,vmax - vmin);
     flags = (config.flags & CFGromable) ? CFcs : 0; // table is in code seg
 
+    if (I64)
+    {   // For now, just generate basic if-then sequence to get us running
+        retregs = ALLREGS;
+        b->BC = BCifthen;
+        c = scodelem(e,&retregs,0,TRUE);
+        assert(!dword);                 // 128 bit switches not supported
+        reg = findreg(retregs);         // reg that result is in
+        bl = b->Bsucc;
+        for (n = 0; n < ncases; n++)
+        {   code *cx;
+            val = *p;
+            if (sz == 4)
+                cx = genc2(CNIL,0x81,modregrmx(3,7,reg),val);  // CMP reg,val
+            else if (sz == 8)
+            {
+                if (val == (int)val)    // if val is a 64 bit value sign-extended from 32 bits
+                {
+                    cx = genc2(CNIL,0x81,modregrmx(3,7,reg),val);  // CMP reg,value32
+                    cx->Irex |= REX_W;  // 64 bit operand
+                }
+                else
+                {   unsigned sreg;
+                                                                // MOV sreg,value64
+                    cx = regwithvalue(CNIL, ALLREGS & ~mask[reg], val, &sreg, 64);
+                    cx = genregs(cx,0x3B,reg,sreg);             // CMP reg,sreg
+                    code_orrex(cx, REX_W);
+                }
+            }
+            else
+                assert(0);
+            bl = list_next(bl);
+            genjmp(cx,JE,FLblock,list_block(bl));       // JE caseaddr
+            c = cat(c,cx);
+            p++;
+        }
+        if (list_block(b->Bsucc) != b->Bnext) /* if default is not next block */
+                c = cat(c,genjmp(CNIL,JMP,FLblock,list_block(b->Bsucc)));
+        ce = NULL;
+    }
     // Need to do research on MACHOBJ to see about better methods
-    if (MACHOBJ || ncases <= 3)                 // generate if-then sequence
-    {
+    else if (MACHOBJ || ncases <= 3)
+    {   // generate if-then sequence
         retregs = ALLREGS;
     L1:
         b->BC = BCifthen;
@@ -832,7 +869,7 @@
  *              into the lvalue
  */
 
-void cod3_ptrchk(code * __ss *pc,code __ss *pcs,regm_t keepmsk)
+void cod3_ptrchk(code **pc,code *pcs,regm_t keepmsk)
 {   code *c;
     code *cs2;
     unsigned char rm,sib;
@@ -844,7 +881,8 @@
     regm_t used;
     int i;
 
-    if (I32 && pcs->Iflags & (CFes | CFss | CFcs | CFds | CFfs | CFgs))
+    assert(!I64);
+    if (!I16 && pcs->Iflags & (CFes | CFss | CFcs | CFds | CFfs | CFgs))
         return;         // not designed to deal with 48 bit far pointers
 
     c = *pc;
@@ -854,7 +892,7 @@
 
     // If the addressing mode is already a register
     reg = rm & 7;
-    if (!I32)
+    if (I16)
     {   static const unsigned char imode[8] = { BP,BP,BP,BP,SI,DI,BP,BX };
 
         reg = imode[reg];               // convert [SI] to SI, etc.
@@ -865,7 +903,7 @@
        )
     {
         // Load the offset into a register, so we can push the address
-        idxregs = (I32 ? ALLREGS : IDXREGS) & ~keepmsk; // only these can be index regs
+        idxregs = (I16 ? IDXREGS : ALLREGS) & ~keepmsk; // only these can be index regs
         assert(idxregs);
         c = cat(c,allocreg(&idxregs,&reg,TYoffset));
 
@@ -910,7 +948,7 @@
     }
 
     // For 16 bit models, push a far pointer
-    if (!I32)
+    if (I16)
     {   int segreg;
 
         switch (pcs->Iflags & (CFes | CFss | CFcs | CFds | CFfs | CFgs))
@@ -936,7 +974,7 @@
     c = gen1(c,0x50 + reg);             // PUSH reg
 
     // Rewrite the addressing mode in *pcs so it is just 0[reg]
-    pcs->Irm = getaddrmode(idxregs);
+    setaddrmode(pcs, idxregs);
     pcs->IFL1 = FLoffset;
     pcs->IEV1.Vuns = 0;
 
@@ -1016,26 +1054,21 @@
 
 code *cdframeptr(elem *e, regm_t *pretregs)
 {
-    regm_t retregs;
     unsigned reg;
-    code *cg;
-    code *c1;
     code cs;
 
-    retregs = *pretregs & allregs;
+    regm_t retregs = *pretregs & allregs;
     if  (!retregs)
         retregs = allregs;
-    cg = allocreg(&retregs, &reg, TYint);
-    //c1 = genmovreg(cg, reg, BP);
+    code *cg = allocreg(&retregs, &reg, TYint);
 
-    cs.Iop = ESCAPE;
-    cs.Iop2 = ESCframeptr;
+    cs.Iop = ESCAPE | ESCframeptr;
     cs.Iflags = 0;
-    cs.Ijty = 0;
+    cs.Irex = 0;
     cs.Irm = reg;
-    c1 = gen(cg,&cs);
+    cg = gen(cg,&cs);
 
-    return cat(c1,fixresult(e,retregs,pretregs));
+    return cat(cg,fixresult(e,retregs,pretregs));
 }
 
 /***************************************
@@ -1134,18 +1167,12 @@
  */
 
 code *prolog()
-{   code *c;
+{
     SYMIDX si;
     unsigned reg;
-    regm_t topush;
-    tym_t tym;
-    tym_t tyf;
     char enter;
-    char pushds;
-    unsigned farfunc;
     unsigned Foffset;
-    targ_size_t xlocalsize;     // amount to subtract from ESP to make room for locals
-    int pushalloc;
+    unsigned xlocalsize;     // amount to subtract from ESP to make room for locals
     unsigned pushallocreg;
     char guessneedframe;
 
@@ -1154,13 +1181,13 @@
     regcon.immed.mval = 0;                      /* no values in registers yet   */
     EBPtoESP = -REGSIZE;
     hasframe = 0;
-    pushds = 0;
+    char pushds = 0;
     BPoff = 0;
-    c = CNIL;
-    pushalloc = 0;
-    tyf = funcsym_p->ty();
-    tym = tybasic(tyf);
-    farfunc = tyfarfunc(tym);
+    code *c = CNIL;
+    int pushalloc = 0;
+    tym_t tyf = funcsym_p->ty();
+    tym_t tym = tybasic(tyf);
+    unsigned farfunc = tyfarfunc(tym);
     pushallocreg = (tyf == TYmfunc) ? CX : AX;
     if (config.flags & CFGalwaysframe || funcsym_p->Sfunc->Fflags3 & Ffakeeh)
         needframe = 1;
@@ -1190,6 +1217,8 @@
 
     if (tym == TYifunc)
         Poff = 26;
+    else if (I64)
+        Poff = 16;
     else if (I32)
         Poff = farfunc ? 12 : 8;
     else
@@ -1210,7 +1239,7 @@
         // Adjust Aoff so that it is Aalign byte aligned, assuming that
         // before function parameters were pushed the stack was
         // Aalign byte aligned
-        int sz = Poffset + -Aoff + Poff + (needframe ? 0 : 4);
+        int sz = Poffset + -Aoff + Poff + (needframe ? 0 : REGSIZE);
         if (sz & (Aalign - 1))
             Aoff -= sz - (sz & (Aalign - 1));
     }
@@ -1224,18 +1253,18 @@
     Toff = NDPoff - align(0,Toffset);
     localsize = -Toff;
 
-    topush = fregsaved & ~mfuncreg;     // mask of registers that need saving
+    regm_t topush = fregsaved & ~mfuncreg;     // mask of registers that need saving
     int npush = 0;                      // number of registers that need saving
     for (regm_t x = topush; x; x >>= 1)
         npush += x & 1;
 
     // Keep the stack aligned by 8 for any subsequent function calls
-    if (I32 && calledafunc &&
+    if (!I16 && calledafunc &&
         (STACKALIGN == 16 || config.flags4 & CFG4stackalign))
     {
         //printf("npush = %d Poff = x%x needframe = %d localsize = x%x\n", npush, Poff, needframe, localsize);
 
-        int sz = Poff + (needframe ? 0 : -4) + localsize + npush * REGSIZE;
+        int sz = Poff + (needframe ? 0 : -REGSIZE) + localsize + npush * REGSIZE;
         if (STACKALIGN == 16)
         {
             if (sz & (8|4))
@@ -1283,7 +1312,7 @@
     {
         if (localsize)
         {
-            if (!I32 ||
+            if (I16 ||
                 !(config.flags4 & CFG4speed) ||
                 config.target_cpu < TARGET_Pentium ||
                 farfunc ||
@@ -1295,7 +1324,7 @@
                )
                 needframe = 1;
         }
-        if (refparam && (anyiasm || !I32))
+        if (refparam && (anyiasm || I16))
             needframe = 1;
     }
 
@@ -1306,15 +1335,16 @@
             goto Lagain;
     }
 
-#if SIXTEENBIT
-    if (config.wflags & WFwindows && farfunc)
+    if (I16 && config.wflags & WFwindows && farfunc)
     {   int wflags;
         int segreg;
 
+#if SCPP
         // alloca() can't be because the 'special' parameter won't be at
         // a known offset from BP.
         if (usedalloca == 1)
             synerr(EM_alloca_win);      // alloca() can't be in Windows functions
+#endif
 
         wflags = config.wflags;
         if (wflags & WFreduced && !(tyf & mTYexport))
@@ -1366,7 +1396,6 @@
         hasframe = 1;                   /* we have a stack frame        */
     }
     else
-#endif
     if (needframe)                      // if variables or parameters
     {
         if (config.wflags & WFincbp && farfunc)
@@ -1386,6 +1415,8 @@
         {
             c = gen1(c,0x50 + BP);      // PUSH BP
             genregs(c,0x8B,BP,SP);      // MOV  BP,SP
+            if (I64)
+                code_orrex(c, REX_W);   // MOV RBP,RSP
 #if ELFOBJ || MACHOBJ
             if (config.fulltypes)
                 // Don't reorder instructions, as dwarf CFA relies on it
@@ -1394,12 +1425,10 @@
             enter = FALSE;              /* do not use ENTER instruction */
 #if NTEXCEPTIONS == 2
             if (usednteh & ~NTEHjmonitor && (config.flags2 & CFG2seh))
-            {   code *ce;
-                int sz;
-
-                ce = nteh_prolog();
+            {
+                code *ce = nteh_prolog();
                 c = cat(c,ce);
-                sz = nteh_contextsym_size();
+                int sz = nteh_contextsym_size();
                 assert(sz != 0);        // should be 5*4, not 0
                 xlocalsize -= sz;       // sz is already subtracted from ESP
                                         // by nteh_prolog()
@@ -1407,13 +1436,14 @@
 #endif
 #if ELFOBJ || MACHOBJ
             if (config.fulltypes)
-            {   dwarf_CFA_set_loc(1);           // address after PUSH EBP
-                dwarf_CFA_set_reg_offset(SP, 8); // CFA is now 8[ESP]
-                dwarf_CFA_offset(BP, -8);       // EBP is at 0[ESP]
+            {   int off = I64 ? 16 : 8;
+                dwarf_CFA_set_loc(1);           // address after PUSH EBP
+                dwarf_CFA_set_reg_offset(SP, off); // CFA is now 8[ESP]
+                dwarf_CFA_offset(BP, -off);       // EBP is at 0[ESP]
                 dwarf_CFA_set_loc(3);           // address after MOV EBP,ESP
                 // Yes, I know the parameter is 8 when we mean 0!
                 // But this gets the cfa register set to EBP correctly
-                dwarf_CFA_set_reg_offset(BP, 8);        // CFA is now 0[EBP]
+                dwarf_CFA_set_reg_offset(BP, off);        // CFA is now 0[EBP]
             }
 #endif
         }
@@ -1436,7 +1466,16 @@
 #endif
                )
             {
-              if (I32)
+                if (I16)
+                {
+                    // BUG: Won't work if parameter is passed in AX
+                    c = movregconst(c,AX,xlocalsize,FALSE); // MOV AX,localsize
+                    makeitextern(rtlsym[RTLSYM_CHKSTK]);
+                                                            // CALL _chkstk
+                    gencs(c,(LARGECODE) ? 0x9A : 0xE8,0,FLfunc,rtlsym[RTLSYM_CHKSTK]);
+                    useregs((ALLREGS | mBP | mES) & ~rtlsym[RTLSYM_CHKSTK]->Sregsaved);
+                }
+                else
               {
                 /*      MOV     EDX, xlocalsize/0x1000
                  *  L1: SUB     ESP, 0x1000
@@ -1449,24 +1488,19 @@
 
                 c = movregconst(c, DX, xlocalsize / 0x1000, FALSE);
                 csub = genc2(NULL,0x81,modregrm(3,5,SP),0x1000);
+                    if (I64)
+                        code_orrex(csub, REX_W);
                 code_orflag(csub, CFtarg2);
                 gen2sib(csub, 0x85, modregrm(0,SP,4),modregrm(0,4,SP));
                 gen1(csub, 0x48 + DX);
                 genc2(csub,JNE,0,(targ_uns)-12);
                 regimmed_set(DX,0);             // EDX is now 0
                 genc2(csub,0x81,modregrm(3,5,SP),xlocalsize & 0xFFF);
+                    if (I64)
+                        code_orrex(csub, REX_W);
                 c = cat(c,csub);
                 useregs(mDX);
               }
-              else
-              {
-                // BUG: Won't work if parameter is passed in EAX
-                c = movregconst(c,AX,xlocalsize,FALSE); // MOV AX,localsize
-                makeitextern(rtlsym[RTLSYM_CHKSTK]);
-                                                        // CALL _chkstk
-                gencs(c,(LARGECODE) ? 0x9A : 0xE8,0,FLfunc,rtlsym[RTLSYM_CHKSTK]);
-                useregs((ALLREGS | mBP | mES) & ~rtlsym[RTLSYM_CHKSTK]->Sregsaved);
-              }
             }
             else
             {
@@ -1485,8 +1519,11 @@
                     pushalloc = 1;
                 }
                 else
-                    // SUB SP,xlocalsize
+                {   // SUB SP,xlocalsize
                     c = genc2(c,0x81,modregrm(3,5,SP),xlocalsize);
+                    if (I64)
+                        code_orrex(c, REX_W);
+                }
             }
 
             if (usedalloca)
@@ -1497,6 +1534,8 @@
                 c = genc(c,0xC7,modregrm(2,0,BPRM),
                         FLconst,AAoff + BPoff,
                         FLconst,localsize - BPoff);
+                if (I64)
+                    code_orrex(c, REX_W);
             }
         }
         else
@@ -1516,8 +1555,11 @@
             pushalloc = 1;
         }
         else
-            // SUB ESP,xlocalsize
+        {   // SUB ESP,xlocalsize
             c = genc2(c,0x81,modregrm(3,5,SP),xlocalsize);
+            if (I64)
+                code_orrex(c, REX_W);
+        }
         BPoff += REGSIZE;
     }
     else
@@ -1543,12 +1585,14 @@
              * and not there.
              */
             c = genc2(c,0x81,modregrm(3,5,SP),npush * REGSIZE); // SUB ESP,npush * REGSIZE
+            if (I64)
+                code_orrex(c, REX_W);
         }
 
         symbol *s = rtlsym[farfunc ? RTLSYM_TRACE_PRO_F : RTLSYM_TRACE_PRO_N];
         makeitextern(s);
-        c = gencs(c,I32 ? 0xE8 : 0x9A,0,FLfunc,s);      // CALL _trace
-        if (I32)
+        c = gencs(c,I16 ? 0x9A : 0xE8,0,FLfunc,s);      // CALL _trace
+        if (!I16)
             code_orflag(c,CFoff | CFselfrel);
         /* Embedding the function name inline after the call works, but it
          * makes disassembling the code annoying.
@@ -1581,6 +1625,8 @@
         if (STACKALIGN == 16 && npush)
         {
             c = genc2(c,0x81,modregrm(3,0,SP),npush * REGSIZE); // ADD ESP,npush * REGSIZE
+            if (I64)
+                code_orrex(c, REX_W);
         }
         useregs((ALLREGS | mBP | mES) & ~s->Sregsaved);
     }
@@ -1603,7 +1649,9 @@
     while (topush)                      /* while registers to push      */
     {   reg = findreg(topush);
         topush &= ~mask[reg];
-        c = gen1(c,0x50 + reg);
+        c = gen1(c,0x50 + (reg & 7));
+        if (reg & 8)
+            code_orrex(c, REX_B);
         EBPtoESP += REGSIZE;
 #if ELFOBJ || MACHOBJ
         if (config.fulltypes)
@@ -1645,6 +1693,7 @@
     for (si = 0; si < globsym.top; si++)
     {   symbol *s = globsym.tab[si];
         code *c2;
+        unsigned sz = tysize(s->ty());
 
         if ((s->Sclass == SCregpar || s->Sclass == SCparameter) &&
             s->Sfl == FLreg &&
@@ -1654,20 +1703,19 @@
                 || s->Stype->Tty & mTYvolatile
 #endif
                 ))
-        {   code *c2;
-            unsigned sz;
-
+        {
             /* MOV reg,param[BP]        */
             //assert(refparam);
-            sz = tysize(s->ty());
-            c2 = genc1(CNIL,0x8B ^ (sz == 1),
-                modregrm(2,s->Sreglsw,BPRM),FLconst,Poff + s->Soffset);
-            if (I32 && sz == SHORTSIZE)
+            code *c2 = genc1(CNIL,0x8B ^ (sz == 1),
+                modregxrm(2,s->Sreglsw,BPRM),FLconst,Poff + s->Soffset);
+            if (!I16 && sz == SHORTSIZE)
                 c2->Iflags |= CFopsize; // operand size
+            if (I64 && sz == REGSIZE)
+                c2->Irex |= REX_W;
             if (!hasframe)
             {   /* Convert to ESP relative address rather than EBP      */
-                assert(I32);
-                c2->Irm = modregrm(2,s->Sreglsw,4);
+                assert(!I16);
+                c2->Irm = modregxrm(2,s->Sreglsw,4);
                 c2->Isib = modregrm(0,4,SP);
                 c2->IEVpointer1 += EBPtoESP;
             }
@@ -1675,11 +1723,13 @@
             {   code *c3;
 
                 c3 = genc1(CNIL,0x8B,
-                    modregrm(2,s->Sregmsw,BPRM),FLconst,Poff + s->Soffset + REGSIZE);
+                    modregxrm(2,s->Sregmsw,BPRM),FLconst,Poff + s->Soffset + REGSIZE);
+                if (I64)
+                    c3->Irex |= REX_W;
                 if (!hasframe)
                 {   /* Convert to ESP relative address rather than EBP  */
-                    assert(I32);
-                    c3->Irm = modregrm(2,s->Sregmsw,4);
+                    assert(!I16);
+                    c3->Irm = modregxrm(2,s->Sregmsw,4);
                     c3->Isib = modregrm(0,4,SP);
                     c3->IEVpointer1 += EBPtoESP;
                 }
@@ -1693,6 +1743,8 @@
             if (s->Sfl == FLreg)
             {   // MOV reg,preg
                 c = genmovreg(c,s->Sreglsw,preg);
+                if (I64 && sz == 8)
+                    code_orrex(c, REX_W);
             }
             else if (s->Sflags & SFLdead ||
                 (!anyiasm && !(s->Sflags & SFLread) && s->Sflags & SFLunambig &&
@@ -1702,44 +1754,64 @@
 #endif
                  (config.flags4 & CFG4optimized || !config.fulltypes)))
             {
+                // Ignore it, as it is never referenced
                 ;
             }
             else
             {
                 targ_size_t offset = Aoff + BPoff + s->Soffset;
+                int op = 0x89;                  // MOV x[EBP],preg
+                if (preg >= XMM0 && preg <= XMM15)
+                {
+                    if (sz == 8)
+                        op = 0xF20F11;          // MOVSD x[EBP],preg
+                    else
+                    {
+                        assert(sz == 4);
+                        op = 0xF30F11;          // MOVSS x[EBP],preg
+                    }
+                }
                 if (hasframe)
                 {
                     if (!(pushalloc && preg == pushallocreg))
-                    {   // MOV x[EBP],preg
-                        c2 = genc1(CNIL,0x89,
-                            modregrm(2,preg,BPRM),FLconst, offset);
+                    {
+                        // MOV x[EBP],preg
+                        c2 = genc1(CNIL,op,
+                            modregxrm(2,preg,BPRM),FLconst, offset);
+                        if (preg >= XMM0 && preg <= XMM15)
+                        {
+                        }
+                        else
+                        {
 //printf("%s Aoff = %d, BPoff = %d, Soffset = %d\n", s->Sident, Aoff, BPoff, s->Soffset);
 //                      if (offset & 2)
 //                          c2->Iflags |= CFopsize;
+                            if (I64 && sz == 8)
+                                code_orrex(c2, REX_W);
+                        }
                         c = cat(c, c2);
                     }
                 }
                 else
                 {
-                    code *clast;
-
                     offset += EBPtoESP;
-#if 1
                     if (!(pushalloc && preg == pushallocreg))
-#else
-                    if (offset == 0 && (clast = code_last(c)) != NULL &&
-                        (clast->Iop & 0xF8) == 0x50)
                     {
-                        clast->Iop = 0x50 + preg;
+                        // MOV offset[ESP],preg
+                        // BUG: byte size?
+                        c2 = genc1(CNIL,op,
+                            (modregrm(0,4,SP) << 8) |
+                            modregxrm(2,preg,4),FLconst,offset);
+                        if (preg >= XMM0 && preg <= XMM15)
+                        {
                     }
                     else
-#endif
-                    {   // MOV offset[ESP],preg
-                        // BUG: byte size?
-                        c2 = genc1(CNIL,0x89,modregrm(2,preg,4),FLconst,offset);
-                        c2->Isib = modregrm(0,4,SP);
+                        {
+                            if (I64 && sz == 8)
+                                c2->Irex |= REX_W;
 //                      if (offset & 2)
 //                          c2->Iflags |= CFopsize;
+                        }
                         c = cat(c,c2);
                     }
                 }
@@ -1815,12 +1887,11 @@
          (config.flags2 & CFG2comdat && SymInline(funcsym_p))
         )
        )
-    {   symbol *s;
-
-        s = rtlsym[farfunc ? RTLSYM_TRACE_EPI_F : RTLSYM_TRACE_EPI_N];
+    {
+        symbol *s = rtlsym[farfunc ? RTLSYM_TRACE_EPI_F : RTLSYM_TRACE_EPI_N];
         makeitextern(s);
-        c = gencs(c,I32 ? 0xE8 : 0x9A,0,FLfunc,s);      // CALLF _trace
-        if (I32)
+        c = gencs(c,I16 ? 0x9A : 0xE8,0,FLfunc,s);      // CALLF _trace
+        if (!I16)
             code_orflag(c,CFoff | CFselfrel);
         useregs((ALLREGS | mBP | mES) & ~s->Sregsaved);
     }
@@ -1835,17 +1906,23 @@
         spoff += intsize;
     }
 
-    reg = 7;
-    regm = 1 << 7;
+    /* Pop all the general purpose registers saved on the stack
+     * by the prolog code. Remember to do them in the reverse
+     * order they were pushed.
+     */
+    reg = I64 ? R15 : DI;
+    regm = 1 << reg;
     topop = fregsaved & ~mfuncreg;
 #ifdef DEBUG
-    if (topop & ~0xFF)
+    if (topop & ~0xFFFF)
         printf("fregsaved = x%x, mfuncreg = x%x\n",fregsaved,mfuncreg);
 #endif
-    assert(!(topop & ~0xFF));
+    assert(!(topop & ~0xFFFF));
     while (topop)
     {   if (topop & regm)
-        {       c = gen1(c,0x58 + reg);         /* POP reg              */
+        {   c = gen1(c,0x58 + (reg & 7));         // POP reg
+            if (reg & 8)
+                code_orrex(c, REX_B);
                 topop &= ~regm;
                 spoff += intsize;
         }
@@ -1855,21 +1932,19 @@
 
 #if MARS
     if (usednteh & NTEHjmonitor)
-    {   code *cn;
-
+    {
         regm_t retregs = 0;
         if (b->BC == BCretexp)
             retregs = regmask(b->Belem->Ety, tym);
-        cn = nteh_monitor_epilog(retregs);
+        code *cn = nteh_monitor_epilog(retregs);
         c = cat(c,cn);
         xlocalsize += 8;
     }
 #endif
 
     if (config.wflags & WFwindows && farfunc)
-    {   int wflags;
-
-        wflags = config.wflags;
+    {
+        int wflags = config.wflags;
         if (wflags & WFreduced && !(tyf & mTYexport))
         {   // reduced prolog/epilog for non-exported functions
             wflags &= ~(WFdgroup | WFds | WFss);
@@ -1911,6 +1986,8 @@
                 }
                 else
                 {   c = genregs(c,0x8B,SP,BP);  // MOV SP,BP
+                    if (I64)
+                        code_orrex(c, REX_W);   // MOV RSP,RBP
                     c = gen1(c,0x58 + BP);      // POP BP
                 }
             }
@@ -1919,13 +1996,15 @@
             if (config.wflags & WFincbp && farfunc)
                 gen1(c,0x48 + BP);              // DEC BP
         }
-        else if (xlocalsize == REGSIZE && (I32 || b->BC == BCret))
+        else if (xlocalsize == REGSIZE && (!I16 || b->BC == BCret))
         {   mfuncreg &= ~mask[regx];
             c = gen1(c,0x58 + regx);                    // POP regx
         }
         else if (xlocalsize)
         {
             c = genc2(c,0x81,modregrm(3,0,SP),xlocalsize);      // ADD SP,xlocalsize
+            if (I64)
+                code_orrex(c, REX_W);
         }
     }
     if (b->BC == BCret || b->BC == BCretexp)
@@ -1936,7 +2015,7 @@
         {
             c = genc2(c,0xC2,0,4);                      // RET 4
         }
-        else if (!typfunc(tym) || Poffset == 0)
+        else if (!typfunc(tym) || Poffset == 0 || I64)
         {   op++;                                       // to a regular RET
             c = gen1(c,op);
         }
@@ -1951,7 +2030,7 @@
     // If last instruction in ce is ADD SP,imm, and first instruction
     // in c sets SP, we can dump the ADD.
     cr = code_last(ce);
-    if (cr && c)
+    if (cr && c && !I64)
     {
         if (cr->Iop == 0x81 && cr->Irm == modregrm(3,0,SP))     // if ADD SP,imm
         {
@@ -2044,7 +2123,7 @@
     else
         p += tysize[TYnptr];
 
-    if (I32)
+    if (!I16)
     {
         /*
            Generate:
@@ -2075,6 +2154,8 @@
                 FLconst,d);                     // ADD p[ESP],d
             c->Isib = modregrm(0,4,SP);
         }
+        if (I64)
+            c->Irex |= REX_W;
     }
     else
     {
@@ -2111,7 +2192,7 @@
 
         assert(thisty != TYvptr);               /* can't handle this case */
 
-        if (I32)
+        if (!I16)
         {
             assert(!FARTHIS && !LARGECODE);
             if (thunkty == TYmfunc)     // if 'this' is in ECX
@@ -2129,12 +2210,15 @@
             else
             {
                 // MOV EAX,p[ESP]
-                c1 = genc1(CNIL,0x8B,modregrm(2,AX,4),FLconst,(targ_uns) p);
-                c1->Isib = modregrm(0,4,SP);
+                c1 = genc1(CNIL,0x8B,(modregrm(0,4,SP) << 8) | modregrm(2,AX,4),FLconst,(targ_uns) p);
+                if (I64)
+                    c1->Irex |= REX_W;
 
                 // MOV EAX,d2[EAX]
                 c2 = genc1(CNIL,0x8B,modregrm(2,AX,AX),FLconst,d2);
             }
+            if (I64)
+                code_orrex(c2, REX_W);
                                                         /* JMP i[EAX]   */
             c3 = genc1(CNIL,0xFF,modregrm(2,4,0),FLconst,(targ_uns) i);
         }
@@ -2226,7 +2310,7 @@
         csize = calccodsize(c);
         cn = code_next(c);
         op = c->Iop;
-        if ((op & 0xF0) == 0x70 && c->Iflags & CFjmp16 ||
+        if ((op & ~0x0F) == 0x70 && c->Iflags & CFjmp16 ||
             op == JMP)
         {
           L1:
@@ -2294,7 +2378,7 @@
                         /* Propagate branch forward past junk   */
                         while (1)
                         {   if (ct->Iop == NOP ||
-                                (ct->Iop == ESCAPE && ct->Iop2 == ESClinnum))
+                                ct->Iop == (ESCAPE | ESClinnum))
                             {   ct = code_next(ct);
                                 if (!ct)
                                     goto L2;
@@ -2337,17 +2421,17 @@
             {
                 if (op == JMP)
                 {   c->Iop = JMPS;              // JMP SHORT
-                    bytesaved += I32 ? 3 : 1;
+                    bytesaved += I16 ? 1 : 3;
                 }
                 else                            // else Jcond
                 {   c->Iflags &= ~CFjmp16;      // a branch is ok
-                    bytesaved += I32 ? 4 : 3;
+                    bytesaved += I16 ? 3 : 4;
 
                     // Replace a cond jump around a call to a function that
                     // never returns with a cond jump to that function.
                     if (config.flags4 & CFG4optimized &&
                         config.target_cpu >= TARGET_80386 &&
-                        disp == (I32 ? 5 : 3) &&
+                        disp == (I16 ? 3 : 5) &&
                         cn &&
                         cn->Iop == 0xE8 &&
                         cn->IFL2 == FLfunc &&
@@ -2355,8 +2439,7 @@
                         !(cn->Iflags & (CFtarg | CFtarg2))
                        )
                     {
-                        cn->Iop = 0x0F;
-                        cn->Iop2 = (c->Iop & 0x0F) ^ 0x81;
+                        cn->Iop = 0x0F00 | ((c->Iop & 0x0F) ^ 0x81);
                         c->Iop = NOP;
                         c->IEV2.Vcode = NULL;
                         bytesaved++;
@@ -2483,37 +2566,44 @@
         if (code_next(c) && code_next(code_next(c)) == c)
             assert(0);
 #endif
-        if (c->Iop == 0x0F)
-            ins = inssize2[c->Iop2];
-        else if (c->Iop == ESCAPE)
+        if ((c->Iop & 0xFF00) == 0x0F00)
+            ins = inssize2[c->Iop & 0xFF];
+        else if ((c->Iop & 0xFF) == ESCAPE)
         {
-            if (c->Iop2 == ESCadjesp)
+            if (c->Iop == (ESCAPE | ESCadjesp))
             {
                 //printf("adjusting EBPtoESP (%d) by %ld\n",EBPtoESP,c->IEV2.Vint);
                 EBPtoESP += c->IEV2.Vint;
                 c->Iop = NOP;
             }
-            if (c->Iop2 == ESCframeptr)
+            if (c->Iop == (ESCAPE | ESCframeptr))
             {   // Convert to load of frame pointer
+                // c->Irm is the register to use
                 if (hasframe)
                 {   // MOV reg,EBP
                     c->Iop = 0x89;
-                    c->Irm = modregrm(3,BP,c->Irm);
+                    if (c->Irm & 8)
+                        c->Irex |= REX_B;
+                    c->Irm = modregrm(3,BP,c->Irm & 7);
                 }
                 else
                 {   // LEA reg,EBPtoESP[ESP]
                     c->Iop = 0x8D;
-                    c->Irm = modregrm(2,c->Irm,4);
+                    if (c->Irm & 8)
+                        c->Irex |= REX_R;
+                    c->Irm = modregrm(2,c->Irm & 7,4);
                     c->Isib = modregrm(0,4,SP);
                     c->Iflags = CFoff;
                     c->IFL1 = FLconst;
                     c->IEV1.Vuns = EBPtoESP;
                 }
             }
+            if (I64)
+                c->Irex |= REX_W;
             continue;
         }
         else
-            ins = inssize[c->Iop];
+            ins = inssize[c->Iop & 0xFF];
         if (!(ins & M) ||
             ((rm = c->Irm) & 0xC0) == 0xC0)
             goto do2;           /* if no first operand          */
@@ -2599,6 +2689,11 @@
                         {   assert(reg < 4);    /* must be a BYTEREGS   */
                             reg |= 4;           /* convert to high byte reg */
                         }
+                        if (reg & 8)
+                        {   assert(I64);
+                            c->Irex |= REX_B;
+                            reg &= 7;
+                        }
                         c->Irm = (c->Irm & modregrm(0,7,0))
                                 | modregrm(3,0,reg);
                         assert(c->Iop != LES && c->Iop != LEA);
@@ -2613,7 +2708,7 @@
                     {   /* Convert to ESP relative address instead of EBP */
                         unsigned char rm;
 
-                        assert(I32);
+                        assert(!I16);
                         c->IEVpointer1 += EBPtoESP;
                         rm = c->Irm;
                         if ((rm & 7) == 4)              // if SIB byte
@@ -2819,13 +2914,17 @@
 
 void pinholeopt(code *c,block *b)
 { targ_size_t a;
-  unsigned op,mod,rm,reg,ereg;
+  unsigned op,mod;
   unsigned char ins;
   int usespace;
   int useopsize;
   int space;
   block *bn;
 
+#ifdef DEBUG
+    static int tested; if (!tested) { tested++; pinholeopt_unittest(); }
+#endif
+
 #if 0
   code *cstart = c;
   if (debugc)
@@ -2837,68 +2936,66 @@
   if (b)
   {     bn = b->Bnext;
         usespace = (config.flags4 & CFG4space && b->BC != BCasm);
-        useopsize = (!I32 || (config.flags4 & CFG4space && b->BC != BCasm));
+        useopsize = (I16 || (config.flags4 & CFG4space && b->BC != BCasm));
   }
   else
   {     bn = NULL;
         usespace = (config.flags4 & CFG4space);
-        useopsize = (!I32 || config.flags4 & CFG4space);
+        useopsize = (I16 || config.flags4 & CFG4space);
   }
   for (; c; c = code_next(c))
   {
     L1:
         op = c->Iop;
-        if (op == 0x0F)
-            ins = inssize2[c->Iop2];
+        if ((op & 0xFF00) == 0x0F00)
+            ins = inssize2[op & 0xFF];
         else
-            ins = inssize[c->Iop];
-        if (ins & M)            /* if modregrm byte             */
-        {   int longop = (c->Iflags & CFopsize) ? !I32 : I32;
+            ins = inssize[op & 0xFF];
+        if (ins & M)            // if modregrm byte
+        {   int shortop = (c->Iflags & CFopsize) ? !I16 : I16;
             int local_BPRM = BPRM;
 
             if (c->Iflags & CFaddrsize)
                 local_BPRM ^= 5 ^ 6;    // toggle between 5 and 6
 
-            rm = c->Irm;
-            reg = rm & (7<<3);          // isolate reg field
-            ereg = rm & 7;
+            unsigned rm = c->Irm;
+            unsigned reg = rm & modregrm(0,7,0);          // isolate reg field
+            unsigned ereg = rm & 7;
+            //printf("c = %p, op = %02x rm = %02x\n", c, op, rm);
 
             /* If immediate second operand      */
             if ((ins & T || op == 0xF6 || op == 0xF7) &&
                 c->IFL2 == FLconst)
-            {   int flags;
-                targ_long u;
-
-                flags = c->Iflags & CFpsw;      /* if want result in flags */
-                u = c->IEV2.Vuns;
+            {
+                int flags = c->Iflags & CFpsw;      /* if want result in flags */
+                targ_long u = c->IEV2.Vuns;
                 if (ins & E)
                     u = (signed char) u;
-                else if (!longop)
+                else if (shortop)
                     u = (short) u;
 
                 // Replace CMP reg,0 with TEST reg,reg
-#if 0
-                // BUG: is this the right one?
-                if ((op & 0xFC) == 0x80 &&
-#else
-                if ((op & 0xFE) == 0x80 &&
-#endif
+                if ((op & 0xFE) == 0x80 &&              // 80 is CMP R8,imm8; 81 is CMP reg,imm
                     rm >= modregrm(3,7,AX) &&
                     u == 0)
                 {       c->Iop = (op & 1) | 0x84;
                         c->Irm = modregrm(3,ereg,ereg);
+                        if (c->Irex & REX_B)
+                            c->Irex |= REX_R;
                         goto L1;
                 }
 
                 /* Optimize ANDs with an immediate constant             */
                 if ((op == 0x81 || op == 0x80) && reg == modregrm(0,4,0))
                 {
-                    if (rm >= modregrm(3,4,AX))
+                    if (rm >= modregrm(3,4,AX))         // AND reg,imm
                     {
                         if (u == 0)
                         {       /* Replace with XOR reg,reg     */
                                 c->Iop = 0x30 | (op & 1);
-                                NEWREG(c->Irm,rm & 7);
+                                c->Irm = modregrm(3,ereg,ereg);
+                                if (c->Irex & REX_B)
+                                    c->Irex |= REX_R;
                                 goto L1;
                         }
                         if (u == 0xFFFFFFFF && !flags)
@@ -2910,15 +3007,15 @@
                     {   // If we can do the operation in one byte
 
                         // If EA is not SI or DI
-                        if (rm < modregrm(3,4,SP) &&
+                        if ((rm < modregrm(3,4,SP) || I64) &&
                             (config.flags4 & CFG4space ||
                              config.target_cpu < TARGET_PentiumPro)
                            )
                         {
                             if ((u & 0xFFFFFF00) == 0xFFFFFF00)
                                 goto L2;
-                            else
-                            {   if (longop)
+                            else if (rm < modregrm(3,0,0) || (!c->Irex && ereg < 4))
+                            {   if (!shortop)
                                 {   if ((u & 0xFFFF00FF) == 0xFFFF00FF)
                                         goto L3;
                                 }
@@ -2929,7 +3026,7 @@
                                 }
                             }
                         }
-                        if (longop && useopsize)
+                        if (!shortop && useopsize)
                         {
                             if ((u & 0xFFFF0000) == 0xFFFF0000)
                             {   c->Iflags ^= CFopsize;
@@ -2943,16 +3040,18 @@
                             }
                             if (rm >= modregrm(3,4,AX))
                             {
-                                if (u == 0xFF && rm <= modregrm(3,4,BX))
-                                {   c->Iop2 = 0xB6;     /* MOVZX        */
-                                    c->Iop = 0x0F;
-                                    NEWREG(c->Irm,rm & 7);
+                                if (u == 0xFF && (rm <= modregrm(3,4,BX) || I64))
+                                {   c->Iop = 0x0FB6;     // MOVZX
+                                    c->Irm = modregrm(3,ereg,ereg);
+                                    if (c->Irex & REX_B)
+                                        c->Irex |= REX_R;
                                     goto L1;
                                 }
                                 if (u == 0xFFFF)
-                                {   c->Iop2 = 0xB7;     /* MOVZX        */
-                                    c->Iop = 0x0F;
-                                    NEWREG(c->Irm,rm & 7);
+                                {   c->Iop = 0x0FB7;     // MOVZX
+                                    c->Irm = modregrm(3,ereg,ereg);
+                                    if (c->Irex & REX_B)
+                                        c->Irex |= REX_R;
                                     goto L1;
                                 }
                             }
@@ -2963,10 +3062,11 @@
                 /* Look for ADD,OR,SUB,XOR with u that we can eliminate */
                 if (!flags &&
                     (op == 0x81 || op == 0x80) &&
-                    (reg == modregrm(0,0,0) || reg == modregrm(0,1,0) ||
-                     reg == modregrm(0,5,0) || reg == modregrm(0,6,0))
+                    (reg == modregrm(0,0,0) || reg == modregrm(0,1,0) ||  // ADD,OR
+                     reg == modregrm(0,5,0) || reg == modregrm(0,6,0))    // SUB, XOR
                    )
-                {       if (u == 0)
+                {
+                        if (u == 0)
                         {
                                 c->Iop = NOP;
                                 goto L1;
@@ -2977,7 +3077,7 @@
                                 c->Irm ^= modregrm(0,6^2,0);
                                 goto L1;
                         }
-                        if (longop &&
+                        if (!shortop &&
                             useopsize &&
                             op == 0x81 &&
                             (u & 0xFFFF0000) == 0 &&
@@ -2996,7 +3096,7 @@
                     // See if we can replace a dword with a word
                     // (avoid for 32 bit instructions, because CFopsize
                     //  is too slow)
-                    if (longop && useopsize)
+                    if (!shortop && useopsize)
                     {   if ((u & 0xFFFF0000) == 0)
                         {   c->Iflags ^= CFopsize;
                             goto L1;
@@ -3022,8 +3122,9 @@
                             c->Iflags &= ~CFopsize;
                             goto L1;
                         }
-                        if ((u & 0xFFFF00FF) == 0 ||
-                            (!longop && (u & 0xFF) == 0))
+                        if (((u & 0xFFFF00FF) == 0 ||
+                             (shortop && (u & 0xFF) == 0)) &&
+                            (rm < modregrm(3,0,0) || (!c->Irex && ereg < 4)))
                         {
                         L3:
                             c->IEV2.Vuns >>= 8;
@@ -3046,20 +3147,22 @@
                 }
 
                 // Try to replace TEST reg,-1 with TEST reg,reg
-                if (op == 0xF6 && rm >= modregrm(3,0,AX))
-                {       if (u == ~0)
+                if (op == 0xF6 && rm >= modregrm(3,0,AX) && rm <= modregrm(3,0,7)) // TEST regL,immed8
+                {       if ((u & 0xFF) == 0xFF)
                         {
                            L4:  c->Iop = 0x84;          // TEST regL,regL
-                                c->Irm |= ereg << 3;
+                                c->Irm = modregrm(3,ereg,ereg);
+                                if (c->Irex & REX_B)
+                                    c->Irex |= REX_R;
                                 c->Iflags &= ~CFopsize;
                                 goto L1;
                         }
                 }
-                if (op == 0xF7 && rm >= modregrm(3,0,AX) && ereg < SP)
+                if (op == 0xF7 && rm >= modregrm(3,0,AX) && rm <= modregrm(3,0,7) && (I64 || ereg < 4))
                 {       if (u == 0xFF)
                                 goto L4;
-                        if (u == ~0xFF && !longop)
-                        {       rm |= 4;                /* to regH      */
+                        if ((u & 0xFFFF) == 0xFF00 && shortop && !c->Irex && ereg < 4)
+                        {       ereg |= 4;                /* to regH      */
                                 goto L4;
                         }
                 }
@@ -3083,7 +3186,10 @@
 
             /* Look for AX short form */
             if (ins & A)
-            {   if (rm == modregrm(0,AX,local_BPRM) && (op & ~3) == 0x88)
+            {   if (rm == modregrm(0,AX,local_BPRM) &&
+                    !(c->Irex & REX_R) &&               // and it's AX, not R8
+                    (op & ~3) == 0x88 &&
+                    !I64)
                 {       op = ((op & 3) + 0xA0) ^ 2;
                         /* 8A-> A0 */
                         /* 8B-> A1 */
@@ -3095,18 +3201,19 @@
                 }
 
                 /* Replace MOV REG1,REG2 with MOV EREG1,EREG2   */
-                else if (I32 &&
+                else if (!I16 &&
                          (op == 0x89 || op == 0x8B) &&
                          (rm & 0xC0) == 0xC0 &&
                          (!b || b->BC != BCasm)
                         )
                     c->Iflags &= ~CFopsize;
 
-                else if ((rm & 0xC7) == 0xC0)
+                // If rm is AX
+                else if ((rm & modregrm(3,0,7)) == modregrm(3,0,AX) && !(c->Irex & (REX_R | REX_B)))
                 {       switch (op)
                         {   case 0x80:  op = reg | 4; break;
                             case 0x81:  op = reg | 5; break;
-                            case 0x87:  op = 0x90 + (reg>>3); break;
+                            case 0x87:  op = 0x90 + (reg>>3); break;    // XCHG
                             case 0xF6:
                                 if (reg == 0)
                                     op = 0xA8;  /* TEST AL,immed8       */
@@ -3128,8 +3235,8 @@
                     case 0xFF:
                         switch (reg)
                         {   case 6<<3: op = 0x50+ereg; break;/* PUSH*/
-                            case 0<<3: op = 0x40+ereg; break; /* INC*/
-                            case 1<<3: op = 0x48+ereg; break; /* DEC*/
+                            case 0<<3: if (!I64) op = 0x40+ereg; break; /* INC*/
+                            case 1<<3: if (!I64) op = 0x48+ereg; break; /* DEC*/
                         }
                         break;
                     case 0x8F:  op = 0x58 + ereg; break;
@@ -3141,13 +3248,15 @@
             }
 
             // Look to replace SHL reg,1 with ADD reg,reg
-            if ((op & 0xFE) == 0xD0 &&
+            if ((op & ~1) == 0xD0 &&
                      (rm & modregrm(3,7,0)) == modregrm(3,4,0) &&
                      config.target_cpu >= TARGET_80486)
             {
                 c->Iop &= 1;
                 c->Irm = (rm & modregrm(3,0,7)) | (ereg << 3);
-                if (!(c->Iflags & CFpsw) && I32)
+                if (c->Irex & REX_B)
+                    c->Irex |= REX_R;
+                if (!(c->Iflags & CFpsw) && !I16)
                     c->Iflags &= ~CFopsize;
                 goto L1;
             }
@@ -3160,11 +3269,11 @@
                 c->IFL1 == FLconst)      // and it's a constant
             {
                 a = c->IEVpointer1;
-                if (a == 0 && (rm & 7) != local_BPRM &&         // if 0 disp
-                    !(local_BPRM == 5 && (rm & 7) == 4 && (c->Isib & 7) == BP)
+                if (a == 0 && (rm & 7) != local_BPRM &&         // if 0[disp]
+                    !(local_BPRM == 5 && (rm & 7) == 4 && (c->Isib & 7) == BP && !(c->Irex & REX_B))
                    )
                     c->Irm &= 0x3F;
-                else if (I32)
+                else if (!I16)
                 {
                     if ((targ_size_t)(targ_schar)a == a)
                         c->Irm ^= 0xC0;                 /* do 8 sx      */
@@ -3179,7 +3288,7 @@
                 mod = c->Irm & modregrm(3,0,0);
                 if (mod == 0)
                 {
-                    if (I32)
+                    if (!I16)
                     {
                         switch (rm)
                         {
@@ -3213,13 +3322,21 @@
                         c->Irm = modregrm(3,0,BP) + reg;
                 }
             }
+
+            // Replace [R13] with 0[R13]
+            if (c->Irex & REX_B && (c->Irm & modregrm(3,0,5)) == modregrm(0,0,5))
+            {
+                c->Irm |= modregrm(1,0,0);
+                c->IFL1 = FLconst;
+                c->IEVpointer1 = 0;
+            }
         }
         else
         {
             switch (op)
             {
                 default:
-                    if ((op & 0xF0) != 0x70)
+                    if ((op & ~0x0F) != 0x70)
                         break;
                 case JMP:
                     switch (c->IFL2)
@@ -3249,14 +3366,15 @@
 
                 case 0x68:                      // PUSH immed16
                     if (c->IFL2 == FLconst)
-                    {   targ_long u;
-
-                        u = c->IEV2.Vuns;
-                        if ((c->Iflags & CFopsize) ? !I32 : I32)
-                        {   if (u == (signed char) u)
+                    {
+                        targ_long u = c->IEV2.Vuns;
+                        if (I64 ||
+                            ((c->Iflags & CFopsize) ? I16 : I32))
+                        {   // PUSH 32/64 bit operand
+                            if (u == (signed char) u)
                                 c->Iop = 0x6A;          // PUSH immed8
                         }
-                        else
+                        else // PUSH 16 bit operand
                         {   if ((short)u == (signed char) u)
                                 c->Iop = 0x6A;          // PUSH immed8
                         }
@@ -3274,6 +3392,78 @@
 #endif
 }
 
+#ifdef DEBUG
+STATIC void pinholeopt_unittest()
+{
+    //printf("pinholeopt_unittest()\n");
+    struct CS { unsigned model,op,ea,ev1,ev2,flags; } tests[][2] =
+    {
+        // XOR reg,immed                            NOT regL
+        {{ 16,0x81,modregrm(3,6,BX),0,0xFF,0 },    { 0,0xF6,modregrm(3,2,BX),0,0xFF }},
+
+        // MOV 0[BX],3                               MOV [BX],3
+        {{ 16,0xC7,modregrm(2,0,7),0,3},           { 0,0xC7,modregrm(0,0,7),0,3 }},
+
+#if 0 // only if config.flags4 & CFG4space
+        // TEST regL,immed8
+        {{ 0,0xF6,modregrm(3,0,BX),0,0xFF,0 },    { 0,0x84,modregrm(3,BX,BX),0,0xFF }},
+        {{ 0,0xF7,modregrm(3,0,BX),0,0xFF,0 },    { 0,0x84,modregrm(3,BX,BX),0,0xFF }},
+        {{ 64,0xF6,modregrmx(3,0,R8),0,0xFF,0 },  { 0,0x84,modregxrmx(3,R8,R8),0,0xFF }},
+        {{ 64,0xF7,modregrmx(3,0,R8),0,0xFF,0 },  { 0,0x84,modregxrmx(3,R8,R8),0,0xFF }},
+#endif
+
+        // PUSH immed => PUSH immed8
+        {{ 0,0x68,0,0,0 },    { 0,0x6A,0,0,0 }},
+        {{ 0,0x68,0,0,0x7F }, { 0,0x6A,0,0,0x7F }},
+        {{ 0,0x68,0,0,0x80 }, { 0,0x68,0,0,0x80 }},
+        {{ 16,0x68,0,0,0,CFopsize },    { 0,0x6A,0,0,0,CFopsize }},
+        {{ 16,0x68,0,0,0x7F,CFopsize }, { 0,0x6A,0,0,0x7F,CFopsize }},
+        {{ 16,0x68,0,0,0x80,CFopsize }, { 0,0x68,0,0,0x80,CFopsize }},
+        {{ 16,0x68,0,0,0x10000,0 },     { 0,0x6A,0,0,0x10000,0 }},
+        {{ 16,0x68,0,0,0x10000,CFopsize }, { 0,0x68,0,0,0x10000,CFopsize }},
+        {{ 32,0x68,0,0,0,CFopsize },    { 0,0x6A,0,0,0,CFopsize }},
+        {{ 32,0x68,0,0,0x7F,CFopsize }, { 0,0x6A,0,0,0x7F,CFopsize }},
+        {{ 32,0x68,0,0,0x80,CFopsize }, { 0,0x68,0,0,0x80,CFopsize }},
+        {{ 32,0x68,0,0,0x10000,CFopsize },    { 0,0x6A,0,0,0x10000,CFopsize }},
+        {{ 32,0x68,0,0,0x8000,CFopsize }, { 0,0x68,0,0,0x8000,CFopsize }},
+    };
+
+    //config.flags4 |= CFG4space;
+    for (int i = 0; i < sizeof(tests)/sizeof(tests[0]); i++)
+    {   CS *pin  = &tests[i][0];
+        CS *pout = &tests[i][1];
+        code cs;
+        memset(&cs, 0, sizeof(cs));
+        if (pin->model)
+        {
+            if (I16 && pin->model != 16)
+                continue;
+            if (I32 && pin->model != 32)
+                continue;
+            if (I64 && pin->model != 64)
+                continue;
+        }
+        //printf("[%d]\n", i);
+        cs.Iop = pin->op;
+        cs.Iea = pin->ea;
+        cs.IFL1 = FLconst;
+        cs.IFL2 = FLconst;
+        cs.IEV1.Vuns = pin->ev1;
+        cs.IEV2.Vuns = pin->ev2;
+        cs.Iflags = pin->flags;
+        pinholeopt(&cs, NULL);
+        if (cs.Iop != pout->op)
+        {   printf("[%d] Iop = x%02x, pout = x%02x\n", i, cs.Iop, pout->op);
+            assert(0);
+        }
+        assert(cs.Iea == pout->ea);
+        assert(cs.IEV1.Vuns == pout->ev1);
+        assert(cs.IEV2.Vuns == pout->ev2);
+        assert(cs.Iflags == pout->flags);
+    }
+}
+#endif
+
 /**************************
  * Compute jump addresses for FLcode.
  * Note: only works for forward referenced code.
@@ -3291,9 +3481,9 @@
   while (c)
   {
         op = c->Iop;
-        if (inssize[op] & T &&          /* if second operand            */
+        if (inssize[op & 0xFF] & T &&   // if second operand
             c->IFL2 == FLcode &&
-            ((op & 0xF0) == 0x70 || op == JMP || op == JMPS || op == JCXZ))
+            ((op & ~0x0F) == 0x70 || op == JMP || op == JMPS || op == JCXZ))
         {       ci = code_next(c);
                 ctarg = c->IEV2.Vcode;  /* target code                  */
                 ad = 0;                 /* IP displacement              */
@@ -3348,8 +3538,8 @@
  * Calculate bl->Bsize.
  */
 
-targ_size_t calcblksize(code *c)
-{   targ_size_t size;
+unsigned calcblksize(code *c)
+{   unsigned size;
 
     for (size = 0; c; c = code_next(c))
         size += calccodsize(c);
@@ -3364,41 +3554,57 @@
  * Note: This routine must be fast. Profiling shows it is significant.
  */
 
-targ_size_t calccodsize(code *c)
+unsigned calccodsize(code *c)
 {   unsigned size;
     unsigned op;
     unsigned char rm,mod,ins;
     unsigned iflags;
-    unsigned a32 = I32;
+    unsigned i32 = I32 || I64;
+    unsigned a32 = i32;
 
 #ifdef DEBUG
     assert((a32 & ~1) == 0);
 #endif
     iflags = c->Iflags;
     op = c->Iop;
+    if ((op & 0xFF00) == 0x0F00)
+        op = 0x0F;
+    else
+        op &= 0xFF;
     switch (op)
     {
         case 0x0F:
-            ins = inssize2[c->Iop2];
+            ins = inssize2[c->Iop & 0xFF];
             size = ins & 7;
+            if (c->Iop & 0xFF0000)
+                size++;
             break;
 
         case NOP:
         case ESCAPE:
             size = 0;                   // since these won't be output
-            goto Lret;
+            goto Lret2;
 
         case ASM:
             if (c->Iflags == CFaddrsize)        // kludge for DA inline asm
                 size = NPTRSIZE;
             else
                 size = c->IEV1.as.len;
+            goto Lret2;
+
+        case 0xA1:
+        case 0xA3:
+            if (c->Irex)
+            {
+                size = 9;               // 64 bit immediate value for MOV to/from RAX
             goto Lret;
+            }
+            goto Ldefault;
 
         case 0xF6:                      /* TEST mem8,immed8             */
             ins = inssize[op];
             size = ins & 7;
-            if (I32)
+            if (i32)
                 size = inssize32[op];
             if ((c->Irm & (7<<3)) == 0)
                 size++;                 /* size of immed8               */
@@ -3407,16 +3613,17 @@
         case 0xF7:
             ins = inssize[op];
             size = ins & 7;
-            if (I32)
+            if (i32)
                 size = inssize32[op];
             if ((c->Irm & (7<<3)) == 0)
-                size += ((I32) ^ ((iflags & CFopsize) !=0)) ? 4 : 2;
+                size += (i32 ^ ((iflags & CFopsize) !=0)) ? 4 : 2;
             break;
 
         default:
+        Ldefault:
             ins = inssize[op];
             size = ins & 7;
-            if (I32)
+            if (i32)
                 size = inssize32[op];
     }
 
@@ -3439,7 +3646,7 @@
             {
                 if ((op & 0xAC) == 0xA0)
                 {
-                    if (iflags & CFaddrsize)
+                    if (iflags & CFaddrsize && !I64)
                     {   if (I32)
                             size -= 2;
                         else
@@ -3454,7 +3661,8 @@
                 }
             }
             if (iflags & CFaddrsize)
-            {   a32 ^= 1;
+            {   if (!I64)
+                    a32 ^= 1;
                 size++;
             }
             if (iflags & CFopsize)
@@ -3462,22 +3670,29 @@
         }
     }
 
-    if ((op & 0xF0) == 0x70)
+    if ((op & ~0x0F) == 0x70)
     {   if (iflags & CFjmp16)           // if long branch
-            size += I32 ? 4 : 3;        // + 3(4) bytes for JMP
+            size += I16 ? 3 : 4;        // + 3(4) bytes for JMP
     }
     else if (ins & M)                   // if modregrm byte
     {
         rm = c->Irm;
         mod = rm & 0xC0;
-        if (a32)
-        {
+        if (a32 || I64)
+        {   // 32 bit addressing
             if (issib(rm))
                 size++;
             switch (mod)
             {   case 0:
-                    if (issib(rm) && (c->Isib & 7) == 5 || (rm & 7) == 5)
+                    if (issib(rm) && (c->Isib & 7) == 5 ||
+                        (rm & 7) == 5)
                         size += 4;      /* disp32                       */
+                    if (c->Irex & REX_B && (rm & 7) == 5)
+                        /* Instead of selecting R13, this mode is an [RIP] relative
+                         * address. Although valid, it's redundant, and should not
+                         * be generated. Instead, generate 0[R13] instead of [R13].
+                         */
+                        assert(0);
                     break;
                 case 0x40:
                     size++;             /* disp8                        */
@@ -3488,7 +3703,7 @@
             }
         }
         else
-        {
+        {   // 16 bit addressing
             if (mod == 0x40)            /* 01: 8 bit displacement       */
                 size++;
             else if (mod == 0x80 || (mod == 0 && (rm & 7) == 6))
@@ -3497,6 +3712,12 @@
     }
 
 Lret:
+    if (c->Irex)
+    {   size++;
+        if (c->Irex & REX_W && (op & ~7) == 0xB8)
+            size += 4;
+    }
+Lret2:
     //printf("op = x%02x, size = %d\n",op,size);
     return size;
 }
@@ -3518,38 +3739,33 @@
     if (cs1.Iop != cs2.Iop)
         goto nomatch;
     switch (cs1.Iop)
-    {   case ESCAPE:
-            switch (c->Iop2)
             {
-                case ESCctor:
+        case ESCAPE | ESCctor:
+        case ESCAPE | ESCdtor:
                     goto nomatch;
-                case ESCdtor:
-                    goto nomatch;
-            }
-            goto match;
+
         case NOP:
             goto match;
+
         case ASM:
             if (cs1.IEV1.as.len == cs2.IEV1.as.len &&
                 memcmp(cs1.IEV1.as.bytes,cs2.IEV1.as.bytes,cs1.EV1.as.len) == 0)
                 goto match;
             else
                 goto nomatch;
+
+        default:
+            if ((cs1.Iop & 0xFF) == ESCAPE)
+                goto match;
+            break;
     }
     if (cs1.Iflags != cs2.Iflags)
         goto nomatch;
 
-    ins = inssize[cs1.Iop];
-    if (cs1.Iop == 0x0F)
-    {
-        if (cs1.Iop2 != cs2.Iop2)
-            goto nomatch;
-        if (cs1.Iop2 == 0x38 || cs1.Iop2 == 0x3A)
+    ins = inssize[cs1.Iop & 0xFF];
+    if ((cs1.Iop & 0xFF00) == 0x0F00)
         {
-            if (cs1.Iop3 != cs2.Iop3)
-                goto nomatch;
-        }
-        ins = inssize2[cs1.Iop2];
+        ins = inssize2[cs1.Iop & 0xFF];
     }
 
     if (ins & M)                // if modregrm byte
@@ -3631,7 +3847,7 @@
     pgen = bytes;
 }
 
-targ_size_t codout(code *c)
+unsigned codout(code *c)
 { unsigned op;
   unsigned char rm,mod;
   unsigned char ins;
@@ -3640,7 +3856,7 @@
   symbol *s;
 
 #ifdef DEBUG
-  if (debugc) printf("codout(%p), Coffset = x%lx\n",c,Coffset);
+  if (debugc) printf("codout(%p), Coffset = x%llx\n",c,(unsigned long long)Coffset);
 #endif
 
   pgen = bytes;
@@ -3649,12 +3865,13 @@
   {
 #ifdef DEBUG
         if (debugc) { printf("off=%02lx, sz=%ld, ",(long)OFFSET(),(long)calccodsize(c)); c->print(); }
+        unsigned startoffset = OFFSET();
 #endif
         op = c->Iop;
-        ins = inssize[op];
-        switch (op)
+        ins = inssize[op & 0xFF];
+        switch (op & 0xFF)
         {   case ESCAPE:
-                switch (c->Iop2)
+                switch (op & 0xFF00)
                 {   case ESClinnum:
                         /* put out line number stuff    */
                         objlinnum(c->IEV2.Vsrcpos,OFFSET());
@@ -3688,10 +3905,20 @@
 #endif
 #endif
                 }
+#ifdef DEBUG
+                assert(calccodsize(c) == 0);
+#endif
                 continue;
             case NOP:                   /* don't send them out          */
+                if (op != NOP)
+                    break;
+#ifdef DEBUG
+                assert(calccodsize(c) == 0);
+#endif
                 continue;
             case ASM:
+                if (op != ASM)
+                    break;
                 FLUSH();
                 if (c->Iflags == CFaddrsize)    // kludge for DA inline asm
                 {
@@ -3701,12 +3928,15 @@
                 {
                     offset += obj_bytes(cseg,offset,c->IEV1.as.len,c->IEV1.as.bytes);
                 }
+#ifdef DEBUG
+                assert(calccodsize(c) == c->IEV1.as.len);
+#endif
                 continue;
         }
         flags = c->Iflags;
 
         // See if we need to flush (don't have room for largest code sequence)
-        if (pgen - bytes > sizeof(bytes) - (4+4+4+4))
+        if (pgen - bytes > sizeof(bytes) - (1+4+4+8+8))
             FLUSH();
 
         // see if we need to put out prefix bytes
@@ -3734,12 +3964,11 @@
             if (flags & CFopsize)
                 GEN(0x66);                      /* operand size         */
 
-            if ((op & 0xF0) == 0x70 && flags & CFjmp16) /* long condit jmp */
+            if ((op & ~0x0F) == 0x70 && flags & CFjmp16) /* long condit jmp */
             {
-                if (I32)
+                if (!I16)
                 {   // Put out 16 bit conditional jump
-                    c->Iop2 = 0x80 | (op & 0x0F);
-                    c->Iop = op = 0x0F;
+                    c->Iop = op = 0x0F00 | (0x80 | (op & 0x0F));
                 }
                 else
                 {
@@ -3752,19 +3981,36 @@
                     cn->IEV2.Vblock = c->IEV2.Vblock;
                     c->Iop = op ^= 1;           // toggle condition
                     c->IFL2 = FLconst;
-                    c->IEVpointer2 = I32 ? 5 : 3; // skip over JMP block
+                    c->IEVpointer2 = I16 ? 3 : 5; // skip over JMP block
                 }
             }
         }
 
-        GEN(op);
-        if (op == 0x0F)
+        if (c->Irex)
+            GEN(c->Irex | REX);
+        if (op > 0xFF)
+        {
+            if ((op & 0xFF00) == 0x0F00)
+                ins = inssize2[op & 0xFF];
+            if (op & 0xFF000000)
+            {   GEN(op >> 24);
+                GEN((op >> 8) & 0xFF);
+                GEN(op & 0xFF);
+                GEN((op >> 16) & 0xFF);         // yes, this is out of order. For 0x660F3A41 & 40
+            }
+            else if (op & 0xFF0000)
         {
-           ins = inssize2[c->Iop2];
-           GEN(c->Iop2);
-           if (c->Iop2 == 0x38 || c->Iop2 == 0x3A)
-                GEN(c->Iop3);
+                GEN((op >> 16) & 0xFF);
+                GEN((op >> 8) & 0xFF);
+                GEN(op & 0xFF);
+            }
+            else
+            {   GEN((op >> 8) & 0xFF);
+                GEN(op & 0xFF);
+            }
         }
+        else
+            GEN(op);
         if (ins & M)            /* if modregrm byte             */
         {
             rm = c->Irm;
@@ -3786,7 +4032,7 @@
                               (rm & 7) == 5))
                             break;
                     case 0x80:
-                        do32bit((enum FL)c->IFL1,&c->IEV1,CFoff);
+                        do32bit((enum FL)c->IFL1,&c->IEV1,CFoff | CFpc32);
                         break;
                 }
             }
@@ -3814,7 +4060,7 @@
         if (ins & T)                    /* if second operand            */
         {       if (ins & E)            /* if data-8                    */
                     do8bit((enum FL) c->IFL2,&c->IEV2);
-                else if (I32)
+                else if (!I16)
                 {
                     switch (op)
                     {   case 0xC2:              /* RETN imm16           */
@@ -3822,11 +4068,18 @@
                         do16:
                             do16bit((enum FL)c->IFL2,&c->IEV2,flags);
                             break;
-                        case 0xA0:              /* MOV AL,byte ptr []   */
+
                         case 0xA1:
-                        case 0xA2:
                         case 0xA3:
-                            if (c->Iflags & CFaddrsize)
+                            if (I64 && c->Irex)
+                            {
+                        do64:
+                                do64bit((enum FL)c->IFL2,&c->IEV2,flags);
+                                break;
+                            }
+                        case 0xA0:              /* MOV AL,byte ptr []   */
+                        case 0xA2:
+                            if (c->Iflags & CFaddrsize && !I64)
                                 goto do16;
                             else
                         do32:
@@ -3851,7 +4104,11 @@
                         case 0xE8:              // CALL rel
                         case 0xE9:              // JMP  rel
                             flags |= CFselfrel;
+                            goto case_default;
+
                         default:
+                            if (I64 && (op & ~7) == 0xB8 && c->Irex & REX_W)
+                                goto do64;
                         case_default:
                             if (c->Iflags & CFopsize)
                                 goto do16;
@@ -3860,7 +4117,8 @@
                             break;
                     }
                 }
-                else {
+                else
+                {
                     switch (op) {
                         case 0xC2:
                         case 0xCA:
@@ -3926,12 +4184,20 @@
         else if (op == 0xF7)
         {   if ((rm & (7<<3)) == 0)     /* TEST mem16/32,immed16/32     */
             {
-                if (I32 ^ ((c->Iflags & CFopsize) != 0))
+                if ((I32 || I64) ^ ((c->Iflags & CFopsize) != 0))
                     do32bit((enum FL)c->IFL2,&c->IEV2,flags);
                 else
                     do16bit((enum FL)c->IFL2,&c->IEV2,flags);
             }
         }
+#ifdef DEBUG
+        if (OFFSET() - startoffset != calccodsize(c))
+        {
+            printf("actual: %d, calc: %d\n", (int)(OFFSET() - startoffset), (int)calccodsize(c));
+            c->print();
+            assert(0);
+        }
+#endif
     }
     FLUSH();
     Coffset = offset;
@@ -3940,16 +4206,103 @@
 }
 
 
+STATIC void do64bit(enum FL fl,union evc *uev,int flags)
+{   char *p;
+    symbol *s;
+    targ_size_t ad;
+    long tmp;
+
+    assert(I64);
+    switch (fl)
+    {
+        case FLconst:
+            ad = * (targ_size_t *) uev;
+        L1:
+            GENP(8,&ad);
+            return;
+        case FLdatseg:
+            FLUSH();
+            reftodatseg(cseg,offset,uev->_EP.Vpointer,uev->_EP.Vseg,CFoffset64 | flags);
+            break;
+        case FLframehandler:
+            framehandleroffset = OFFSET();
+            ad = 0;
+            goto L1;
+        case FLswitch:
+            FLUSH();
+            ad = uev->Vswitch->Btableoffset;
+            if (config.flags & CFGromable)
+                    reftocodseg(cseg,offset,ad);
+            else
+                    reftodatseg(cseg,offset,ad,JMPSEG,CFoff);
+            break;
+        case FLcsdata:
+        case FLfardata:
+#if DEBUG
+            symbol_print(uev->sp.Vsym);
+#endif
+            assert(!TARGET_FLAT);
+            // NOTE: In ELFOBJ all symbol refs have been tagged FLextern
+            // strings and statics are treated like offsets from a
+            // un-named external with is the start of .rodata or .data
+        case FLextern:                      /* external data symbol         */
+        case FLtlsdata:
+#if TARGET_LINUX || TARGET_FREEBSD || TARGET_SOLARIS
+        case FLgot:
+        case FLgotoff:
+#endif
+            FLUSH();
+            s = uev->sp.Vsym;               /* symbol pointer               */
+            reftoident(cseg,offset,s,uev->sp.Voffset,CFoffset64 | flags);
+            break;
+
+#if TARGET_OSX
+        case FLgot:
+            funcsym_p->Slocalgotoffset = OFFSET();
+            ad = 0;
+            goto L1;
+#endif
+
+        case FLfunc:                        /* function call                */
+            s = uev->sp.Vsym;               /* symbol pointer               */
+            assert(!(TARGET_FLAT && tyfarfunc(s->ty())));
+            FLUSH();
+            reftoident(cseg,offset,s,0,CFoffset64 | flags);
+            break;
+
+        case FLblock:                       /* displacement to another block */
+            ad = uev->Vblock->Boffset - OFFSET() - 4;
+            //printf("FLblock: funcoffset = %x, OFFSET = %x, Boffset = %x, ad = %x\n", funcoffset, OFFSET(), uev->Vblock->Boffset, ad);
+            goto L1;
+
+        case FLblockoff:
+            FLUSH();
+            assert(uev->Vblock);
+            //printf("FLblockoff: offset = %x, Boffset = %x, funcoffset = %x\n", offset, uev->Vblock->Boffset, funcoffset);
+            reftocodseg(cseg,offset,uev->Vblock->Boffset);
+            break;
+
+        default:
+#ifdef DEBUG
+            WRFL(fl);
+#endif
+            assert(0);
+    }
+    offset += 8;
+}
+
+
 STATIC void do32bit(enum FL fl,union evc *uev,int flags)
 { char *p;
   symbol *s;
   targ_size_t ad;
   long tmp;
 
+  //printf("do32bit(flags = x%x)\n", flags);
   switch (fl)
   {
     case FLconst:
-        assert(sizeof(targ_size_t) == 4);
+        assert(sizeof(targ_size_t) == 4 || sizeof(targ_size_t) == 8);
         ad = * (targ_size_t *) uev;
     L1:
         GENP(4,&ad);
@@ -4155,7 +4508,7 @@
 
 void addtofixlist(symbol *s,targ_size_t soffset,int seg,targ_size_t val,int flags)
 {       fixlist *ln;
-        static char zeros[6];
+        static char zeros[8];
         int numbytes;
 
         //printf("addtofixlist(%p '%s')\n",s,s->Sident);
@@ -4173,6 +4526,8 @@
         fixlist::start = ln;
 #if TARGET_FLAT
         numbytes = tysize[TYnptr];
+        if (I64 && !(flags & CFoffset64))
+            numbytes = 4;
         assert(!(flags & CFseg));
 #else
         switch (flags & (CFoff | CFseg))
@@ -4311,6 +4666,7 @@
   }
 }
 
+
 /**********************************
  */
 
@@ -4325,24 +4681,24 @@
     while (*pc)
     {
         c = (code *) ph_hydrate(pc);
+        if ((c->Iop & 0xFF00) == 0x0F00)
+            ins = inssize2[c->Iop & 0xFF];
+        else
+            ins = inssize[c->Iop & 0xFF];
         switch (c->Iop)
-        {   case 0x0F:
-                ins = inssize2[c->Iop2];
-                break;
+        {
             default:
-                ins = inssize[c->Iop];
                 break;
-            case ESCAPE:
-                switch (c->Iop2)
-                {   case ESClinnum:
+
+            case ESCAPE | ESClinnum:
                         srcpos_hydrate(&c->IEV2.Vsrcpos);
-                        break;
-                    case ESCctor:
-                    case ESCdtor:
+                goto done;
+
+            case ESCAPE | ESCctor:
+            case ESCAPE | ESCdtor:
                         el_hydrate(&c->IEV1.Vtor);
-                        break;
-                }
                 goto done;
+
             case ASM:
                 ph_hydrate(&c->IEV1.as.bytes);
                 goto done;
@@ -4489,24 +4845,24 @@
     {
         ph_dehydrate(pc);
 
+        if ((c->Iop & 0xFF00) == 0x0F00)
+            ins = inssize2[c->Iop & 0xFF];
+        else
+            ins = inssize[c->Iop & 0xFF];
         switch (c->Iop)
-        {   case 0x0F:
-                ins = inssize2[c->Iop2];
-                break;
+        {
             default:
-                ins = inssize[c->Iop];
                 break;
-            case ESCAPE:
-                switch (c->Iop2)
-                {   case ESClinnum:
+
+            case ESCAPE | ESClinnum:
                         srcpos_dehydrate(&c->IEV2.Vsrcpos);
-                        break;
-                    case ESCctor:
-                    case ESCdtor:
+                goto done;
+
+            case ESCAPE | ESCctor:
+            case ESCAPE | ESCdtor:
                         el_dehydrate(&c->IEV1.Vtor);
-                        break;
-                }
                 goto done;
+
             case ASM:
                 ph_dehydrate(&c->IEV1.as.bytes);
                 goto done;
@@ -4661,20 +5017,19 @@
         return;
   }
   op = c->Iop;
-  ins = inssize[op];
-  if (op == 0x0F)
-  {     op = 0x0F00 + c->Iop2;
-        if (op == 0x0F38 || op == 0x0F3A)
-            op = (op << 8) | c->Iop3;
-        ins = inssize2[c->Iop2];
-  }
+
+    if ((c->Iop & 0xFF00) == 0x0F00)
+        ins = inssize2[op & 0xFF];
+    else
+        ins = inssize[op & 0xFF];
+
   printf("code %p: nxt=%p op=%02x",c,code_next(c),op);
-  if (op == ESCAPE)
-  {     if (c->Iop2 == ESClinnum)
+  if ((op & 0xFF) == ESCAPE)
+  {     if ((op & 0xFF00) == ESClinnum)
         {   printf(" linnum = %d\n",c->IEV2.Vsrcpos.Slinnum);
             return;
         }
-        printf(" ESCAPE %d",c->Iop2);
+        printf(" ESCAPE %d",c->Iop >> 8);
   }
   if (c->Iflags)
         printf(" flg=%x",c->Iflags);
@@ -4691,7 +5046,7 @@
             {
                 case FLconst:
                 case FLoffset:
-                    printf(" int = %4ld",c->IEV1.Vuns);
+                    printf(" int = %4d",c->IEV1.Vuns);
                     break;
                 case FLblock:
                     printf(" block = %p",c->IEV1.Vblock);
@@ -4703,7 +5058,7 @@
                 case 0:
                     break;
                 case FLdatseg:
-                    printf(" %d.%lx",c->IEVseg1,c->IEVpointer1);
+                    printf(" %d.%llx",c->IEVseg1,(unsigned long long)c->IEVpointer1);
                     break;
                 case FLauto:
                 case FLreg:
@@ -4726,7 +5081,7 @@
         switch (c->IFL2)
         {
             case FLconst:
-                printf(" int = %4ld",c->IEV2.Vuns);
+                printf(" int = %4d",c->IEV2.Vuns);
                 break;
             case FLblock:
                 printf(" block = %p",c->IEV2.Vblock);
@@ -4738,7 +5093,7 @@
             case FLframehandler:
                 break;
             case FLdatseg:
-                printf(" %d.%lx",c->IEVseg2,c->IEVpointer2);
+                printf(" %d.%llx",c->IEVseg2,(unsigned long long)c->IEVpointer2);
                 break;
             case FLauto:
             case FLreg:
diff -aruw dmd62/backend/cod4.c dmd63/backend/cod4.c
--- dmd62/backend/cod4.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/cod4.c	2010-08-09 14:33:14.000000000 -0400
@@ -50,7 +50,7 @@
  */
 
 STATIC int doinreg(symbol *s, elem *e)
-{   int in;
+{   int in = 0;
     int op;
 
  L1:
@@ -89,9 +89,18 @@
  * This is called just before modifying an EA.
  */
 
-code *modEA(unsigned Irm)
+code *modEA(code *c)
 {
-    return ((Irm & 0xC0) == 0xC0) ? getregs(mask[Irm & 7]) : CNIL;
+    if ((c->Irm & 0xC0) == 0xC0)        // addressing mode refers to a register
+    {
+        unsigned reg = c->Irm & 7;
+        if (c->Irex & REX_B)
+        {   reg |= 8;
+            assert(I64);
+        }
+        return getregs(mask[reg]);
+    }
+    return CNIL;
 }
 
 #if TARGET_WINDOS
@@ -138,7 +147,7 @@
 
         }
         retregs2 = FLOATREGS2;
-        idxregs = FLOATREGS | idxregm(cs.Irm,cs.Isib);
+        idxregs = FLOATREGS | idxregm(&cs);
         retregs = FLOATREGS;
   }
   else
@@ -156,7 +165,7 @@
             getlvalue_lsw(&cs);
 
             retregs2 = DOUBLEREGS2_32;
-            idxregs = DOUBLEREGS_32 | idxregm(cs.Irm,cs.Isib);
+            idxregs = DOUBLEREGS_32 | idxregm(&cs);
         }
         else
         {
@@ -174,7 +183,7 @@
             stackpush += DOUBLESIZE;
 
             retregs2 = DOUBLEREGS_16;
-            idxregs = idxregm(cs.Irm,cs.Isib);
+            idxregs = idxregm(&cs);
         }
         retregs = DOUBLEREGS;
   }
@@ -213,7 +222,7 @@
     sz = tysize[tym];
 
     cl = getlvalue(&cs,e1,*pretregs ? DOUBLEREGS | mBX | mCX : 0);
-    cr = modEA(cs.Irm);
+    cr = modEA(&cs);
     cs.Irm |= modregrm(0,6,0);
     cs.Iop = 0x80;
     cs.IEVoffset1 += sz - 1;
@@ -370,7 +379,7 @@
                 ((e11 = e1->E1)->Eoper == OPpostinc || e11->Eoper == OPpostdec) &&
                 e11->E1->Eoper == OPvar &&
                 e11->E1->EV.sp.Vsym->Sfl == FLreg &&
-                (I32 || e11->E1->EV.sp.Vsym->Sregm & IDXREGS)
+                (!I16 || e11->E1->EV.sp.Vsym->Sregm & IDXREGS)
                )
             {
                 postinc = e11->E2->EV.Vint;
@@ -390,28 +399,44 @@
                     (cs.Irm & 0xC0) == 0x80
                    )
                 {
-                    if (sz == REGSIZE && e2->EV.Vint)
-                    {   regm_t rregm;
-                        unsigned rreg;
-
+                    if (I64 && sz == 8 && e2->EV.Vpointer)
+                    {
+                        // MOV reg,imm64
+                        // MOV EA,reg
+                        regm_t rregm = allregs & ~idxregm(&cs);
+                        unsigned reg;
+                        cl = regwithvalue(cl,rregm,e2->EV.Vpointer,&reg,CFoffset64);
+                        cs.Iop = 0x89;
+                        cs.Irm |= modregrm(0,reg & 7,0);
+                        if (reg & 8)
+                            cs.Irex |= REX_R;
+                        c = gen(cl,&cs);
+                        freenode(e2);
+                        goto Lp;
+                    }
+                    if ((sz == REGSIZE || (I64 && sz == 4)) && e2->EV.Vint)
+                    {
                         // MOV reg,imm
                         // MOV EA,reg
-                        rregm = allregs & ~idxregm(cs.Irm,cs.Isib);
+                        regm_t rregm = allregs & ~idxregm(&cs);
+                        unsigned reg;
                         cl = regwithvalue(cl,rregm,e2->EV.Vint,&reg,0);
                         cs.Iop = 0x89;
-                        cs.Irm |= modregrm(0,reg,0);
+                        cs.Irm |= modregrm(0,reg & 7,0);
+                        if (reg & 8)
+                            cs.Irex |= REX_R;
                         c = gen(cl,&cs);
                         freenode(e2);
                         goto Lp;
                     }
                     if (sz == 2 * REGSIZE && e2->EV.Vllong == 0)
                     {   regm_t rregm;
-                        unsigned rreg;
+                        unsigned reg;
 
                         // MOV reg,imm
                         // MOV EA,reg
                         // MOV EA+2,reg
-                        rregm = getscratch() & ~idxregm(cs.Irm,cs.Isib);
+                        rregm = getscratch() & ~idxregm(&cs);
                         if (rregm)
                         {   cl = regwithvalue(cl,rregm,e2->EV.Vint,&reg,0);
                             cs.Iop = 0x89;
@@ -428,7 +453,7 @@
 
             /* If loading result into a register        */
             if ((cs.Irm & 0xC0) == 0xC0)
-            {   cl = cat(cl,getregs(mask[cs.Irm & 7]));
+            {   cl = cat(cl,modEA(&cs));
                 if (sz == 2 * REGSIZE && cs.IFL1 == FLreg)
                     cl = cat(cl,getregs(cs.IEVsym1->Sregm));
             }
@@ -441,6 +466,8 @@
                 cs.IEVsym2 = e2->EV.sp.Vsym;
                 cs.Iflags |= CFoff;
                 cl = gen(cl,&cs);       /* MOV EA,&variable     */
+                if (I64 && sz == 8)
+                    code_orrex(cl, REX_W);
                 if (sz > REGSIZE)
                 {
                     cs.Iop = 0x8C;
@@ -450,15 +477,21 @@
                 }
             }
             else
-            {   targ_int *p;
-
+            {
+                assert(e2oper == OPconst);
                 cs.IFL2 = FLconst;
-                p = (targ_int *) &(e2->EV);
-                cs.IEV2.Vint = *p;
+                targ_size_t *p = (targ_size_t *) &(e2->EV);
+                cs.IEV2.Vsize_t = *p;
                 // Look for loading a register variable
                 if ((cs.Irm & 0xC0) == 0xC0)
-                {
-                        cl = movregconst(cl,cs.Irm & 7,*p,1 ^ (cs.Iop & 1));
+                {   unsigned reg = cs.Irm & 7;
+
+                    if (cs.Irex & REX_B)
+                        reg |= 8;
+                    if (I64 && sz == 8)
+                        cl = movregconst(cl,reg,*p,CFoffset64);
+                    else
+                        cl = movregconst(cl,reg,*p,1 ^ (cs.Iop & 1));
                         if (sz == 2 * REGSIZE)
                         {   getlvalue_msw(&cs);
                             cl = movregconst(cl,cs.Irm & 7,p[1],0);
@@ -471,26 +504,31 @@
                         do
                         {   regsize = REGSIZE;
                             retregs = (sz == 1) ? BYTEREGS : allregs;
-                            if (i >= 4 && !I32 && I386)
+                        if (i >= 4 && I16 && I386)
                             {
                                 regsize = 4;
-                                cs.Iflags |= CFopsize;
+                            cs.Iflags |= CFopsize;      // use opsize to do 32 bit operation
                             }
                             else
                             {
                                 if (reghasvalue(retregs,*p,&reg))
                                 {
                                     cs.Iop = (cs.Iop & 1) | 0x88;
-                                    cs.Irm |= reg << 3; /* MOV EA,reg   */
+                                cs.Irm |= modregrm(0,reg & 7,0); // MOV EA,reg
+                                if (reg & 8)
+                                    cs.Irex |= REX_R;
                                 }
-                                if (I32 && i == 2)      // if 16 bit operand
+                            if (!I16 && i == 2)      // if 16 bit operand
                                     cs.Iflags |= CFopsize;
+                            if (I64 && sz == 8)
+                                assert(cs.Irex & REX_W);
                             }
                             cl = gen(cl,&cs);           /* MOV EA,const */
 
-                            p = (targ_int *)((char *) p + regsize);
+                        p = (targ_size_t *)((char *) p + regsize);
                             cs.Iop = (cs.Iop & 1) | 0xC6;
-                            cs.Irm &= ~(7 << 3);
+                        cs.Irm &= ~modregrm(0,7,0);
+                        cs.Irex &= ~REX_R;
                             cs.IEVoffset1 += regsize;
                             cs.IEV2.Vint = *p;
                             i -= regsize;
@@ -559,7 +597,7 @@
         ((e11 = e1->E1)->Eoper == OPpostinc || e11->Eoper == OPpostdec) &&
         e11->E1->Eoper == OPvar &&
         e11->E1->EV.sp.Vsym->Sfl == FLreg &&
-        (I32 || e11->E1->EV.sp.Vsym->Sregm & IDXREGS)
+        (!I16 || e11->E1->EV.sp.Vsym->Sregm & IDXREGS)
        )
     {
         postinc = e11->E2->EV.Vint;
@@ -588,11 +626,13 @@
   }
   else
   {
-        if (I32)
+        if (!I16)
         {
             reg = findreg(retregs &
                     ((sz > REGSIZE) ? mBP | mLSW : mBP | ALLREGS));
-            cs.Irm |= modregrm(0,reg,0);
+            cs.Irm |= modregrm(0,reg & 7,0);
+            if (reg & 8)
+                cs.Irex |= REX_R;
             for (; TRUE; sz -= REGSIZE)
             {
                 // Do not generate mov from register onto itself
@@ -605,7 +645,7 @@
                     break;
                 getlvalue_msw(&cs);
                 reg = findregmsw(retregs);
-                NEWREG(cs.Irm,reg);
+                code_newreg(&cs, reg);
             }
         }
         else
@@ -645,12 +685,22 @@
     c = cat4(cr,cl,c,fixresult(e,retregs,pretregs));
 Lp:
     if (postinc)
-    {   int reg;
-
-        reg = findreg(idxregm(cs.Irm,cs.Isib));
+    {
+        int reg = findreg(idxregm(&cs));
         if (*pretregs & mPSW)
         {   // Use LEA to avoid touching the flags
-            c = genc1(c,0x8D,modregrm(2,reg,cs.Irm & 7),FLconst,postinc);
+            unsigned rm = cs.Irm & 7;
+            if (cs.Irex & REX_B)
+                rm |= 8;
+            c = genc1(c,0x8D,modregxrmx(2,reg,rm),FLconst,postinc);
+            if (sz == 8)
+                code_orrex(c, REX_W);
+        }
+        else if (I64)
+        {
+            c = genc2(c,0x81,modregrmx(3,0,reg),postinc);
+            if (sz == 8)
+                code_orrex(c, REX_W);
         }
         else
         {
@@ -668,6 +718,7 @@
     return c;
 }
 
+
 /************************
  * Generate code for += -= &= |= ^= negass
  */
@@ -711,11 +762,11 @@
 #endif
         return c;
   }
-  opsize = (!I32 && tylong(tyml) && config.target_cpu >= TARGET_80386)
+  opsize = (I16 && tylong(tyml) && config.target_cpu >= TARGET_80386)
         ? CFopsize : 0;
   cflags = 0;
   forccs = *pretregs & mPSW;            // return result in flags
-  forregs = *pretregs & (mBP | ALLREGS | mES);  // return result in regs
+  forregs = *pretregs & ~mPSW;          // return result in regs
   /* TRUE if we want the result in a register   */
   wantres = forregs || (e1->Ecount && EOP(e1));
 
@@ -744,20 +795,22 @@
   if (op == OPnegass)
   {
         cl = getlvalue(&cs,e1,0);
-        cr = modEA(cs.Irm);
+        cr = modEA(&cs);
         cs.Irm |= modregrm(0,3,0);
         cs.Iop = op1;
         switch (tysize[tyml])
         {   case CHARSIZE:
                 c = gen(CNIL,&cs);
                 break;
+
             case SHORTSIZE:
                 c = gen(CNIL,&cs);
-                if (I32 && *pretregs & mPSW)
+                if (!I16 && *pretregs & mPSW)
                     c->Iflags |= CFopsize | CFpsw;
                 break;
+
             case LONGSIZE:
-                if (I32 || opsize)
+                if (!I16 || opsize)
                 {   c = gen(CNIL,&cs);
                     c->Iflags |= opsize;
                     break;
@@ -774,11 +827,12 @@
                 cs.IEV2.Vuns = 0;
                 gen(c,&cs);                     // SBB EA+2,0
                 break;
+
             case LLONGSIZE:
-                if (I32)
-                    goto neg_2reg;
+                if (I16)
                 assert(0);                      // not implemented yet
-                break;
+                goto neg_2reg;
+
             default:
                 assert(0);
         }
@@ -797,13 +851,12 @@
      )
   {
         cl = getlvalue(&cs,e1,0);
-        cl = cat(cl,modEA(cs.Irm));
+        cl = cat(cl,modEA(&cs));
         cs.IFL2 = FLconst;
         cs.IEV2.Vint = e2->EV.Vint;
         if (sz <= REGSIZE || tyfv(tyml) || opsize)
-        {   targ_int i;
-
-            i = cs.IEV2.Vint;
+        {
+            targ_size_t i = cs.IEV2.Vsize_t;
 
             /* Handle shortcuts. Watch out for if result has    */
             /* to be in flags.                                  */
@@ -822,7 +875,7 @@
                 {   case OPminass:      /* convert to +=        */
                         cs.Irm ^= modregrm(0,5,0);
                         i = -i;
-                        cs.IEV2.Vint = i;
+                        cs.IEV2.Vsize_t = i;
                         /* FALL-THROUGH */
                     case OPaddass:
                         if (i == 1)             /* INC EA       */
@@ -838,16 +891,16 @@
             cs.Iflags |= opsize;
             if (forccs)
                 cs.Iflags |= CFpsw;
-            else if (I32 && cs.Iflags & CFopsize)
+            else if (!I16 && cs.Iflags & CFopsize)
             {
                 switch (op)
                 {   case OPorass:
                     case OPxorass:
-                        cs.IEV2.Vint &= 0xFFFF;
+                        cs.IEV2.Vsize_t &= 0xFFFF;
                         cs.Iflags &= ~CFopsize; // don't worry about MSW
                         break;
                     case OPandass:
-                        cs.IEV2.Vint |= ~0xFFFFL;
+                        cs.IEV2.Vsize_t |= ~0xFFFFLL;
                         cs.Iflags &= ~CFopsize; // don't worry about MSW
                         break;
                     case OPminass:
@@ -881,7 +934,7 @@
                 code cs2;
 
                 // Determine which registers to use
-                sregm = allregs & ~idxregm(cs.Irm,cs.Isib);
+                sregm = allregs & ~idxregm(&cs);
                 if (byte)
                     sregm &= BYTEREGS;
                 if (sregm & forregs)
@@ -892,10 +945,12 @@
                 cs2 = cs;
                 cs2.Iflags &= ~CFpsw;
                 cs2.Iop = 0x8B ^ byte;
-                cs2.Irm = (cs2.Irm & modregrm(3,0,7)) | modregrm(0,reg,0);
+                code_newreg(&cs2, reg);
                 cr = gen(cr,&cs2);                      // MOV reg,EA
 
-                cs.Irm = (cs.Irm & modregrm(0,7,0)) | modregrm(3,0,reg);
+                cs.Irm = (cs.Irm & modregrm(0,7,0)) | modregrm(3,0,reg & 7);
+                if (reg & 8)
+                    cs.Irex |= REX_B;
                 gen(cr,&cs);                            // OP reg
 
                 cs2.Iop ^= 2;
@@ -912,7 +967,7 @@
                 c = gen(cl,&cs);
                 cs.Iflags &= ~opsize;
                 cs.Iflags &= ~CFpsw;
-                if (!I32 && opsize)                     // if DWORD operand
+                if (I16 && opsize)                     // if DWORD operand
                     cs.IEVoffset1 += 2; // compensate for wantres code
             }
         }
@@ -949,7 +1004,7 @@
         cr = getlvalue(&cs,e2,0);
         freenode(e2);
         cl = getregs(varregm);
-        cs.Irm |= modregrm(0,varreg,0);
+        code_newreg(&cs, varreg);
         cs.Iop = op1 ^ 2;                       // toggle direction bit
         if (forccs)
             cs.Iflags |= CFpsw;
@@ -965,11 +1020,11 @@
             retregs &= ~mCX;                    // need CX for shift count
         cr = scodelem(e->E2,&retregs,0,TRUE);   // get rvalue
         cl = getlvalue(&cs,e1,retregs);         // get lvalue
-        cl = cat(cl,modEA(cs.Irm));
+        cl = cat(cl,modEA(&cs));
         cs.Iop = op1;
         if (sz <= REGSIZE || tyfv(tyml))
         {   reg = findreg(retregs);
-            cs.Irm |= modregrm(0,reg,0);        // OP1 EA,reg
+            code_newreg(&cs, reg);              // OP1 EA,reg
         }
         else if (tyml == TYhptr)
         {   unsigned mreg,lreg;
@@ -1031,6 +1086,8 @@
             if (cs.Iop & 2 && cs.Iop < 0x40 && (cs.Iop & 7) <= 5)
             {
                 reg = (cs.Irm >> 3) & 7;
+                if (cs.Irex & REX_R)
+                    reg |= 8;
                 retregs = mask[reg];
                 ce = allocreg(&retregs,&reg,tyml);
             }
@@ -1038,6 +1095,8 @@
             else if ((cs.Irm & 0xC0) == 0xC0)
             {
                 reg = cs.Irm & 7;
+                if (cs.Irex & REX_B)
+                    reg |= 8;
                 retregs = mask[reg];
                 ce = allocreg(&retregs,&reg,tyml);
             }
@@ -1045,7 +1104,7 @@
             {
                 ce = allocreg(&retregs,&reg,tyml);
                 cs.Iop = 0x8B ^ byte ^ reverse;
-                NEWREG(cs.Irm,reg);
+                code_newreg(&cs, reg);
                 ce = gen(ce,&cs);               // MOV reg,EA
             }
         }
@@ -1054,7 +1113,7 @@
 
                 if (tyml == TYhptr)
                     getlvalue_lsw(&cs);
-                idxregs = idxregm(cs.Irm,cs.Isib);
+                idxregs = idxregm(&cs);
                 retregs = forregs & ~idxregs;
                 if (!(retregs & IDXREGS))
                         retregs |= IDXREGS & ~idxregs;
@@ -1080,7 +1139,7 @@
         {       regm_t idx;
                 code *cm,*cl;
 
-                idx = idxregm(cs.Irm,cs.Isib);
+                idx = idxregm(&cs);
                 retregs = forregs;
                 if (!retregs)
                         retregs = ALLREGS;
@@ -1102,7 +1161,7 @@
   }
   freenode(e1);
   if (sz <= REGSIZE)
-        *pretregs &= mES | ALLREGS | mBP;       // flags are already set
+        *pretregs &= ~mPSW;            // flags are already set
   return cat(c,fixresult(e,retregs,pretregs));
 }
 
@@ -1128,6 +1187,10 @@
   tym = tybasic(e->Ety);                /* type of result               */
   sz = tysize[tyml];
 
+    unsigned rex = (I64 && sz == 8) ? REX_W : 0;
+    unsigned grex = rex << 16;          // 64 bit operands
+
+
   if (tyfloating(tyml))
 #if TARGET_LINUX || TARGET_OSX || TARGET_FREEBSD || TARGET_SOLARIS
         return opass87(e,pretregs);
@@ -1151,14 +1214,14 @@
         {
             if (config.target_cpu >= TARGET_80286 &&
                 e2->Eoper == OPconst && !byte)
-            {   targ_int e2factor;
-                regm_t idxregs;
-
-                e2factor = el_tolong(e2);
+            {
+                targ_size_t e2factor = el_tolong(e2);
+                if (I64 && sz == 8 && e2factor != (int)e2factor)
+                    goto L1;
                 freenode(e2);
                 cr = CNIL;
                 cl = getlvalue(&cs,e1,0);       /* get EA               */
-                idxregs = idxregm(cs.Irm,cs.Isib);
+                regm_t idxregs = idxregm(&cs);
                 retregs = *pretregs & (ALLREGS | mBP) & ~idxregs;
                 if (!retregs)
                     retregs = ALLREGS & ~idxregs;
@@ -1168,16 +1231,16 @@
                 cs.IEV2.Vint = e2factor;
                 opr = resreg;
             }
-            else if (I32 && !byte)
+            else if (!I16 && !byte)
             {
+             L1:
                 retregs = *pretregs & (ALLREGS | mBP);
                 if (!retregs)
                     retregs = ALLREGS;
                 cr = codelem(e2,&retregs,FALSE); /* load rvalue in reg  */
                 cl = getlvalue(&cs,e1,retregs); /* get EA               */
                 cg = getregs(retregs);          /* destroy these regs   */
-                cs.Iop = 0x0F;                  /* IMUL resreg,EA       */
-                cs.Iop2 = 0xAF;
+                cs.Iop = 0x0FAF;                // IMUL resreg,EA
                 resreg = findreg(retregs);
                 opr = resreg;
             }
@@ -1193,15 +1256,17 @@
             c = gen(CNIL,&cs);
         }
         else // /= or %=
-        {   targ_int e2factor;
+        {   targ_size_t e2factor;
             int pow2;
             targ_ulong m;
 
             assert(!byte);                      // should never happen
-            assert(!I32 || sz != SHORTSIZE);
+            assert(I16 || sz != SHORTSIZE);
             if (config.flags4 & CFG4speed &&
-                e2->Eoper == OPconst && sz == REGSIZE && !uns &&
+                e2->Eoper == OPconst && !uns &&
+                (sz == REGSIZE || (I64 && sz == 4)) &&
                 (pow2 = ispow2(e2factor = el_tolong(e2))) != -1 &&
+                e2factor == (int)e2factor &&
                 !(config.target_cpu < TARGET_80286 && pow2 != 1 && op == OPdivass)
                )
             {
@@ -1210,43 +1275,44 @@
                 c = NULL;
                 cl = getlvalue(&cs,e1,mAX | mDX);
                 cs.Iop = 0x8B;
-                NEWREG(cs.Irm,AX);
+                code_newreg(&cs, AX);
                 cl = gen(cl,&cs);                       // MOV AX,EA
                 freenode(e2);
                 cg = getregs(mAX | mDX);                // trash these regs
                 cg = gen1(cg,0x99);                     // CWD
+                code_orrex(cg, rex);
                 if (pow2 == 1)
                 {
                     if (op == OPdivass)
-                    {   gen2(cg,0x2B,modregrm(3,AX,DX));        // SUB AX,DX
-                        gen2(cg,0xD1,modregrm(3,7,AX));         // SAR AX,1
+                    {   gen2(cg,0x2B,grex | modregrm(3,AX,DX));        // SUB AX,DX
+                        gen2(cg,0xD1,grex | modregrm(3,7,AX));         // SAR AX,1
                         resreg = AX;
                     }
                     else // OPmod
-                    {   gen2(cg,0x33,modregrm(3,AX,DX));        // XOR AX,DX
-                        genc2(cg,0x81,modregrm(3,4,AX),1);      // AND AX,1
-                        gen2(cg,0x03,modregrm(3,DX,AX));        // ADD DX,AX
+                    {   gen2(cg,0x33,grex | modregrm(3,AX,DX));        // XOR AX,DX
+                        genc2(cg,0x81,grex | modregrm(3,4,AX),1);      // AND AX,1
+                        gen2(cg,0x03,grex | modregrm(3,DX,AX));        // ADD DX,AX
                         resreg = DX;
                     }
                 }
                 else
-                {   targ_ulong m;
-
-                    m = (1 << pow2) - 1;
+                {
+                    assert(pow2 < 32);
+                    targ_ulong m = (1 << pow2) - 1;
                     if (op == OPdivass)
-                    {   genc2(cg,0x81,modregrm(3,4,DX),m);      // AND DX,m
-                        gen2(cg,0x03,modregrm(3,AX,DX));        // ADD AX,DX
+                    {   genc2(cg,0x81,grex | modregrm(3,4,DX),m);      // AND DX,m
+                        gen2(cg,0x03,grex | modregrm(3,AX,DX));        // ADD AX,DX
                         // Be careful not to generate this for 8088
                         assert(config.target_cpu >= TARGET_80286);
-                        genc2(cg,0xC1,modregrm(3,7,AX),pow2);   // SAR AX,pow2
+                        genc2(cg,0xC1,grex | modregrm(3,7,AX),pow2);   // SAR AX,pow2
                         resreg = AX;
                     }
                     else // OPmodass
-                    {   gen2(cg,0x33,modregrm(3,AX,DX));        // XOR AX,DX
-                        gen2(cg,0x2B,modregrm(3,AX,DX));        // SUB AX,DX
-                        genc2(cg,0x81,modregrm(3,4,AX),m);      // AND AX,m
-                        gen2(cg,0x33,modregrm(3,AX,DX));        // XOR AX,DX
-                        gen2(cg,0x2B,modregrm(3,AX,DX));        // SUB AX,DX
+                    {   gen2(cg,0x33,grex | modregrm(3,AX,DX));        // XOR AX,DX
+                        gen2(cg,0x2B,grex | modregrm(3,AX,DX));        // SUB AX,DX
+                        genc2(cg,0x81,grex | modregrm(3,4,AX),m);      // AND AX,m
+                        gen2(cg,0x33,grex | modregrm(3,AX,DX));        // XOR AX,DX
+                        gen2(cg,0x2B,grex | modregrm(3,AX,DX));        // SUB AX,DX
                         resreg = AX;
                     }
                 }
@@ -1264,9 +1330,12 @@
                 if (uns)                        // if unsigned
                     movregconst(c,DX,0,0);      // CLR DX
                 else                            // else signed
-                    gen1(c,0x99);               // CWD
+                {   gen1(c,0x99);               // CWD
+                    code_orrex(c,rex);
+                }
                 c = cat(c,getregs(mDX | mAX));  // DX and AX will be destroyed
                 genregs(c,0xF7,opr,reg);        // OPR reg
+                code_orrex(c,rex);
             }
         }
         cs.Iop = 0x89 ^ byte;
@@ -1314,7 +1383,7 @@
              retregs = mDX | mAX;
         }
         else
-            c = callclib(e,lib,&retregs,idxregm(cs.Irm,cs.Isib));
+            c = callclib(e,lib,&retregs,idxregm(&cs));
         reg = (op == OPmodass) ? BX : AX;
         retregs = mask[reg];
         cs.Iop = 0x89;
@@ -1338,6 +1407,7 @@
   }
 }
 
+
 /********************************
  * Generate code for <<= and >>=
  */
@@ -1362,6 +1432,9 @@
   oper = e->Eoper;
   assert(tysize(e2->Ety) <= REGSIZE);
 
+    unsigned rex = (I64 && sz == 8) ? REX_W : 0;
+    unsigned grex = rex << 16;          // 64 bit operands
+
   // if our lvalue is a cse, make sure we evaluate for result in register
   if (e1->Ecount && !(*pretregs & (ALLREGS | mBP)) && !isregvar(e1,&retregs,&reg))
         *pretregs |= ALLREGS;
@@ -1416,7 +1489,7 @@
   else
         freenode(e2);
   cl = getlvalue(&cs,e1,mCX);           /* get lvalue, preserve CX      */
-  cl = cat(cl,modEA(cs.Irm));           /* check for modifying register */
+  cl = cat(cl,modEA(&cs));              // check for modifying register
 
   if (*pretregs == 0 ||                 /* if don't return result       */
       (*pretregs == mPSW && conste2 && tysize[tym] <= REGSIZE) ||
@@ -1491,7 +1564,7 @@
                     cg = cat(cg,tstresult(retregs,tyml,TRUE));
             }
             else        /* flags only   */
-            {   retregs = ALLREGS & ~idxregm(cs.Irm,cs.Isib);
+            {   retregs = ALLREGS & ~idxregm(&cs);
                 ce = allocreg(&retregs,&reg,TYint);
                 cs.Iop = 0x8B;
                 NEWREG(cs.Irm,reg);
@@ -1505,13 +1578,11 @@
         }
         cg = CNIL;
   }
-
   else                                  /* else must evaluate in register */
   {
         if (sz <= REGSIZE)
-        {   regm_t possregs;
-
-            possregs = ALLREGS & ~mCX & ~idxregm(cs.Irm,cs.Isib);
+        {
+            regm_t possregs = ALLREGS & ~mCX & ~idxregm(&cs);
             if (byte)
                     possregs &= BYTEREGS;
             retregs = *pretregs & possregs;
@@ -1519,12 +1590,13 @@
                     retregs = possregs;
             cg = allocreg(&retregs,&reg,tym);
             cs.Iop = 0x8B ^ byte;
-            cs.Irm |= modregrm(0,reg,0);
+            code_newreg(&cs, reg);
             c = ce = gen(CNIL,&cs);                     /* MOV reg,EA   */
-            if (I32)
+            if (!I16)
             {
                 assert(!byte || (mask[reg] & BYTEREGS));
-                ce = genc2(CNIL,v ^ byte,modregrm(3,op1,reg),shiftcnt);
+                ce = genc2(CNIL,v ^ byte,modregrmx(3,op1,reg),shiftcnt);
+                code_orrex(ce, rex);
                 /* We can do a 32 bit shift on a 16 bit operand if      */
                 /* it's a left shift and we're not concerned about      */
                 /* the flags. Remember that flags are not set if        */
@@ -1565,6 +1637,7 @@
   return cat4(cr,cl,cg,c);
 }
 
+
 /**********************************
  * Generate code for compares.
  * Handles lt,gt,le,ge,eqeq,ne for all data types.
@@ -1608,6 +1681,10 @@
   tym = tybasic(e1->Ety);
   sz = tysize[tym];
   byte = sz == 1;
+
+    unsigned rex = (I64 && sz == 8) ? REX_W : 0;
+    unsigned grex = rex << 16;          // 64 bit operands
+
 #if TARGET_LINUX || TARGET_OSX || TARGET_FREEBSD || TARGET_SOLARIS
   if (tyfloating(tym))                  /* if floating operation        */
   {
@@ -1658,7 +1735,7 @@
   /* routine, because we don't know the target of the signed branch     */
   /* (have to set up flags so that jmpopcode() will do it right)        */
   if (!eqorne &&
-        (!I32 && tym == TYlong  && tybasic(e2->Ety) == TYlong ||
+        (I16 && tym == TYlong  && tybasic(e2->Ety) == TYlong ||
           I32 && tym == TYllong && tybasic(e2->Ety) == TYllong)
      )
   {     retregs = mDX | mAX;
@@ -1683,8 +1760,8 @@
 
   c = CNIL;
   ce = CNIL;
-  cs.Iflags = (I32 && sz == SHORTSIZE) ? CFopsize : 0;
-  cs.Ijty = 0;
+  cs.Iflags = (!I16 && sz == SHORTSIZE) ? CFopsize : 0;
+  cs.Irex = rex;
   if (sz > REGSIZE)
         ce = gennop(ce);
 
@@ -1702,7 +1779,8 @@
         {   reg = findreg(retregs);             /* get reg that e1 is in */
             rreg = findreg(rretregs);
             c = genregs(CNIL,0x3B ^ byte ^ reverse,reg,rreg);
-            if (I32 && sz == SHORTSIZE)
+            code_orrex(c, rex);
+            if (!I16 && sz == SHORTSIZE)
                 c->Iflags |= CFopsize;          /* compare only 16 bits */
         }
         else
@@ -1712,7 +1790,7 @@
             reg = findregmsw(retregs);
             rreg = findregmsw(rretregs);
             c = genregs(CNIL,0x3B ^ reverse,reg,rreg);  /* CMP reg,rreg */
-            if (I32 && sz == 6)
+            if (!I16 && sz == 6)
                 c->Iflags |= CFopsize;          /* seg is only 16 bits  */
             genjmp(c,JNE,FLcode,(block *) ce);          /* JNE nop      */
 
@@ -1759,13 +1837,15 @@
         {   // Just do a TEST instruction
             c = genregs(NULL,0x85 ^ byte,reg,reg);      // TEST reg,reg
             c->Iflags |= (cs.Iflags & CFopsize) | CFpsw;
+            code_orrex(c, rex);
             retregs = mPSW;
             break;
         }
 
         if (!tyuns(tym) && !tyuns(e2->Ety) &&
-            !boolres(e2) && !(*pretregs & mPSW) && sz == REGSIZE &&
-            (I32 || op == OPlt || op == OPge))
+            !boolres(e2) && !(*pretregs & mPSW) &&
+            (sz == REGSIZE || (I64 && sz == 4)) &&
+            (!I16 || op == OPlt || op == OPge))
         {   unsigned regi;
 
             assert(*pretregs & (allregs));
@@ -1774,22 +1854,22 @@
             c = getregs(mask[reg]);
             switch (op)
             {   case OPle:
-                    c = genc2(c,0x81,modregrm(3,0,reg),(unsigned)-1);   /* ADD reg,-1   */
-                    genc2(c,0x81,modregrm(3,2,reg),0);          /* ADC reg,0    */
+                    c = genc2(c,0x81,grex | modregrmx(3,0,reg & 7),(unsigned)-1);   // ADD reg,-1
+                    genc2(c,0x81,grex | modregrmx(3,2,reg & 7),0);          // ADC reg,0
                     goto oplt;
                 case OPgt:
-                    c = gen2(c,0xF7,modregrm(3,3,reg));         // NEG reg
+                    c = gen2(c,0xF7,grex | modregrmx(3,3,reg & 7));         // NEG reg
 #if TARGET_WINDOS
                     // What does the Windows platform do?
                     //  lower INT_MIN by 1?   See test exe9.c
                     // BUG: fix later
-                    genc2(c,0x81,modregrm(3,3,reg),0);  // SBB reg,0
+                    genc2(c,0x81,grex | modregrmx(3,3,reg & 7),0);  // SBB reg,0
 #endif
                     goto oplt;
                 case OPlt:
                 oplt:
-                    if (I32)
-                        c = genc2(c,0xC1,modregrm(3,5,reg),31); /* SHR reg,31   */
+                    if (!I16)
+                        c = genc2(c,0xC1,grex | modregrmx(3,5,reg & 7),sz * 8 - 1); // SHR reg,31
                     else
                     {   /* 8088-286 do not have a barrel shifter, so use this
                            faster sequence
@@ -1803,9 +1883,18 @@
                     break;
                 case OPge:
                     c = genregs(c,0xD1,4,reg);          /* SHL reg,1    */
+                    code_orrex(c,rex);
                     genregs(c,0x19,reg,reg);            /* SBB reg,reg  */
-                    gen1(c,0x40 + reg);                 /* INC reg      */
+                    code_orrex(c,rex);
+                    if (I64)
+                    {
+                        c = gen2(c,0xFF,modregrmx(3,0,reg));    // INC reg
+                        code_orrex(c, rex);
+                    }
+                    else
+                        c = gen1(c,0x40 + reg);                 // INC reg
                     break;
+
                 default:
                     assert(0);
             }
@@ -1832,7 +1921,7 @@
                 freenode(e1);
                 if (evalinregister(e2))
                 {
-                    retregs = idxregm(cs.Irm,cs.Isib);
+                    retregs = idxregm(&cs);
                     if ((cs.Iflags & CFSEG) == CFes)
                             retregs |= mES;             /* take no chances */
                     rretregs = allregs & ~retregs;
@@ -1856,7 +1945,7 @@
                     else
                     {
                         rreg = findreg(rretregs);
-                        cs.Irm |= modregrm(0,rreg,0);
+                        code_newreg(&cs, rreg);
                     }
                 }
                 else
@@ -1874,7 +1963,7 @@
                         }
                         getlvalue_msw(&cs);
                         c = gen(CNIL,&cs);              /* CMP EA+2,const */
-                        if (I32 && sz == 6)
+                        if (!I16 && sz == 6)
                             c->Iflags |= CFopsize;      /* seg is only 16 bits  */
                         genjmp(c,JNE,FLcode,(block *) ce); /* JNE nop   */
                         if (e2->Eoper == OPconst)
@@ -1921,25 +2010,31 @@
         if (sz == 1)
         {
             reg = findreg(retregs & allregs);   // get reg that e1 is in
-            cs.Irm = modregrm(3,7,reg);
+            cs.Irm = modregrm(3,7,reg & 7);
+            if (reg & 8)
+                cs.Irex |= REX_B;
             if (e1->Eoper == OPvar && e1->EV.sp.Voffset == 1 && e1->EV.sp.Vsym->Sfl == FLreg)
+            {   assert(reg < 4);
                 cs.Irm |= 4;                    // use upper register half
         }
+        }
         else if (sz <= REGSIZE)
         {                                       /* CMP reg,const        */
             reg = findreg(retregs & allregs);   // get reg that e1 is in
             rretregs = allregs & ~retregs;
             if (cs.IFL2 == FLconst && reghasvalue(rretregs,cs.IEV2.Vint,&rreg))
-            {   code *cc;
-
-                cc = genregs(CNIL,0x3B,reg,rreg);
-                if (I32)
+            {
+                code *cc = genregs(CNIL,0x3B,reg,rreg);
+                code_orrex(cc, rex);
+                if (!I16)
                     cc->Iflags |= cs.Iflags & CFopsize;
                 c = cat(c,cc);
                 freenode(e2);
                 break;
             }
-            cs.Irm = modregrm(3,7,reg);
+            cs.Irm = modregrm(3,7,reg & 7);
+            if (reg & 8)
+                cs.Irex |= REX_B;
         }
         else if (sz <= 2 * REGSIZE)
         {
@@ -1987,7 +2082,7 @@
             cl = getlvalue(&cs,e1,RMload);
             freenode(e1);
             cs.Iop = 0x39 ^ byte ^ reverse;
-            cs.Irm |= modregrm(0,reg,0);
+            code_newreg(&cs,reg);
             c = gen(c,&cs);
             freenode(e2);
             break;
@@ -1995,10 +2090,9 @@
       L5:
         cl = scodelem(e1,&retregs,0,TRUE);      /* compute left leaf    */
         if (sz <= REGSIZE)                      /* CMP reg,EA           */
-        {   unsigned opsize;
-
+        {
             reg = findreg(retregs & allregs);   // get reg that e1 is in
-            opsize = cs.Iflags & CFopsize;
+            unsigned opsize = cs.Iflags & CFopsize;
             c = cat(c,loadea(e2,&cs,0x3B ^ byte ^ reverse,reg,0,RMload | retregs,0));
             code_orflag(c,opsize);
         }
@@ -2028,12 +2122,9 @@
   c = cat(c,ce);
 
 L3:
-  if ((retregs = (*pretregs & (ALLREGS | mBP))) != 0) /* if return result in register*/
-  {     code *nop;
-        regm_t save;
-
-        nop = CNIL;
-        save = regcon.immed.mval;
+  if ((retregs = (*pretregs & (ALLREGS | mBP))) != 0) // if return result in register
+  {     code *nop = CNIL;
+        regm_t save = regcon.immed.mval;
         cg = allocreg(&retregs,&reg,TYint);
         regcon.immed.mval = save;
         if ((*pretregs & mPSW) == 0 &&
@@ -2041,12 +2132,34 @@
         {
             cg = cat(cg,getregs(retregs));
             cg = genregs(cg,0x19,reg,reg);              /* SBB reg,reg  */
+            if (rex)
+                code_orrex(cg, rex);
             if (flag)
                 ;                                       // cdcond() will handle it
             else if (jop == JNC)
-                gen1(cg,0x40 + reg);                    /* INC reg      */
+            {
+                if (I64)
+                {
+                    cg = gen2(cg,0xFF,modregrmx(3,0,reg));      // INC reg
+                    code_orrex(cg, rex);
+                }
             else
-                gen2(cg,0xF7,modregrm(3,3,reg));        /* NEG reg      */
+                    gen1(cg,0x40 + reg);                 // INC reg
+            }
+            else
+            {   gen2(cg,0xF7,modregrmx(3,3,reg));        /* NEG reg      */
+                code_orrex(cg, rex);
+            }
+        }
+        else if (I64 && sz == 8)
+        {
+            assert(!flag);
+            cg = movregconst(cg,reg,1,64|8);               // MOV reg,1
+            nop = gennop(nop);
+            cg = genjmp(cg,jop,FLcode,(block *) nop);   // Jtrue nop
+                                                        // MOV reg,0
+            movregconst(cg,reg,0,(*pretregs & mPSW) ? 64|8 : 64);
+            regcon.immed.mval &= ~mask[reg];
         }
         else
         {
@@ -2065,6 +2178,7 @@
   return cat3(cl,cr,c);
 }
 
+
 /**********************************
  * Generate code for signed compare of longs.
  * Input:
@@ -2094,7 +2208,7 @@
   }
 
   cs.Iflags = 0;
-  cs.Ijty = 0;
+  cs.Irex = 0;
 
   ce = gennop(CNIL);
   retregs = ALLREGS;
@@ -2131,7 +2245,7 @@
                 freenode(e1);
                 if (evalinregister(e2))
                 {
-                        retregs = idxregm(cs.Irm,cs.Isib);
+                        retregs = idxregm(&cs);
                         if ((cs.Iflags & CFSEG) == CFes)
                                 retregs |= mES;         /* take no chances */
                         rretregs = ALLREGS & ~retregs;
@@ -2290,12 +2404,11 @@
             case OPu16_d:
                 return load87(e,0,pretregs,NULL,-1);
             case OPu32_d:
-                if (I32)
-                {   unsigned reg;
-
-                    retregs = ALLREGS;
+                if (!I16)
+                {
+                    unsigned retregs = ALLREGS;
                     c1 = codelem(e->E1, &retregs, FALSE);
-                    reg = findreg(retregs);
+                    unsigned reg = findreg(retregs);
                     c1 = genfltreg(c1, 0x89, reg, 0);
                     regwithvalue(c1,ALLREGS,0,&reg,0);
                     genfltreg(c1, 0x89, reg, REGSIZE);
@@ -2353,9 +2466,10 @@
   return cat(c1,c2);
 }
 
+
 /***************************
  * Convert short to long.
- * For OPshtlng, OPu16_32, OPptrlptr, OPulngllng, OPlngllng
+ * For OPs16_32, OPu16_32, OPptrlptr, OPu32_64, OPs32_64
  */
 
 code *cdshtlng(elem *e,regm_t *pretregs)
@@ -2370,8 +2484,8 @@
     c = codelem(e->E1,pretregs,FALSE);  /* then conversion isn't necessary */
 
   else if ((op = e->Eoper) == OPptrlptr ||
-           (!I32 && op == OPu16_32) ||
-           ( I32 && op == OPulngllng)
+           (I16 && op == OPu16_32) ||
+           (I32 && op == OPu32_64)
           )
   {
         regm_t regm;
@@ -2406,13 +2520,11 @@
 
         c = cat3(c,ce,fixresult(e,retregs | regm,pretregs));
   }
-  else if (I32 && (op == OPshtlng || op == OPu16_32))
+  else if (!I16 && (op == OPs16_32 || op == OPu16_32))
   {
-    /* OPshtlng || OPu16_32 */
-    elem *e1;
     elem *e11;
 
-    e1 = e->E1;
+    elem *e1 = e->E1;
 
     if (e1->Eoper == OPu8_16 && !e1->Ecount &&
         ((e11 = e1->E1)->Eoper == OPvar || (e11->Eoper == OPind && !e11->Ecount))
@@ -2462,7 +2574,7 @@
                 goto L1;
             }
         }
-        if (op == OPshtlng && retregs == mAX)
+        if (op == OPs16_32 && retregs == mAX)
             c2 = gen1(c2,0x98);         /* CWDE                         */
         else
         {
@@ -2473,8 +2585,8 @@
             }
             else
             {
-                c3 = genregs(CNIL,0x0F,reg,reg);
-                c3->Iop2 = (op == OPu16_32) ? 0xB7 : 0xBF; /* MOVZX/MOVSX reg,reg */
+                unsigned iop = (op == OPu16_32) ? 0x0FB7 : 0x0FBF; /* MOVZX/MOVSX reg,reg */
+                c3 = genregs(CNIL,iop,reg,reg);
             }
             c2 = cat(c2,c3);
         }
@@ -2486,7 +2598,7 @@
   }
   else if (*pretregs & mPSW || config.target_cpu < TARGET_80286)
   {
-    // OPshtlng, OPlngllng
+    // OPs16_32, OPs32_64
     // CWD doesn't affect flags, so we can depend on the integer
     // math to provide the flags.
     retregs = mAX | mPSW;               // want integer result in AX
@@ -2500,7 +2612,7 @@
   }
   else
   {
-    // OPshtlng, OPlngllng
+    // OPs16_32, OPs32_64
     unsigned msreg,lsreg;
 
     retregs = *pretregs & mLSW;
@@ -2519,6 +2631,7 @@
   return c;
 }
 
+
 /***************************
  * Convert byte to int.
  * For OPu8int and OPs8int.
@@ -2541,7 +2654,7 @@
     c0 = NULL;
     if (e1->Eoper == OPcomma)
         c0 = docommas(&e1);
-    if (I32)
+    if (!I16)
     {
         if (e1->Eoper == OPvar || (e1->Eoper == OPind && !e1->Ecount))
         {   code cs;
@@ -2598,7 +2711,7 @@
         ;                               /* find previous instruction    */
 
     /* If previous instruction is an AND bytereg,value  */
-    if (c->Iop == 0x80 && c->Irm == modregrm(3,4,reg) &&
+    if (c->Iop == 0x80 && c->Irm == modregrm(3,4,reg & 7) &&
         (op == OPu8int || (c->IEV2.Vuns & 0x80) == 0))
     {
         if (*pretregs & mPSW)
@@ -2610,7 +2723,7 @@
     else
     {
      L1:
-        if (I32)
+        if (!I16)
         {
             if (op == OPs8int && reg == AX && size == 2)
             {   c3 = gen1(c3,0x98);             /* CBW                  */
@@ -2626,8 +2739,9 @@
                     c3 = genc2(c3,0x81,modregrm(3,4,reg),0xFF);
                 }
                 else
-                {   c3 = genregs(c3,0x0F,reg,reg);
-                    c3->Iop2 = (op == OPu8int) ? 0xB6 : 0xBE; /* MOVZX/MOVSX reg,reg */
+                {
+                    unsigned iop = (op == OPu8int) ? 0x0FB6 : 0x0FBE; // MOVZX/MOVSX reg,reg
+                    c3 = genregs(c3,iop,reg,reg);
                 }
             }
         }
@@ -2648,10 +2762,11 @@
     return cat6(c0,c1,c2,c3,c4,NULL);
 }
 
+
 /***************************
- * Convert long to short (OPlngsht).
+ * Convert long to short (OP32_16).
  * Get offset of far pointer (OPoffset).
- * Convert int to byte (OPint8).
+ * Convert int to byte (OP16_8).
  * Convert long long to long (OP64_32).
  */
 
@@ -2662,9 +2777,9 @@
 #ifdef DEBUG
     switch (e->Eoper)
     {
-        case OPlngsht:
+        case OP32_16:
         case OPoffset:
-        case OPint8:
+        case OP16_8:
         case OP64_32:
             break;
 
@@ -2673,7 +2788,7 @@
     }
 #endif
 
-  if (e->Eoper == OPint8)
+  if (e->Eoper == OP16_8)
   {     retregs = *pretregs ? BYTEREGS : 0;
         c = codelem(e->E1,&retregs,FALSE);
   }
@@ -2683,7 +2798,7 @@
         else
         {   retregs = *pretregs ? ALLREGS : 0;
             c = codelem(e->E1,&retregs,FALSE);
-            if (!I32 || e->Eoper == OPoffset || e->Eoper == OP64_32)
+            if (I16 || I32 && (e->Eoper == OPoffset || e->Eoper == OP64_32))
                 retregs &= mLSW;                /* want LSW only        */
         }
   }
@@ -2806,7 +2921,7 @@
     c = getregs(ALLREGS | mES);
 #endif
     c = genasm(c,e->EV.ss.Vstring,e->EV.ss.Vstrlen);
-    return cat(c,fixresult(e,(I32 ? mAX : mDX | mAX),pretregs));
+    return cat(c,fixresult(e,(I16 ? mDX | mAX : mAX),pretregs));
 }
 
 /************************
@@ -2829,7 +2944,7 @@
     cs.Iop = 0xC1;
     cs.Irm = modregrm(3,0,reg);
     cs.Iflags = 0;
-    cs.Ijty = 0;
+    cs.Irex = 0;
     cs.IFL2 = FLconst;
     cs.IEV2.Vuns = 16;
 
@@ -2928,14 +3043,13 @@
         return cat(c, codelem(e2,pretregs,FALSE));
 
     ty1 = tybasic(e1->Ety);
-    word = (I32 && tysize[ty1] == SHORTSIZE) ? CFopsize : 0;
-    idxregs = idxregm(cs.Irm, cs.Isib);         // mask if index regs used
+    word = (!I16 && tysize[ty1] == SHORTSIZE) ? CFopsize : 0;
+    idxregs = idxregm(&cs);         // mask if index regs used
 
 //    if (e2->Eoper == OPconst && e2->EV.Vuns < 0x100)  // should do this instead?
     if (e2->Eoper == OPconst)
     {
-        cs.Iop = 0x0F;
-        cs.Iop2 = 0xBA;                         // BT rm,imm8
+        cs.Iop = 0x0FBA;                         // BT rm,imm8
         cs.Irm |= modregrm(0,mode,0);
         cs.Iflags |= CFpsw | word;
         cs.IFL2 = FLconst;
@@ -2944,11 +3058,16 @@
             cs.IEVoffset1 += (e2->EV.Vuns & ~15) >> 3;
             cs.IEV2.Vint = e2->EV.Vint & 15;
         }
-        else
+        else if (tysize[ty1] == 4)
         {
             cs.IEVoffset1 += (e2->EV.Vuns & ~31) >> 3;
             cs.IEV2.Vint = e2->EV.Vint & 31;
         }
+        else
+        {
+            cs.IEVoffset1 += (e2->EV.Vuns & ~63) >> 3;
+            cs.IEV2.Vint = e2->EV.Vint & 63;
+        }
         c2 = gen(CNIL,&cs);
     }
     else
@@ -2957,21 +3076,17 @@
         c2 = scodelem(e2,&retregs,idxregs,TRUE);
         reg = findreg(retregs);
 
-        cs.Iop = 0x0F;
-        cs.Iop2 = op;                           // BT rm,reg
-        cs.Irm |= modregrm(0,reg,0);
+        cs.Iop = 0x0F00 | op;                     // BT rm,reg
+        code_newreg(&cs,reg);
         cs.Iflags |= CFpsw | word;
         c2 = gen(c2,&cs);
     }
 
     if ((retregs = (*pretregs & (ALLREGS | mBP))) != 0) // if return result in register
-    {   code *nop;
-        regm_t save;
-        code *cg;
-
-        nop = CNIL;
-        save = regcon.immed.mval;
-        cg = allocreg(&retregs,&reg,TYint);
+    {
+        code *nop = CNIL;
+        regm_t save = regcon.immed.mval;
+        code *cg = allocreg(&retregs,&reg,TYint);
         regcon.immed.mval = save;
         if ((*pretregs & mPSW) == 0)
         {
@@ -3024,8 +3139,11 @@
         retregs = allregs;
         cl = codelem(e->E1, &retregs, FALSE);
         reg = findreg(retregs);
-        cs.Irm = modregrm(3,0,reg);
+        cs.Irm = modregrm(3,0,reg & 7);
         cs.Iflags = 0;
+        cs.Irex = 0;
+        if (reg & 8)
+            cs.Irex |= REX_B;
     }
 
     retregs = *pretregs & allregs;
@@ -3033,10 +3151,9 @@
         retregs = allregs;
     cg = allocreg(&retregs, &reg, e->Ety);
 
-    cs.Iop = 0x0F;
-    cs.Iop2 = (e->Eoper == OPbsf) ? 0xBC : 0xBD;        // BSF/BSR reg,EA
-    cs.Irm |= modregrm(0,reg,0);
-    if (I32 && sz == SHORTSIZE)
+    cs.Iop = (e->Eoper == OPbsf) ? 0x0FBC : 0x0FBD;        // BSF/BSR reg,EA
+    code_newreg(&cs, reg);
+    if (!I16 && sz == SHORTSIZE)
         cs.Iflags |= CFopsize;
     cg = gen(cg,&cs);
 
diff -aruw dmd62/backend/code.c dmd63/backend/code.c
--- dmd62/backend/code.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/code.c	2010-08-09 14:33:14.000000000 -0400
@@ -29,7 +29,7 @@
 
 __declspec(naked) code *code_calloc()
 {
-    if (sizeof(code) != 0x20)
+    if (sizeof(code) != 0x24)
         util_assert("code",__LINE__);
     __asm
     {
@@ -57,6 +57,7 @@
         mov     24[EAX],ECX
 
         mov     28[EAX],ECX
+        mov     32[EAX],ECX
         ret
     }
 }
@@ -67,6 +68,7 @@
 {   code *c;
     static code czero;
 
+    //printf("code %x\n", sizeof(code));
     c = code_list;
     if (c)
         code_list = code_next(c);
diff -aruw dmd62/backend/code.h dmd63/backend/code.h
--- dmd62/backend/code.h	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/code.h	2010-08-09 14:33:14.000000000 -0400
@@ -1,5 +1,5 @@
 // Copyright (C) 1985-1996 by Symantec
-// Copyright (C) 2000-2009 by Digital Mars
+// Copyright (C) 2000-2010 by Digital Mars
 // All Rights Reserved
 // http://www.digitalmars.com
 // Written by Walter Bright
@@ -32,15 +32,34 @@
 #define SI      6
 #define DI      7
 
-#define ES      9
-#define PSW     10
-#define STACK   11      // top of stack
-#define MEM     12      // memory
-#define OTHER   13      // other things
-#define ST0     14      // 8087 top of stack register
-#define ST01    15      // top two 8087 registers; for complex types
+#define R8      8
+#define R9      9
+#define R10     10
+#define R11     11
+#define R12     12
+#define R13     13
+#define R14     14
+#define R15     15
+
+#define XMM0    16
+#define XMM1    17
+#define XMM2    18
+#define XMM3    19
+#define XMM4    20
+#define XMM5    21
+#define XMM6    22
+#define XMM7    23
+/* There are also XMM8..XMM14 */
+#define XMM15   31
+
+
+#define ES      24
+#define PSW     25
+#define STACK   26      // top of stack
+#define ST0     27      // 8087 top of stack register
+#define ST01    28      // top two 8087 registers; for complex types
 
-#define NOREG   100     // no register
+#define NOREG   29     // no register
 
 #define AL      0
 #define CL      1
@@ -59,19 +78,37 @@
 #define mBP     0x20
 #define mSI     0x40
 #define mDI     0x80
-#define mES     (1 << ES)       // 0x200
-#define mPSW    (1 << PSW)      // 0x400
 
-#define mSTACK  (1 << STACK)    // 0x800
-#define mMEM    (1 << MEM)      // 0x1000
-#define mOTHER  (1 << OTHER)    // 0x2000
+#define mR8     (1 << R8)
+#define mR9     (1 << R9)
+#define mR10    (1 << R10)
+#define mR11    (1 << R11)
+#define mR12    (1 << R12)
+#define mR13    (1 << R13)
+#define mR14    (1 << R14)
+#define mR15    (1 << R15)
+
+#define mXMM0   (1 << XMM0)
+#define mXMM1   (1 << XMM1)
+#define mXMM2   (1 << XMM2)
+#define mXMM3   (1 << XMM3)
+#define mXMM4   (1 << XMM4)
+#define mXMM5   (1 << XMM5)
+#define mXMM6   (1 << XMM6)
+#define mXMM7   (1 << XMM7)
+#define XMMREGS  (mXMM0 |mXMM1 |mXMM2 |mXMM3 |mXMM4 |mXMM5 |mXMM6 |mXMM7)
 
-#define mST0    (1 << ST0)      // 0x4000
-#define mST01   (1 << ST01)     // 0x8000
+#define mES     (1 << ES)       // 0x10000
+#define mPSW    (1 << PSW)      // 0x20000
+
+#define mSTACK  (1 << STACK)    // 0x40000
+
+#define mST0    (1 << ST0)      // 0x200000
+#define mST01   (1 << ST01)     // 0x400000
 
 // Flags for getlvalue (must fit in regm_t)
-#define RMload  0x4000
-#define RMstore 0x8000
+#define RMload  (1 << 30)
+#define RMstore (1 << 31)
 
 #if TARGET_LINUX || TARGET_OSX || TARGET_FREEBSD || TARGET_SOLARIS
     // To support positional independent code,
@@ -94,6 +131,11 @@
  */
 #define IDXREGS         (mBX|mSI|mDI)
 
+#define FLOATREGS_64    mAX
+#define FLOATREGS2_64   mDX
+#define DOUBLEREGS_64   mAX
+#define DOUBLEREGS2_64  mDX
+
 #define FLOATREGS_32    mAX
 #define FLOATREGS2_32   mDX
 #define DOUBLEREGS_32   (mAX|mDX)
@@ -126,7 +168,7 @@
 #define mLSW    (mAX|mBX|mSI|mDI)       /* least significant regs       */
 #endif
 
-/* Return !=0 if there is an SIB byte   */
+/* Return !=0 if there is a SIB byte   */
 #define issib(rm)       (((rm) & 7) == 4 && ((rm) & 0xC0) != 0xC0)
 
 #if 0
@@ -140,7 +182,7 @@
 //
 // Note: even for linux targets, CFaddrsize can be set by the inline
 // assembler.
-#define is32bitaddr(x,Iflags) ((x) ^(((Iflags) & CFaddrsize) !=0))
+#define is32bitaddr(x,Iflags) (I64 || ((x) ^(((Iflags) & CFaddrsize) !=0)))
 #endif
 
 /*******************
@@ -189,30 +231,46 @@
                         // (Iop2 is the type of special information)
                         // (Same as DS:, but we will never generate
                         // a separate DS: opcode anyway)
-    #define ESClinnum   1       // line number information
-    #define ESCctor     2       // object is constructed
-    #define ESCdtor     3       // object is destructed
-    #define ESCmark     4       // mark eh stack
-    #define ESCrelease  5       // release eh stack
-    #define ESCoffset   6       // set code offset for eh
-    #define ESCadjesp   7       // adjust ESP by IEV2.Vint
-    #define ESCmark2    8       // mark eh stack
-    #define ESCrelease2 9       // release eh stack
-    #define ESCframeptr 10      // replace with load of frame pointer
+    #define ESClinnum   (1 << 8)       // line number information
+    #define ESCctor     (2 << 8)       // object is constructed
+    #define ESCdtor     (3 << 8)       // object is destructed
+    #define ESCmark     (4 << 8)       // mark eh stack
+    #define ESCrelease  (5 << 8)       // release eh stack
+    #define ESCoffset   (6 << 8)       // set code offset for eh
+    #define ESCadjesp   (7 << 8)       // adjust ESP by IEV2.Vint
+    #define ESCmark2    (8 << 8)       // mark eh stack
+    #define ESCrelease2 (9 << 8)       // release eh stack
+    #define ESCframeptr (10 << 8)      // replace with load of frame pointer
 
 #define ASM     0x36    // string of asm bytes, actually an SS: opcode
 
 /*********************************
  * Macros to ease generating code
  * modregrm:    generate mod reg r/m field
+ * modregxrm:   reg could be R8..R15
+ * modregrmx:   rm could be R8..R15
+ * modregxrmx:  reg or rm could be R8..R15
  * NEWREG:      change reg field of x to r
  * genorreg:    OR  t,f
  */
 
-#define modregrm(m,r,rm)        (((m)<<6)+((r)<<3)+(rm))
+#define modregrm(m,r,rm)        (((m)<<6)|((r)<<3)|(rm))
+#define modregxrm(m,r,rm)       ((((r)&8)<<15)|modregrm((m),(r)&7,rm))
+#define modregrmx(m,r,rm)       ((((rm)&8)<<13)|modregrm((m),r,(rm)&7))
+#define modregxrmx(m,r,rm)      ((((r)&8)<<15)|(((rm)&8)<<13)|modregrm((m),(r)&7,(rm)&7))
+
+#define NEWREXR(x,r)            ((x)=((x)&~REX_R)|(((r)&8)>>1))
 #define NEWREG(x,r)             ((x)=((x)&~(7<<3))|((r)<<3))
+#define code_newreg(c,r)        (NEWREG((c)->Irm,(r)&7),NEWREXR((c)->Irex,(r)))
+
 #define genorreg(c,t,f)         genregs((c),0x09,(f),(t))
 
+#define REX     0x40            // REX prefix byte, OR'd with the following bits:
+#define REX_W   8               // 0 = default operand size, 1 = 64 bit operand size
+#define REX_R   4               // high bit of reg field of modregrm
+#define REX_X   2               // high bit of sib index reg
+#define REX_B   1               // high bit of rm field, sib base reg, or opcode reg
+
 /**********************
  * C library routines.
  * See callclib().
@@ -274,6 +332,7 @@
     targ_int    Vint;           // also used for tmp numbers (FLtmp)
     targ_uns    Vuns;
     targ_long   Vlong;
+    targ_size_t Vsize_t;
     struct
     {   targ_size_t Vpointer;
         int Vseg;               // segment the pointer is in
@@ -301,7 +360,7 @@
     } lab;
 #endif
     struct
-    {   unsigned len;
+    {   size_t len;
         char *bytes;
     } as;                       // asm node (FLasm)
 };
@@ -331,19 +390,29 @@
 #define CFtarg2      0x8000     // like CFtarg, but we can't optimize this away
 #define CFvolatile  0x10000     // volatile reference, do not schedule
 #define CFclassinit 0x20000     // class init code
+#define CFoffset64  0x40000     // offset is 64 bits
+#define CFpc32      0x80000     // I64: PC relative 32 bit fixup
 
 #define CFPREFIX (CFSEG | CFopsize | CFaddrsize)
 #define CFSEG   (CFes | CFss | CFds | CFcs | CFfs | CFgs)
 
-    unsigned char Ijty;         // type of operand, 0 if unknown
-
-    unsigned char Iop;
-    unsigned char Irm;          // reg/mode
 
-    unsigned char Iop2;         // second opcode byte
-    unsigned char Isib;         // SIB byte
+    unsigned Iop;
 
-    unsigned char Iop3;         // third opcode byte
+    union
+    {   unsigned _Iea;
+        struct
+        {
+            unsigned char _Irm;          // reg/mode
+            unsigned char _Isib;         // SIB byte
+            unsigned char _Irex;         // REX prefix
+        } _ea;
+    } _EA;
+
+#define Iea _EA._Iea
+#define Irm _EA._ea._Irm
+#define Isib _EA._ea._Isib
+#define Irex _EA._ea._Irex
 
     unsigned char IFL1,IFL2;    // FLavors of 1st, 2nd operands
     union evc IEV1;             // 1st operand, if any
@@ -364,7 +433,20 @@
       #define IEVint2     IEV2.Vint
     void print();               // pretty-printer
 
-    code() { Ijty = 0; Isib = 0; }      // constructor
+    code() { Irex = 0; Isib = 0; }      // constructor
+
+    void orReg(unsigned reg)
+    {   if (reg & 8)
+            Irex |= REX_R;
+        Irm |= modregrm(0, reg & 7, 0);
+    }
+
+    void setReg(unsigned reg)
+    {
+        Irex &= ~REX_R;
+        Irm &= ~modregrm(0, 7, 0);
+        orReg(reg);
+    }
 };
 
 // !=0 if we have to add FWAIT to floating point ops
@@ -476,6 +558,7 @@
         Aoffset,Toffset,EEoffset;
 extern  int Aalign;
 extern  int cseg;
+extern  int STACKALIGN;
 #if TARGET_OSX
 extern  targ_size_t localgotoffset;
 #endif
@@ -529,6 +612,7 @@
 regm_t getscratch();
 code *codelem (elem *e , regm_t *pretregs , bool constflag );
 const char *regm_str(regm_t rm);
+int numbitsset(regm_t);
 
 /* cod1.c */
 extern int clib_inited;
@@ -542,13 +626,14 @@
 void gensaverestore(regm_t, code **, code **);
 code *genstackclean(code *c,unsigned numpara,regm_t keepmsk);
 code *logexp (elem *e , int jcond , unsigned fltarg , code *targ );
-code *loadea (elem *e , code __ss *cs , unsigned op , unsigned reg , targ_size_t offset , regm_t keepmsk , regm_t desmsk );
+code *loadea (elem *e , code *cs , unsigned op , unsigned reg , targ_size_t offset , regm_t keepmsk , regm_t desmsk );
 unsigned getaddrmode (regm_t idxregs );
+void setaddrmode(code *c, regm_t idxregs);
 void getlvalue_msw(code *);
 void getlvalue_lsw(code *);
-code *getlvalue (code __ss *pcs , elem *e , regm_t keepmsk );
+code *getlvalue (code *pcs , elem *e , regm_t keepmsk );
 code *scodelem (elem *e , regm_t *pretregs , regm_t keepmsk , bool constflag );
-code *fltregs (code __ss *pcs , tym_t tym );
+code *fltregs (code *pcs , tym_t tym );
 code *tstresult (regm_t regm , tym_t tym , unsigned saveflag );
 code *fixresult (elem *e , regm_t retregs , regm_t *pretregs );
 code *callclib (elem *e , unsigned clib , regm_t *pretregs , regm_t keepmask );
@@ -559,7 +644,7 @@
 code *loaddata (elem *e , regm_t *pretregs );
 
 /* cod2.c */
-regm_t idxregm (unsigned rm,unsigned sib);
+regm_t idxregm(code *c);
 #if TARGET_WINDOS
 code *opdouble (elem *e , regm_t *pretregs , unsigned clib );
 #endif
@@ -610,7 +695,7 @@
 void outjmptab (block *b );
 void outswitab (block *b );
 int jmpopcode (elem *e );
-void cod3_ptrchk(code * __ss *pc,code __ss *pcs,regm_t keepmsk);
+void cod3_ptrchk(code **pc,code *pcs,regm_t keepmsk);
 code *prolog (void );
 void epilog (block *b);
 cd_t cdframeptr;
@@ -627,9 +712,9 @@
 void pinholeopt (code *c , block *bn );
 void jmpaddr (code *c );
 int code_match(code *c1,code *c2);
-targ_size_t calcblksize (code *c);
-targ_size_t calccodsize(code *c);
-targ_size_t codout (code *c );
+unsigned calcblksize (code *c);
+unsigned calccodsize(code *c);
+unsigned codout (code *c );
 void addtofixlist (symbol *s , targ_size_t soffset , int seg , targ_size_t val , int flags );
 void searchfixlist (symbol *s );
 void outfixlist (void );
@@ -640,7 +725,7 @@
 extern  const unsigned dblreg[];
 extern int cdcmp_flag;
 
-code *modEA (unsigned Irm );
+code *modEA(code *c);
 cd_t cdeq;
 cd_t cdaddass;
 cd_t cdmulass;
@@ -724,6 +809,8 @@
 // cgen.c
 code *code_last(code *c);
 void code_orflag(code *c,unsigned flag);
+void code_orrex(code *c,unsigned rex);
+code *setOpcode(code *c, code *cs, unsigned op);
 code * __pascal cat (code *c1 , code *c2 );
 code * cat3 (code *c1 , code *c2 , code *c3 );
 code * cat4 (code *c1 , code *c2 , code *c3 , code *c4 );
@@ -733,15 +820,17 @@
 code *gen2 (code *c , unsigned op , unsigned rm );
 code *gen2sib(code *c,unsigned op,unsigned rm,unsigned sib);
 code *genregs (code *c , unsigned op , unsigned dstreg , unsigned srcreg );
+code *genpush (code *c , unsigned reg );
+code *genpop (code *c , unsigned reg );
 code *gentstreg (code *c , unsigned reg );
 code *genasm (code *c , char *s , unsigned slen );
 code *genmovreg (code *c , unsigned to , unsigned from );
 code *genjmp (code *c , unsigned op , unsigned fltarg , block *targ );
 code *gencsi (code *c , unsigned op , unsigned rm , unsigned FL2 , SYMIDX si );
 code *gencs (code *c , unsigned op , unsigned rm , unsigned FL2 , symbol *s );
-code *genc2 (code *c , unsigned op , unsigned rm , targ_uns EV2 );
-code *genc1 (code *c , unsigned op , unsigned rm , unsigned FL1 , targ_uns EV1 );
-code *genc (code *c , unsigned op , unsigned rm , unsigned FL1 , targ_uns EV1 , unsigned FL2 , targ_uns EV2 );
+code *genc2 (code *c , unsigned op , unsigned rm , targ_size_t EV2 );
+code *genc1 (code *c , unsigned op , unsigned rm , unsigned FL1 , targ_size_t EV1 );
+code *genc (code *c , unsigned op , unsigned rm , unsigned FL1 , targ_size_t EV1 , unsigned FL2 , targ_size_t EV2 );
 code *genmulimm(code *c,unsigned r1,unsigned r2,targ_int imm);
 code *genlinnum(code *,Srcpos);
 void cgen_linnum(code **pc,Srcpos srcpos);
@@ -749,9 +838,9 @@
 code *genadjesp(code *c, int offset);
 code *gennop(code *);
 code *genshift(code *);
-code *movregconst (code *c , unsigned reg , targ_int value , regm_t flags );
-bool reghasvalue (regm_t regm , targ_int value , unsigned *preg );
-code *regwithvalue (code *c , regm_t regm , targ_int value , unsigned *preg , regm_t flags );
+code *movregconst (code *c , unsigned reg , targ_size_t value , regm_t flags );
+bool reghasvalue (regm_t regm , targ_size_t value , unsigned *preg );
+code *regwithvalue (code *c , regm_t regm , targ_size_t value , unsigned *preg , regm_t flags );
 
 // cgreg.c
 void cgreg_init();
diff -aruw dmd62/backend/dt.c dmd63/backend/dt.c
--- dmd62/backend/dt.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/dt.c	2010-08-09 14:33:14.000000000 -0400
@@ -190,7 +190,7 @@
  * Construct a DTibytes record, and return it.
  */
 
-dt_t ** dtdword(dt_t **pdtend,long value)
+dt_t ** dtdword(dt_t **pdtend, int value)
 {   dt_t *dt;
 
     while (*pdtend)
@@ -198,7 +198,7 @@
     dt = dt_calloc(DT_ibytes);
     dt->DTn = 4;
 
-    union { char* cp; long* lp; } u;
+    union { char* cp; int* lp; } u;
     u.cp = dt->DTdata;
     *u.lp = value;
 
diff -aruw dmd62/backend/dt.h dmd63/backend/dt.h
--- dmd62/backend/dt.h	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/dt.h	2010-08-09 14:33:14.000000000 -0400
@@ -1,5 +1,5 @@
 // Copyright (C) 1984-1995 by Symantec
-// Copyright (C) 2000-2009 by Digital Mars
+// Copyright (C) 2000-2010 by Digital Mars
 // All Rights Reserved
 // http://www.digitalmars.com
 // Written by Walter Bright
@@ -101,7 +101,7 @@
 
 dt_t **dtnbytes(dt_t **,targ_size_t,const char *);
 dt_t **dtabytes(dt_t **pdtend,tym_t ty, targ_size_t offset, targ_size_t size, const char *ptr);
-dt_t **dtdword(dt_t **,long value);
+dt_t **dtdword(dt_t **, int value);
 dt_t **dtnzeros(dt_t **pdtend,targ_size_t size);
 dt_t **dtxoff(dt_t **pdtend,symbol *s,targ_size_t offset,tym_t ty);
 dt_t **dtselfoff(dt_t **pdtend,targ_size_t offset,tym_t ty);
diff -aruw dmd62/backend/dwarf.c dmd63/backend/dwarf.c
--- dmd62/backend/dwarf.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/dwarf.c	2010-08-09 14:33:14.000000000 -0400
@@ -1,5 +1,5 @@
 
-// Copyright (c) 1999-2009 by Digital Mars
+// Copyright (c) 1999-2010 by Digital Mars
 // All Rights Reserved
 // written by Walter Bright
 // http://www.digitalmars.com
@@ -83,7 +83,18 @@
 void dwarf_addrel(int seg, targ_size_t offset, int targseg)
 {
 #if ELFOBJ
-    elf_addrel(seg, offset, RI_TYPE_SYM32, MAP_SEG2SYMIDX(targseg),0);
+    elf_addrel(seg, offset, I64 ? R_X86_64_32 : RI_TYPE_SYM32, MAP_SEG2SYMIDX(targseg),0);
+#elif MACHOBJ
+    mach_addrel(seg, offset, NULL, targseg, 0);
+#else
+    assert(0);
+#endif
+}
+
+void dwarf_addrel64(int seg, targ_size_t offset, int targseg)
+{
+#if ELFOBJ
+    elf_addrel(seg, offset, R_X86_64_64, MAP_SEG2SYMIDX(targseg),0);
 #elif MACHOBJ
     mach_addrel(seg, offset, NULL, targseg, 0);
 #else
@@ -644,10 +655,20 @@
 
             // Set address to start of segment with DW_LNE_set_address
             linebuf->writeByte(0);
+            if (I64)
+            {
+                linebuf->writeByte(9);
+                linebuf->writeByte(2);
+                dwarf_addrel64(lineseg,linebuf->size(),seg);
+                linebuf->write64(0);
+            }
+            else
+            {
             linebuf->writeByte(5);
             linebuf->writeByte(2);
             dwarf_addrel(lineseg,linebuf->size(),seg);
             linebuf->write32(0);
+            }
 
             // Dwarf2 6.2.2 State machine registers
             unsigned address = 0;       // instruction address
diff -aruw dmd62/backend/el.c dmd63/backend/el.c
--- dmd62/backend/el.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/el.c	2010-08-09 14:33:14.000000000 -0400
@@ -1343,6 +1343,100 @@
     e->EV.sp.Vsym = s;
     e->Ety = s->ty();
 
+    /* For 32 bit:
+     *      CALL __i686.get_pc_thunk.bx@PC32
+     *      ADD  EBX,offset _GLOBAL_OFFSET_TABLE_@GOTPC[2]
+     * Generate for var locals:
+     *      MOV  reg,s@GOTOFF[014h][EBX]
+     * For var globals:
+     *      MOV  EAX,s@GOT32[EBX]
+     *      MOV  reg,[EAX]
+     * For TLS var locals and globals:
+     *      MOV  EAX,s@TLS_GD[EBX]
+     *      CALL ___tls_get_addr@PLT32
+     *      MOV  reg,[EAX]
+     *****************************************
+     * Generate for var locals:
+     *      MOV reg,s@PC32[RIP]
+     * For var globals:
+     *      MOV RAX,s@GOTPCREL[RIP]
+     *      MOV reg,[RAX]
+     * For TLS var locals and globals:
+     *      0x66
+     *      LEA DI,s@TLSGD[RIP]
+     *      0x66
+     *      0x66
+     *      0x48 (REX | REX_W)
+     *      CALL __tls_get_addr@PLT32
+     *      MOV reg,[RAX]
+     */
+
+    if (I64)
+    {
+        elfobj_refGOTsym();
+        switch (s->Sclass)
+        {
+            case SCstatic:
+            case SClocstat:
+                x = 0;
+                goto case_got64;
+
+            case SCcomdat:
+            case SCcomdef:
+            case SCglobal:
+            case SCextern:
+                x = 1;
+            case_got64:
+            {
+                int op = e->Eoper;
+                tym_t tym = e->Ety;
+                e->Ety = TYnptr;
+
+                if (s->Stype->Tty & mTYthread)
+                {
+                    /* Add "volatile" to prevent e from being common subexpressioned.
+                     * This is so we can preserve the magic sequence of instructions
+                     * that the gnu linker patches:
+                     *   lea EDI,x@tlsgd[RIP], call __tls_get_addr@plt
+                     *      =>
+                     *   mov EAX,gs[0], sub EAX,x@tpoff
+                     */
+                    e->Eoper = OPrelconst;
+                    e->Ety |= mTYvolatile;
+                    if (!tls_get_addr_sym)
+                    {
+                        /* void *__tls_get_addr(void *ptr);
+                         * Parameter ptr is passed in RDI, matching TYnfunc calling convention.
+                         */
+                        tls_get_addr_sym = symbol_name("__tls_get_addr",SCglobal,type_fake(TYnfunc));
+                        symbol_keep(tls_get_addr_sym);
+                    }
+                    e = el_bin(OPcall, TYnptr, el_var(tls_get_addr_sym), e);
+                }
+
+                switch (op * 2 + x)
+                {
+                    case OPvar * 2 + 1:
+                        e = el_una(OPind, TYnptr, e);
+                        break;
+                    case OPvar * 2 + 0:
+                    case OPrelconst * 2 + 1:
+                        break;
+                    case OPrelconst * 2 + 0:
+                        e = el_una(OPaddr, TYnptr, e);
+                        break;
+                    default:
+                        assert(0);
+                        break;
+                }
+                e->Ety = tym;
+                break;
+            }
+            default:
+                break;
+        }
+    }
+    else
     switch (s->Sclass)
     {
         /* local (and thread) symbols get only one level of indirection;
@@ -1441,7 +1535,7 @@
     // OSX is currently always pic
     if (config.flags3 & CFG3pic &&
 #if TARGET_LINUX || TARGET_FREEBSD || TARGET_SOLARIS
-        !(s->Stype->Tty & mTYthread) &&
+        (!(s->Stype->Tty & mTYthread) || I64) &&
 #endif
         !tyfunc(s->ty()))
         // Position Independent Code
@@ -1460,20 +1554,43 @@
 #if TARGET_OSX
         ;
 #elif TARGET_LINUX || TARGET_FREEBSD || TARGET_SOLARIS
-        ;               // add GS: override in back end
-        /* Generate:
-         *      MOV reg,GS:[00000000]
+        /* For 32 bit:
+         * Generate for var locals:
+         *      MOV reg,GS:[00000000]   // add GS: override in back end
          *      ADD reg, offset s@TLS_LE
          *      e => *(&s + *(GS:0))
-         * for locals, and for globals:
+         * For var globals:
          *      MOV reg,GS:[00000000]
          *      ADD reg, s@TLS_IE
          *      e => *(s + *(GS:0))
          * note different fixup
-         */
-        elem *e1,*e2;
-
-        e1 = el_calloc();
+         *****************************************
+         * For 64 bit:
+         * Generate for var locals:
+         *      MOV reg,FS:s@TPOFF32
+         * For var globals:
+         *      MOV RAX,s@GOTTPOFF[RIP]
+         *      MOV reg,FS:[RAX]
+         *
+         * For address of locals:
+         *      MOV RAX,FS:[00]
+         *      LEA reg,s@TPOFF32[RAX]
+         *      e => &s + *(FS:0)
+         * For address of globals:
+         *      MOV reg,FS:[00]
+         *      MOV RAX,s@GOTTPOFF[RIP]
+         *      ADD reg,RAX
+         *      e => s + *(FS:0)
+         * This leaves us with a problem, as the 'var' version cannot simply have
+         * its address taken, as what is the address of FS:s ? The (not so efficient)
+         * solution is to just use the second address form, and * it.
+         * Turns out that is identical to the 32 bit version, except GS => FS and the
+         * fixups are different.
+         * In the future, we should figure out a way to optimize to the 'var' version.
+         */
+        if (I64)
+            elfobj_refGOTsym();
+        elem *e1 = el_calloc();
         e1->EV.sp.Vsym = s;
         if (s->Sclass == SCstatic || s->Sclass == SClocstat)
         {   e1->Eoper = OPrelconst;
@@ -1485,8 +1602,11 @@
             e1->Ety = TYnptr;
         }
 
-        // We'll fix this up in the back end to be GS:[0000]
-        e2 = el_calloc();
+        /* Fake GS:[0000] as a load of _tls_array, and then in the back end recognize
+         * the fake and rewrite it as GS:[0000] (or FS:[0000] for I64), because there is
+         * no way to represent segment overrides in the elem nodes.
+         */
+        elem *e2 = el_calloc();
         e2->Eoper = OPvar;
         e2->EV.sp.Vsym = rtlsym[RTLSYM_TLS_ARRAY];
         e2->Ety = e2->EV.sp.Vsym->ty();
@@ -1862,8 +1982,12 @@
 
 elem *el_convfloat(elem *e)
 {
+    unsigned char buffer[32];
+
 #if TX86
     assert(config.inline8087);
+
+    // Do not convert if the constants can be loaded with the special FPU instructions
     if (tycomplex(e->Ety))
     {
         if (loadconst(e, 0) && loadconst(e, 1))
@@ -1871,40 +1995,66 @@
     }
     else if (loadconst(e, 0))
         return e;
+
     changes++;
-    int sz = tysize(e->Ety);
-#if LNGDBLSIZE == 12
-    if (sz == 12 || sz == 24)
-    {
-        unsigned short *p = (unsigned short *)&e->EV.Vfloat;
-        p[5] = 0;               // fill in 2 byte hole
-        if (sz == 24)
-            p[11] = 0;          // other 2 byte hole
-    }
-#endif
-#if LNGDBLSIZE == 16
-    if ((sz == 16 && !tycomplex(e->Ety)) || sz == 32)
-    {
-        unsigned short *p = (unsigned short *)&e->EV.Vfloat;
-        p[5] = 0;               // fill in 6 byte hole
-        p[6] = 0;
-        p[7] = 0;
-        if (sz == 32)
-        {   p[13] = 0;          // other 6 byte hole
-            p[14] = 0;
-            p[15] = 0;
-        }
+    tym_t ty = e->Ety;
+    int sz = tysize(ty);
+    assert(sz <= sizeof(buffer));
+    void *p;
+    switch (tybasic(ty))
+    {
+        case TYfloat:
+        case TYifloat:
+            p = &e->EV.Vfloat;
+            assert(sz == sizeof(e->EV.Vfloat));
+            break;
+
+        case TYdouble:
+        case TYidouble:
+        case TYdouble_alias:
+            p = &e->EV.Vdouble;
+            assert(sz == sizeof(e->EV.Vdouble));
+            break;
+
+        case TYldouble:
+        case TYildouble:
+            /* The size, alignment, and padding of long doubles may be different
+             * from host to target
+             */
+            p = buffer;
+            memset(buffer, 0, sz);                      // ensure padding is 0
+            memcpy(buffer, &e->EV.Vldouble, 10);
+            break;
+
+        case TYcfloat:
+            p = &e->EV.Vcfloat;
+            assert(sz == sizeof(e->EV.Vcfloat));
+            break;
+
+        case TYcdouble:
+            p = &e->EV.Vcdouble;
+            assert(sz == sizeof(e->EV.Vcdouble));
+            break;
+
+        case TYcldouble:
+            p = buffer;
+            memset(buffer, 0, sz);
+            memcpy(buffer, &e->EV.Vcldouble.re, 10);
+            memcpy(buffer + tysize(TYldouble), &e->EV.Vcldouble.im, 10);
+            break;
+
+        default:
+            assert(0);
     }
-#endif
 #if 0
+    printf("%gL+%gLi\n", (double)e->EV.Vcldouble.re, (double)e->EV.Vcldouble.im);
     printf("el_convfloat() %g %g sz=%d\n", e->EV.Vcdouble.re, e->EV.Vcdouble.im, sz);
 printf("el_convfloat(): sz = %d\n", sz);
 unsigned short *p = (unsigned short *)&e->EV.Vcldouble;
 for (int i = 0; i < sz/2; i++) printf("%04x ", p[i]);
 printf("\n");
 #endif
-    symbol *s  = out_readonly_sym(e->Ety, &e->EV.Vfloat, sz);
-    tym_t ty = e->Ety;
+    symbol *s  = out_readonly_sym(ty, p, sz);
     el_free(e);
     e = el_var(s);
     e->Ety = ty;
@@ -2836,7 +2986,7 @@
                 break;
         case 2: value = (short) value;
                 break;
-        case 4: value = (long) value;
+        case 4: value = (int) value;
                 break;
         case 8: break;
         default:
@@ -3023,7 +3173,7 @@
  && (e->PEFflags & PEFstrsize)
 #endif
                )
-                dbg_printf("%ld ",e->Enumbytes);
+                dbg_printf("%d ",e->Enumbytes);
             WRTYxx(e->ET->Tty);
         }
   }
@@ -3031,7 +3181,7 @@
   {
         if ((e->Eoper == OPstrpar || e->Eoper == OPstrctor || e->Eoper == OPstreq) ||
             e->Ety == TYstruct)
-            dbg_printf("%ld ",e->Enumbytes);
+            dbg_printf("%d ",e->Enumbytes);
         WRTYxx(e->Ety);
   }
   if (OTunary(e->Eoper))
@@ -3045,7 +3195,7 @@
   else if (OTbinary(e->Eoper))
   {
         if (!PARSER && e->Eoper == OPstreq)
-                dbg_printf("bytes=%ld ",e->Enumbytes);
+                dbg_printf("bytes=%d ",e->Enumbytes);
         dbg_printf("%p %p\n",e->E1,e->E2);
         elem_print(e->E1);
         elem_print(e->E2);
@@ -3055,18 +3205,18 @@
         switch (e->Eoper)
         {
             case OPrelconst:
-                dbg_printf(" %ld+&",e->Eoffset);
+                dbg_printf(" %lld+&",(unsigned long long)e->Eoffset);
                 dbg_printf(" %s",e->EV.sp.Vsym->Sident);
                 break;
             case OPvar:
                 if (e->Eoffset)
-                    dbg_printf(" %ld+",e->Eoffset);
+                    dbg_printf(" %lld+",(unsigned long long)e->Eoffset);
                 dbg_printf(" %s",e->EV.sp.Vsym->Sident);
                 break;
             case OPasm:
             case OPstring:
             case OPhstring:
-                dbg_printf(" '%s',%ld\n",e->EV.ss.Vstring,e->EV.ss.Voffset);
+                dbg_printf(" '%s',%lld\n",e->EV.ss.Vstring,(unsigned long long)e->EV.ss.Voffset);
                 break;
             case OPconst:
                 tym = tybasic(typemask(e));
@@ -3113,7 +3263,7 @@
                     case TYchar16:
                     L3:
 #if TX86
-                        dbg_printf("%ld ",e->EV.Vint);
+                        dbg_printf("%d ",e->EV.Vint);
                         break;
 #endif
                     case TYlong:
@@ -3125,7 +3275,7 @@
                     case TYhptr:
 #endif
                     L1:
-                        dbg_printf("%ldL ",e->EV.Vlong);
+                        dbg_printf("%dL ",e->EV.Vlong);
                         break;
 
                     case TYllong:
diff -aruw dmd62/backend/elfobj.c dmd63/backend/elfobj.c
--- dmd62/backend/elfobj.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/elfobj.c	2010-08-09 14:33:14.000000000 -0400
@@ -1,5 +1,5 @@
 // Copyright (C) ?-1998 by Symantec
-// Copyright (C) 2000-2009 by Digital Mars
+// Copyright (C) 2000-2010 by Digital Mars
 // All Rights Reserved
 // http://www.digitalmars.com
 /*
@@ -58,6 +58,19 @@
 #define cpp_mangle(s) ((s)->Sident)
 #endif
 
+/***************************************************
+ * Correspondence of relocation types
+ *      386             32 bit in 64      64 in 64
+ *      RI_TYPE_SYM32   R_X86_64_32       R_X86_64_64
+ *      RI_TYPE_GOTOFF  R_X86_64_PC32     R_X86_64_
+ *      RI_TYPE_GOTPC   R_X86_64_         R_X86_64_
+ *      RI_TYPE_GOT32   R_X86_64_         R_X86_64_
+ *      RI_TYPE_TLS_GD  R_X86_64_TLSGD    R_X86_64_
+ *      RI_TYPE_TLS_IE  R_X86_64_GOTTPOFF R_X86_64_
+ *      RI_TYPE_TLS_LE  R_X86_64_TPOFF32  R_X86_64_
+ *      RI_TYPE_PLT32   R_X86_64_PLT32    R_X86_64_
+ *      RI_TYPE_PC32    R_X86_64_PC32     R_X86_64_
+ */
 
 /******************************************
  */
@@ -73,13 +86,21 @@
     return GOTsym;
 }
 
+void elfobj_refGOTsym()
+{
+    if (!GOTsym)
+    {
+        symbol *s = elfobj_getGOTsym();
+        objextern(s);
+    }
+}
+
 static void objfile_write(FILE *fd, void *buffer, unsigned len);
 
 STATIC char * objmodtoseg (const char *modname);
 STATIC void obj_browse_flush();
 STATIC void objfixupp (struct FIXUP *);
 STATIC void ledata_new (int seg,targ_size_t offset);
-static int obj_align(Symbol *s);
 void obj_tlssections();
 
 static IDXSYM elf_addsym(IDXSTR sym, targ_size_t val, unsigned sz,
@@ -563,21 +584,54 @@
         symtab_strings->writeByte(0);
     }
 
+    if (SECbuf)
+        SECbuf->setsize(0);
+    section_cnt = 0;
+
+    if (I64)
+    {
+        static char section_names_init64[] =
+          "\0.symtab\0.strtab\0.shstrtab\0.text\0.data\0.bss\0.note\0.comment\0.rodata\0.rela.text\0.rela.data";
+        #define NAMIDX_NONE      0
+        #define NAMIDX_SYMTAB    1       // .symtab
+        #define NAMIDX_STRTAB    9       // .strtab
+        #define NAMIDX_SHSTRTAB 17      // .shstrtab
+        #define NAMIDX_TEXT     27      // .text
+        #define NAMIDX_DATA     33      // .data
+        #define NAMIDX_BSS      39      // .bss
+        #define NAMIDX_NOTE     44      // .note
+        #define NAMIDX_COMMENT  50      // .comment
+        #define NAMIDX_RODATA   59      // .rodata
+        #define NAMIDX_RELTEXT  67      // .rel.text and .rela.text
+        #define NAMIDX_RELDATA  77      // .rel.data
+        #define NAMIDX_RELDATA64 78      // .rela.data
+
+        if (section_names)
+            section_names->setsize(sizeof(section_names_init64));
+        else
+        {   section_names = new Outbuffer(512);
+            section_names->reserve(1024);
+            section_names->writen(section_names_init64, sizeof(section_names_init64));
+        }
+
+        // name,type,flags,addr,offset,size,link,info,addralign,entsize
+        elf_newsection2(0,               SHT_NULL,   0,                 0,0,0,0,0, 0,0);
+        elf_newsection2(NAMIDX_TEXT,SHT_PROGDEF,SHF_ALLOC|SHF_EXECINSTR,0,0,0,0,0, 4,0);
+        elf_newsection2(NAMIDX_RELTEXT,SHT_RELA, 0,0,0,0,SHI_SYMTAB,     SHI_TEXT, 8,8);
+        elf_newsection2(NAMIDX_DATA,SHT_PROGDEF,SHF_ALLOC|SHF_WRITE,    0,0,0,0,0, 8,0);
+        elf_newsection2(NAMIDX_RELDATA64,SHT_RELA, 0,0,0,0,SHI_SYMTAB,   SHI_DATA, 8,8);
+        elf_newsection2(NAMIDX_BSS, SHT_NOBITS,SHF_ALLOC|SHF_WRITE,     0,0,0,0,0, 16,0);
+        elf_newsection2(NAMIDX_RODATA,SHT_PROGDEF,SHF_ALLOC,            0,0,0,0,0, 1,0);
+        elf_newsection2(NAMIDX_STRTAB,SHT_STRTAB, 0,                    0,0,0,0,0, 1,0);
+        elf_newsection2(NAMIDX_SYMTAB,SHT_SYMTAB, 0,                    0,0,0,0,0, 8,0);
+        elf_newsection2(NAMIDX_SHSTRTAB,SHT_STRTAB, 0,                  0,0,0,0,0, 1,0);
+        elf_newsection2(NAMIDX_COMMENT, SHT_PROGDEF,0,                  0,0,0,0,0, 1,0);
+        elf_newsection2(NAMIDX_NOTE,SHT_NOTE,   0,                      0,0,0,0,0, 1,0);
+    }
+    else
+    {
     static char section_names_init[] =
-      "\0.symtab\0.strtab\0.shstrtab\0.text\0.data\0.bss\0.note\0\
-.comment\0.rel.text\0.rel.data\0.rodata";
-    #define SEC_NAMIDX_NONE     0
-    #define SEC_NAMIDX_SYMS     1       // .symtab
-    #define SEC_NAMIDX_STRS     9       // .strtab
-    #define SEC_NAMIDX_SECS     17      // .shstrtab
-    #define SEC_NAMIDX_TEXT     27      // .text
-    #define SEC_NAMIDX_DATA     33      // .data
-    #define SEC_NAMIDX_BSS      39      // .bss
-    #define SEC_NAMIDX_NOTE     44      // .note
-    #define SEC_NAMIDX_COM      50      // .comment
-    #define SEC_NAMIDX_TEXTREL  59      // .rel.text
-    #define SEC_NAMIDX_DATAREL  69      // .rel.data
-    #define SEC_NAMIDX_RODATA   79      // .rodata
+          "\0.symtab\0.strtab\0.shstrtab\0.text\0.data\0.bss\0.note\0.comment\0.rodata\0.rel.text\0.rel.data";
 
     if (section_names)
         section_names->setsize(sizeof(section_names_init));
@@ -587,24 +641,20 @@
         section_names->writen(section_names_init, sizeof(section_names_init));
     }
 
-    if (SECbuf)
-        SECbuf->setsize(0);
-    section_cnt = 0;
-
     // name,type,flags,addr,offset,size,link,info,addralign,entsize
     elf_newsection2(0,               SHT_NULL,   0,                     0,0,0,0,0, 0,0);
-    elf_newsection2(SEC_NAMIDX_TEXT,SHT_PROGDEF,SHF_ALLOC|SHF_EXECINSTR,0,0,0,0,0, 16,0);
-    elf_newsection2(SEC_NAMIDX_TEXTREL,SHT_REL, 0,0,0,0,SHI_SYMTAB,      SHI_TEXT,4,8);
-    elf_newsection2(SEC_NAMIDX_DATA,SHT_PROGDEF,SHF_ALLOC|SHF_WRITE,   0,0,0,0,0, 4,0);
-    elf_newsection2(SEC_NAMIDX_DATAREL,SHT_REL, 0,0,0,0,SHI_SYMTAB,      SHI_DATA,4,8);
-    elf_newsection2(SEC_NAMIDX_BSS, SHT_NOBITS,SHF_ALLOC|SHF_WRITE,   0,0,0,0,0, 32,0);
-    elf_newsection2(SEC_NAMIDX_RODATA,SHT_PROGDEF,SHF_ALLOC,           0,0,0,0,0, 1,0);
-    elf_newsection2(SEC_NAMIDX_STRS,SHT_STRTAB, 0,                      0,0,0,0,0, 1,0);
-    elf_newsection2(SEC_NAMIDX_SYMS,SHT_SYMTAB, 0,                      0,0,0,0,0, 4,0);
-    elf_newsection2(SEC_NAMIDX_SECS,SHT_STRTAB, 0,                      0,0,0,0,0, 1,0);
-    elf_newsection2(SEC_NAMIDX_COM, SHT_PROGDEF,0,                      0,0,0,0,0, 1,0);
-    elf_newsection2(SEC_NAMIDX_NOTE,SHT_NOTE,   0,                      0,0,0,0,0, 1,0);
-
+        elf_newsection2(NAMIDX_TEXT,SHT_PROGDEF,SHF_ALLOC|SHF_EXECINSTR,0,0,0,0,0, 16,0);
+        elf_newsection2(NAMIDX_RELTEXT,SHT_REL, 0,0,0,0,SHI_SYMTAB,      SHI_TEXT, 4,8);
+        elf_newsection2(NAMIDX_DATA,SHT_PROGDEF,SHF_ALLOC|SHF_WRITE,    0,0,0,0,0, 4,0);
+        elf_newsection2(NAMIDX_RELDATA,SHT_REL, 0,0,0,0,SHI_SYMTAB,      SHI_DATA, 4,8);
+        elf_newsection2(NAMIDX_BSS, SHT_NOBITS,SHF_ALLOC|SHF_WRITE,     0,0,0,0,0, 32,0);
+        elf_newsection2(NAMIDX_RODATA,SHT_PROGDEF,SHF_ALLOC,            0,0,0,0,0, 1,0);
+        elf_newsection2(NAMIDX_STRTAB,SHT_STRTAB, 0,                    0,0,0,0,0, 1,0);
+        elf_newsection2(NAMIDX_SYMTAB,SHT_SYMTAB, 0,                    0,0,0,0,0, 4,0);
+        elf_newsection2(NAMIDX_SHSTRTAB,SHT_STRTAB, 0,                  0,0,0,0,0, 1,0);
+        elf_newsection2(NAMIDX_COMMENT, SHT_PROGDEF,0,                  0,0,0,0,0, 1,0);
+        elf_newsection2(NAMIDX_NOTE,SHT_NOTE,   0,                      0,0,0,0,0, 1,0);
+    }
 
     if (SYMbuf)
         SYMbuf->setsize(0);
@@ -766,7 +816,7 @@
         {
             if (I64)
             {
-                Elf64_Rel *rel = (Elf64_Rel *) pseg->SDrel->buf;
+                Elf64_Rela *rel = (Elf64_Rela *) pseg->SDrel->buf;
                 for (int r = 0; r < pseg->SDrelcnt; r++)
                 {
                     unsigned t = ELF64_R_TYPE(rel->r_info);
@@ -1006,6 +1056,9 @@
             sechdr = &SecHdrTab[seg->SDrelidx];
             sechdr->sh_size = seg->SDrel->size();
             sechdr->sh_offset = foffset;
+            if (I64)
+                assert(seg->SDrelcnt == seg->SDrel->size() / sizeof(Elf64_Rela));
+            else
             assert(seg->SDrelcnt == seg->SDrel->size() / sizeof(Elf32_Rel));
             fobjbuf->write(seg->SDrel->buf, sechdr->sh_size);
             foffset += sechdr->sh_size;
@@ -1221,17 +1274,6 @@
 void obj_wkext(Symbol *s1,Symbol *s2)
 {
     //dbg_printf("obj_wkext(Symbol *%s,Symbol *s2)\n",s1->Sident,s2->Sident);
-#if 0
-    char buffer[2+2+2];
-    int i;
-
-    buffer[0] = 0x80;
-    buffer[1] = 0xA8;
-    i = 2;
-    i += insidx(&buffer[2],s1->Sxtrnnum);
-    i += insidx(&buffer[i],s2->Sxtrnnum);
-    objrecord(COMENT,buffer,i);
-#endif
 }
 
 /*******************************
@@ -1242,11 +1284,9 @@
  */
 
 void obj_filename(const char *modname)
-{   unsigned strtab_idx;
-    unsigned symtab_idx;
-
+{
     //dbg_printf("obj_filename(char *%s)\n",modname);
-    strtab_idx = elf_addstr(symtab_strings,modname);
+    unsigned strtab_idx = elf_addstr(symtab_strings,modname);
     elf_addsym(strtab_idx,0,0,STT_FILE,STB_LOCAL,SHT_ABS);
 }
 
@@ -1262,33 +1302,6 @@
     //dbg_printf("Comment data size %d\n",comment_data->size());
 }
 
-#if 0
-/********************************
- * Convert module name to code segment name.
- * Output:
- *      mem_malloc'd code seg name
- */
-
-STATIC char * objmodtoseg(const char *modname)
-{   char *csegname = NULL;
-
-    if (LARGECODE)              // if need to add in module name
-    {   int i;
-        char *m;
-        static const char suffix[] = "_TEXT";
-
-        // Prepend the module name to the beginning of the _TEXT
-        m = filespecgetroot(filespecname(modname));
-        strupr(m);
-        i = strlen(m);
-        csegname = mem_malloc(i + sizeof(suffix));
-        strcpy(csegname,m);
-        strcat(csegname,suffix);
-        mem_free(m);
-    }
-    return csegname;
-}
-#endif
 
 //#if NEWSTATICDTOR
 
@@ -1319,7 +1332,7 @@
         buf->write64(s->Soffset);
     else
         buf->write32(s->Soffset);
-    elf_addrel(seg,SegData[seg]->SDoffset,RI_TYPE_SYM32,STI_TEXT,0);
+    elf_addrel(seg,SegData[seg]->SDoffset,I64 ? R_X86_64_64 : RI_TYPE_SYM32,STI_TEXT,0);
     SegData[seg]->SDoffset = buf->size();
 }
 
@@ -1344,8 +1357,7 @@
         buf->write64(s->Soffset);
     else
         buf->write32(s->Soffset);
-    //elf_addrel(seg,0,RI_TYPE_SYM32,STI_TEXT,0);
-    elf_addrel(seg,SegData[seg]->SDoffset,RI_TYPE_SYM32,s->Sxtrnnum,0);
+    elf_addrel(seg,SegData[seg]->SDoffset,I64 ? R_X86_64_64 : RI_TYPE_SYM32,s->Sxtrnnum,0);
     SegData[seg]->SDoffset = buf->size();
 }
 
@@ -1374,17 +1386,14 @@
 {
     //dbg_printf("obj_ehtables(%s) \n",sfunc->Sident);
 
-    symbol *ehtab_entry;
-    dt_t **pdte;
-
-    ehtab_entry = symbol_generate(SCstatic,type_alloc(TYint));
+    symbol *ehtab_entry = symbol_generate(SCstatic,type_alloc(TYint));
     symbol_keep(ehtab_entry);
     elf_getsegment(".deh_beg", NULL, SHT_PROGDEF, SHF_ALLOC, 4);
     ehtab_entry->Sseg = elf_getsegment(".deh_eh", NULL, SHT_PROGDEF, SHF_ALLOC, 4);
     elf_getsegment(".deh_end", NULL, SHT_PROGDEF, SHF_ALLOC, 4);
     ehtab_entry->Stype->Tmangle = mTYman_c;
     ehsym->Stype->Tmangle = mTYman_c;
-    pdte = &ehtab_entry->Sdt;
+    dt_t **pdte = &ehtab_entry->Sdt;
     pdte = dtxoff(pdte,sfunc,0,TYnptr);
     pdte = dtxoff(pdte,ehsym,0,TYnptr);
     pdte = dtnbytes(pdte,4,(char *)&sfunc->Ssize);
@@ -1396,14 +1405,11 @@
  */
 
 void obj_ehsections()
-{   int sec;
-    IDXSYM symidx;
-    IDXSTR namidx;
-
-    sec = elf_getsegment(".deh_beg", NULL, SHT_PROGDEF, SHF_ALLOC, 4);
+{
+    int sec = elf_getsegment(".deh_beg", NULL, SHT_PROGDEF, SHF_ALLOC, 4);
     //obj_bytes(sec, 0, 4, NULL);
 
-    namidx = elf_addstr(symtab_strings,"_deh_beg");
+    IDXSTR namidx = elf_addstr(symtab_strings,"_deh_beg");
     elf_addsym(namidx, 0, 0, STT_OBJECT, STB_GLOBAL, MAP_SEG2SECIDX(sec));
     //elf_addsym(namidx, 0, 4, STT_OBJECT, STB_GLOBAL, MAP_SEG2SECIDX(sec));
 
@@ -1661,7 +1667,7 @@
     if (seg_tlsseg == UNKNOWN)
     {
         seg_tlsseg = elf_getsegment(tlssegname, NULL, SHT_PROGDEF,
-            SHF_ALLOC|SHF_WRITE|SHF_TLS, 4);
+            SHF_ALLOC|SHF_WRITE|SHF_TLS, I64 ? 16 : 4);
     }
     return SegData[seg_tlsseg];
 }
@@ -1683,7 +1689,7 @@
     if (seg_tlsseg_bss == UNKNOWN)
     {
         seg_tlsseg_bss = elf_getsegment(tlssegname, NULL, SHT_NOBITS,
-            SHF_ALLOC|SHF_WRITE|SHF_TLS, 4);
+            SHF_ALLOC|SHF_WRITE|SHF_TLS, I64 ? 16 : 4);
     }
     return SegData[seg_tlsseg_bss];
 }
@@ -1694,14 +1700,12 @@
  */
 
 void obj_alias(const char *n1,const char *n2)
-{   unsigned len;
-    char *buffer;
-
+{
     dbg_printf("obj_alias(%s,%s)\n",n1,n2);
     assert(0);
 #if NOT_DONE
-    buffer = (char *) alloca(strlen(n1) + strlen(n2) + 2 * ONS_OHD);
-    len = obj_namestring(buffer,n1);
+    char *buffer = (char *) alloca(strlen(n1) + strlen(n2) + 2 * ONS_OHD);
+    unsigned len = obj_namestring(buffer,n1);
     len += obj_namestring(buffer + len,n2);
     objrecord(ALIAS,buffer,len);
 #endif
@@ -1723,7 +1727,6 @@
 
 char *obj_mangle2(Symbol *s,char *dest)
 {
-    size_t len;
     char *name;
 
     //dbg_printf("obj_mangle('%s'), mangle = x%x\n",s->Sident,type_mangle(s->Stype));
@@ -1736,7 +1739,7 @@
 #else
     name = s->Sident;
 #endif
-    len = strlen(name);                 // # of bytes in name
+    size_t len = strlen(name);                 // # of bytes in name
     //dbg_printf("len %d\n",len);
     switch (type_mangle(s->Stype))
     {
@@ -1800,11 +1803,8 @@
  */
 
 void obj_export(Symbol *s,unsigned argsize)
-{   char *coment;
-    size_t len;
-
+{
     //dbg_printf("obj_export(%s,%d)\n",s->Sident,argsize);
-
 }
 
 /*******************************
@@ -1820,7 +1820,7 @@
  *      actual seg
  */
 
-int elf_data_start(Symbol *sdata,int datasize,int seg)
+int elf_data_start(Symbol *sdata, targ_size_t datasize, int seg)
 {
     targ_size_t alignbytes;
     //dbg_printf("elf_data_start(%s,size %d,seg %d)\n",sdata->Sident,datasize,seg);
@@ -1970,13 +1970,12 @@
 
 int objextern(Symbol *s)
 {
-    IDXSTR namidx;
     int symtype,sectype;
-    int size;
+    unsigned size;
 
     //dbg_printf("objextern('%s') %x\n",s->Sident,s->Svalue);
     symbol_debug(s);
-    namidx = elf_addmangled(s);
+    IDXSTR namidx = elf_addmangled(s);
 
 #if SCPP
     if (s->Sscope && !tyfunc(s->ty()))
@@ -2019,10 +2018,11 @@
     //printf("obj_comdef('%s',%d,%d)\n",s->Sident,size,count);
     symbol_debug(s);
 
+    int align = I64 ? 16 : 4;
     if (s->ty() & mTYthread)
     {
         s->Sseg = elf_getsegment(".tbss.", cpp_mangle(s),
-                SHT_NOBITS, SHF_ALLOC|SHF_WRITE|SHF_TLS, 4);
+                SHT_NOBITS, SHF_ALLOC|SHF_WRITE|SHF_TLS, align);
         s->Sfl = FLtlsdata;
         SegData[s->Sseg]->SDsym = s;
         SegData[s->Sseg]->SDoffset += size * count;
@@ -2033,7 +2033,7 @@
     else
     {
         s->Sseg = elf_getsegment(".bss.", cpp_mangle(s),
-                SHT_NOBITS, SHF_ALLOC|SHF_WRITE, 4);
+                SHT_NOBITS, SHF_ALLOC|SHF_WRITE, align);
         s->Sfl = FLudata;
         SegData[s->Sseg]->SDsym = s;
         SegData[s->Sseg]->SDoffset += size * count;
@@ -2174,7 +2174,7 @@
  * Input:
  *      seg =           where the address is going
  *      offset =        offset within seg
- *      type =          ELF relocation type
+ *      type =          ELF relocation type RI_TYPE_XXXX
  *      index =         Related symbol table index
  *      val =           addend or displacement from address
  */
@@ -2216,21 +2216,38 @@
             char *p = (char *)alloca(len);
             memcpy(p, section_name, len);
 
-            relidx = elf_newsection(".rel", p, SHT_REL, 0);
+            relidx = elf_newsection(I64 ? ".rela" : ".rel", p, I64 ? SHT_RELA : SHT_REL, 0);
             segdata->SDrelidx = relidx;
         }
+
+        if (I64)
+        {
+            /* Note that we're using Elf32_Shdr here instead of Elf64_Shdr. This is to make
+             * the code a bit simpler. In obj_term(), we translate the Elf32_Shdr into the proper
+             * Elf64_Shdr.
+             */
         Elf32_Shdr *relsec = &SecHdrTab[relidx];
         relsec->sh_link = SHI_SYMTAB;
         relsec->sh_info = secidx;
-        relsec->sh_entsize = I64 ? sizeof(Elf64_Rel) : sizeof(Elf32_Rel);
+            relsec->sh_entsize = sizeof(Elf64_Rela);
+            relsec->sh_addralign = 8;
+        }
+        else
+        {
+            Elf32_Shdr *relsec = &SecHdrTab[relidx];
+            relsec->sh_link = SHI_SYMTAB;
+            relsec->sh_info = secidx;
+            relsec->sh_entsize = sizeof(Elf32_Rel);
         relsec->sh_addralign = 4;
     }
+    }
 
     if (I64)
     {
-        Elf64_Rel rel;
+        Elf64_Rela rel;
         rel.r_offset = offset;          // build relocation information
         rel.r_info = ELF64_R_INFO(symidx,type);
+        rel.r_addend = val;
         buf = segdata->SDrel;
         buf->write(&rel,sizeof(rel));
         segdata->SDrelcnt++;
@@ -2239,9 +2256,8 @@
             segdata->SDrelmaxoff = offset;
         else
         {   // insert numerically
-            int i;
-            Elf64_Rel *relbuf = (Elf64_Rel *)buf->buf;
-            i = relbuf[segdata->SDrelindex].r_offset > offset ? 0 : segdata->SDrelindex;
+            Elf64_Rela *relbuf = (Elf64_Rela *)buf->buf;
+            int i = relbuf[segdata->SDrelindex].r_offset > offset ? 0 : segdata->SDrelindex;
             while (i < segdata->SDrelcnt)
             {
                 if (relbuf[i].r_offset > offset)
@@ -2249,7 +2265,7 @@
                 i++;
             }
             assert(i != segdata->SDrelcnt);     // slide greater offsets down
-            memmove(relbuf+i+1,relbuf+i,sizeof(Elf64_Rel) * (segdata->SDrelcnt - i - 1));
+            memmove(relbuf+i+1,relbuf+i,sizeof(Elf64_Rela) * (segdata->SDrelcnt - i - 1));
             *(relbuf+i) = rel;          // copy to correct location
             segdata->SDrelindex = i;    // next entry usually greater
         }
@@ -2267,9 +2283,8 @@
             segdata->SDrelmaxoff = offset;
         else
         {   // insert numerically
-            int i;
             Elf32_Rel *relbuf = (Elf32_Rel *)buf->buf;
-            i = relbuf[segdata->SDrelindex].r_offset > offset ? 0 : segdata->SDrelindex;
+            int i = relbuf[segdata->SDrelindex].r_offset > offset ? 0 : segdata->SDrelindex;
             while (i < segdata->SDrelcnt)
             {
                 if (relbuf[i].r_offset > offset)
@@ -2307,28 +2322,44 @@
     buf = SegData[seg]->SDbuf;
     save = buf->size();
     buf->setsize(offset);
-    //dbg_printf("reftodatseg(seg=%d, offset=x%lx, val=x%lx,data %x, flags %x )\n",
-    //  seg,offset,val,targetdatum,flags);
+#if 0
+    printf("reftodatseg(seg=%d, offset=x%llx, val=x%llx,data %x, flags %x)\n",
+        seg,(unsigned long long)offset,(unsigned long long)val,targetdatum,flags);
+#endif
     /*if (OPT_IS_SET(OPTfwritable_strings))
     {
         elf_addrel(seg,offset,RI_TYPE_SYM32,STI_DATA,0);
     }
     else*/
     {
-        unsigned type = RI_TYPE_SYM32;
+        int relinfo;
+        targ_size_t v = 0;
 
+        if (I64)
+        {
         if (MAP_SEG2TYP(seg) == CODE && config.flags3 & CFG3pic)
-            type = RI_TYPE_GOTOFF;
+            {   relinfo = R_X86_64_PC32;
+                //v = -4L;
+            }
         else if (MAP_SEG2SEC(targetdatum)->sh_flags & SHF_TLS)
-            type = config.flags3 & CFG3pic ? RI_TYPE_TLS_GD : RI_TYPE_TLS_LE;
-
-        elf_addrel(seg,offset,type,STI_RODAT,0);
+                relinfo = config.flags3 & CFG3pic ? R_X86_64_TLSGD : R_X86_64_TPOFF32;
+            else
+                relinfo = R_X86_64_32;
     }
-    if (I64)
-        buf->write64(val);
     else
+        {
+            if (MAP_SEG2TYP(seg) == CODE && config.flags3 & CFG3pic)
+                relinfo = RI_TYPE_GOTOFF;
+            else if (MAP_SEG2SEC(targetdatum)->sh_flags & SHF_TLS)
+                relinfo = config.flags3 & CFG3pic ? RI_TYPE_TLS_GD : RI_TYPE_TLS_LE;
+            else
+                relinfo = RI_TYPE_SYM32;
+        }
+
+        elf_addrel(seg, offset, relinfo, STI_RODAT, v);
+    }
         buf->write32(val);
-    if (save > offset + NPTRSIZE)
+    if (save > offset + 4)
         buf->setsize(save);
 }
 
@@ -2363,15 +2394,16 @@
 #endif
     {
         val = val - funcsym_p->Soffset;
-        elf_addrel(seg,offset,
-                (config.flags3 & CFG3pic) ? RI_TYPE_GOTOFF : RI_TYPE_SYM32,
-                funcsym_p->Sxtrnnum,0);
-    }
+        int relinfo;
+        targ_size_t v = 0;
     if (I64)
-        buf->write64(val);
+            relinfo = (config.flags3 & CFG3pic) ? R_X86_64_PC32 : R_X86_64_32;
     else
+            relinfo = (config.flags3 & CFG3pic) ? RI_TYPE_GOTOFF : RI_TYPE_SYM32;
+        elf_addrel(seg,offset, relinfo, funcsym_p->Sxtrnnum, v);
+    }
         buf->write32(val);
-    if (save > offset + NPTRSIZE)
+    if (save > offset + 4)
         buf->setsize(save);
 }
 
@@ -2385,8 +2417,9 @@
  *      flags =         CFselfrel: self-relative
  *                      CFseg: get segment
  *                      CFoff: get offset
+ *                      CFoffset64: 64 bit fixup
  * Returns:
- *      number of bytes in reference (2 or 4 or 8)
+ *      number of bytes in reference (4 or 8)
  */
 
 int reftoident(int seg, targ_size_t offset, Symbol *s, targ_size_t val,
@@ -2398,11 +2431,13 @@
     elf_u32_f32 relinfo,refseg;
     int segtyp = MAP_SEG2TYP(seg);
     //assert(val == 0);
+    int retsize = (flags & CFoffset64) ? 8 : 4;
+    targ_size_t v = 0;
 
 #if 0
-    dbg_printf("\nreftoident('%s' seg %d, offset x%lx, val x%lx, flags x%x)\n",
+    printf("\nreftoident('%s' seg %d, offset x%llx, val x%llx, flags x%x)\n",
         s->Sident,seg,offset,val,flags);
-    dbg_printf("Sseg = %d, Sxtrnnum = %d\n",s->Sseg,s->Sxtrnnum);
+    dbg_printf("Sseg = %d, Sxtrnnum = %d, retsize = %d\n",s->Sseg,s->Sxtrnnum,retsize);
     symbol_print(s);
 #endif
 
@@ -2425,14 +2460,29 @@
     {
         case SClocstat:
             buf = SegData[seg]->SDbuf;
-            refseg = /*(OPT_IS_SET(OPTfwritable_strings)) ?
-                STI_DATA : */STI_RODAT;
-            relinfo = config.flags3 & CFG3pic ?
-                  RI_TYPE_GOTOFF:RI_TYPE_SYM32,STI_RODAT;
+            if (I64)
+            {
+                if (s->Sfl == FLtlsdata)
+                    relinfo = config.flags3 & CFG3pic ? R_X86_64_TLSGD : R_X86_64_TPOFF32;
+                else
+                {   relinfo = config.flags3 & CFG3pic ? R_X86_64_PC32 : R_X86_64_32;
+                    if (config.flags3 & CFG3pic)
+                        v = -4L;
+                }
+            }
+            else
+            {
             if (s->Sfl == FLtlsdata)
                 relinfo = config.flags3 & CFG3pic ? RI_TYPE_TLS_GD : RI_TYPE_TLS_LE;
-            elf_addrel(seg,offset,relinfo,refseg,0);
-            if (I64)
+                else
+                    relinfo = config.flags3 & CFG3pic ? RI_TYPE_GOTOFF : RI_TYPE_SYM32;
+            }
+            if (flags & CFoffset64 && relinfo == R_X86_64_32)
+            {
+                relinfo = R_X86_64_64;
+            }
+            elf_addrel(seg,offset,relinfo,STI_RODAT,v);
+            if (retsize == 8)
                 buf->write64(val + s->Soffset);
             else
                 buf->write32(val + s->Soffset);
@@ -2459,7 +2509,7 @@
             {   // not in symbol table yet - class might change
                 //dbg_printf("\tadding %s to fixlist\n",s->Sident);
                 addtofixlist(s,offset,seg,val,flags);
-                return NPTRSIZE;
+                return retsize;
             }
             else
             {
@@ -2475,15 +2525,21 @@
                            s->Sclass == SCstatic)) // or is pic, but declared static
                     {                   // Can use PC relative
                         //dbg_printf("\tdoing PC relative\n");
-                        val = (s->Soffset+val) - (offset+NPTRSIZE);
+                        val = (s->Soffset+val) - (offset+4);
                     }
                     else
                     {
-                        val = (targ_size_t)-NPTRSIZE;
                         //dbg_printf("\tadding relocation\n");
-                        elf_addrel(seg,offset,
-                                config.flags3 & CFG3pic ?  RI_TYPE_PLT32 : RI_TYPE_PC32,
-                                s->Sxtrnnum,0);
+                        if (I64)
+                        {   relinfo = config.flags3 & CFG3pic ?  R_X86_64_PLT32 : R_X86_64_PC32;
+                            elf_addrel(seg,offset, relinfo, s->Sxtrnnum, -4);
+                            val = 0;
+                        }
+                        else
+                        {   relinfo = config.flags3 & CFG3pic ?  RI_TYPE_PLT32 : RI_TYPE_PC32;
+                            elf_addrel(seg,offset, relinfo, s->Sxtrnnum, 0);
+                            val = (targ_size_t)-4;
+                        }
                     }
                 }
                 else
@@ -2497,28 +2553,53 @@
                         if (!(config.flags3 & CFG3pic) ||       // all static refs from normal code
                              segtyp == DATA)    // or refs from data from posi indp
                         {
-                           relinfo = RI_TYPE_SYM32;
+                           relinfo = I64 ? R_X86_64_32 : RI_TYPE_SYM32;
                         }
                         else
                         {
-                            relinfo = RI_TYPE_GOTOFF;
+                            relinfo = I64 ? R_X86_64_PC32 : RI_TYPE_GOTOFF;
                         }
                     }
                     else if (config.flags3 & CFG3pic && s == GOTsym)
                     {                   // relocation for Gbl Offset Tab
-                        relinfo =  RI_TYPE_GOTPC;
+                        relinfo =  I64 ? R_X86_64_NONE : RI_TYPE_GOTPC;
                     }
                     else if (segtyp == DATA)
                     {                   // relocation from with in DATA seg
-                        relinfo = RI_TYPE_SYM32;
+                        relinfo = I64 ? R_X86_64_32 : RI_TYPE_SYM32;
                     }
                     else
                     {                   // relocation from with in CODE seg
-                        relinfo = config.flags3 & CFG3pic ?
-                             RI_TYPE_GOT32 : RI_TYPE_SYM32;
+                        if (I64)
+                        {   if (config.flags3 & CFG3pic)
+                                relinfo = R_X86_64_GOTPCREL;
+                            else
+                                relinfo = (flags & CFpc32) ? R_X86_64_PC32 : R_X86_64_32;
+                        }
+                        else
+                            relinfo = config.flags3 & CFG3pic ? RI_TYPE_GOT32 : RI_TYPE_SYM32;
                     }
                     if ((s->ty() & mTYLINK) & mTYthread)
                     {
+                        if (I64)
+                        {
+                            if (config.flags3 & CFG3pic)
+                            {
+                                if (s->Sclass == SCstatic || s->Sclass == SClocstat)
+                                    relinfo = R_X86_64_TLSGD;  // TLS_GD?
+                                else
+                                    relinfo = R_X86_64_TLSGD;
+                            }
+                            else
+                            {
+                                if (s->Sclass == SCstatic || s->Sclass == SClocstat)
+                                    relinfo = R_X86_64_TPOFF32;
+                                else
+                                    relinfo = R_X86_64_GOTTPOFF;
+                            }
+                        }
+                        else
+                        {
                         if (config.flags3 & CFG3pic)
                         {
                             if (s->Sclass == SCstatic)
@@ -2534,15 +2615,21 @@
                                 relinfo = RI_TYPE_TLS_IE;
                         }
                     }
+                    }
+                    if (flags & CFoffset64 && relinfo == R_X86_64_32)
+                    {
+                        relinfo = R_X86_64_64;
+                    }
                     //printf("\t\t************* adding relocation\n");
-                    elf_addrel(seg,offset,relinfo,refseg,0);
+                    targ_size_t v = (relinfo == R_X86_64_PC32) ? -4 : 0;
+                    elf_addrel(seg,offset,relinfo,refseg,v);
                 }
 outaddrval:
-                if (I64)
+                if (retsize == 8)
                     buf->write64(val);
                 else
                     buf->write32(val);
-                if (save > offset + NPTRSIZE)
+                if (save > offset + retsize)
                     buf->setsize(save);
             }
             break;
@@ -2566,7 +2653,7 @@
 #endif
             assert(0);
     }
-    return NPTRSIZE;
+    return retsize;
 }
 
 /*****************************************
@@ -2590,18 +2677,6 @@
     //dbg_printf("obj_fltused()\n");
 }
 
-static int obj_align(Symbol *s)
-{
-    if (type_size(s->Stype) == CHARSIZE)
-        return 1;
-    else if (type_size(s->Stype) == SHORTSIZE)
-        return 2;
-    else if (type_size(s->Stype) == LONGSIZE)
-        return 4;
-    else
-        return I64 ? 8 : 4;
-}
-
 /************************************
  * Close and delete .OBJ file.
  */
@@ -2669,16 +2744,9 @@
 
 void obj_moduleinfo(Symbol *scc)
 {
-    int offset, codeOffset, refOffset;
-    Outbuffer *buf;
-    int seg;
+//    if (I64) return;          // for now, until Phobos64 works
 
-    /* Put in the ModuleInfo reference for some reason. */
-    /*{
-        seg = DATA;
-        offset = SegData[seg]->SDoffset;
-        SegData[seg]->SDoffset += reftoident(seg, offset, scc, 0, CFoff);
-    }*/
+    int codeOffset, refOffset;
 
     /* Put in the ModuleReference. */
     {
@@ -2688,17 +2756,21 @@
          *      ModuleReference* module;
          * }
          */
-        seg = DATA;
+        const int seg = DATA;
+        alignOffset(seg, NPTRSIZE);
         SegData[seg]->SDoffset = SegData[seg]->SDbuf->size();
         refOffset = SegData[seg]->SDoffset;
         SegData[seg]->SDbuf->writezeros(NPTRSIZE);
         SegData[seg]->SDoffset += NPTRSIZE;
-        SegData[seg]->SDoffset += reftoident(seg, SegData[seg]->SDoffset, scc, 0, CFoff);
+        SegData[seg]->SDoffset += reftoident(seg, SegData[seg]->SDoffset, scc, 0, CFoffset64 | CFoff);
     }
 
-    /* Constructor that links the ModuleReference into the code. */
+    /* Constructor that links the ModuleReference to the head of
+     * the list pointed to by _Dmoduleref
+     */
     {
         /*      ret
+         * codeOffset:
          *      pushad
          *      mov     EAX,&ModuleReference
          *      mov     ECX,_DmoduleRef
@@ -2709,86 +2781,70 @@
          *      ret
          */
 
-        seg = CODE;
-        buf = SegData[seg]->SDbuf;
+        const int reltype = I64 ? R_X86_64_32 : RI_TYPE_SYM32;
+        const int refsize = 4;                          // use 32 bit relocations, even in 64 bit mode
+
+        const int seg = CODE;
+        Outbuffer *buf = SegData[seg]->SDbuf;
         SegData[seg]->SDoffset = buf->size();
         codeOffset = SegData[seg]->SDoffset + 1;
-//      codeOffset = SegData[seg]->SDoffset;
         buf->writeByte(0xC3); /* ret */
 
-        buf->writeByte(0x60); /* pushad */
+        int off = 0;
+        if (I32)
+        {   buf->writeByte(0x60); // PUSHAD
+            off = 1;
+        }
+
+        if (I64 && config.flags3 & CFG3pic)
+        {   // LEA RAX,ModuleReference[RIP]
+            buf->writeByte(REX | REX_W);
+            buf->writeByte(0x8D);
+            buf->writeByte(modregrm(0,AX,5));
+            buf->write32(refOffset);
+            elf_addrel(seg, codeOffset + off + 3, R_X86_64_PC32, STI_DATA, -4);
 
+            // LEA RCX,_DmoduleRef[RIP]
+            buf->writeByte(REX | REX_W);
+            buf->writeByte(0x8D);
+            buf->writeByte(modregrm(0,CX,5));
+            buf->write32(0);
+            elf_addrel(seg, codeOffset + off + 10, R_X86_64_PC32, objextern("_Dmodule_ref"), -4);
+        }
+        else
+        {
         /* movl ModuleReference*, %eax */
         buf->writeByte(0xB8);
         buf->write32(refOffset);
-        elf_addrel(seg, codeOffset + 2, RI_TYPE_SYM32, STI_DATA, 0);
+            elf_addrel(seg, codeOffset + off + 1, reltype, STI_DATA, 0);
 
         /* movl _Dmodule_ref, %ecx */
         buf->writeByte(0xB9);
-        buf->write32(0);//offset);
-        elf_addrel(seg, codeOffset + 7, RI_TYPE_SYM32, objextern("_Dmodule_ref"), 0);
+            buf->write32(0);
+            elf_addrel(seg, codeOffset + off + 6, reltype, objextern("_Dmodule_ref"), 0);
+        }
 
         buf->writeByte(0x8B); buf->writeByte(0x11); /* movl (%ecx), %edx */
         buf->writeByte(0x89); buf->writeByte(0x10); /* movl %edx, (%eax) */
         buf->writeByte(0x89); buf->writeByte(0x01); /* movl %eax, (%ecx) */
 
-        buf->writeByte(0x61); /* popad */
+        if (I32) buf->writeByte(0x61); // POPAD
         buf->writeByte(0xC3); /* ret */
         SegData[seg]->SDoffset = buf->size();
     }
 
-    /* Create the linked list-generating code. */
-    seg = elf_getsegment(".ctors", NULL, SHT_PROGDEF, SHF_ALLOC|SHF_WRITE,4);
+    /* Add reference to constructor into ".ctors" segment
+     */
+    const int seg = elf_getsegment(".ctors", NULL, SHT_PROGDEF, SHF_ALLOC|SHF_WRITE, NPTRSIZE);
 
-    buf = SegData[seg]->SDbuf;
+    Outbuffer *buf = SegData[seg]->SDbuf;
     buf->write32(codeOffset);
-    elf_addrel(seg, SegData[seg]->SDoffset, RI_TYPE_SYM32, STI_TEXT, 0);
+    elf_addrel(seg, SegData[seg]->SDoffset, I64 ? R_X86_64_64 : RI_TYPE_SYM32, STI_TEXT, 0);
     SegData[seg]->SDoffset += NPTRSIZE;
 }
 
 #endif
 
-/************************************
- * Output long word of data.
- * Input:
- *      seg     CODE, DATA, CDATA, UDATA
- *      offset  offset of start of data
- *      data    long word of data
- *   Present only if size == 2:
- *      lcfd    LCxxxx | FDxxxx
- *      if (FD_F2 | FD_T6)
- *              idx1 = external Symbol #
- *      else
- *              idx1 = frame datum
- *              idx2 = target datum
- */
-
-void obj_long(int seg,targ_size_t offset,unsigned long data,
-        unsigned lcfd,unsigned idx1,unsigned idx2)
-{
-    printf ("obj_long\n");
-    exit (1);
-    /*
-    unsigned i;
-
-    if (
-        (seg != obj.ledata->lseg ||             // or segments don't match
-         obj.ledata->i + tysize[TYfptr] > LEDATAMAX || // or it'll overflow
-         offset < obj.ledata->offset || // underflow
-         offset > obj.ledata->offset + obj.ledata->i
-        )
-     )
-        ledata_new(seg,offset);
-  i = offset - obj.ledata->offset;
-  if (obj.ledata->i < i + tysize[TYfptr])
-        obj.ledata->i = i + tysize[TYfptr];
-  TOLONG(obj.ledata->data + i,data);
-  if (I32)                              // if 6 byte far pointers
-        TOWORD(obj.ledata->data + i + LONGSIZE,0);              // fill out seg
-  addfixup(offset - obj.ledata->offset,lcfd,idx1,idx2);
-  */
-}
-
 /*************************************
  */
 
diff -aruw dmd62/backend/el.h dmd63/backend/el.h
--- dmd62/backend/el.h	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/el.h	2010-08-09 14:33:14.000000000 -0400
@@ -1,5 +1,5 @@
 // Copyright (C) 1985-1995 by Symantec
-// Copyright (C) 2000-2009 by Digital Mars
+// Copyright (C) 2000-2010 by Digital Mars
 // All Rights Reserved
 // http://www.digitalmars.com
 // Written by Walter Bright
@@ -43,6 +43,9 @@
     unsigned char Eoper;        // operator (OPxxxx)
     unsigned char Ecount;       // # of parents of this elem - 1,
                                 // always 0 until CSE elimination is done
+    unsigned char Eflags;
+    #define EFLAGS_variadic 1   // variadic function call
+
     union eve EV;               // variants for each type of elem
     union
     {
@@ -125,7 +128,7 @@
         }_EC;
     }_EU;
 
-    targ_size_t Enumbytes;      // number of bytes for type if TYstruct | TYarray
+    unsigned Enumbytes;         // number of bytes for type if TYstruct | TYarray
     TARGET_structELEM           // target specific additions
     Srcpos Esrcpos;             // source file position
 };
diff -aruw dmd62/backend/evalu8.c dmd63/backend/evalu8.c
--- dmd62/backend/evalu8.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/evalu8.c	2010-08-09 14:33:14.000000000 -0400
@@ -1894,7 +1894,7 @@
         }
         else
 #endif
-        e->EV.Vldouble = (unsigned long) l1;
+        e->EV.Vldouble = (unsigned) l1;
         break;
     case OPd_s16:
         e->EV.Vint = d1;
@@ -1939,10 +1939,10 @@
         e->EV.Vlong = (targ_long)d1;
         break;
     case OPu32_d:
-        e->EV.Vdouble = (unsigned long) l1;
+        e->EV.Vdouble = (unsigned) l1;
         break;
     case OPs32_d:
-        e->EV.Vdouble = (long) l1;
+        e->EV.Vdouble = (int) l1;
         break;
     case OPd_s16:
         e->EV.Vint = (targ_int)d1;
diff -aruw dmd62/backend/global.h dmd63/backend/global.h
--- dmd62/backend/global.h	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/global.h	2010-08-09 14:33:14.000000000 -0400
@@ -51,7 +51,7 @@
  * Bit masks
  */
 
-CEXTERN const unsigned mask[16];
+CEXTERN const unsigned mask[32];
 CEXTERN const unsigned long maskl[32];
 
 extern  char *argv0;
@@ -447,7 +447,7 @@
 #ifdef DEBUG
 
 /* debug.c */
-CEXTERN const char __near *regstring[];
+CEXTERN const char *regstring[];
 
 void WRclass(enum SC c);
 void WRTYxx(tym_t t);
@@ -536,7 +536,7 @@
         unsigned targseg, int rtype);
 #endif
 void elf_func_start(Symbol *sfunc);
-int elf_data_start(Symbol *sdata,int datasize,int seg);
+int elf_data_start(Symbol *sdata, targ_size_t datasize, int seg);
 void elf_func_term(Symbol *sfunc);
 unsigned elf_addstr(Outbuffer *strtab, const char *);
 
@@ -549,6 +549,7 @@
 #if TARGET_LINUX || TARGET_OSX || TARGET_FREEBSD || TARGET_SOLARIS
 void elfobj_gotref(symbol *s);
 symbol *elfobj_getGOTsym();
+void elfobj_refGOTsym();
 elem * exp_isconst();
 elem *lnx_builtin_next_arg(elem *efunc,list_t arglist);
 char *lnx_redirect_funcname(const char *);
diff -aruw dmd62/backend/gother.c dmd63/backend/gother.c
--- dmd62/backend/gother.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/gother.c	2010-08-09 14:33:14.000000000 -0400
@@ -1,5 +1,5 @@
 // Copyright (C) 1986-1998 by Symantec
-// Copyright (C) 2000-2009 by Digital Mars
+// Copyright (C) 2000-2010 by Digital Mars
 // All Rights Reserved
 // http://www.digitalmars.com
 // Written by Walter Bright
@@ -477,7 +477,12 @@
         //printf("\trd: "); WReqn(d); printf("\n");
         if (d->Eoper == OPasm)          /* OPasm elems ruin everything  */
             goto noprop;
+#if 0
+        // Runs afoul of Buzilla 4506
         if (OTassign(d->Eoper) && EBIN(d))      // if assignment elem
+#else
+        if (OTassign(d->Eoper))      // if assignment elem
+#endif
         {   elem *t = Elvalue(d);
 
             if (t->Eoper == OPvar)
@@ -487,6 +492,9 @@
                     !tyscalar(t->Ety))
                     goto noprop;        // not worth bothering with these cases
 
+                if (d->Eoper == OPnegass)
+                    goto noprop;        // don't bother with this case, either
+
                 /* Everything must match or we must skip this variable  */
                 /* (in case of assigning to overlapping unions, etc.)   */
                 if (t->EV.sp.Voffset != noff ||
diff -aruw dmd62/backend/iasm.h dmd63/backend/iasm.h
--- dmd62/backend/iasm.h	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/iasm.h	2010-08-09 14:33:14.000000000 -0400
@@ -1,7 +1,7 @@
 
 /*
  * Copyright (c) 1992-1999 by Symantec
- * Copyright (c) 1999-2008 by Digital Mars
+ * Copyright (c) 1999-2010 by Digital Mars
  * All Rights Reserved
  * http://www.digitalmars.com
  * Written by Mike Cote, John Micco and Walter Bright
@@ -36,6 +36,7 @@
 #define _cb     _modrm
 #define _cw     _modrm
 #define _cd     _modrm
+#define _cq     _modrm
 #define _cp     _modrm
 #define _ib     0
 #define _iw     0
@@ -45,6 +46,7 @@
 #define _rd     0
 #define _16_bit 0x20
 #define _32_bit 0x40
+#define _64_bit 0x10000
 #define _I386   0x80            // opcode is only for 386 and later
 #define _16_bit_addr    0x100
 #define _32_bit_addr    0x200
@@ -70,22 +72,24 @@
 // Operand flags - usOp1, usOp2, usOp3
 //
 
-typedef unsigned short opflag_t;
+typedef unsigned opflag_t;
 
 // Operand flags for normal opcodes
 
 #define _r8     CONSTRUCT_FLAGS( _8, _reg, _normal, 0 )
 #define _r16    CONSTRUCT_FLAGS(_16, _reg, _normal, 0 )
 #define _r32    CONSTRUCT_FLAGS(_32, _reg, _normal, 0 )
+#define _r64    CONSTRUCT_FLAGS(_64, _reg, _normal, 0 )
 #define _m8     CONSTRUCT_FLAGS(_8, _m, _normal, 0 )
 #define _m16    CONSTRUCT_FLAGS(_16, _m, _normal, 0 )
 #define _m32    CONSTRUCT_FLAGS(_32, _m, _normal, 0 )
 #define _m48    CONSTRUCT_FLAGS( _48, _m, _normal, 0 )
-#define _m64    CONSTRUCT_FLAGS( _anysize, _m, _normal, 0 )
+#define _m64    CONSTRUCT_FLAGS( _64, _m, _normal, 0 )
 #define _m128   CONSTRUCT_FLAGS( _anysize, _m, _normal, 0 )
 #define _rm8    CONSTRUCT_FLAGS(_8, _rm, _normal, 0 )
 #define _rm16   CONSTRUCT_FLAGS(_16, _rm, _normal, 0 )
 #define _rm32   CONSTRUCT_FLAGS(_32, _rm, _normal, 0)
+#define _rm64   CONSTRUCT_FLAGS(_64, _rm, _normal, 0)
 #define _r32m16 CONSTRUCT_FLAGS(_32|_16, _rm, _normal, 0)
 #define _imm8   CONSTRUCT_FLAGS(_8, _imm, _normal, 0 )
 #define _imm16  CONSTRUCT_FLAGS(_16, _imm, _normal, 0)
@@ -109,8 +113,8 @@
                                                 // Label (in current function)
 
 #define _mmm32  CONSTRUCT_FLAGS( 0, _m, 0, _32)
-#define _mmm64  CONSTRUCT_FLAGS( 0, _m, 0, _64)
-#define _mmm128 CONSTRUCT_FLAGS( 0, _m, 0, _128)
+#define _mmm64  CONSTRUCT_FLAGS( _64, _m, 0, _f64)
+#define _mmm128 CONSTRUCT_FLAGS( 0, _m, 0, _f128)
 
 #define _xmm_m32 CONSTRUCT_FLAGS( _32, _m, _rspecial, 0)
 #define _xmm_m64 CONSTRUCT_FLAGS( _anysize, _m, _rspecial, 0)
@@ -126,21 +130,31 @@
 // normal opcode variants and only asm_determine_operator_flags should
 // need to care.
 //
-#define _fm80   CONSTRUCT_FLAGS( 0, _m, 0, _80 )
-#define _fm64   CONSTRUCT_FLAGS( 0, _m, 0, _64 )
-#define _fm128  CONSTRUCT_FLAGS( 0, _m, 0, _128 )
-#define _fanysize (_64 | _80 | _112 | _224)
+#define _fm80   CONSTRUCT_FLAGS( 0, _m, 0, _f80 )
+#define _fm64   CONSTRUCT_FLAGS( 0, _m, 0, _f64 )
+#define _fm128  CONSTRUCT_FLAGS( 0, _m, 0, _f128 )
+#define _fanysize (_f64 | _f80 | _f112 )
 
 #define _float_m CONSTRUCT_FLAGS( _anysize, _float, 0, _fanysize)
 
 #define _st     CONSTRUCT_FLAGS( 0, _float, 0, _rst )   // stack register 0
-#define _m112   CONSTRUCT_FLAGS( 0, _m, 0, _112 )
-#define _m224   CONSTRUCT_FLAGS( 0, _m, 0, _224 )
+#define _m112   CONSTRUCT_FLAGS( 0, _m, 0, _f112 )
+#define _m224   _m112
 #define _m512   _m224
 #define _sti    CONSTRUCT_FLAGS( 0, _float, 0, _rsti )
 
 ////////////////// FLAGS /////////////////////////////////////
 
+#if 1
+// bit size                      5      3     3         7
+#define CONSTRUCT_FLAGS( uSizemask, aopty, amod, uRegmask ) \
+    ( (uSizemask) | (aopty) << 5 | (amod) << 8 | (uRegmask) << 11)
+
+#define ASM_GET_uSizemask(us)   ((us) & 0x1F)
+#define ASM_GET_aopty(us)       ((ASM_OPERAND_TYPE)(((us) >> 5) & 7))
+#define ASM_GET_amod(us)        ((ASM_MODIFIERS)(((us) >> 8) & 7))
+#define ASM_GET_uRegmask(us)    (((us) >> 11) & 0x7F)
+#else
 #define CONSTRUCT_FLAGS( uSizemask, aopty, amod, uRegmask ) \
     ( (uSizemask) | (aopty) << 4 | (amod) << 7 | (uRegmask) << 10)
 
@@ -148,14 +162,15 @@
 #define ASM_GET_aopty(us)       ((ASM_OPERAND_TYPE)(((us) & 0x70) >> 4))
 #define ASM_GET_amod(us)        ((ASM_MODIFIERS)(((us) & 0x380) >> 7))
 #define ASM_GET_uRegmask(us)    (((us) & 0xFC00) >> 10)
+#endif
 
-
-// For uSizemask (4 bits)
+// For uSizemask (5 bits)
 #define _8  0x1
 #define _16 0x2
 #define _32 0x4
 #define _48 0x8
-#define _anysize (_8 | _16 | _32 | _48 )
+#define _64 0x10
+#define _anysize (_8 | _16 | _32 | _48 | _64 )
 
 // For aopty (3 bits)
 enum ASM_OPERAND_TYPE {
@@ -182,16 +197,15 @@
     _flbl           // Label
 };
 
-// For uRegmask (6 bits)
+// For uRegmask (7 bits)
 
 // uRegmask flags when aopty == _float
 #define _rst    0x1
 #define _rsti   0x2
-#define _64     0x4
-#define _80     0x8
-#define _128    0x40
-#define _112    0x10
-#define _224    0x20
+#define _f64    0x4
+#define _f80    0x8
+#define _f112   0x10
+#define _f128   0x20
 
 // _seg register values (amod == _rseg)
 //
@@ -220,6 +234,8 @@
 #define _eax    CONSTRUCT_FLAGS( 0, 0, _normal, 0x04 )  // EAX register
 #define _dx     CONSTRUCT_FLAGS( 0, 0, _normal, 0x08 )  // DX register
 #define _cl     CONSTRUCT_FLAGS( 0, 0, _normal, 0x10 )  // CL register
+#define _rax    CONSTRUCT_FLAGS( 0, 0, _normal, 0x40 )  // RAX register
+
 
 #define _rplus_r        0x20
 #define _plus_r CONSTRUCT_FLAGS( 0, 0, 0, _rplus_r )
@@ -283,7 +299,7 @@
 
 typedef struct _PTRNTAB3 {
         unsigned usOpcode;
-        unsigned short usFlags;
+        unsigned usFlags;
         opflag_t usOp1;
         opflag_t usOp2;
         opflag_t usOp3;
@@ -291,21 +307,21 @@
 
 typedef struct _PTRNTAB2 {
         unsigned usOpcode;
-        unsigned short usFlags;
+        unsigned usFlags;
         opflag_t usOp1;
         opflag_t usOp2;
 } PTRNTAB2, * PPTRNTAB2, ** PPPTRNTAB2;
 
 typedef struct _PTRNTAB1 {
         unsigned usOpcode;
-        unsigned short usFlags;
+        unsigned usFlags;
         opflag_t usOp1;
 } PTRNTAB1, * PPTRNTAB1, ** PPPTRNTAB1;
 
 typedef struct _PTRNTAB0 {
         unsigned usOpcode;
         #define ASM_END 0xffff          // special opcode meaning end of table
-        unsigned short usFlags;
+        unsigned usFlags;
 } PTRNTAB0, * PPTRNTAB0, ** PPPTRNTAB0;
 
 typedef union _PTRNTAB {
diff -aruw dmd62/backend/machobj.c dmd63/backend/machobj.c
--- dmd62/backend/machobj.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/machobj.c	2010-08-09 14:33:14.000000000 -0400
@@ -1685,7 +1685,7 @@
  *      actual seg
  */
 
-int elf_data_start(Symbol *sdata,int datasize,int seg)
+int elf_data_start(Symbol *sdata, targ_size_t datasize, int seg)
 {
     targ_size_t alignbytes;
     //dbg_printf("elf_data_start(%s,size %d,seg %d)\n",sdata->Sident,datasize,seg);
@@ -2326,28 +2326,6 @@
 
 #endif
 
-/************************************
- * Output long word of data.
- * Input:
- *      seg     CODE, DATA, CDATA, UDATA
- *      offset  offset of start of data
- *      data    long word of data
- *   Present only if size == 2:
- *      lcfd    LCxxxx | FDxxxx
- *      if (FD_F2 | FD_T6)
- *              idx1 = external Symbol #
- *      else
- *              idx1 = frame datum
- *              idx2 = target datum
- */
-
-void obj_long(int seg,targ_size_t offset,unsigned long data,
-        unsigned lcfd,unsigned idx1,unsigned idx2)
-{
-    printf("obj_long\n");
-    exit(1);
-}
-
 /*************************************
  */
 
diff -aruw dmd62/backend/melf.h dmd63/backend/melf.h
--- dmd62/backend/melf.h	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/melf.h	2010-08-09 14:33:14.000000000 -0400
@@ -341,32 +341,35 @@
 
         // X86-64 Relocation types
 
-        #define R_X86_64_NONE      0
-        #define R_X86_64_64        1
-        #define R_X86_64_PC32      2
-        #define R_X86_64_GOT32     3
-        #define R_X86_64_PLT32     4
-        #define R_X86_64_COPY      5
-        #define R_X86_64_GLOB_DAT  6
-        #define R_X86_64_JUMP_SLOT 7
-        #define R_X86_64_RELATIVE  8
-        #define R_X86_64_GOTPCREL  9
-        #define R_X86_64_32       10
-        #define R_X86_64_32S      11
-        #define R_X86_64_16       12
-        #define R_X86_64_PC16     13
-        #define R_X86_64_8        14
-        #define R_X86_64_PC8      15
-        #define R_X86_64_DTPMOD64 16
-        #define R_X86_64_DTPOFF64 17
-        #define R_X86_64_TPOFF64  18
-        #define R_X86_64_TLSGD    19
-        #define R_X86_64_TLSLD    20
-        #define R_X86_64_DTPOFF32 21
-        #define R_X86_64_GOTTPOFF 22
-        #define R_X86_64_TPOFF32  23
-        #define R_X86_64_GNU_VTINHERIT 250
-        #define R_X86_64_GNU_VTENTRY   251
+        #define R_X86_64_NONE      0     // -- No relocation
+        #define R_X86_64_64        1     // 64 Direct 64 bit
+        #define R_X86_64_PC32      2     // 32 PC relative 32 bit signed
+        #define R_X86_64_GOT32     3     // 32 32 bit GOT entry
+        #define R_X86_64_PLT32     4     // 32 bit PLT address
+        #define R_X86_64_COPY      5     // -- Copy symbol at runtime
+        #define R_X86_64_GLOB_DAT  6     // 64 Create GOT entry
+        #define R_X86_64_JUMP_SLOT 7     // 64 Create PLT entry
+        #define R_X86_64_RELATIVE  8     // 64 Adjust by program base
+        #define R_X86_64_GOTPCREL  9     // 32 32 bit signed pc relative offset to GOT
+        #define R_X86_64_32       10     // 32 Direct 32 bit zero extended
+        #define R_X86_64_32S      11     // 32 Direct 32 bit sign extended
+        #define R_X86_64_16       12     // 16 Direct 16 bit zero extended
+        #define R_X86_64_PC16     13     // 16 16 bit sign extended pc relative
+        #define R_X86_64_8        14     //  8 Direct 8 bit sign extended
+        #define R_X86_64_PC8      15     //  8 8 bit sign extended pc relative
+        #define R_X86_64_DTPMOD64 16     // 64 ID of module containing symbol
+        #define R_X86_64_DTPOFF64 17     // 64 Offset in TLS block
+        #define R_X86_64_TPOFF64  18     // 64 Offset in initial TLS block
+        #define R_X86_64_TLSGD    19     // 32 PC relative offset to GD GOT block
+        #define R_X86_64_TLSLD    20     // 32 PC relative offset to LD GOT block
+        #define R_X86_64_DTPOFF32 21     // 32 Offset in TLS block
+        #define R_X86_64_GOTTPOFF 22     // 32 PC relative offset to IE GOT entry
+        #define R_X86_64_TPOFF32  23     // 32 Offset in initial TLS block
+        #define R_X86_64_PC64     24     // 64
+        #define R_X86_64_GOTOFF64 25     // 64
+        #define R_X86_64_GOTPC32  26     // 32
+        #define R_X86_64_GNU_VTINHERIT 250    // GNU C++ hack
+        #define R_X86_64_GNU_VTENTRY   251    // GNU C++ hack
 } Elf64_Rel;
 
 typedef struct {
diff -aruw dmd62/backend/nteh.c dmd63/backend/nteh.c
--- dmd62/backend/nteh.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/nteh.c	2010-08-09 14:33:14.000000000 -0400
@@ -418,7 +418,7 @@
         assert(config.exe & (EX_LINUX | EX_LINUX64 | EX_OSX | EX_OSX64 | EX_FREEBSD | EX_FREEBSD64 | EX_SOLARIS | EX_SOLARIS64));
         cs.Iop = 0x68;
         cs.Iflags = 0;
-        cs.Ijty = 0;
+        cs.Irex = 0;
         cs.IFL2 = FLconst;
         cs.IEV2.Vint = -2;
         return gen(CNIL,&cs);                   // PUSH -2
@@ -439,7 +439,7 @@
 
     cs.Iop = 0x68;
     cs.Iflags = 0;
-    cs.Ijty = 0;
+    cs.Irex = 0;
     cs.IFL2 = FLconst;
     cs.IEV2.Vint = -1;
     c1 = gen(CNIL,&cs);                 // PUSH -1
@@ -474,7 +474,7 @@
         cs.Iop = 0xFF;
         cs.Irm = modregrm(0,6,BPRM);
         cs.Iflags = CFfs;
-        cs.Ijty = 0;
+        cs.Irex = 0;
         cs.IFL1 = FLextern;
         cs.IEVsym1 = rtlsym[RTLSYM_EXCEPT_LIST];
         cs.IEVoffset1 = 0;
@@ -484,7 +484,7 @@
         cs.Iop = 0x8B;
         cs.Irm = modregrm(0,DX,BPRM);
         cs.Iflags = CFfs;
-        cs.Ijty = 0;
+        cs.Irex = 0;
         cs.IFL1 = FLextern;
         cs.IEVsym1 = rtlsym[RTLSYM_EXCEPT_LIST];
         cs.IEVoffset1 = 0;
@@ -529,7 +529,7 @@
     cs.Iop = 0x8B;
     cs.Irm = modregrm(2,reg,BPRM);
     cs.Iflags = 0;
-    cs.Ijty = 0;
+    cs.Irex = 0;
     cs.IFL1 = FLconst;
     // EBP offset of __context.prev
     cs.IEV1.Vint = nteh_EBPoffset_prev();
@@ -554,7 +554,7 @@
     cs.Iop = op;
     cs.Irm = modregrm(2,SP,BPRM);
     cs.Iflags = 0;
-    cs.Ijty = 0;
+    cs.Irex = 0;
     cs.IFL1 = FLconst;
     // EBP offset of __context.esp
     cs.IEV1.Vint = nteh_EBPoffset_esp();
@@ -585,7 +585,7 @@
         cs.Iop = 0x8B;
         cs.Irm = modregrm(2,AX,BPRM);
         cs.Iflags = 0;
-        cs.Ijty = 0;
+        cs.Irex = 0;
         cs.IFL1 = FLconst;
         // EBP offset of __context.info
         cs.IEV1.Vint = nteh_EBPoffset_info();
@@ -692,7 +692,7 @@
 
         cs.Iop = 0x68;
         cs.Iflags = CFoff;
-        cs.Ijty = 0;
+        cs.Irex = 0;
         cs.IFL2 = FLextern;
         cs.IEVsym2 = rtlsym[RTLSYM_CPP_LONGJMP];
         cs.IEVoffset2 = 0;
@@ -723,7 +723,7 @@
         cs.Iop = 0xFF;
         cs.Irm = modregrm(2,6,BPRM);
         cs.Iflags = 0;
-        cs.Ijty = 0;
+        cs.Irex = 0;
         cs.IFL1 = FLbprel;
         cs.IEVsym1 = nteh_contextsym();
         cs.IEVoffset1 = sindex_off;
@@ -733,7 +733,7 @@
 
         cs.Iop = 0x68;
         cs.Iflags = CFoff;
-        cs.Ijty = 0;
+        cs.Irex = 0;
         cs.IFL2 = FLextern;
         cs.IEVsym2 = rtlsym[RTLSYM_LONGJMP];
         cs.IEVoffset2 = 0;
@@ -755,7 +755,7 @@
 
     cs.Iop = 0x68;
     cs.Iflags = 0;
-    cs.Ijty = 0;
+    cs.Irex = 0;
     cs.IFL2 = FLconst;
     cs.IEV2.Vint = flag;
     c = gen(c,&cs);                     // PUSH flag
@@ -810,7 +810,7 @@
     cs.Iop = 0x8D;
     cs.Irm = modregrm(2,reg,BPRM);
     cs.Iflags = 0;
-    cs.Ijty = 0;
+    cs.Irex = 0;
     cs.IFL1 = FLconst;
     // EBP offset of __context.prev
     cs.IEV1.Vint = nteh_EBPoffset_prev();
@@ -843,7 +843,6 @@
 
 code *linux_unwind(regm_t retregs,unsigned index)
 {   code *c;
-    code cs;
     code *cs1;
     code *cs2;
     int i;
@@ -934,7 +933,7 @@
     cs.Iop = 0xFF;
     cs.Irm = modregrm(0,6,BPRM);
     cs.Iflags = CFfs;
-    cs.Ijty = 0;
+    cs.Irex = 0;
     cs.IFL1 = FLextern;
     cs.IEVsym1 = rtlsym[RTLSYM_EXCEPT_LIST];
     cs.IEVoffset1 = 0;
@@ -944,7 +943,7 @@
     cs.Iop = 0x8B;
     cs.Irm = modregrm(0,DX,BPRM);
     cs.Iflags = CFfs;
-    cs.Ijty = 0;
+    cs.Irex = 0;
     cs.IFL1 = FLextern;
     cs.IEVsym1 = rtlsym[RTLSYM_EXCEPT_LIST];
     cs.IEVoffset1 = 0;
@@ -1003,7 +1002,7 @@
     cs.Iop = 0x8F;
     cs.Irm = modregrm(0,0,BPRM);
     cs.Iflags = CFfs;
-    cs.Ijty = 0;
+    cs.Irex = 0;
     cs.IFL1 = FLextern;
     cs.IEVsym1 = rtlsym[RTLSYM_EXCEPT_LIST];
     cs.IEVoffset1 = 0;
diff -aruw dmd62/backend/optabgen.c dmd63/backend/optabgen.c
--- dmd62/backend/optabgen.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/optabgen.c	2010-08-09 14:33:14.000000000 -0400
@@ -763,7 +763,7 @@
     static tym_t _integral[] = { TYbool,TYchar,TYschar,TYuchar,TYshort,
                                  TYwchar_t,TYushort,TYenum,TYint,TYuint,
                                  TYlong,TYulong,TYllong,TYullong,TYdchar,
-                                 TYchar16 };
+                                 TYchar16, TYcent, TYucent };
     static tym_t _ref[]      = { TYnref,TYfref,TYref };
 #if TARGET_MAC
     static tym_t _func[]     = { TYnfunc,TYffunc,TYnpfunc,TYfpfunc,TYpsfunc,
@@ -777,7 +777,7 @@
 #if MARS
                                 TYwchar_t,
 #endif
-                                TYdchar,TYullong,TYchar16 };
+                                TYdchar,TYullong,TYucent,TYchar16 };
     static tym_t _mptr[]    = { TYmemptr };
     static tym_t _nullptr[] = { TYnullptr };
     static tym_t _fv[]      = { TYfptr, TYvptr };
@@ -826,6 +826,8 @@
 "dchar",        TYdchar,        TYdchar,   TYlong,      4,         0x86,0x78,
 "long long",    TYllong,        TYullong,  TYllong,     LLONGSIZE, 0x82,0x13,
 "uns long long",TYullong,       TYullong,  TYllong,     LLONGSIZE, 0x86,0x23,
+"cent",         TYcent,         TYucent,   TYcent,      16,        0x82,0x13,
+"ucent",        TYucent,        TYucent,   TYcent,      16,        0x86,0x23,
 "float",        TYfloat,        TYfloat,   TYfloat,     FLOATSIZE, 0x88,0x40,
 "double",       TYdouble,       TYdouble,  TYdouble,    DOUBLESIZE,0x89,0x41,
 "double alias", TYdouble_alias, TYdouble_alias,  TYdouble_alias,8, 0x89,0x41,
@@ -957,7 +959,7 @@
     }
     fprintf(f,"const tym_t tytouns[] =\n{ ");
     for (i = 0; i < arraysize(tytouns); i++)
-    {   fprintf(f,"0x%02lx,",tytouns[i]);
+    {   fprintf(f,"0x%02x,",tytouns[i]);
         if ((i & 7) == 7 && i < arraysize(tytouns) - 1)
             fprintf(f,"\n  ");
     }
@@ -984,7 +986,7 @@
     }
     fprintf(f,"unsigned char _tyrelax[] =\n{ ");
     for (i = 0; i < arraysize(_tyrelax); i++)
-    {   fprintf(f,"0x%02lx,",_tyrelax[i]);
+    {   fprintf(f,"0x%02x,",_tyrelax[i]);
         if ((i & 7) == 7 && i < arraysize(_tyrelax) - 1)
             fprintf(f,"\n  ");
     }
@@ -1001,7 +1003,7 @@
 
     fprintf(f,"unsigned char tyequiv[] =\n{ ");
     for (i = 0; i < arraysize(_tyequiv); i++)
-    {   fprintf(f,"0x%02lx,",_tyequiv[i]);
+    {   fprintf(f,"0x%02x,",_tyequiv[i]);
         if ((i & 7) == 7 && i < arraysize(_tyequiv) - 1)
             fprintf(f,"\n  ");
     }
diff -aruw dmd62/backend/outbuf.c dmd63/backend/outbuf.c
--- dmd62/backend/outbuf.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/outbuf.c	2010-08-09 14:33:14.000000000 -0400
@@ -143,11 +143,11 @@
 /**
  * Writes a 32 bit int.
  */
-void Outbuffer::write32(long v)
+void Outbuffer::write32(int v)
 {
     if (pend - p < 4)
         reserve(4);
-    *(long *)p = v;
+    *(int *)p = v;
     p += 4;
 }
 
@@ -260,7 +260,7 @@
     p = buf + size;
 }
 
-void Outbuffer::writesLEB128(long value)
+void Outbuffer::writesLEB128(int value)
 {
     int negative = (value < 0);
 
@@ -279,7 +279,7 @@
     }
 }
 
-void Outbuffer::writeuLEB128(unsigned long value)
+void Outbuffer::writeuLEB128(unsigned value)
 {
     do
     {   unsigned char b = value & 0x7F;
diff -aruw dmd62/backend/outbuf.h dmd63/backend/outbuf.h
--- dmd62/backend/outbuf.h	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/outbuf.h	2010-08-09 14:33:14.000000000 -0400
@@ -133,7 +133,7 @@
     /**
      * Writes a 32 bit int.
      */
-    void write32(long v);
+    void write32(int v);
 
     /**
      * Writes a 64 bit long.
@@ -173,7 +173,7 @@
     char *toString();
     void setsize(unsigned size);
 
-    void writesLEB128(long value);
-    void writeuLEB128(unsigned long value);
+    void writesLEB128(int value);
+    void writeuLEB128(unsigned value);
 
 };
diff -aruw dmd62/backend/out.c dmd63/backend/out.c
--- dmd62/backend/out.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/out.c	2010-08-09 14:33:14.000000000 -0400
@@ -433,14 +433,15 @@
                 offset += dt->DTazeros;
                 break;
             case DT_xoff:
-            {   symbol *sb;
-
-                sb = dt->DTsym;          // get external symbol pointer
+            {
+                symbol *sb = dt->DTsym;          // get external symbol pointer
                 a = dt->DToffset; // offset from it
                 if (tyreg(dt->Dty))
                     flags = CFoff;
                 else
                     flags = CFoff | CFseg;
+                if (I64)
+                    flags |= CFoffset64;
                 offset += reftoident(seg,offset,sb,a,flags);
                 break;
             }
diff -aruw dmd62/backend/ptrntab.c dmd63/backend/ptrntab.c
--- dmd62/backend/ptrntab.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/ptrntab.c	2010-08-09 14:33:14.000000000 -0400
@@ -517,6 +517,7 @@
         { 0xf6, _3,     _rm8 },
         { 0xf7, _3 | _16_bit,   _rm16 },
         { 0xf7, _3 | _32_bit,   _rm32 },
+        { 0xf7, _3 | _64_bit,   _rm64 },
         { ASM_END, 0, 0 }
 };
 PTRNTAB1 aptb1NOT[] = /* NOT */ {
@@ -530,6 +531,7 @@
         { 0x8f, _0 | _32_bit,   _m32},
         { 0x58, _rw | _16_bit, _r16 | _plus_r },
         { 0x58, _rd | _32_bit, _r32 | _plus_r },
+        { 0x58, _r | _64_bit,   _r64 | _plus_r },
         { 0x1f, 0,      _ds | _seg },
         { 0x07, _modes, _es | _seg},
         { 0x17, 0,      _ss | _seg},
@@ -540,8 +542,10 @@
 PTRNTAB1 aptb1PUSH[] = /* PUSH */ {
         { 0xff, _6 | _16_bit,   _m16 },
         { 0xff, _6 | _32_bit,   _m32 },
+        { 0xff, _6 | _64_bit,   _m64 },
         { 0x50, _r | _16_bit,   _r16 | _plus_r },
         { 0x50, _r | _32_bit,   _r32 | _plus_r },
+        { 0x50, _r | _64_bit,   _r64 | _plus_r },
         { 0x6a, 0,_imm8 },
         { 0x68, _16_bit,_imm16 },
         { 0x68, _16_bit,_rel16 },
@@ -808,6 +812,7 @@
                                                 // instruction
         { 0xfb1, _I386 | _cw | _16_bit|_mod2,   _rm16,  _r16 },
         { 0xfb1, _I386 | _cd | _32_bit|_mod2,   _rm32,  _r32 },
+        { 0xfb1, _I386 | _cq | _64_bit|_mod2,   _rm64,  _r64 },
         { ASM_END, 0, 0, 0 }
 };
 PTRNTAB2  aptb2DIV[] = /* DIV */ {
@@ -843,8 +848,8 @@
 };
 PTRNTAB2  aptb2INS[] = /* INS */ {
         { 0x6c, _modsi, _rm8, _dx },
-        { 0x6d, _modsi|_16_bit, _rm16 | _16_bit, _dx },
-        { 0x6d, _32_bit|_modsi, _rm32 | _32_bit, _dx },
+        { 0x6d, _modsi|_16_bit, _rm16, _dx },
+        { 0x6d, _32_bit|_modsi, _rm32, _dx },
         { ASM_END, 0, 0, 0 }
 };
 
@@ -904,9 +909,11 @@
         { 0x88, _r,             _rm8,           _r8             },
         { 0x89, _r|_16_bit,     _rm16,          _r16            },
         { 0x89, _r|_32_bit,     _rm32,          _r32            },
+        { 0x89, _r|_64_bit,     _rm64,          _r64            },
         { 0x8a, _r,             _r8,            _rm8            },
         { 0x8b, _r|_16_bit,     _r16,           _rm16           },
         { 0x8b, _r|_32_bit,     _r32,           _rm32           },
+        { 0x8b, _r|_64_bit,     _r64,           _rm64           },
         { 0x8c, _r,             _rm16,          _seg|_ds|_es| _ss | _fs | _gs | _cs },
         { 0x8e, _r,             _seg|_ds|_es|_ss|_fs|_gs|_cs,   _rm16 },
         { 0xb0, _rb,            _r8 | _plus_r,  _imm8           },
diff -aruw dmd62/backend/rtlsym.c dmd63/backend/rtlsym.c
--- dmd62/backend/rtlsym.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/rtlsym.c	2010-08-09 14:33:14.000000000 -0400
@@ -47,6 +47,7 @@
     if (!inited)
     {   inited++;
 
+        //printf("rtlsym_init()\n");
 #if MARS
         fregsaved = FREGSAVED;
 #endif
diff -aruw dmd62/backend/strtold.c dmd63/backend/strtold.c
--- dmd62/backend/strtold.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/strtold.c	2010-08-09 14:33:14.000000000 -0400
@@ -1,5 +1,5 @@
 // Copyright (C) 1985-1998 by Symantec
-// Copyright (C) 2000-2009 by Digital Mars
+// Copyright (C) 2000-2010 by Digital Mars
 // All Rights Reserved
 // http://www.digitalmars.com
 // Written by Walter Bright
@@ -32,7 +32,10 @@
 
 #if _WIN32 || linux || __APPLE__ || __FreeBSD__ || __sun&&__SVR4
 
-#if __GCC__
+#if 0
+/* This is for compilers that don't support hex float literals,
+ * and also makes it clearer what constants we're trying to use.
+ */
 
 static long double negtab[] =
         {1e-4096L,1e-2048L,1e-1024L,1e-512L,
@@ -42,6 +45,48 @@
         {1e+4096L,1e+2048L,1e+1024L,1e+512L,
          1e+256L,1e+128L,1e+64L,1e+32L,1e+16L,1e+8L,1e+4L,1e+2L,1e+1L};
 
+#elif defined(__GNUC__) && __FreeBSD__ && __i386__
+
+// GCC on FreeBSD/i386 incorrectly rounds long double constants to double precision.  Workaround:
+
+// Note that the [sizeof(long double)] takes care of whatever the 0 padding is for the
+// target platform
+
+static unsigned char _negtab_bytes[][sizeof(long double)] =
+        { { 0xDE,0x9F,0xCE,0xD2,0xC8,0x04,0xDD,0xA6,0xD8,0x0A,0xBF,0xBF },
+          { 0xE4,0x2D,0x36,0x34,0x4F,0x53,0xAE,0xCE,0x6B,0x25,0xBF,0xBF },
+          { 0xBE,0xC0,0x57,0xDA,0xA5,0x82,0xA6,0xA2,0xB5,0x32,0xBF,0xBF },
+          { 0x1C,0xD2,0x23,0xDB,0x32,0xEE,0x49,0x90,0x5A,0x39,0xBF,0xBF },
+          { 0x3A,0x19,0x7A,0x63,0x25,0x43,0x31,0xC0,0xAC,0x3C,0xBF,0xBF },
+          { 0xA1,0xE4,0xBC,0x64,0x7C,0x46,0xD0,0xDD,0x55,0x3E,0xBF,0xBF },
+          { 0xA5,0xE9,0x39,0xA5,0x27,0xEA,0x7F,0xA8,0x2A,0x3F,0xBF,0xBF },
+          { 0xBA,0x94,0x39,0x45,0xAD,0x1E,0xB1,0xCF,0x94,0x3F,0xBF,0xBF },
+          { 0x5B,0xE1,0x4D,0xC4,0xBE,0x94,0x95,0xE6,0xC9,0x3F,0xBF,0xBF },
+          { 0xFD,0xCE,0x61,0x84,0x11,0x77,0xCC,0xAB,0xE4,0x3F,0xBF,0xBF },
+          { 0x2C,0x65,0x19,0xE2,0x58,0x17,0xB7,0xD1,0xF1,0x3F,0xBF,0xBF },
+          { 0x0A,0xD7,0xA3,0x70,0x3D,0x0A,0xD7,0xA3,0xF8,0x3F,0xBF,0xBF },
+          { 0xCD,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xFB,0x3F,0xBF,0xBF },
+          { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0x3F,0xBF,0xBF } };
+
+static unsigned char _postab_bytes[][sizeof(long double)] =
+        { { 0x9B,0x97,0x20,0x8A,0x02,0x52,0x60,0xC4,0x25,0x75,0x18,0x28 },
+          { 0xE5,0x5D,0x3D,0xC5,0x5D,0x3B,0x8B,0x9E,0x92,0x5A,0x18,0x28 },
+          { 0x17,0x0C,0x75,0x81,0x86,0x75,0x76,0xC9,0x48,0x4D,0x18,0x28 },
+          { 0xC7,0x91,0x0E,0xA6,0xAE,0xA0,0x19,0xE3,0xA3,0x46,0x18,0x28 },
+          { 0x8E,0xDE,0xF9,0x9D,0xFB,0xEB,0x7E,0xAA,0x51,0x43,0x18,0x28 },
+          { 0xE0,0x8C,0xE9,0x80,0xC9,0x47,0xBA,0x93,0xA8,0x41,0x18,0x28 },
+          { 0xD5,0xA6,0xCF,0xFF,0x49,0x1F,0x78,0xC2,0xD3,0x40,0x18,0x28 },
+          { 0x9E,0xB5,0x70,0x2B,0xA8,0xAD,0xC5,0x9D,0x69,0x40,0x18,0x28 },
+          { 0x00,0x00,0x00,0x04,0xBF,0xC9,0x1B,0x8E,0x34,0x40,0x18,0x28 },
+          { 0x00,0x00,0x00,0x00,0x00,0x20,0xBC,0xBE,0x19,0x40,0x18,0x28 },
+          { 0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x9C,0x0C,0x40,0x18,0x28 },
+          { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x05,0x40,0x18,0x28 },
+          { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x02,0x40,0x18,0x28 },
+          { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0x3F,0x18,0x28 } };
+
+static long double *negtab = (long double *) _negtab_bytes;
+static long double *postab = (long double *) _postab_bytes;
+
 #else
 
 // Use exact values, computed separately, to bootstrap.
diff -aruw dmd62/backend/symbol.c dmd63/backend/symbol.c
--- dmd62/backend/symbol.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/symbol.c	2010-08-09 14:33:14.000000000 -0400
@@ -363,12 +363,14 @@
 
 void symbol_func(symbol *s)
 {
+    //printf("symbol_func(%s, x%x)\n", s->Sident, fregsaved);
     symbol_debug(s);
     s->Sfl = FLfunc;
     // Interrupt functions modify all registers
 #if TX86
     // BUG: do interrupt functions really save BP?
     #define mBP 0x20
+    // Note that fregsaved may not be set yet
     s->Sregsaved = (s->Stype && tybasic(s->Stype->Tty) == TYifunc) ? mBP : fregsaved;
     s->Sseg = UNKNOWN;          // don't know what segment it is in
 #endif
diff -aruw dmd62/backend/ty.h dmd63/backend/ty.h
--- dmd62/backend/ty.h	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/ty.h	2010-08-09 14:33:14.000000000 -0400
@@ -99,7 +99,11 @@
     TYhfunc             = 0x39, // C function with hidden parameter
     TYnref              = 0x3A, // near reference
     TYfref              = 0x3B, // far reference
-    TYMAX               = 0x3C,
+
+    TYcent              = 0x3C, // 128 bit signed integer
+    TYucent             = 0x3D, // 128 bit unsigned integer
+
+    TYMAX               = 0x3E,
 
 #if MARS
 #define TYaarray        TYnptr
@@ -193,6 +197,9 @@
 
 #define tyreal(ty)      (tytab[(ty) & 0xFF] & TYFLreal)
 
+// Fits into 64 bit register
+#define ty64reg(ty)     (tytab[(ty) & 0xFF] & (TYFLintegral | TYFLptr))
+
 #ifndef tyshort
 /* Types that are chars or shorts       */
 #define tyshort(ty)     (tytab[(ty) & 0xFF] & TYFLshort)
@@ -286,7 +293,7 @@
 
 // Determine if parameter can go in register for TYjfunc
 #ifndef tyjparam
-#define tyjparam(ty)    (tysize(ty) <= intsize && !tyfloating(ty) && tybasic(ty) != TYstruct && tybasic(ty) != TYarray)
+#define tyjparam(ty)    (tysize(ty) <= NPTRSIZE && !tyfloating(ty) && tybasic(ty) != TYstruct && tybasic(ty) != TYarray)
 #endif
 
 /* Determine relaxed type       */
diff -aruw dmd62/backend/var.c dmd63/backend/var.c
--- dmd62/backend/var.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/backend/var.c	2010-08-09 14:33:14.000000000 -0400
@@ -1,5 +1,5 @@
 // Copyright (C) 1985-1998 by Symantec
-// Copyright (C) 2000-2009 by Digital Mars
+// Copyright (C) 2000-2010 by Digital Mars
 // All Rights Reserved
 // http://www.digitalmars.com
 // Written by Walter Bright
@@ -173,8 +173,11 @@
  * Bit masks
  */
 
-const unsigned mask[16] =
-        {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,0x8000};
+const unsigned mask[32] =
+        {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,0x8000,
+         0x10000,0x20000,0x40000,0x80000,0x100000,0x200000,0x400000,0x800000,
+         0x1000000,0x2000000,0x4000000,0x8000000,
+         0x10000000,0x20000000,0x40000000,0x80000000};
 
 #if 0
 const unsigned long maskl[32] =
@@ -232,9 +235,10 @@
 
 /* From debug.c */
 #if DEBUG
-const char *regstring[16] = {"AX","CX","DX","BX","SP","BP","SI","DI",
-                            "8","ES","PSW","STACK","MEM","OTHER",
-                                "ST0", "ST01"};
+const char *regstring[32] = {"AX","CX","DX","BX","SP","BP","SI","DI",
+                             "R8","R9","R10","R11","R12","R13","R14","R15",
+                             "XMM0","XMM1","XMM2","XMM3","XMM4","XMM5","XMM6","XMM7",
+                             "ES","PSW","STACK","ST0", "ST01"};
 #endif
 
 /* From nwc.c */
diff -aruw dmd62/cppmangle.c dmd63/cppmangle.c
--- dmd62/cppmangle.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/cppmangle.c	2010-08-09 14:33:14.000000000 -0400
@@ -1,6 +1,6 @@
 
 // Compiler implementation of the D programming language
-// Copyright (c) 1999-2007 by Digital Mars
+// Copyright (c) 1999-2010 by Digital Mars
 // All Rights Reserved
 // written by Walter Bright
 // http://www.digitalmars.com
@@ -25,7 +25,7 @@
 #include "import.h"
 #include "aggregate.h"
 
-#if DMDV2
+#if CPP_MANGLE
 
 /* Do mangling for C++ linkage.
  * Follows Itanium C++ ABI 1.86
@@ -198,6 +198,9 @@
      * u <source-name>  # vendor extended type
      */
 
+    if (isConst())
+        buf->writeByte('K');
+
     switch (ty)
     {
         case Tvoid:     c = 'v';        break;
diff -aruw dmd62/declaration.c dmd63/declaration.c
--- dmd62/declaration.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/declaration.c	2010-08-09 14:33:14.000000000 -0400
@@ -616,6 +616,8 @@
     {   error("recursive alias declaration");
         aliassym = new TypedefDeclaration(loc, ident, Type::terror, NULL);
     }
+    else if (!aliassym && scope)
+        semantic(scope);
     Dsymbol *s = aliassym ? aliassym->toAlias() : this;
     return s;
 }
@@ -1319,6 +1321,9 @@
             nestedref = 1;
             fdv->nestedFrameRef = 1;
             //printf("var %s in function %s is nested ref\n", toChars(), fdv->toChars());
+            // __dollar creates problems because it isn't a real variable Bugzilla 3326
+            if (ident == Id::dollar)
+                ::error(loc, "cannnot use $ inside a function literal");
         }
     }
 }
diff -aruw dmd62/declaration.h dmd63/declaration.h
--- dmd62/declaration.h	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/declaration.h	2010-08-09 14:33:14.000000000 -0400
@@ -98,6 +98,14 @@
         int (*fp)(void *, FuncDeclaration *),
         void *param);
 
+enum Semantic
+{
+    SemanticStart,      // semantic has not been run
+    SemanticIn,         // semantic() is in progress
+    SemanticDone,       // semantic() has been run
+    Semantic2Done,      // semantic2() has been run
+};
+
 /**************************************************************/
 
 struct Declaration : Dsymbol
@@ -456,6 +464,13 @@
 
     void toDt(dt_t **pdt);
 };
+
+struct TypeInfoWildDeclaration : TypeInfoDeclaration
+{
+    TypeInfoWildDeclaration(Type *tinfo);
+
+    void toDt(dt_t **pdt);
+};
 #endif
 
 /**************************************************************/
@@ -598,6 +613,8 @@
     int isCodeseg();
     int isOverloadable();
     int isPure();
+    int isSafe();
+    int isTrusted();
     virtual int isNested();
     int needThis();
     virtual int isVirtual();
@@ -735,6 +752,17 @@
     StaticCtorDeclaration *isStaticCtorDeclaration() { return this; }
 };
 
+#if DMDV2
+struct SharedStaticCtorDeclaration : StaticCtorDeclaration
+{
+    SharedStaticCtorDeclaration(Loc loc, Loc endloc);
+    Dsymbol *syntaxCopy(Dsymbol *);
+    void toCBuffer(OutBuffer *buf, HdrGenState *hgs);
+
+    SharedStaticCtorDeclaration *isSharedStaticCtorDeclaration() { return this; }
+};
+#endif
+
 struct StaticDtorDeclaration : FuncDeclaration
 {   VarDeclaration *vgate;      // 'gate' variable
 
@@ -753,6 +781,17 @@
     StaticDtorDeclaration *isStaticDtorDeclaration() { return this; }
 };
 
+#if DMDV2
+struct SharedStaticDtorDeclaration : StaticDtorDeclaration
+{
+    SharedStaticDtorDeclaration(Loc loc, Loc endloc);
+    Dsymbol *syntaxCopy(Dsymbol *);
+    void toCBuffer(OutBuffer *buf, HdrGenState *hgs);
+
+    SharedStaticDtorDeclaration *isSharedStaticDtorDeclaration() { return this; }
+};
+#endif
+
 struct InvariantDeclaration : FuncDeclaration
 {
     InvariantDeclaration(Loc loc, Loc endloc);
@@ -768,7 +807,6 @@
     InvariantDeclaration *isInvariantDeclaration() { return this; }
 };
 
-
 struct UnitTestDeclaration : FuncDeclaration
 {
     UnitTestDeclaration(Loc loc, Loc endloc);
diff -aruw dmd62/dsymbol.c dmd63/dsymbol.c
--- dmd62/dsymbol.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/dsymbol.c	2010-08-09 14:33:14.000000000 -0400
@@ -286,6 +286,10 @@
  * Does semantic analysis on the public face of declarations.
  */
 
+void Dsymbol::semantic0(Scope *sc)
+{
+}
+
 void Dsymbol::semantic(Scope *sc)
 {
     error("%p has no semantic routine", this);
diff -aruw dmd62/dsymbol.h dmd63/dsymbol.h
--- dmd62/dsymbol.h	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/dsymbol.h	2010-08-09 14:33:14.000000000 -0400
@@ -143,6 +143,7 @@
     virtual int addMember(Scope *sc, ScopeDsymbol *s, int memnum);
     virtual void setScope(Scope *sc);
     virtual void importAll(Scope *sc);
+    virtual void semantic0(Scope *sc);
     virtual void semantic(Scope *sc);
     virtual void semantic2(Scope *sc);
     virtual void semantic3(Scope *sc);
diff -aruw dmd62/e2ir.c dmd63/e2ir.c
--- dmd62/e2ir.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/e2ir.c	2010-08-09 14:33:14.000000000 -0400
@@ -280,9 +280,15 @@
             e = el_una(op,tyret,ep);
     }
     else if (ep)
-        e = el_bin(OPcall,tyret,ec,ep);
+    {   e = el_bin(OPcall,tyret,ec,ep);
+        if (tf->varargs)
+            e->Eflags |= EFLAGS_variadic;
+    }
     else
-        e = el_una(OPucall,tyret,ec);
+    {   e = el_una(OPucall,tyret,ec);
+        if (tf->varargs)
+            e->Eflags |= EFLAGS_variadic;
+    }
 
     if (retmethod == RETstack)
     {
@@ -933,7 +939,7 @@
             print();
             type->print();
             type->toBasetype()->print();
-            printf("ty = %d, tym = %lx\n", type->ty, ty);
+            printf("ty = %d, tym = %x\n", type->ty, ty);
             assert(0);
     }
     return el_const(ty, &c);
@@ -1691,9 +1697,10 @@
     Type *tb1 = e1->type->toBasetype();
     Type *tb2 = e2->type->toBasetype();
 
-    if ((tb1->ty == Tarray || tb1->ty == Tsarray) &&
-        (tb2->ty == Tarray || tb2->ty == Tsarray) &&
-        op != OPeq
+    if ((tb1->ty == Tarray || tb1->ty == Tsarray ||
+         tb2->ty == Tarray || tb2->ty == Tsarray) &&
+        tb2->ty != Tvoid &&
+        op != OPeq && op != OPandand && op != OPoror
        )
     {
         error("Array operation %s not implemented", toChars());
@@ -1773,6 +1780,7 @@
                            ta->getTypeInfo(NULL)->toElem(irs),
                            NULL);
             e = el_bin(OPcall, TYdarray, el_var(rtlsym[RTLSYM_ARRAYCATNT]), ep);
+            e->Eflags |= EFLAGS_variadic;
 #else
             ep = el_params(
                            ep,
@@ -1780,6 +1788,7 @@
                            el_long(TYint, tn->size()),
                            NULL);
             e = el_bin(OPcall, TYdarray, el_var(rtlsym[RTLSYM_ARRAYCATN]), ep);
+            e->Eflags |= EFLAGS_variadic;
 #endif
         }
         else
@@ -4217,11 +4226,13 @@
 
     // call _d_arrayliteralT(ti, dim, ...)
     e = el_bin(OPcall,TYnptr,el_var(rtlsym[RTLSYM_ARRAYLITERALT]),e);
+    e->Eflags |= EFLAGS_variadic;
 #else
     e = el_param(e, el_long(TYint, tb->next->size()));
 
     // call _d_arrayliteral(size, dim, ...)
     e = el_bin(OPcall,TYnptr,el_var(rtlsym[RTLSYM_ARRAYLITERAL]),e);
+    e->Eflags |= EFLAGS_variadic;
 #endif
     if (tb->ty == Tarray)
     {
@@ -4270,6 +4281,7 @@
 
     // call _d_assocarrayliteralT(ti, dim, ...)
     e = el_bin(OPcall,TYnptr,el_var(rtlsym[RTLSYM_ASSOCARRAYLITERALT]),e);
+    e->Eflags |= EFLAGS_variadic;
 
     el_setLoc(e,loc);
     return e;
diff -aruw dmd62/enum.c dmd63/enum.c
--- dmd62/enum.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/enum.c	2010-08-09 14:33:14.000000000 -0400
@@ -49,6 +49,34 @@
     return ed;
 }
 
+void EnumDeclaration::semantic0(Scope *sc)
+{
+    /* This function is a hack to get around a significant problem.
+     * The members of anonymous enums, like:
+     *  enum { A, B, C }
+     * don't get installed into the symbol table until after they are
+     * semantically analyzed, yet they're supposed to go into the enclosing
+     * scope's table. Hence, when forward referenced, they come out as
+     * 'undefined'. The real fix is to add them in at addSymbol() time.
+     * But to get code to compile, we'll just do this quick hack at the moment
+     * to compile it if it doesn't depend on anything else.
+     */
+
+    if (isdone || !scope)
+        return;
+    if (!isAnonymous() || memtype)
+        return;
+    for (int i = 0; i < members->dim; i++)
+    {
+        EnumMember *em = ((Dsymbol *)members->data[i])->isEnumMember();
+        if (em && em->value)
+            return;
+    }
+
+    // Can do it
+    semantic(sc);
+}
+
 void EnumDeclaration::semantic(Scope *sc)
 {   int i;
     uinteger_t number;
diff -aruw dmd62/enum.h dmd63/enum.h
--- dmd62/enum.h	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/enum.h	2010-08-09 14:33:14.000000000 -0400
@@ -47,6 +47,7 @@
 
     EnumDeclaration(Loc loc, Identifier *id, Type *memtype);
     Dsymbol *syntaxCopy(Dsymbol *s);
+    void semantic0(Scope *sc);
     void semantic(Scope *sc);
     int oneMember(Dsymbol **ps);
     void toCBuffer(OutBuffer *buf, HdrGenState *hgs);
diff -aruw dmd62/expression.c dmd63/expression.c
--- dmd62/expression.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/expression.c	2010-08-09 14:33:14.000000000 -0400
@@ -50,148 +50,6 @@
 
 #define LOGSEMANTIC     0
 
-/**********************************
- * Set operator precedence for each operator.
- */
-
-// Operator precedence - greater values are higher precedence
-
-enum PREC
-{
-    PREC_zero,
-    PREC_expr,
-    PREC_assign,
-    PREC_cond,
-    PREC_oror,
-    PREC_andand,
-    PREC_or,
-    PREC_xor,
-    PREC_and,
-    PREC_equal,
-    PREC_rel,
-    PREC_shift,
-    PREC_add,
-    PREC_mul,
-    PREC_unary,
-    PREC_primary,
-};
-
-enum PREC precedence[TOKMAX];
-
-void initPrecedence()
-{
-    precedence[TOKdotvar] = PREC_primary;
-    precedence[TOKimport] = PREC_primary;
-    precedence[TOKidentifier] = PREC_primary;
-    precedence[TOKthis] = PREC_primary;
-    precedence[TOKsuper] = PREC_primary;
-    precedence[TOKint64] = PREC_primary;
-    precedence[TOKfloat64] = PREC_primary;
-    precedence[TOKnull] = PREC_primary;
-    precedence[TOKstring] = PREC_primary;
-    precedence[TOKarrayliteral] = PREC_primary;
-    precedence[TOKtypeid] = PREC_primary;
-    precedence[TOKis] = PREC_primary;
-    precedence[TOKassert] = PREC_primary;
-    precedence[TOKfunction] = PREC_primary;
-    precedence[TOKvar] = PREC_primary;
-#if DMDV2
-    precedence[TOKdefault] = PREC_primary;
-#endif
-
-    // post
-    precedence[TOKdotti] = PREC_primary;
-    precedence[TOKdot] = PREC_primary;
-//  precedence[TOKarrow] = PREC_primary;
-    precedence[TOKplusplus] = PREC_primary;
-    precedence[TOKminusminus] = PREC_primary;
-    precedence[TOKcall] = PREC_primary;
-    precedence[TOKslice] = PREC_primary;
-    precedence[TOKarray] = PREC_primary;
-
-    precedence[TOKaddress] = PREC_unary;
-    precedence[TOKstar] = PREC_unary;
-    precedence[TOKneg] = PREC_unary;
-    precedence[TOKuadd] = PREC_unary;
-    precedence[TOKnot] = PREC_unary;
-    precedence[TOKtobool] = PREC_add;
-    precedence[TOKtilde] = PREC_unary;
-    precedence[TOKdelete] = PREC_unary;
-    precedence[TOKnew] = PREC_unary;
-    precedence[TOKcast] = PREC_unary;
-
-    precedence[TOKmul] = PREC_mul;
-    precedence[TOKdiv] = PREC_mul;
-    precedence[TOKmod] = PREC_mul;
-
-    precedence[TOKadd] = PREC_add;
-    precedence[TOKmin] = PREC_add;
-    precedence[TOKcat] = PREC_add;
-
-    precedence[TOKshl] = PREC_shift;
-    precedence[TOKshr] = PREC_shift;
-    precedence[TOKushr] = PREC_shift;
-
-    precedence[TOKlt] = PREC_rel;
-    precedence[TOKle] = PREC_rel;
-    precedence[TOKgt] = PREC_rel;
-    precedence[TOKge] = PREC_rel;
-    precedence[TOKunord] = PREC_rel;
-    precedence[TOKlg] = PREC_rel;
-    precedence[TOKleg] = PREC_rel;
-    precedence[TOKule] = PREC_rel;
-    precedence[TOKul] = PREC_rel;
-    precedence[TOKuge] = PREC_rel;
-    precedence[TOKug] = PREC_rel;
-    precedence[TOKue] = PREC_rel;
-    precedence[TOKin] = PREC_rel;
-
-#if 0
-    precedence[TOKequal] = PREC_equal;
-    precedence[TOKnotequal] = PREC_equal;
-    precedence[TOKidentity] = PREC_equal;
-    precedence[TOKnotidentity] = PREC_equal;
-#else
-    /* Note that we changed precedence, so that < and != have the same
-     * precedence. This change is in the parser, too.
-     */
-    precedence[TOKequal] = PREC_rel;
-    precedence[TOKnotequal] = PREC_rel;
-    precedence[TOKidentity] = PREC_rel;
-    precedence[TOKnotidentity] = PREC_rel;
-#endif
-
-    precedence[TOKand] = PREC_and;
-
-    precedence[TOKxor] = PREC_xor;
-
-    precedence[TOKor] = PREC_or;
-
-    precedence[TOKandand] = PREC_andand;
-
-    precedence[TOKoror] = PREC_oror;
-
-    precedence[TOKquestion] = PREC_cond;
-
-    precedence[TOKassign] = PREC_assign;
-    precedence[TOKconstruct] = PREC_assign;
-    precedence[TOKblit] = PREC_assign;
-    precedence[TOKaddass] = PREC_assign;
-    precedence[TOKminass] = PREC_assign;
-    precedence[TOKcatass] = PREC_assign;
-    precedence[TOKmulass] = PREC_assign;
-    precedence[TOKdivass] = PREC_assign;
-    precedence[TOKmodass] = PREC_assign;
-    precedence[TOKshlass] = PREC_assign;
-    precedence[TOKshrass] = PREC_assign;
-    precedence[TOKushrass] = PREC_assign;
-    precedence[TOKandass] = PREC_assign;
-    precedence[TOKorass] = PREC_assign;
-    precedence[TOKxorass] = PREC_assign;
-
-    precedence[TOKcomma] = PREC_expr;
-}
-
 /*************************************************************
  * Given var, we need to get the
  * right 'this' pointer if var is in an outer class, but our
@@ -6194,6 +6052,11 @@
         AggregateDeclaration *ad = func->toParent()->isAggregateDeclaration();
         if (func->needThis())
             e1 = getRightThis(loc, sc, ad, e1, func);
+        if (ad && ad->isClassDeclaration() && ad->type != e1->type)
+        {   // A downcast is required for interfaces, see Bugzilla 3706
+            e1 = new CastExp(loc, e1, ad->type);
+            e1 = e1->semantic(sc);
+        }
     }
     return this;
 }
diff -aruw dmd62/freebsd.mak dmd63/freebsd.mak
--- dmd62/freebsd.mak	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/freebsd.mak	2010-08-09 14:33:14.000000000 -0400
@@ -3,7 +3,9 @@
 TK=tk
 ROOT=root
 
-CC=g++ -m32
+MODEL=-m32
+
+CC=g++ $(MODEL)
 
 #OPT=-g -g3
 #OPT=-O2
@@ -24,7 +26,7 @@
 
 DMD_OBJS = \
 	access.o array.o attrib.o bcomplex.o bit.o blockopt.o \
-	cast.o code.o cg.o cg87.o cgcod.o cgcs.o cgcv.o cgelem.o cgen.o \
+	cast.o code.o cg.o cg87.o cgcod.o cgcs.o cgelem.o cgen.o \
 	cgreg.o cgsched.o class.o cod1.o cod2.o cod3.o cod4.o cod5.o \
 	constfold.o irstate.o dchar.o cond.o debug.o \
 	declaration.o dsymbol.o dt.o dump.o e2ir.o ee.o eh.o el.o \
@@ -51,7 +53,7 @@
 	inifile.c iasm.c module.c scope.c dump.c init.h init.c attrib.h \
 	attrib.c opover.c class.c mangle.c bit.c tocsym.c func.c inline.c \
 	access.c complex_t.h irstate.h irstate.c glue.c msc.c ph.c tk.c \
-	s2ir.c todt.c e2ir.c util.c identifier.h parse.h objfile.h \
+	s2ir.c todt.c e2ir.c util.c identifier.h parse.h \
 	scope.h enum.h import.h mars.h module.h mtype.h dsymbol.h \
 	declaration.h lexer.h expression.h irstate.h statement.h eh.c \
 	utf.h utf.c staticassert.h staticassert.c unialpha.c \
@@ -91,7 +93,7 @@
 all: dmd
 
 dmd: $(DMD_OBJS)
-	gcc -m32 -lstdc++ $(COV) $(DMD_OBJS) -o dmd
+	gcc $(MODEL) -lstdc++ -lpthread $(COV) $(DMD_OBJS) -o dmd
 
 clean:
 	rm -f $(DMD_OBJS) dmd optab.o id.o impcnvgen idgen id.c id.h \
@@ -155,7 +157,7 @@
 	$(CC) -c $(CFLAGS) $<
 
 bcomplex.o: $C/bcomplex.c
-	$(CC) -c $(MFLAGS) $C/bcomplex.c
+	$(CC) -c $(MFLAGS) $<
 
 bit.o: expression.h bit.c
 	$(CC) -c -I$(ROOT) $(MFLAGS) bit.c
@@ -461,7 +463,7 @@
 	$(CC) -c $(GFLAGS) -I$(ROOT) $<
 
 strtold.o: $C/strtold.c
-	gcc -m32 -c $C/strtold.c
+	gcc $(MODEL) -c $C/strtold.c
 
 struct.o: struct.c
 	$(CC) -c $(CFLAGS) $<
diff -aruw dmd62/func.c dmd63/func.c
--- dmd62/func.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/func.c	2010-08-09 14:33:14.000000000 -0400
@@ -1037,7 +1037,6 @@
             if (fensure)
             {   returnLabel = new LabelDsymbol(Id::returnLabel);
                 LabelStatement *ls = new LabelStatement(0, Id::returnLabel, fensure);
-                ls->isReturnLabel = 1;
                 returnLabel->statement = ls;
             }
             sc2 = sc2->pop();
@@ -1217,19 +1216,38 @@
 #else
                 Type *t = argptr->type;
                 VarDeclaration *p;
-                unsigned offset;
+                unsigned offset = 0;
 
                 Expression *e1 = new VarExp(0, argptr);
+                // Find the last non-ref parameter
                 if (parameters && parameters->dim)
-                    p = (VarDeclaration *)parameters->data[parameters->dim - 1];
+                {
+                    int lastNonref = parameters->dim -1;
+                    p = (VarDeclaration *)parameters->data[lastNonref];
+                    /* The trouble with out and ref parameters is that taking
+                     * the address of it doesn't work, because later processing
+                     * adds in an extra level of indirection. So we skip over them.
+                     */
+                    while (p->storage_class & (STCout | STCref))
+                    {
+                        --lastNonref;
+                        offset += PTRSIZE;
+                        if (lastNonref < 0)
+                        {
+                            p = v_arguments;
+                            break;
+                        }
+                        p = (VarDeclaration *)parameters->data[lastNonref];
+                    }
+                }
                 else
                     p = v_arguments;            // last parameter is _arguments[]
                 if (p->storage_class & STClazy)
                     // If the last parameter is lazy, it's the size of a delegate
-                    offset = PTRSIZE * 2;
+                    offset += PTRSIZE * 2;
                 else
-                    offset = p->type->size();
-                offset = (offset + 3) & ~3;     // assume stack aligns on 4
+                    offset += p->type->size();
+                offset = (offset + PTRSIZE - 1) & ~(PTRSIZE - 1);  // assume stack aligns on pointer size
                 Expression *e = new SymOffExp(0, p, offset);
                 e->type = Type::tvoidptr;
                 //e = e->semantic(sc);
diff -aruw dmd62/glue.c dmd63/glue.c
--- dmd62/glue.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/glue.c	2010-08-09 14:33:14.000000000 -0400
@@ -1,6 +1,6 @@
 
 // Compiler implementation of the D programming language
-// Copyright (c) 1999-2009 by Digital Mars
+// Copyright (c) 1999-2010 by Digital Mars
 // All Rights Reserved
 // written by Walter Bright
 // http://www.digitalmars.com
@@ -53,10 +53,16 @@
 elem *eictor;
 symbol *ictorlocalgot;
 elem *ector;
+Array ectorgates;
 elem *edtor;
 elem *etest;
 
+elem *esharedctor;
+Array esharedctorgates;
+elem *eshareddtor;
+
 int dtorcount;
+int shareddtorcount;
 
 char *lastmname;
 
@@ -104,7 +110,7 @@
         Identifier *id = new Identifier(idstr, TOKidentifier);
 
         Module *md = new Module(mname, id, 0, 0);
-        md->members = new Array();
+        md->members = new Dsymbols();
         md->members->push(s);   // its only 'member' is s
         if (m)
         {
@@ -112,6 +118,7 @@
             md->md = m->md;
             md->aimports.push(m);       // it only 'imports' m
             md->massert = m->massert;
+            md->munittest = m->munittest;
             md->marray = m->marray;
         }
 
@@ -206,9 +213,14 @@
     eictor = NULL;
     ictorlocalgot = NULL;
     ector = NULL;
+    ectorgates.setDim(0);
     edtor = NULL;
+    esharedctor = NULL;
+    esharedctorgates.setDim(0);
+    eshareddtor = NULL;
     etest = NULL;
     dtorcount = 0;
+    shareddtorcount = 0;
 
     if (doppelganger)
     {
@@ -343,6 +355,18 @@
         {
             localgot = NULL;
             sctor = toSymbolX("__modctor", SCglobal, t, moddeco);
+#if DMDV2
+            cstate.CSpsymtab = &sctor->Sfunc->Flocsym;
+
+            for (int i = 0; i < ectorgates.dim; i++)
+            {   StaticDtorDeclaration *f = (StaticDtorDeclaration *)ectorgates.data[i];
+
+                Symbol *s = f->vgate->toSymbol();
+                elem *e = el_var(s);
+                e = el_bin(OPaddass, TYint, e, el_long(TYint, 1));
+                ector = el_combine(ector, e);
+            }
+#endif
 
             block *b = block_calloc();
             b->BC = BCret;
@@ -366,6 +390,45 @@
             writefunc(sdtor);
         }
 
+#if DMDV2
+        if (esharedctor || esharedctorgates.dim)
+        {
+            localgot = NULL;
+            ssharedctor = toSymbolX("__modsharedctor", SCglobal, t, moddeco);
+            cstate.CSpsymtab = &ssharedctor->Sfunc->Flocsym;
+
+            for (int i = 0; i < esharedctorgates.dim; i++)
+            {   SharedStaticDtorDeclaration *f = (SharedStaticDtorDeclaration *)esharedctorgates.data[i];
+
+                Symbol *s = f->vgate->toSymbol();
+                elem *e = el_var(s);
+                e = el_bin(OPaddass, TYint, e, el_long(TYint, 1));
+                esharedctor = el_combine(esharedctor, e);
+            }
+
+            block *b = block_calloc();
+            b->BC = BCret;
+            b->Belem = esharedctor;
+            ssharedctor->Sfunc->Fstartblock = b;
+            writefunc(ssharedctor);
+#if STATICCTOR
+            obj_staticctor(ssharedctor, shareddtorcount, 1);
+#endif
+        }
+
+        if (eshareddtor)
+        {
+            localgot = NULL;
+            sshareddtor = toSymbolX("__modshareddtor", SCglobal, t, moddeco);
+
+            block *b = block_calloc();
+            b->BC = BCret;
+            b->Belem = eshareddtor;
+            sshareddtor->Sfunc->Fstartblock = b;
+            writefunc(sshareddtor);
+        }
+#endif
+
         if (etest)
         {
             localgot = NULL;
@@ -390,7 +453,7 @@
 
     if (global.params.multiobj)
     {   /* This is necessary because the main .obj for this module is written
-         * first, but determining whether marray or massert are needed is done
+         * first, but determining whether marray or massert or munittest are needed is done
          * possibly later in the doppelganger modules.
          * Another way to fix it is do the main one last.
          */
@@ -402,21 +465,26 @@
     // If module assert
     for (int i = 0; i < 2; i++)
     {
-        Symbol *ma = i ? marray : massert;
+        Symbol *ma;
+        unsigned rt;
+        switch (i)
+        {
+            case 0:     ma = marray;    rt = RTLSYM_DARRAY;     break;
+            case 1:     ma = massert;   rt = RTLSYM_DASSERT;   break;
+            case 2:     ma = munittest; rt = RTLSYM_DUNITTESTM; break;
+            default:    assert(0);
+        }
 
         if (ma)
         {
             elem *elinnum;
-            elem *efilename;
 
             localgot = NULL;
 
             // Call dassert(filename, line)
             // Get sole parameter, linnum
             {
-                Symbol *sp;
-
-                sp = symbol_calloc("linnum");
+                Symbol *sp = symbol_calloc("linnum");
                 sp->Stype = type_fake(TYint);
                 sp->Stype->Tcount++;
                 sp->Sclass = SCfastpar;
@@ -429,9 +497,9 @@
                 elinnum = el_var(sp);
             }
 
-            efilename = toEmodulename();
+            elem *efilename = toEmodulename();
 
-            elem *e = el_var(rtlsym[i ? RTLSYM_DARRAY : RTLSYM_DASSERT]);
+            elem *e = el_var(rtlsym[rt]);
             e = el_bin(OPcall, TYvoid, e, el_param(elinnum, efilename));
 
             block *b = block_calloc();
@@ -459,8 +527,6 @@
 
 void FuncDeclaration::toObjFile(int multiobj)
 {
-    Symbol *s;
-    func_t *f;
     Symbol *senter;
     Symbol *sexit;
     FuncDeclaration *func = this;
@@ -469,7 +535,7 @@
     int i;
     int has_arguments;
 
-    //printf("FuncDeclaration::toObjFile(%p, %s)\n", func, func->toChars());
+    //printf("FuncDeclaration::toObjFile(%p, %s.%s)\n", func, parent->toChars(), func->toChars());
 #if 0
     //printf("line = %d\n",func->getWhere() / LINEINC);
     EEcontext *ee = env->getEEcontext();
@@ -502,8 +568,8 @@
     if (global.params.verbose)
         printf("function  %s\n",func->toChars());
 
-    s = func->toSymbol();
-    f = s->Sfunc;
+    Symbol *s = func->toSymbol();
+    func_t *f = s->Sfunc;
 
 #if TARGET_WINDOS
     /* This is done so that the 'this' pointer on the stack is the same
@@ -670,9 +736,8 @@
     if (reverse)
     {   // Reverse params[] entries
         for (i = 0; i < pi/2; i++)
-        {   Symbol *sptmp;
-
-            sptmp = params[i];
+        {
+            Symbol *sptmp = params[i];
             params[i] = params[pi - 1 - i];
             params[pi - 1 - i] = sptmp;
         }
@@ -723,9 +788,45 @@
         symbol_add(sp);
     }
 
-    // First parameter goes in register
+    // Determine register assignments
     if (pi)
     {
+        if (global.params.isX86_64)
+        {
+            // Order of assignment of pointer or integer parameters
+            static const unsigned char argregs[6] = { DI,SI,DX,CX,R8,R9 };
+            int r = 0;
+            int xmmcnt = XMM0;
+
+            for (int i = 0; i < pi; i++)
+            {   Symbol *sp = params[i];
+                tym_t ty = tybasic(sp->Stype->Tty);
+                // BUG: doesn't work for structs
+                if (r < sizeof(argregs)/sizeof(argregs[0]))
+                {
+                    if (type_jparam(sp->Stype))
+                    {
+                        sp->Sclass = SCfastpar;
+                        sp->Spreg = argregs[r];
+                        sp->Sfl = FLauto;
+                        ++r;
+                    }
+                }
+                if (xmmcnt < XMM7)
+                {
+                    if (tyfloating(ty) && tysize(ty) <= 8)
+                    {
+                        sp->Sclass = SCfastpar;
+                        sp->Spreg = xmmcnt;
+                        sp->Sfl = FLauto;
+                        ++xmmcnt;
+                    }
+                }
+            }
+        }
+        else
+        {
+            // First parameter goes in register
         Symbol *sp = params[0];
         if ((tyf == TYjfunc || tyf == TYmfunc) &&
             type_jparam(sp->Stype))
@@ -735,6 +836,7 @@
             //printf("'%s' is SCfastpar\n",sp->Sident);
         }
     }
+    }
 
     if (func->fbody)
     {   block *b;
@@ -753,6 +855,9 @@
         bx.member = func;
         bx.module = getModule();
         irs.blx = &bx;
+#if DMDV2
+        buildClosure(&irs);
+#endif
 
 #if 0
         if (func->isSynchronized())
@@ -826,14 +931,46 @@
     }
 
     // If static constructor
-    if (isStaticConstructor())
+#if DMDV2
+    if (isSharedStaticCtorDeclaration())        // must come first because it derives from StaticCtorDeclaration
+    {
+        elem *e = el_una(OPucall, TYvoid, el_var(s));
+        esharedctor = el_combine(esharedctor, e);
+    }
+    else
+#endif
+    if (isStaticCtorDeclaration())
     {
         elem *e = el_una(OPucall, TYvoid, el_var(s));
         ector = el_combine(ector, e);
     }
 
     // If static destructor
-    if (isStaticDestructor())
+#if DMDV2
+    if (isSharedStaticDtorDeclaration())        // must come first because it derives from StaticDtorDeclaration
+    {
+        elem *e;
+
+#if STATICCTOR
+        e = el_bin(OPcall, TYvoid, el_var(rtlsym[RTLSYM_FATEXIT]), el_ptr(s));
+        esharedctor = el_combine(esharedctor, e);
+        shareddtorcount++;
+#else
+        SharedStaticDtorDeclaration *f = isSharedStaticDtorDeclaration();
+        assert(f);
+        if (f->vgate)
+        {   /* Increment destructor's vgate at construction time
+             */
+            esharedctorgates.push(f);
+        }
+
+        e = el_una(OPucall, TYvoid, el_var(s));
+        eshareddtor = el_combine(e, eshareddtor);
+#endif
+    }
+    else
+#endif
+    if (isStaticDtorDeclaration())
     {
         elem *e;
 
@@ -845,7 +982,7 @@
         StaticDtorDeclaration *f = isStaticDtorDeclaration();
         assert(f);
         if (f->vgate)
-        {   /* Increment vgate at construction time
+        {   /* Increment destructor's vgate at construction time
              */
             Symbol *s = f->vgate->toSymbol();
             e = el_var(s);
@@ -940,7 +1077,11 @@
         case Tpointer:  t = TYnptr;     break;
         case Tdelegate: t = TYdelegate; break;
         case Tarray:    t = TYdarray;   break;
+#if SARRAYVALUE
+        case Tsarray:   t = TYstruct;   break;
+#else
         case Tsarray:   t = TYarray;    break;
+#endif
         case Tstruct:   t = TYstruct;   break;
 
         case Tenum:
@@ -972,6 +1113,7 @@
         case 0:
             break;
         case MODconst:
+        case MODwild:
             t |= mTYconst;
             break;
         case MODimmutable:
@@ -980,6 +1122,7 @@
         case MODshared:
             t |= mTYshared;
             break;
+        case MODshared | MODwild:
         case MODshared | MODconst:
             t |= mTYshared | mTYconst;
             break;
diff -aruw dmd62/iasm.c dmd63/iasm.c
--- dmd62/iasm.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/iasm.c	2010-08-09 14:33:14.000000000 -0400
@@ -1,7 +1,7 @@
 
 /*
  * Copyright (c) 1992-1999 by Symantec
- * Copyright (c) 1999-2009 by Digital Mars
+ * Copyright (c) 1999-2010 by Digital Mars
  * All Rights Reserved
  * http://www.digitalmars.com
  * Written by Mike Cote, John Micco and Walter Bright
@@ -37,6 +37,7 @@
 #include        "scope.h"
 #include        "init.h"
 #include        "enum.h"
+#include        "module.h"
 
 // C/C++ compiler
 #define SCOPE_H 1               // avoid conflicts with D's Scope
@@ -55,8 +56,12 @@
 
 // I32 isn't set correctly yet because this is the front end, and I32
 // is a backend flag
+#undef I16
 #undef I32
+#undef I64
+#define I16 0
 #define I32 (global.params.isX86_64 == 0)
+#define I64 (global.params.isX86_64 == 1)
 
 //#define EXTRA_DEBUG 1
 
@@ -105,7 +110,7 @@
     "bad integral operand",
     "identifier expected",
     "not struct",
-    "nops expected",
+    "%u operands found for %s instead of the expected %u",
     "bad type/size of operands '%s'",
     "constant initializer expected",
     "undefined identifier '%s'",
@@ -306,6 +311,115 @@
 "XMM7", 7,      _xmm,
 };
 
+// 64 bit only registers
+#define _RAX    0
+#define _RBX    3
+#define _RCX    1
+#define _RDX    2
+#define _RSI    6
+#define _RDI    7
+#define _RBP    5
+#define _RSP    4
+#define _R8     8
+#define _R9     9
+#define _R10    10
+#define _R11    11
+#define _R12    12
+#define _R13    13
+#define _R14    14
+#define _R15    15
+
+#define _R8D    8
+#define _R9D    9
+#define _R10D   10
+#define _R11D   11
+#define _R12D   12
+#define _R13D   13
+#define _R14D   14
+#define _R15D   15
+
+#define _R8W    8
+#define _R9W    9
+#define _R10W   10
+#define _R11W   11
+#define _R12W   12
+#define _R13W   13
+#define _R14W   13
+#define _R15W   15
+
+#define _SIL    6
+#define _DIL    7
+#define _BPL    5
+#define _SPL    4
+#define _R8B    8
+#define _R9B    9
+#define _R10B   10
+#define _R11B   11
+#define _R12B   12
+#define _R13B   13
+#define _R14B   14
+#define _R15B   15
+
+static REG regtab64[] =
+{
+"RAX",  _RAX,   _r64 | _rax,
+"RBX",  _RBX,   _r64,
+"RCX",  _RCX,   _r64,
+"RDX",  _RDX,   _r64,
+"RSI",  _RSI,   _r64,
+"RDI",  _RDI,   _r64,
+"RBP",  _RBP,   _r64,
+"RSP",  _RSP,   _r64,
+"R8",   _R8,    _r64,
+"R9",   _R9,    _r64,
+"R10",  _R10,   _r64,
+"R11",  _R11,   _r64,
+"R12",  _R12,   _r64,
+"R13",  _R13,   _r64,
+"R14",  _R14,   _r64,
+"R15",  _R15,   _r64,
+
+"R8D",  _R8D,   _r32,
+"R9D",  _R9D,   _r32,
+"R10D", _R10D,  _r32,
+"R11D", _R11D,  _r32,
+"R12D", _R12D,  _r32,
+"R13D", _R13D,  _r32,
+"R14D", _R14D,  _r32,
+"R15D", _R15D,  _r32,
+
+"R8W",  _R8W,   _r16,
+"R9W",  _R9W,   _r16,
+"R10W", _R10W,  _r16,
+"R11W", _R11W,  _r16,
+"R12W", _R12W,  _r16,
+"R13W", _R13W,  _r16,
+"R14W", _R14W,  _r16,
+"R15W", _R15W,  _r16,
+
+"SIL",  _SIL,   _r8,
+"DIL",  _DIL,   _r8,
+"BPL",  _BPL,   _r8,
+"SPL",  _SPL,   _r8,
+"R8B",  _R8B,   _r8,
+"R9B",  _R9B,   _r8,
+"R10B", _R10B,  _r8,
+"R11B", _R11B,  _r8,
+"R12B", _R12B,  _r8,
+"R13B", _R13B,  _r8,
+"R14B", _R14B,  _r8,
+"R15B", _R15B,  _r8,
+
+"XMM8",   8,    _xmm,
+"XMM9",   9,    _xmm,
+"XMM10", 10,    _xmm,
+"XMM11", 11,    _xmm,
+"XMM12", 12,    _xmm,
+"XMM13", 13,    _xmm,
+"XMM14", 14,    _xmm,
+"XMM15", 15,    _xmm,
+};
+
 typedef enum {
     ASM_JUMPTYPE_UNSPECIFIED,
     ASM_JUMPTYPE_SHORT,
@@ -368,7 +482,7 @@
         unsigned char *puchOpcode, unsigned *pusIdx,
 #endif
         code *pc,
-        unsigned short usFlags,
+        unsigned usFlags,
         OPND *popnd, OPND *popnd2);
 STATIC regm_t asm_modify_regs(PTRNTAB ptb, OPND *popnd1, OPND *popnd2);
 STATIC void asm_output_flags(opflag_t usFlags);
@@ -388,7 +502,7 @@
 STATIC code *asm_db_parse(OP *pop);
 STATIC code *asm_da_parse(OP *pop);
 
-unsigned short compute_hashkey(char *);
+unsigned compute_hashkey(char *);
 
 
 /*******************************
@@ -437,12 +551,9 @@
         unsigned usNumops;
         unsigned usActual;
         PTRNTAB ptbRet = { NULL };
-        opflag_t usFlags1 = 0 ;
-        opflag_t usFlags2 = 0;
-        opflag_t usFlags3 = 0;
-        PTRNTAB1 *pptb1;
-        PTRNTAB2 *pptb2;
-        PTRNTAB3 *pptb3;
+        opflag_t opflags1 = 0 ;
+        opflag_t opflags2 = 0;
+        opflag_t opflags3 = 0;
         char    bFake = FALSE;
 
         unsigned char   bMatch1, bMatch2, bMatch3, bRetry = FALSE;
@@ -454,17 +565,17 @@
             usNumops = 0;
         else
         {
-            popnd1->usFlags = usFlags1 = asm_determine_operand_flags(popnd1);
+            popnd1->usFlags = opflags1 = asm_determine_operand_flags(popnd1);
             if (!popnd2)
                 usNumops = 1;
             else
             {
-                popnd2->usFlags = usFlags2 = asm_determine_operand_flags(popnd2);
+                popnd2->usFlags = opflags2 = asm_determine_operand_flags(popnd2);
                 if (!popnd3)
                     usNumops = 2;
                 else
                 {
-                    popnd3->usFlags = usFlags3 = asm_determine_operand_flags(popnd3);
+                    popnd3->usFlags = opflags3 = asm_determine_operand_flags(popnd3);
                     usNumops = 3;
                 }
             }
@@ -478,6 +589,9 @@
 PARAM_ERROR:
                 asmerr(EM_nops_expected, usActual, asm_opstr(pop), usNumops);
         }
+        if (usActual < usNumops)
+            *pusNumops = usActual;
+        else
         *pusNumops = usNumops;
 //
 //      The number of arguments matches, now check to find the opcode
@@ -492,38 +606,40 @@
                 goto RETURN_IT;
 
             case 1:
-                //printf("usFlags1 = "); asm_output_flags(usFlags1); printf("\n");
-                for (pptb1 = pop->ptb.pptb1; pptb1->usOpcode != ASM_END;
-                        pptb1++)
-                {
-                        //printf("table    = "); asm_output_flags(pptb1->usOp1); printf("\n");
-                        bMatch1 = asm_match_flags(usFlags1, pptb1->usOp1);
+            {   //printf("opflags1 = "); asm_output_flags(opflags1); printf("\n");
+                PTRNTAB1 *table1;
+                for (table1 = pop->ptb.pptb1; table1->usOpcode != ASM_END;
+                        table1++)
+                {
+                        //printf("table    = "); asm_output_flags(table1->usOp1); printf("\n");
+                        bMatch1 = asm_match_flags(opflags1, table1->usOp1);
+                        //printf("bMatch1 = x%x\n", bMatch1);
                         if (bMatch1)
-                        {   if (pptb1->usOpcode == 0x68 &&
-                                I32 &&
-                                pptb1->usOp1 == _imm16
+                        {   if (table1->usOpcode == 0x68 &&
+                                !I16 &&
+                                table1->usOp1 == _imm16
                               )
                                 // Don't match PUSH imm16 in 32 bit code
                                 continue;
                             break;
                         }
                         if ((asmstate.ucItype == ITimmed) &&
-                            asm_match_flags(usFlags1,
+                            asm_match_flags(opflags1,
                                 CONSTRUCT_FLAGS(_8 | _16 | _32, _imm, _normal,
                                                  0)) &&
-                                popnd1->disp == pptb1->usFlags)
+                                popnd1->disp == table1->usFlags)
                             break;
                         if ((asmstate.ucItype == ITopt ||
                              asmstate.ucItype == ITfloat) &&
                             !usNumops &&
-                            !pptb1->usOp1)
+                            !table1->usOp1)
                         {
                             if (usNumops > 1)
                                 goto PARAM_ERROR;
                             break;
                         }
                 }
-                if (pptb1->usOpcode == ASM_END)
+                if (table1->usOpcode == ASM_END)
                 {
 #ifdef DEBUG
                     if (debuga)
@@ -551,7 +667,7 @@
 TYPE_SIZE_ERROR:
                         if (popnd1 && ASM_GET_aopty(popnd1->usFlags) != _reg)
                         {
-                            usFlags1 = popnd1->usFlags |= _anysize;
+                            opflags1 = popnd1->usFlags |= _anysize;
                             if (asmstate.ucItype == ITjump)
                             {
                                 if (bRetry && popnd1->s && !popnd1->s->isLabel())
@@ -564,13 +680,13 @@
                             }
                         }
                         if (popnd2 && ASM_GET_aopty(popnd2->usFlags) != _reg) {
-                            usFlags2 = popnd2->usFlags |= (_anysize);
+                            opflags2 = popnd2->usFlags |= (_anysize);
                             if (asmstate.ucItype == ITjump)
                                 popnd2->usFlags |= CONSTRUCT_FLAGS(0, 0, 0,
                                         _fanysize);
                         }
                         if (popnd3 && ASM_GET_aopty(popnd3->usFlags) != _reg) {
-                            usFlags3 = popnd3->usFlags |= (_anysize);
+                            opflags3 = popnd3->usFlags |= (_anysize);
                             if (asmstate.ucItype == ITjump)
                                 popnd3->usFlags |= CONSTRUCT_FLAGS(0, 0, 0,
                                         _fanysize);
@@ -583,35 +699,36 @@
                         goto RETRY;
 
                 }
-                ptbRet.pptb1 = pptb1;
+                ptbRet.pptb1 = table1;
                 goto RETURN_IT;
-
+            }
             case 2:
-                //printf("usFlags1 = "); asm_output_flags(usFlags1); printf(" ");
-                //printf("usFlags2 = "); asm_output_flags(usFlags2); printf("\n");
-                for (pptb2 = pop->ptb.pptb2;
-                     pptb2->usOpcode != ASM_END;
-                     pptb2++)
-                {
-                        //printf("table1   = "); asm_output_flags(pptb2->usOp1); printf(" ");
-                        //printf("table2   = "); asm_output_flags(pptb2->usOp2); printf("\n");
-                        bMatch1 = asm_match_flags(usFlags1, pptb2->usOp1);
-                        bMatch2 = asm_match_flags(usFlags2, pptb2->usOp2);
+            {   //printf("opflags1 = "); asm_output_flags(opflags1); printf(" ");
+                //printf("opflags2 = "); asm_output_flags(opflags2); printf("\n");
+                PTRNTAB2 *table2;
+                for (table2 = pop->ptb.pptb2;
+                     table2->usOpcode != ASM_END;
+                     table2++)
+                {
+                        //printf("table1   = "); asm_output_flags(table2->usOp1); printf(" ");
+                        //printf("table2   = "); asm_output_flags(table2->usOp2); printf("\n");
+                        bMatch1 = asm_match_flags(opflags1, table2->usOp1);
+                        bMatch2 = asm_match_flags(opflags2, table2->usOp2);
                         //printf("match1 = %d, match2 = %d\n",bMatch1,bMatch2);
                         if (bMatch1 && bMatch2) {
 
                             //printf("match\n");
 
-// OK, if they both match and the first op in the table is not AL
-// or size of 8 and the second is immediate 8,
-// then check to see if the constant
-// is a signed 8 bit constant.  If so, then do not match, otherwise match
-//
+                            /* If they both match and the first op in the table is not AL
+                             * or size of 8 and the second is immediate 8,
+                             * then check to see if the constant
+                             * is a signed 8 bit constant.  If so, then do not match, otherwise match
+                             */
                             if (!bRetry &&
-                                !((ASM_GET_uSizemask(pptb2->usOp1) & _8) ||
-                                  (ASM_GET_uRegmask(pptb2->usOp1) & _al)) &&
-                                (ASM_GET_aopty(pptb2->usOp2) == _imm) &&
-                                (ASM_GET_uSizemask(pptb2->usOp2) & _8))
+                                !((ASM_GET_uSizemask(table2->usOp1) & _8) ||
+                                  (ASM_GET_uRegmask(table2->usOp1) & _al)) &&
+                                (ASM_GET_aopty(table2->usOp2) == _imm) &&
+                                (ASM_GET_uSizemask(table2->usOp2) & _8))
                             {
 
                                 if (popnd2->disp <= SCHAR_MAX)
@@ -628,11 +745,11 @@
                                 switch (usNumops)
                                 {
                                     case 0:
-                                        if (!pptb2->usOp1)
+                                        if (!table2->usOp1)
                                             goto Lfound2;
                                         break;
                                     case 1:
-                                        if (bMatch1 && !pptb2->usOp2)
+                                        if (bMatch1 && !table2->usOp2)
                                             goto Lfound2;
                                         break;
                                     case 2:
@@ -643,16 +760,16 @@
                         }
 #if 0
                         if (asmstate.ucItype == ITshift &&
-                            !pptb2->usOp2 &&
+                            !table2->usOp2 &&
                             bMatch1 && popnd2->disp == 1 &&
-                            asm_match_flags(usFlags2,
+                            asm_match_flags(opflags2,
                                 CONSTRUCT_FLAGS(_8|_16|_32, _imm,_normal,0))
                           )
                             break;
 #endif
                 }
             Lfound2:
-                if (pptb2->usOpcode == ASM_END)
+                if (table2->usOpcode == ASM_END)
                 {
 #ifdef DEBUG
                     if (debuga)
@@ -684,16 +801,19 @@
 #endif
                     goto TYPE_SIZE_ERROR;
                 }
-                ptbRet.pptb2 = pptb2;
+                ptbRet.pptb2 = table2;
                 goto RETURN_IT;
+            }
         case 3:
-                for (pptb3 = pop->ptb.pptb3;
-                     pptb3->usOpcode != ASM_END;
-                     pptb3++)
-                {
-                        bMatch1 = asm_match_flags(usFlags1, pptb3->usOp1);
-                        bMatch2 = asm_match_flags(usFlags2, pptb3->usOp2);
-                        bMatch3 = asm_match_flags(usFlags3, pptb3->usOp3);
+            {
+                PTRNTAB3 *table3;
+                for (table3 = pop->ptb.pptb3;
+                     table3->usOpcode != ASM_END;
+                     table3++)
+                {
+                        bMatch1 = asm_match_flags(opflags1, table3->usOp1);
+                        bMatch2 = asm_match_flags(opflags2, table3->usOp2);
+                        bMatch3 = asm_match_flags(opflags3, table3->usOp3);
                         if (bMatch1 && bMatch2 && bMatch3)
                             goto Lfound3;
                         if (asmstate.ucItype == ITopt)
@@ -701,15 +821,15 @@
                             switch (usNumops)
                             {
                                 case 0:
-                                        if (!pptb3->usOp1)
+                                        if (!table3->usOp1)
                                             goto Lfound3;
                                         break;
                                 case 1:
-                                        if (bMatch1 && !pptb3->usOp2)
+                                        if (bMatch1 && !table3->usOp2)
                                             goto Lfound3;
                                         break;
                                 case 2:
-                                        if (bMatch1 && bMatch2 && !pptb3->usOp3)
+                                        if (bMatch1 && bMatch2 && !table3->usOp3)
                                             goto Lfound3;
                                         break;
                                 case 3:
@@ -720,7 +840,7 @@
                         }
                 }
             Lfound3:
-                if (pptb3->usOpcode == ASM_END)
+                if (table3->usOpcode == ASM_END)
                 {
 #ifdef DEBUG
                     if (debuga)
@@ -754,9 +874,10 @@
 #endif
                     goto TYPE_SIZE_ERROR;
                 }
-                ptbRet.pptb3 = pptb3;
+                ptbRet.pptb3 = table3;
                 goto RETURN_IT;
         }
+        }
 RETURN_IT:
         if (bRetry && !bFake)
         {
@@ -802,10 +923,10 @@
     if (popnd->segreg)
     {
         us = asm_float_type_size(popnd->ptype, &usFloat);
-        if (I32)
-            return(CONSTRUCT_FLAGS(us, _m, _addr32, usFloat));
-        else
+        if (I16)
             return(CONSTRUCT_FLAGS(us, _m, _addr16, usFloat));
+        else
+            return(CONSTRUCT_FLAGS(us, _m, _addr32, usFloat));
     }
 
 #if 0
@@ -819,11 +940,11 @@
 
             case Tfloat64:
                 popnd->s = dconst(popnd->real);
-                return(CONSTRUCT_FLAGS(0, _m, _normal, _64));
+                return(CONSTRUCT_FLAGS(0, _m, _normal, _f64));
 
             case Tfloat80:
                 popnd->s = ldconst(popnd->real);
-                return(CONSTRUCT_FLAGS(0, _m, _normal, _80));
+                return(CONSTRUCT_FLAGS(0, _m, _normal, _f80));
         }
     }
 #endif
@@ -867,17 +988,17 @@
         if (popnd->pregDisp1 && !popnd->base)
         {
             if (ps && ps->isLabel() && sz == _anysize)
-                sz = I32 ? _32 : _16;
-            return (popnd->pregDisp1->ty & _r32)
+                sz = I16 ? _16 : _32;
+            return (popnd->pregDisp1->ty & (_r32 | _r64))
                 ? CONSTRUCT_FLAGS(sz, _m, _addr32, 0)
                 : CONSTRUCT_FLAGS(sz, _m, _addr16, 0);
         }
         else if (ps)
         {
                 if (popnd->bOffset || popnd->bSeg || ps == asmstate.psLocalsize)
-                    return I32
-                        ? CONSTRUCT_FLAGS(_32, _imm, _normal, 0)
-                        : CONSTRUCT_FLAGS(_16, _imm, _normal, 0);
+                    return I16
+                        ? CONSTRUCT_FLAGS(_16, _imm, _normal, 0)
+                        : CONSTRUCT_FLAGS(_32, _imm, _normal, 0);
 
                 if (ps->isLabel())
                 {
@@ -904,24 +1025,24 @@
                                 goto case_near;
                             }
                             else
-                                us = I32
-                                    ? CONSTRUCT_FLAGS(_8|_32, _rel, _flbl,0)
-                                    : CONSTRUCT_FLAGS(_8|_16, _rel, _flbl,0);
+                                us = I16
+                                    ? CONSTRUCT_FLAGS(_8|_16, _rel, _flbl,0)
+                                    : CONSTRUCT_FLAGS(_8|_32, _rel, _flbl,0);
                             break;
 
                         case ASM_JUMPTYPE_NEAR:
                         case_near:
-                            us = I32
-                                ? CONSTRUCT_FLAGS(_32, _rel, _flbl, 0)
-                                : CONSTRUCT_FLAGS(_16, _rel, _flbl, 0);
+                            us = I16
+                                ? CONSTRUCT_FLAGS(_16, _rel, _flbl, 0)
+                                : CONSTRUCT_FLAGS(_32, _rel, _flbl, 0);
                             break;
                         case ASM_JUMPTYPE_SHORT:
                             us = CONSTRUCT_FLAGS(_8, _rel, _flbl, 0);
                             break;
                         case ASM_JUMPTYPE_FAR:
-                            us = I32
-                                ? CONSTRUCT_FLAGS(_48, _rel, _flbl, 0)
-                                : CONSTRUCT_FLAGS(_32, _rel, _flbl, 0);
+                            us = I16
+                                ? CONSTRUCT_FLAGS(_32, _rel, _flbl, 0)
+                                : CONSTRUCT_FLAGS(_48, _rel, _flbl, 0);
                             break;
                         default:
                             assert(0);
@@ -974,18 +1095,17 @@
         }
         if (popnd->segreg /*|| popnd->bPtr*/)
         {
-            amod = I32 ? _addr32 : _addr16;
+            amod = I16 ? _addr16 : _addr32;
             if (asmstate.ucItype == ITjump)
             {
             L1:
                 opty = _m;
-                if (I32)
-                {   if (sz == _48)
+                if (I16)
+                {   if (sz == _32)
                         opty = _mnoi;
                 }
                 else
-                {
-                    if (sz == _32)
+                {   if (sz == _48)
                         opty = _mnoi;
                 }
                 us = CONSTRUCT_FLAGS(sz,opty,amod,0);
@@ -1026,13 +1146,13 @@
         #define emit(op)        ((void)(op))
 #endif
         Identifier *id;
-//      unsigned short us;
+//      unsigned us;
         unsigned char *puc;
         unsigned usDefaultseg;
         code *pc = NULL;
         OPND *popndTmp;
         ASM_OPERAND_TYPE    aoptyTmp;
-        unsigned short  uSizemaskTmp;
+        unsigned  uSizemaskTmp;
         REG     *pregSegment;
         code    *pcPrefix = NULL;
         unsigned            uSizemask1 =0, uSizemask2 =0, uSizemask3 =0;
@@ -1097,7 +1217,7 @@
 
         asmstate.statement->regs |= asm_modify_regs(ptb, popnd1, popnd2);
 
-        if (!I32 && ptb.pptb0->usFlags & _I386)
+        if (I16 && ptb.pptb0->usFlags & _I386)
         {
             switch (usNumops)
             {
@@ -1132,7 +1252,7 @@
         {
             case 0:
                 if ((I32 && (ptb.pptb0->usFlags & _16_bit)) ||
-                        (!I32 && (ptb.pptb0->usFlags & _32_bit)))
+                        (I16 && (ptb.pptb0->usFlags & _32_bit)))
                 {
                         emit(0x66);
                         pc->Iflags |= CFopsize;
@@ -1150,7 +1270,7 @@
                        (ptb.pptb2->usFlags & _16_bit_addr)
                      )
                     ) ||
-                     (!I32 &&
+                     (I16 &&
                        (amod2 == _addr32 ||
                         (uSizemaskTable2 & _32 && aoptyTable2 == _rel) ||
                         (uSizemaskTable2 & _48 && aoptyTable2 == _mnoi) ||
@@ -1181,7 +1301,7 @@
                        (uSizemaskTable1 & _16 && aoptyTable1 == _rel) ||
                         (uSizemaskTable1 & _32 && aoptyTable1 == _mnoi) ||
                         (ptb.pptb1->usFlags & _16_bit_addr))) ||
-                     (!I32 &&
+                     (I16 &&
                       (amod1 == _addr32 ||
                         (uSizemaskTable1 & _32 && aoptyTable1 == _rel) ||
                         (uSizemaskTable1 & _48 && aoptyTable1 == _mnoi) ||
@@ -1200,7 +1320,7 @@
                 // If the size of the operand is unknown, assume that it is
                 // the default size
                 if ((I32 && (ptb.pptb0->usFlags & _16_bit)) ||
-                    (!I32 && (ptb.pptb0->usFlags & _32_bit)))
+                    (I16 && (ptb.pptb0->usFlags & _32_bit)))
                 {
                     //if (asmstate.ucItype != ITjump)
                     {   emit(0x66);
@@ -1253,13 +1373,11 @@
         }
         unsigned usOpcode = ptb.pptb0->usOpcode;
 
+        pc->Iop = usOpcode;
         if ((usOpcode & 0xFFFFFF00) == 0x660F3A00 ||    // SSE4
             (usOpcode & 0xFFFFFF00) == 0x660F3800)      // SSE4
         {
-            pc->Iflags |= CFopsize;
-            pc->Iop = 0x0F;
-            pc->Iop2 = (usOpcode >> 8) & 0xFF;
-            pc->Iop3 = usOpcode & 0xFF;
+            pc->Iop = 0x66000F00 | ((usOpcode >> 8) & 0xFF) | ((usOpcode & 0xFF) << 16);
             goto L3;
         }
         switch (usOpcode & 0xFF0000)
@@ -1268,19 +1386,16 @@
                 break;
 
             case 0x660000:
-                pc->Iflags |= CFopsize;
                 usOpcode &= 0xFFFF;
-                break;
+                goto L3;
 
             case 0xF20000:                      // REPNE
             case 0xF30000:                      // REP/REPE
                 // BUG: What if there's an address size prefix or segment
                 // override prefix? Must the REP be adjacent to the rest
                 // of the opcode?
-                pcPrefix = code_calloc();
-                pcPrefix->Iop = usOpcode >> 16;
                 usOpcode &= 0xFFFF;
-                break;
+                goto L3;
 
             case 0x0F0000:                      // an AMD instruction
                 puc = ((unsigned char *) &usOpcode);
@@ -1289,8 +1404,7 @@
                 emit(puc[2]);
                 emit(puc[1]);
                 emit(puc[0]);
-                pc->Iop = puc[2];
-                pc->Iop2 = puc[1];
+                pc->Iop >>= 8;
                 pc->IEVint2 = puc[0];
                 pc->IFL2 = FLconst;
                 goto L3;
@@ -1301,8 +1415,7 @@
                 emit(puc[2]);
                 emit(puc[1]);
                 emit(puc[0]);
-                pc->Iop = puc[2];
-                pc->Iop2 = puc[1];
+                pc->Iop >>= 8;
                 pc->Irm = puc[0];
                 goto L3;
         }
@@ -1313,7 +1426,7 @@
             emit(puc[0]);
             pc->Iop = puc[1];
             if (pc->Iop == 0x0f)
-                pc->Iop2 = puc[0];
+                pc->Iop = 0x0F00 | puc[0];
             else
             {
                 if (usOpcode == 0xDFE0) // FSTSW AX
@@ -1331,7 +1444,6 @@
         else
         {
             emit(usOpcode);
-            pc->Iop = usOpcode;
         }
     L3: ;
 
@@ -1354,7 +1466,7 @@
 
                 label = s->isLabel();
                 if (label)
-                {   if ((pc->Iop & 0xF0) == 0x70)
+                {   if ((pc->Iop & ~0x0F) == 0x70)
                         pc->Iflags |= CFjmp16;
                     if (usNumops == 1)
                     {   pc->IFL2 = FLblock;
@@ -1376,14 +1488,18 @@
                 if (((aoptyTable1 == _reg || aoptyTable1 == _float) &&
                      amodTable1 == _normal && (uRegmaskTable1 & _rplus_r)))
                 {
+                    unsigned reg = popnd1->base->val;
+                    if (reg & 8)
+                    {   reg &= 7;
+                        pc->Irex |= REX_B;
+                        assert(I64);
+                    }
                         if (asmstate.ucItype == ITfloat)
-                                pc->Irm += popnd1->base->val;
-                        else if (pc->Iop == 0x0f)
-                                pc->Iop2 += popnd1->base->val;
+                        pc->Irm += reg;
                         else
-                                pc->Iop += popnd1->base->val;
+                        pc->Iop += reg;
 #ifdef DEBUG
-                        auchOpcode[usIdx-1] += popnd1->base->val;
+                    auchOpcode[usIdx-1] += reg;
 #endif
                 }
                 else
@@ -1475,6 +1591,8 @@
 );
 printf("usOpcode = %x\n", usOpcode);
 #endif
+                        if (popnd1->usFlags == _r64)
+                            pc->Irex |= REX_W;
                         if (ptb.pptb0->usOpcode == 0x0F7E ||    // MOVD _rm32,_mm
                             ptb.pptb0->usOpcode == 0x660F7E     // MOVD _rm32,_xmm
                            )
@@ -1503,19 +1621,25 @@
                 }
                 else
                 {
+                        if (popnd2->usFlags == _r64)
+                            pc->Irex |= REX_W;
+
                         if (((aoptyTable1 == _reg || aoptyTable1 == _float) &&
                              amodTable1 == _normal &&
                              (uRegmaskTable1 & _rplus_r)))
                         {
+                            unsigned reg = popnd1->base->val;
+                            if (reg & 8)
+                            {   reg &= 7;
+                                pc->Irex |= REX_B;
+                                assert(I64);
+                            }
                                 if (asmstate.ucItype == ITfloat)
-                                        pc->Irm += popnd1->base->val;
-                                else
-                                if (pc->Iop == 0x0f)
-                                        pc->Iop2 += popnd1->base->val;
+                                pc->Irm += reg;
                                 else
-                                        pc->Iop += popnd1->base->val;
+                                pc->Iop += reg;
 #ifdef DEBUG
-                                auchOpcode[usIdx-1] += popnd1->base->val;
+                            auchOpcode[usIdx-1] += reg;
 #endif
                         }
                         else
@@ -1523,15 +1647,18 @@
                              amodTable2 == _normal &&
                              (uRegmaskTable2 & _rplus_r)))
                         {
+                            unsigned reg = popnd2->base->val;
+                            if (reg & 8)
+                            {   reg &= 7;
+                                pc->Irex |= REX_B;
+                                assert(I64);
+                            }
                                 if (asmstate.ucItype == ITfloat)
-                                        pc->Irm += popnd2->base->val;
+                                pc->Irm += reg;
                                 else
-                                if (pc->Iop == 0x0f)
-                                        pc->Iop2 += popnd2->base->val;
-                                else
-                                        pc->Iop += popnd2->base->val;
+                                pc->Iop += reg;
 #ifdef DEBUG
-                                auchOpcode[usIdx-1] += popnd2->base->val;
+                            auchOpcode[usIdx-1] += reg;
 #endif
                         }
                         else if (ptb.pptb0->usOpcode == 0xF30FD6 ||
@@ -1597,15 +1724,18 @@
                              amodTable1 == _normal &&
                              (uRegmaskTable1 &_rplus_r)))
                         {
+                            unsigned reg = popnd1->base->val;
+                            if (reg & 8)
+                            {   reg &= 7;
+                                pc->Irex |= REX_B;
+                                assert(I64);
+                            }
                                 if (asmstate.ucItype == ITfloat)
-                                        pc->Irm += popnd1->base->val;
+                                pc->Irm += reg;
                                 else
-                                if (pc->Iop == 0x0f)
-                                        pc->Iop2 += popnd1->base->val;
-                                else
-                                        pc->Iop += popnd1->base->val;
+                                pc->Iop += reg;
 #ifdef DEBUG
-                                auchOpcode[usIdx-1] += popnd1->base->val;
+                            auchOpcode[usIdx-1] += reg;
 #endif
                         }
                         else
@@ -1613,15 +1743,18 @@
                              amodTable2 == _normal &&
                              (uRegmaskTable2 &_rplus_r)))
                         {
+                            unsigned reg = popnd1->base->val;
+                            if (reg & 8)
+                            {   reg &= 7;
+                                pc->Irex |= REX_B;
+                                assert(I64);
+                            }
                                 if (asmstate.ucItype == ITfloat)
-                                        pc->Irm += popnd1->base->val;
+                                pc->Irm += reg;
                                 else
-                                if (pc->Iop == 0x0f)
-                                        pc->Iop2 += popnd1->base->val;
-                                else
-                                        pc->Iop += popnd2->base->val;
+                                pc->Iop += reg;
 #ifdef DEBUG
-                                auchOpcode[usIdx-1] += popnd2->base->val;
+                            auchOpcode[usIdx-1] += reg;
 #endif
                         }
                         else
@@ -1642,7 +1775,7 @@
         }
 L2:
 
-        if ((pc->Iop & 0xF8) == 0xD8 &&
+        if ((pc->Iop & ~7) == 0xD8 &&
             ADDFWAIT() &&
             !(ptb.pptb0->usFlags & _nfwait))
                 pc->Iflags |= CFwait;
@@ -1714,7 +1847,7 @@
 
     printf("\n");
     fflush(stdout);
-
+halt();
     longjmp(asmstate.env,1);
 }
 
@@ -1750,7 +1883,7 @@
     {
         int sz = (int)ptype->size();
         if (sz == REALSIZE)
-        {   *pusFloat = _80;
+        {   *pusFloat = _f80;
             return 0;
         }
         switch (sz)
@@ -1760,7 +1893,10 @@
             case 4:
                 return _32;
             case 8:
-                *pusFloat = _64;
+                *pusFloat = _f64;
+                return 0;
+            case 10:
+                *pusFloat = _f80;
                 return 0;
             default:
                 break;
@@ -2010,7 +2146,7 @@
 #if DMDV2
                 || v->isImmutable() || v->storage_class & STCmanifest
 #endif
-            ) && !v->type->isfloating())
+            ) && !v->type->isfloating() && v->init)
         {   ExpInitializer *ei = v->init->isExpInitializer();
 
             if (ei)
@@ -2050,7 +2186,7 @@
         unsigned char *puchOpcode, unsigned *pusIdx,
 #endif
         code *pc,
-        unsigned short usFlags,
+        unsigned usFlags,
         OPND *popnd, OPND *popnd2)
 {
     #undef modregrm
@@ -2086,7 +2222,7 @@
     unsigned        uSizemask =0;
     ASM_OPERAND_TYPE    aopty;
     ASM_MODIFIERS           amod;
-    unsigned short          uRegmask;
+    unsigned          uRegmask;
     unsigned char           bOffsetsym = FALSE;
 
 #if 0
@@ -2208,7 +2344,7 @@
             if (d->isDataseg() || d->isCodeseg())
             {
                 if (( I32 && amod == _addr16) ||
-                    (!I32 && amod == _addr32))
+                    (I16 && amod == _addr32))
                     asmerr(EM_bad_addr_mode);   // illegal addressing mode
                 goto DATA_REF;
             }
@@ -2221,7 +2357,7 @@
             mrmb.modregrm.mod = 0x3;
             mrmb.modregrm.rm |= popnd->base->val;
     }
-    else if (amod == _addr16 || (amod == _flbl && !I32))
+    else if (amod == _addr16 || (amod == _flbl && I16))
     {   unsigned rm;
 
 #ifdef DEBUG
@@ -2262,7 +2398,7 @@
                 case Y(_DI):    rm = 5; break;
 
                 default:
-                    asmerr(EM_bad_addr_mode);   // illegal addressing mode
+                    asmerr("bad 16 bit index address mode");
             }
             #undef X
             #undef Y
@@ -2551,54 +2687,15 @@
         popnd1 = NULL;
         break;
     }
-    if (popnd1 && ASM_GET_aopty(popnd1->usFlags) == _reg) {
-        switch (ASM_GET_amod(popnd1->usFlags)) {
-        default:
-            if (ASM_GET_uSizemask(popnd1->usFlags) == _8) {
-                switch(popnd1->base->val) {
-                    case _AL:
-                    case _AH:
-                        usRet |= mAX;
-                        break;
-                    case _BL:
-                    case _BH:
-                        usRet |= mBX;
-                        break;
-                    case _CL:
-                    case _CH:
-                        usRet |= mCX;
-                        break;
-                    case _DL:
-                    case _DH:
-                        usRet |= mDX;
-                        break;
+    if (popnd1 && ASM_GET_aopty(popnd1->usFlags) == _reg)
+    {
+        switch (ASM_GET_amod(popnd1->usFlags))
+        {
                     default:
-                        assert(0);
-                }
-            }
-            else {
-                switch (popnd1->base->val) {
-                    case _AX:
-                        usRet |= mAX;
-                        break;
-                    case _BX:
-                        usRet |= mBX;
-                        break;
-                    case _CX:
-                        usRet |= mCX;
-                        break;
-                    case _DX:
-                        usRet |= mDX;
-                        break;
-                    case _SI:
-                        usRet |= mSI;
-                        break;
-                    case _DI:
-                        usRet |= mDI;
-                        break;
-                }
-            }
+            usRet |= 1 << popnd1->base->val;
+            usRet &= ~(mBP | mSP);              // ignore changing these
             break;
+
         case _rseg:
             //if (popnd1->base->val == _ES)
                 //usRet |= mES;
@@ -2632,7 +2729,7 @@
     unsigned char       bRetval = FALSE;
     unsigned            uSizemaskOp;
     unsigned            uSizemaskTable;
-    unsigned char       bSizematch;
+    unsigned            bSizematch;
 
     //printf("asm_match_flags(usOp = x%x, usTable = x%x)\n", usOp, usTable);
     if (asmstate.ucItype == ITfloat)
@@ -2758,7 +2855,7 @@
     ASM_MODIFIERS       amodOp;
     unsigned            uRegmaskTable;
     unsigned            uRegmaskOp;
-    unsigned char       bRegmatch;
+    unsigned            bRegmatch;
 
 
 //
@@ -2820,12 +2917,12 @@
 /*******************************
  */
 
-STATIC void asm_output_flags(opflag_t usFlags)
+STATIC void asm_output_flags(opflag_t opflags)
 {
-        ASM_OPERAND_TYPE    aopty = ASM_GET_aopty(usFlags);
-        ASM_MODIFIERS       amod = ASM_GET_amod(usFlags);
-        unsigned            uRegmask = ASM_GET_uRegmask(usFlags);
-        unsigned            uSizemask = ASM_GET_uSizemask(usFlags);
+        ASM_OPERAND_TYPE    aopty = ASM_GET_aopty(opflags);
+        ASM_MODIFIERS       amod = ASM_GET_amod(opflags);
+        unsigned            uRegmask = ASM_GET_uRegmask(opflags);
+        unsigned            uSizemask = ASM_GET_uSizemask(opflags);
 
         if (uSizemask == _anysize)
             printf("_anysize ");
@@ -2841,6 +2938,8 @@
                 printf("_32 ");
             if (uSizemask & _48)
                 printf("_48 ");
+            if (uSizemask & _64)
+                printf("_64 ");
         }
 
         printf("_");
@@ -2882,6 +2981,8 @@
                 if (uRegmask & 4) printf("_eax ");
                 if (uRegmask & 8) printf("_dx ");
                 if (uRegmask & 0x10) printf("_cl ");
+                if (uRegmask & 0x40) printf("_rax ");
+                if (uRegmask & 0x20) printf("_rplus_r ");
                 return;
             case _rseg:
                 printf("rseg     ");
@@ -2977,6 +3078,16 @@
             return &regtab[i];
         }
     }
+    if (I64)
+    {
+        for (i = 0; i < sizeof(regtab64) / sizeof(regtab64[0]); i++)
+        {
+            if (strcmp(s,regtab64[i].regstr) == 0)
+            {
+                return &regtab64[i];
+            }
+        }
+    }
     return NULL;
 }
 
@@ -3033,6 +3144,7 @@
             case 2:     u = _16;        break;
             case 4:     u = _32;        break;
             case 6:     u = _48;        break;
+            case 8:     if (I64) u = _64;        break;
         }
     }
     return u;
@@ -4232,6 +4344,12 @@
 Statement *AsmStatement::semantic(Scope *sc)
 {
     //printf("AsmStatement::semantic()\n");
+
+#if DMDV2
+    if (sc->func && sc->func->isSafe())
+        error("inline assembler not allowed in @safe function %s", sc->func->toChars());
+#endif
+
     OP *o;
     OPND *o1 = NULL,*o2 = NULL, *o3 = NULL;
     PTRNTAB ptb;
@@ -4415,3 +4533,4 @@
     //return asmstate.bReturnax;
     return this;
 }
+
diff -aruw dmd62/init.c dmd63/init.c
--- dmd62/init.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/init.c	2010-08-09 14:33:14.000000000 -0400
@@ -341,7 +341,7 @@
 Initializer *ArrayInitializer::semantic(Scope *sc, Type *t)
 {   unsigned i;
     unsigned length;
-    const unsigned long amax = 0x80000000;
+    const unsigned amax = 0x80000000;
 
     //printf("ArrayInitializer::semantic(%s)\n", t->toChars());
     if (sem)                            // if semantic() already run
@@ -394,7 +394,7 @@
     }
 
     if ((unsigned long) dim * t->nextOf()->size() >= amax)
-    {   error(loc, "array dimension %u exceeds max of %ju", dim, amax / t->nextOf()->size());
+    {   error(loc, "array dimension %u exceeds max of %u", dim, amax / t->nextOf()->size());
         goto Lerr;
     }
     return this;
diff -aruw dmd62/interpret.c dmd63/interpret.c
--- dmd62/interpret.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/interpret.c	2010-08-09 14:33:14.000000000 -0400
@@ -1110,8 +1110,9 @@
 
 Expression *ThisExp::interpret(InterState *istate)
 {
-    if (istate->localThis)
+    if (istate && istate->localThis)
         return istate->localThis->interpret(istate);
+    error("value of 'this' is not known at compile time");
     return EXP_CANT_INTERPRET;
 }
 
@@ -2105,6 +2106,11 @@
 #endif
     Expression *e = EXP_CANT_INTERPRET;
     Expression *e1 = this->e1;
+    if (!istate)
+    {
+        error("value of %s is not known at compile time", e1->toChars());
+        return e;
+    }
 
     if (fp)
     {
diff -aruw dmd62/libelf.c dmd63/libelf.c
--- dmd62/libelf.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/libelf.c	2010-08-09 14:33:14.000000000 -0400
@@ -161,6 +161,8 @@
     assert(len <= 12);
     memset(h->file_time + len, ' ', 12 - len);
 
+    if (om->user_id > 999999)
+        om->user_id = 0;
     len = sprintf(h->user_id, "%u", om->user_id);
     assert(len <= 6);
     memset(h->user_id + len, ' ', 6 - len);
diff -aruw dmd62/libmach.c dmd63/libmach.c
--- dmd62/libmach.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/libmach.c	2010-08-09 14:33:14.000000000 -0400
@@ -164,10 +164,14 @@
     assert(len <= 12);
     memset(h->file_time + len, ' ', 12 - len);
 
+    if (om->user_id > 999999)           // yes, it happens
+        om->user_id = 0;                // don't really know what to do here
     len = sprintf(h->user_id, "%u", om->user_id);
     assert(len <= 6);
     memset(h->user_id + len, ' ', 6 - len);
 
+    if (om->group_id > 999999)          // yes, it happens
+        om->group_id = 0;               // don't really know what to do here
     len = sprintf(h->group_id, "%u", om->group_id);
     assert(len <= 6);
     memset(h->group_id + len, ' ', 6 - len);
diff -aruw dmd62/link.c dmd63/link.c
--- dmd62/link.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/link.c	2010-08-09 14:33:14.000000000 -0400
@@ -210,11 +210,20 @@
     argv.push((void *)cc);
     argv.insert(1, global.params.objfiles);
 
+#if __APPLE__
+    // If we are on Mac OS X and linking a dynamic library,
+    // add the "-dynamiclib" flag
+    if (global.params.dll)
+        argv.push((void *) "-dynamiclib");
+#endif
+
     // None of that a.out stuff. Use explicit exe file name, or
     // generate one from name of first source file.
     argv.push((void *)"-o");
     if (global.params.exefile)
     {
+        if (global.params.dll)
+            global.params.exefile = FileName::forceExt(global.params.exefile, global.dll_ext)->toChars();
         argv.push(global.params.exefile);
     }
     else
@@ -231,6 +240,9 @@
             ex = (char *)mem.malloc(e - n + 1);
             memcpy(ex, n, e - n);
             ex[e - n] = 0;
+            // If generating dll then force dll extension
+            if (global.params.dll)
+                ex = FileName::forceExt(ex, global.dll_ext)->toChars();
         }
         else
             ex = (char *)"a.out";       // no extension, so give up
@@ -357,9 +369,17 @@
 
     waitpid(childpid, &status, 0);
 
+    if (WIFEXITED(status))
+    {
     status=WEXITSTATUS(status);
     if (status)
         printf("--- errorlevel %d\n", status);
+    }
+    else if (WIFSIGNALED(status))
+    {
+        printf("--- killed by signal %d\n", WTERMSIG(status));
+        status = 1;
+    }
     return status;
 #else
     printf ("Linking is not yet supported for this version of DMD.\n");
@@ -546,7 +566,16 @@
 
     waitpid(childpid, &status, 0);
 
+    if (WIFEXITED(status))
+    {
     status = WEXITSTATUS(status);
+        //printf("--- errorlevel %d\n", status);
+    }
+    else if (WIFSIGNALED(status))
+    {
+        printf("--- killed by signal %d\n", WTERMSIG(status));
+        status = 1;
+    }
     return status;
 #else
     assert(0);
diff -aruw dmd62/linux.mak dmd63/linux.mak
--- dmd62/linux.mak	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/linux.mak	2010-08-09 14:33:14.000000000 -0400
@@ -3,7 +3,9 @@
 TK=tk
 ROOT=root
 
-CC=g++ -m32
+MODEL=-m32
+
+CC=g++ $(MODEL)
 
 #OPT=-g -g3
 #OPT=-O2
@@ -24,7 +26,7 @@
 
 DMD_OBJS = \
 	access.o array.o attrib.o bcomplex.o bit.o blockopt.o \
-	cast.o code.o cg.o cg87.o cgcod.o cgcs.o cgcv.o cgelem.o cgen.o \
+	cast.o code.o cg.o cg87.o cgcod.o cgcs.o cgelem.o cgen.o \
 	cgreg.o cgsched.o class.o cod1.o cod2.o cod3.o cod4.o cod5.o \
 	constfold.o irstate.o dchar.o cond.o debug.o \
 	declaration.o dsymbol.o dt.o dump.o e2ir.o ee.o eh.o el.o \
@@ -51,7 +53,7 @@
 	inifile.c iasm.c module.c scope.c dump.c init.h init.c attrib.h \
 	attrib.c opover.c class.c mangle.c bit.c tocsym.c func.c inline.c \
 	access.c complex_t.h irstate.h irstate.c glue.c msc.c ph.c tk.c \
-	s2ir.c todt.c e2ir.c util.c identifier.h parse.h objfile.h \
+	s2ir.c todt.c e2ir.c util.c identifier.h parse.h \
 	scope.h enum.h import.h mars.h module.h mtype.h dsymbol.h \
 	declaration.h lexer.h expression.h irstate.h statement.h eh.c \
 	utf.h utf.c staticassert.h staticassert.c unialpha.c \
@@ -91,7 +93,7 @@
 all: dmd
 
 dmd: $(DMD_OBJS)
-	gcc -m32 -lstdc++ $(COV) $(DMD_OBJS) -o dmd
+	gcc $(MODEL) -lstdc++ -lpthread $(COV) $(DMD_OBJS) -o dmd
 
 clean:
 	rm -f $(DMD_OBJS) dmd optab.o id.o impcnvgen idgen id.c id.h \
@@ -461,7 +463,7 @@
 	$(CC) -c $(GFLAGS) -I$(ROOT) $<
 
 strtold.o: $C/strtold.c
-	gcc -m32 -c $C/strtold.c
+	gcc $(MODEL) -c $C/strtold.c
 
 struct.o: struct.c
 	$(CC) -c $(CFLAGS) $<
diff -aruw dmd62/mars.c dmd63/mars.c
--- dmd62/mars.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/mars.c	2010-08-09 14:33:14.000000000 -0400
@@ -75,13 +75,23 @@
 #error "fix this"
 #endif
 
+#if TARGET_WINDOS
+    dll_ext  = "dll";
+#elif TARGET_LINUX || TARGET_FREEBSD || TARGET_SOLARIS
+    dll_ext  = "so";
+#elif TARGET_OSX
+    dll_ext = "dylib";
+#else
+#error "fix this"
+#endif
+
     copyright = "Copyright (c) 1999-2010 by Digital Mars";
     written = "written by Walter Bright"
 #if TARGET_NET
     "\nMSIL back-end (alpha release) by Cristian L. Vlasceanu and associates.";
 #endif
     ;
-    version = "v1.062";
+    version = "v1.063";
     global.structalign = 8;
 
     memset(&params, 0, sizeof(Param));
@@ -253,8 +263,11 @@
   -debug=ident   compile in debug code identified by ident\n\
   -debuglib=name    set symbolic debug library to name\n\
   -defaultlib=name  set default library to name\n\
-  -deps=filename write module dependencies to filename\n%s\
-  -g             add symbolic debug info\n\
+  -deps=filename write module dependencies to filename\n%s"
+#if TARGET_OSX
+"  -dylib         generate dylib\n"
+#endif
+"  -g             add symbolic debug info\n\
   -gc            add symbolic debug info, pretend to be C\n\
   -H             generate 'header' file\n\
   -Hddirectory   write 'header' file to directory\n\
@@ -419,6 +432,10 @@
             else if (strcmp(p + 1, "fPIC") == 0)
                 global.params.pic = 1;
 #endif
+#if TARGET_OSX
+            else if (strcmp(p + 1, "dylib") == 0)
+                global.params.dll = 1;
+#endif
             else if (strcmp(p + 1, "map") == 0)
                 global.params.map = 1;
             else if (strcmp(p + 1, "multiobj") == 0)
@@ -431,6 +448,8 @@
             {   error("use -profile instead of -gt\n");
                 global.params.trace = 1;
             }
+            else if (strcmp(p + 1, "m32") == 0)
+                global.params.isX86_64 = 0;
             else if (strcmp(p + 1, "m64") == 0)
                 global.params.isX86_64 = 1;
             else if (strcmp(p + 1, "profile") == 0)
diff -aruw dmd62/mars.h dmd63/mars.h
--- dmd62/mars.h	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/mars.h	2010-08-09 14:33:14.000000000 -0400
@@ -119,6 +119,7 @@
 {
     char obj;           // write object file
     char link;          // perform link
+    char dll;           // generate shared dynamic library
     char lib;           // write library file instead of object file(s)
     char multiobj;      // break one object file into multiple ones
     char oneobj;        // write one object file instead of multiple ones
@@ -142,7 +143,10 @@
     char useInvariants; // generate class invariant checks
     char useIn;         // generate precondition checks
     char useOut;        // generate postcondition checks
-    char useArrayBounds; // generate array bounds checks
+    char useArrayBounds; // 0: no array bounds checks
+                         // 1: array bounds checks for safe functions only
+                         // 2: array bounds checks for all functions
+    char noboundscheck; // no array bounds checking at all
     char useSwitchError; // check for switches without a default
     char useUnitTests;  // generate unittest code
     char useInline;     // inline expand functions
@@ -221,6 +225,7 @@
     const char *sym_ext;
     const char *obj_ext;
     const char *lib_ext;
+    const char *dll_ext;
     const char *doc_ext;        // for Ddoc generated files
     const char *ddoc_ext;       // for Ddoc macro include files
     const char *hdr_ext;        // for D 'header' import files
diff -aruw dmd62/module.c dmd63/module.c
--- dmd62/module.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/module.c	2010-08-09 14:33:14.000000000 -0400
@@ -89,6 +89,7 @@
     decldefs = NULL;
     vmoduleinfo = NULL;
     massert = NULL;
+    munittest = NULL;
     marray = NULL;
     sictor = NULL;
     sctor = NULL;
@@ -350,16 +351,21 @@
 {
     //printf("Module::read('%s') file '%s'\n", toChars(), srcfile->toChars());
     if (srcfile->read())
-    {   error(loc, "cannot read file '%s'", srcfile->toChars());
+    {   error(loc, "is in file '%s' which cannot be read", srcfile->toChars());
         if (!global.gag)
         {   /* Print path
              */
-            for (size_t i = 0; i < global.path->dim; i++)
+            if (global.path)
+            {
+                for (int i = 0; i < global.path->dim; i++)
             {
                 char *p = (char *)global.path->data[i];
                 fprintf(stdmsg, "import path[%d] = %s\n", i, p);
             }
         }
+            else
+                fprintf(stdmsg, "Specify path to file '%s' with -I switch\n", srcfile->toChars());
+        }
         fatal();
     }
 }
@@ -756,6 +762,14 @@
     }
 #endif
 
+    // Do semantic() on members that don't depend on others
+    for (int i = 0; i < members->dim; i++)
+    {   Dsymbol *s = (Dsymbol *)members->data[i];
+
+        //printf("\tModule('%s'): '%s'.semantic0()\n", toChars(), s->toChars());
+        s->semantic0(sc);
+    }
+
     // Pass 1 semantic routines: do public side of the definition
     for (int i = 0; i < members->dim; i++)
     {   Dsymbol *s = (Dsymbol *)members->data[i];
diff -aruw dmd62/module.h dmd63/module.h
--- dmd62/module.h	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/module.h	2010-08-09 14:33:14.000000000 -0400
@@ -160,6 +160,9 @@
     Symbol *massert;            // module assert function
     Symbol *toModuleAssert();   // get module assert function
 
+    Symbol *munittest;          // module unittest failure function
+    Symbol *toModuleUnittest(); // get module unittest failure function
+
     Symbol *marray;             // module array bounds function
     Symbol *toModuleArray();    // get module array bounds function
 
diff -aruw dmd62/msc.c dmd63/msc.c
--- dmd62/msc.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/msc.c	2010-08-09 14:33:14.000000000 -0400
@@ -1,6 +1,6 @@
 
 // Compiler implementation of the D programming language
-// Copyright (c) 1999-2009 by Digital Mars
+// Copyright (c) 1999-2010 by Digital Mars
 // All Rights Reserved
 // written by Walter Bright
 // http://www.digitalmars.com
@@ -27,6 +27,7 @@
 #include        "tassert.h"
 
 extern Global global;
+extern int REALSIZE;
 
 Config config;
 Configv configv;
@@ -39,6 +40,7 @@
 
 void out_config_init()
 {
+    //printf("out_config_init()\n");
     Param *params = &global.params;
 
     if (!config.target_cpu)
@@ -230,6 +232,9 @@
             tysize[TYfptr + i] = 10;    // NOTE: There are codgen test that check
             tysize[TYvptr + i] = 10;    // tysize[x] == tysize[TYfptr] so don't set
             tysize[TYfref + i] = 10;    // tysize[TYfptr] to tysize[TYnptr]
+            tysize[TYldouble + i] = REALSIZE;
+            tysize[TYildouble + i] = REALSIZE;
+            tysize[TYcldouble + i] = 2 * REALSIZE;
         }
     }
 
diff -aruw dmd62/mtype.c dmd63/mtype.c
--- dmd62/mtype.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/mtype.c	2010-08-09 14:33:14.000000000 -0400
@@ -75,10 +75,12 @@
 int REALSIZE = 12;
 int REALPAD = 2;
 int REALALIGNSIZE = 4;
-#else
+#elif TARGET_WINDOS
 int REALSIZE = 10;
 int REALPAD = 0;
 int REALALIGNSIZE = 2;
+#else
+#error "fix this"
 #endif
 
 int Tsize_t = Tuns32;
@@ -235,9 +237,11 @@
     {
         PTRSIZE = 8;
         if (global.params.isLinux || global.params.isFreeBSD || global.params.isSolaris)
-            REALSIZE = 10;
-        else
-            REALSIZE = 8;
+        {
+            REALSIZE = 16;
+            REALPAD = 6;
+            REALALIGNSIZE = 16;
+        }
         Tsize_t = Tuns64;
         Tptrdiff_t = Tint64;
     }
@@ -4739,6 +4743,9 @@
         exps->reserve(sym->fields.dim);
         for (size_t i = 0; i < sym->fields.dim; i++)
         {   VarDeclaration *v = (VarDeclaration *)sym->fields.data[i];
+            // Don't include hidden 'this' pointer
+            if (v->isThisDeclaration())
+                continue;
             Expression *fe = new DotVarExp(e->loc, e, v);
             exps->push(fe);
         }
Only in dmd62: objfile.h
diff -aruw dmd62/osx.mak dmd63/osx.mak
--- dmd62/osx.mak	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/osx.mak	2010-08-09 14:33:14.000000000 -0400
@@ -32,7 +32,7 @@
 
 DMD_OBJS = \
 	access.o array.o attrib.o bcomplex.o bit.o blockopt.o \
-	cast.o code.o cg.o cg87.o cgcod.o cgcs.o cgcv.o cgelem.o cgen.o \
+	cast.o code.o cg.o cg87.o cgcod.o cgcs.o cgelem.o cgen.o \
 	cgreg.o cgsched.o class.o cod1.o cod2.o cod3.o cod4.o cod5.o \
 	constfold.o irstate.o dchar.o cond.o debug.o \
 	declaration.o dsymbol.o dt.o dump.o e2ir.o ee.o eh.o el.o \
@@ -59,7 +59,7 @@
 	inifile.c iasm.c module.c scope.c dump.c init.h init.c attrib.h \
 	attrib.c opover.c class.c mangle.c bit.c tocsym.c func.c inline.c \
 	access.c complex_t.h irstate.h irstate.c glue.c msc.c ph.c tk.c \
-	s2ir.c todt.c e2ir.c util.c identifier.h parse.h objfile.h \
+	s2ir.c todt.c e2ir.c util.c identifier.h parse.h \
 	scope.h enum.h import.h mars.h module.h mtype.h dsymbol.h \
 	declaration.h lexer.h expression.h irstate.h statement.h eh.c \
 	utf.h utf.c staticassert.h staticassert.c unialpha.c \
diff -aruw dmd62/parse.c dmd63/parse.c
--- dmd62/parse.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/parse.c	2010-08-09 14:33:14.000000000 -0400
@@ -5456,6 +5456,123 @@
     token.lineComment = NULL;
 }
 
+/**********************************
+ * Set operator precedence for each operator.
+ */
+
+enum PREC precedence[TOKMAX];
+
+void initPrecedence()
+{
+    precedence[TOKdotvar] = PREC_primary;
+    precedence[TOKimport] = PREC_primary;
+    precedence[TOKidentifier] = PREC_primary;
+    precedence[TOKthis] = PREC_primary;
+    precedence[TOKsuper] = PREC_primary;
+    precedence[TOKint64] = PREC_primary;
+    precedence[TOKfloat64] = PREC_primary;
+    precedence[TOKnull] = PREC_primary;
+    precedence[TOKstring] = PREC_primary;
+    precedence[TOKarrayliteral] = PREC_primary;
+    precedence[TOKtypeid] = PREC_primary;
+    precedence[TOKis] = PREC_primary;
+    precedence[TOKassert] = PREC_primary;
+    precedence[TOKfunction] = PREC_primary;
+    precedence[TOKvar] = PREC_primary;
+#if DMDV2
+    precedence[TOKdefault] = PREC_primary;
+#endif
+
+    // post
+    precedence[TOKdotti] = PREC_primary;
+    precedence[TOKdot] = PREC_primary;
+//  precedence[TOKarrow] = PREC_primary;
+    precedence[TOKplusplus] = PREC_primary;
+    precedence[TOKminusminus] = PREC_primary;
+    precedence[TOKcall] = PREC_primary;
+    precedence[TOKslice] = PREC_primary;
+    precedence[TOKarray] = PREC_primary;
+
+    precedence[TOKaddress] = PREC_unary;
+    precedence[TOKstar] = PREC_unary;
+    precedence[TOKneg] = PREC_unary;
+    precedence[TOKuadd] = PREC_unary;
+    precedence[TOKnot] = PREC_unary;
+    precedence[TOKtobool] = PREC_add;
+    precedence[TOKtilde] = PREC_unary;
+    precedence[TOKdelete] = PREC_unary;
+    precedence[TOKnew] = PREC_unary;
+    precedence[TOKcast] = PREC_unary;
+
+    precedence[TOKmul] = PREC_mul;
+    precedence[TOKdiv] = PREC_mul;
+    precedence[TOKmod] = PREC_mul;
+
+    precedence[TOKadd] = PREC_add;
+    precedence[TOKmin] = PREC_add;
+    precedence[TOKcat] = PREC_add;
+
+    precedence[TOKshl] = PREC_shift;
+    precedence[TOKshr] = PREC_shift;
+    precedence[TOKushr] = PREC_shift;
+
+    precedence[TOKlt] = PREC_rel;
+    precedence[TOKle] = PREC_rel;
+    precedence[TOKgt] = PREC_rel;
+    precedence[TOKge] = PREC_rel;
+    precedence[TOKunord] = PREC_rel;
+    precedence[TOKlg] = PREC_rel;
+    precedence[TOKleg] = PREC_rel;
+    precedence[TOKule] = PREC_rel;
+    precedence[TOKul] = PREC_rel;
+    precedence[TOKuge] = PREC_rel;
+    precedence[TOKug] = PREC_rel;
+    precedence[TOKue] = PREC_rel;
+    precedence[TOKin] = PREC_rel;
 
-/********************************* ***************************/
+#if 0
+    precedence[TOKequal] = PREC_equal;
+    precedence[TOKnotequal] = PREC_equal;
+    precedence[TOKidentity] = PREC_equal;
+    precedence[TOKnotidentity] = PREC_equal;
+#else
+    /* Note that we changed precedence, so that < and != have the same
+     * precedence. This change is in the parser, too.
+     */
+    precedence[TOKequal] = PREC_rel;
+    precedence[TOKnotequal] = PREC_rel;
+    precedence[TOKidentity] = PREC_rel;
+    precedence[TOKnotidentity] = PREC_rel;
+#endif
+
+    precedence[TOKand] = PREC_and;
+
+    precedence[TOKxor] = PREC_xor;
+
+    precedence[TOKor] = PREC_or;
+
+    precedence[TOKandand] = PREC_andand;
+
+    precedence[TOKoror] = PREC_oror;
+
+    precedence[TOKquestion] = PREC_cond;
+
+    precedence[TOKassign] = PREC_assign;
+    precedence[TOKconstruct] = PREC_assign;
+    precedence[TOKblit] = PREC_assign;
+    precedence[TOKaddass] = PREC_assign;
+    precedence[TOKminass] = PREC_assign;
+    precedence[TOKcatass] = PREC_assign;
+    precedence[TOKmulass] = PREC_assign;
+    precedence[TOKdivass] = PREC_assign;
+    precedence[TOKmodass] = PREC_assign;
+    precedence[TOKshlass] = PREC_assign;
+    precedence[TOKshrass] = PREC_assign;
+    precedence[TOKushrass] = PREC_assign;
+    precedence[TOKandass] = PREC_assign;
+    precedence[TOKorass] = PREC_assign;
+    precedence[TOKxorass] = PREC_assign;
+
+    precedence[TOKcomma] = PREC_expr;
+}
 
diff -aruw dmd62/parse.h dmd63/parse.h
--- dmd62/parse.h	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/parse.h	2010-08-09 14:33:14.000000000 -0400
@@ -143,4 +143,30 @@
     void addComment(Dsymbol *s, unsigned char *blockComment);
 };
 
+// Operator precedence - greater values are higher precedence
+
+enum PREC
+{
+    PREC_zero,
+    PREC_expr,
+    PREC_assign,
+    PREC_cond,
+    PREC_oror,
+    PREC_andand,
+    PREC_or,
+    PREC_xor,
+    PREC_and,
+    PREC_equal,
+    PREC_rel,
+    PREC_shift,
+    PREC_add,
+    PREC_mul,
+    PREC_unary,
+    PREC_primary,
+};
+
+extern enum PREC precedence[TOKMAX];
+
+void initPrecedence();
+
 #endif /* DMD_PARSE_H */
diff -aruw dmd62/root/async.c dmd63/root/async.c
--- dmd62/root/async.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/root/async.c	2010-08-09 14:33:14.000000000 -0400
@@ -8,7 +8,6 @@
 #if _WIN32
 
 #include <windows.h>
-#include <stdio.h>
 #include <errno.h>
 #include <process.h>
 
@@ -113,6 +112,153 @@
     return EXIT_SUCCESS;                // if skidding
 }
 
+#elif linux  // Posix
+
+#include <errno.h>
+#include <pthread.h>
+#include <time.h>
+
+#include "root.h"
+#include "rmem.h"
+
+void *startthread(void *arg);
+
+void err_abort(int status, const char *msg)
+{
+    fprintf(stderr, "fatal error = %d, %s\n", status, msg);
+    exit(EXIT_FAILURE);
+}
+
+struct FileData
+{
+    File *file;
+    int result;
+
+    pthread_mutex_t mutex;
+    pthread_cond_t cond;
+    int value;
+};
+
+struct AsyncRead
+{
+    static AsyncRead *create(size_t nfiles);
+    void addFile(File *file);
+    void start();
+    int read(size_t i);
+    static void dispose(AsyncRead *);
+
+    size_t filesdim;
+    size_t filesmax;
+    FileData files[1];
+};
+
+
+AsyncRead *AsyncRead::create(size_t nfiles)
+{
+    AsyncRead *aw = (AsyncRead *)mem.calloc(1, sizeof(AsyncRead) +
+                                (nfiles - 1) * sizeof(FileData));
+    aw->filesmax = nfiles;
+    return aw;
+}
+
+void AsyncRead::addFile(File *file)
+{
+    //printf("addFile(file = %p)\n", file);
+    //printf("filesdim = %d, filesmax = %d\n", filesdim, filesmax);
+    assert(filesdim < filesmax);
+    FileData *f = &files[filesdim];
+    f->file = file;
+
+    int status = pthread_mutex_init(&f->mutex, NULL);
+    if (status != 0)
+        err_abort(status, "init mutex");
+    status = pthread_cond_init(&f->cond, NULL);
+    if (status != 0)
+        err_abort(status, "init cond");
+
+    filesdim++;
+}
+
+void AsyncRead::start()
+{
+    //printf("aw->filesdim = %p %d\n", this, filesdim);
+    if (filesdim)
+    {
+        pthread_t thread_id;
+        int status = pthread_create(&thread_id,
+            NULL,
+            &startthread,
+            this);
+        if (status != 0)
+            err_abort(status, "create thread");
+    }
+}
+
+int AsyncRead::read(size_t i)
+{
+    FileData *f = &files[i];
+
+    // Wait for the event
+    int status = pthread_mutex_lock(&f->mutex);
+    if (status != 0)
+        err_abort(status, "lock mutex");
+    while (f->value == 0)
+    {
+        status = pthread_cond_wait(&f->cond, &f->mutex);
+        if (status != 0)
+            err_abort(status, "wait on condition");
+    }
+    status = pthread_mutex_unlock(&f->mutex);
+    if (status != 0)
+        err_abort(status, "unlock mutex");
+
+    return f->result;
+}
+
+void AsyncRead::dispose(AsyncRead *aw)
+{
+    //printf("AsyncRead::dispose()\n");
+    for (int i = 0; i < aw->filesdim; i++)
+    {
+        FileData *f = &aw->files[i];
+        int status = pthread_cond_destroy(&f->cond);
+        if (status != 0)
+            err_abort(status, "cond destroy");
+        status = pthread_mutex_destroy(&f->mutex);
+        if (status != 0)
+            err_abort(status, "mutex destroy");
+    }
+    delete aw;
+}
+
+
+void *startthread(void *p)
+{
+    AsyncRead *aw = (AsyncRead *)p;
+
+    //printf("startthread: aw->filesdim = %p %d\n", aw, aw->filesdim);
+    size_t dim = aw->filesdim;
+    for (size_t i = 0; i < dim; i++)
+    {   FileData *f = &aw->files[i];
+
+        f->result = f->file->read();
+
+        // Set event
+        int status = pthread_mutex_lock(&f->mutex);
+        if (status != 0)
+            err_abort(status, "lock mutex");
+        f->value = 1;
+        status = pthread_cond_signal(&f->cond);
+        if (status != 0)
+            err_abort(status, "signal condition");
+        status = pthread_mutex_unlock(&f->mutex);
+        if (status != 0)
+            err_abort(status, "unlock mutex");
+    }
+
+    return NULL;                        // end thread
+}
+
 #else
 
 #include <stdio.h>
diff -aruw dmd62/root/port.c dmd63/root/port.c
--- dmd62/root/port.c	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/root/port.c	2010-08-09 14:33:14.000000000 -0400
@@ -322,6 +322,9 @@
 #include <bits/nan.h>
 #include <bits/mathdef.h>
 #endif
+#if __FreeBSD__ && __i386__
+#include <ieeefp.h>
+#endif
 #include <time.h>
 #include <sys/time.h>
 #include <unistd.h>
@@ -355,11 +358,13 @@
         foo = -foo;     // turn off sign bit
     Port::nan = foo;
 
-#if __FreeBSD__
+#if __FreeBSD__ && __i386__
     // LDBL_MAX comes out as infinity. Fix.
     static unsigned char x[sizeof(long double)] =
         { 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x7F };
     Port::ldbl_max = *(long double *)&x[0];
+    // FreeBSD defaults to double precision. Switch to extended precision.
+    fpsetprec(FP_PE);
 #endif
 }
 
diff -aruw dmd62/root/root.c dmd63/root/root.c
--- dmd62/root/root.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/root/root.c	2010-08-09 14:33:14.000000000 -0400
@@ -29,6 +29,7 @@
 #if _WIN32
 #include <windows.h>
 #include <direct.h>
+#include <errno.h>
 #endif
 
 #if POSIX
@@ -957,11 +958,17 @@
 #if POSIX
                 if (mkdir(path, 0777))
 #endif
+                {
+                    /* Don't error out if another instance of dmd just created
+                     * this directory
+                     */
+                    if (errno != EEXIST)
                     error("cannot create directory %s", path);
             }
         }
     }
 }
+}
 
 
 /******************************************
@@ -1749,7 +1756,7 @@
 void OutBuffer::write4(unsigned w)
 {
     reserve(4);
-    *(unsigned long *)(this->data + offset) = w;
+    *(unsigned *)(this->data + offset) = w;
     offset += 4;
 }
 
diff -aruw dmd62/s2ir.c dmd63/s2ir.c
--- dmd62/s2ir.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/s2ir.c	2010-08-09 14:33:14.000000000 -0400
@@ -89,20 +89,25 @@
  * Convert label to block.
  */
 
-block *labelToBlock(Loc loc, Blockx *blx, LabelDsymbol *label)
+block *labelToBlock(Loc loc, Blockx *blx, LabelDsymbol *label, int flag = 0)
 {
-    LabelStatement *s;
-
     if (!label->statement)
     {
         error(loc, "undefined label %s", label->toChars());
         return NULL;
     }
-    s = label->statement;
+    LabelStatement *s = label->statement;
     if (!s->lblock)
     {   s->lblock = block_calloc(blx);
-        if (s->isReturnLabel)
-            s->lblock->Btry = NULL;
+        s->lblock->Btry = NULL;         // fill this in later
+
+        if (flag)
+        {
+            // Keep track of the forward reference to this block, so we can check it later
+            if (!s->fwdrefs)
+                s->fwdrefs = new Array();
+            s->fwdrefs->push(s->lblock);
+        }
     }
     return s->lblock;
 }
@@ -809,7 +814,7 @@
     if (tf != label->statement->tf)
         error("cannot goto forward out of or into finally block");
 
-    bdest = labelToBlock(loc, blx, label);
+    bdest = labelToBlock(loc, blx, label, 1);
     if (!bdest)
         return;
     b = blx->curblock;
@@ -846,11 +851,34 @@
 
     if (lblock)
     {
-        // We had made a guess about which tryblock the label is in.
-        // Error if we guessed wrong.
-        // BUG: should fix this
-        if (lblock->Btry != blx->tryblock)
-            error("cannot goto forward into different try block level");
+        // At last, we know which try block this label is inside
+        lblock->Btry = blx->tryblock;
+
+        /* Go through the forward references and check.
+         */
+        if (fwdrefs)
+        {
+            for (int i = 0; i < fwdrefs->dim; i++)
+            {   block *b = (block *)fwdrefs->data[i];
+
+                if (b->Btry != lblock->Btry)
+                {
+                    // Check that lblock is in an enclosing try block
+                    for (block *bt = b->Btry; bt != lblock->Btry; bt = bt->Btry)
+                    {
+                        if (!bt)
+                        {
+                            //printf("b->Btry = %p, lblock->Btry = %p\n", b->Btry, lblock->Btry);
+                            error("cannot goto into try block");
+                            break;
+                        }
+                    }
+                }
+
+            }
+            delete fwdrefs;
+            fwdrefs = NULL;
+        }
     }
     else
         lblock = block_calloc(blx);
diff -aruw dmd62/solaris.mak dmd63/solaris.mak
--- dmd62/solaris.mak	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/solaris.mak	2010-08-09 14:33:14.000000000 -0400
@@ -3,15 +3,19 @@
 TK=tk
 ROOT=root
 
-CC=g++ -m32
+MODEL=-m32
+
+CC=g++ $(MODEL)
 
 #OPT=-g -g3
 #OPT=-O2
 
 #COV=-fprofile-arcs -ftest-coverage
 
-#GFLAGS = -Wno-deprecated -D__near= -D__pascal= -fno-exceptions -g -DDEBUG=1 $(COV)
-GFLAGS = -Wno-deprecated -D__near= -D__pascal= -fno-exceptions -O2
+WARNINGS=-Wno-deprecated -Wstrict-aliasing
+
+#GFLAGS = $(WARNINGS) -D__near= -D__pascal= -fno-exceptions -g -DDEBUG=1 $(COV)
+GFLAGS = $(WARNINGS) -D__near= -D__pascal= -fno-exceptions -O2
 
 CFLAGS = $(GFLAGS) -I$(ROOT) -D__I86__=1 -DMARS=1 -DTARGET_SOLARIS=1 -D_DH
 MFLAGS = $(GFLAGS) -I$C -I$(TK) -D__I86__=1 -DMARS=1 -DTARGET_SOLARIS=1 -D_DH
@@ -22,7 +26,7 @@
 
 DMD_OBJS = \
 	access.o array.o attrib.o bcomplex.o bit.o blockopt.o \
-	cast.o code.o cg.o cg87.o cgcod.o cgcs.o cgcv.o cgelem.o cgen.o \
+	cast.o code.o cg.o cg87.o cgcod.o cgcs.o cgelem.o cgen.o \
 	cgreg.o cgsched.o class.o cod1.o cod2.o cod3.o cod4.o cod5.o \
 	constfold.o irstate.o dchar.o cond.o debug.o \
 	declaration.o dsymbol.o dt.o dump.o e2ir.o ee.o eh.o el.o \
@@ -49,7 +53,7 @@
 	inifile.c iasm.c module.c scope.c dump.c init.h init.c attrib.h \
 	attrib.c opover.c class.c mangle.c bit.c tocsym.c func.c inline.c \
 	access.c complex_t.h irstate.h irstate.c glue.c msc.c ph.c tk.c \
-	s2ir.c todt.c e2ir.c util.c identifier.h parse.h objfile.h \
+	s2ir.c todt.c e2ir.c util.c identifier.h parse.h \
 	scope.h enum.h import.h mars.h module.h mtype.h dsymbol.h \
 	declaration.h lexer.h expression.h irstate.h statement.h eh.c \
 	utf.h utf.c staticassert.h staticassert.c unialpha.c \
@@ -88,8 +92,8 @@
 
 all: dmd
 
-dmd: id.o optabgen $(DMD_OBJS)
-	gcc -m32 -lstdc++ $(COV) $(DMD_OBJS) -o dmd
+dmd: $(DMD_OBJS)
+	gcc $(MODEL) -lstdc++ -lpthread $(COV) $(DMD_OBJS) -o dmd
 
 clean:
 	rm -f $(DMD_OBJS) dmd optab.o id.o impcnvgen idgen id.c id.h \
@@ -103,30 +107,31 @@
 	$(CC) $(MFLAGS) $< -o optabgen
 	./optabgen
 
-debtab.c optab.c cdxxx.c elxxx.c fltables.c tytab.c : optabgen
-	./optabgen
+optabgen_output = debtab.c optab.c cdxxx.c elxxx.c fltables.c tytab.c
+$(optabgen_output) : optabgen
 
 ######## idgen generates some source
 
-id.h id.c : idgen
-	./idgen
+idgen_output = id.h id.c
+$(idgen_output) : idgen
 
 idgen : idgen.c
 	$(CC) idgen.c -o idgen
-
-id.o : id.h id.c
-	$(CC) -c $(CFLAGS) id.c
+	./idgen
 
 ######### impcnvgen generates some source
 
-impcnvtab.c : impcnvgen
-	./impcnvgen
+impcnvtab_output = impcnvtab.c
+$(impcnvtab_output) : impcnvgen
 
 impcnvgen : mtype.h impcnvgen.c
 	$(CC) $(CFLAGS) impcnvgen.c -o impcnvgen
+	./impcnvgen
 
 #########
 
+$(DMD_OBJS) : $(idgen_output) $(optabgen_output) $(impcnvgen_output)
+
 aa.o: $C/aa.h $C/tinfo.h $C/aa.c
 	$(CC) -c $(MFLAGS) -I. $C/aa.c
 
@@ -152,7 +157,7 @@
 	$(CC) -c $(CFLAGS) $<
 
 bcomplex.o: $C/bcomplex.c
-	$(CC) -c $(MFLAGS) $C/bcomplex.c
+	$(CC) -c $(MFLAGS) $<
 
 bit.o: expression.h bit.c
 	$(CC) -c -I$(ROOT) $(MFLAGS) bit.c
@@ -328,6 +333,9 @@
 iasm.o : $(CH) $(TOTALH) $C/iasm.h iasm.c
 	$(CC) -c $(MFLAGS) -I$(ROOT) iasm.c
 
+id.o : id.h id.c
+	$(CC) -c $(CFLAGS) id.c
+
 identifier.o: identifier.c
 	$(CC) -c $(CFLAGS) $<
 
@@ -455,7 +463,7 @@
 	$(CC) -c $(GFLAGS) -I$(ROOT) $<
 
 strtold.o: $C/strtold.c
-	gcc -m32 -c $C/strtold.c
+	gcc $(MODEL) -c $C/strtold.c
 
 struct.o: struct.c
 	$(CC) -c $(CFLAGS) $<
diff -aruw dmd62/statement.c dmd63/statement.c
--- dmd62/statement.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/statement.c	2010-08-09 14:33:14.000000000 -0400
@@ -1829,6 +1829,11 @@
                  */
                 Expressions *exps = new Expressions();
                 exps->push(flde);
+                if (aggr->op == TOKdelegate &&
+                    ((DelegateExp *)aggr)->func->isNested())
+                    // See Bugzilla 3560
+                    e = new CallExp(loc, ((DelegateExp *)aggr)->e1, exps);
+                else
                 e = new CallExp(loc, aggr, exps);
                 e = e->semantic(sc);
                 if (e->type != Type::tint32)
@@ -3766,9 +3771,11 @@
     else if (exp->op == TOKtype)
     {   TypeExp *es = (TypeExp *)exp;
 
-        sym = es->type->toDsymbol(sc)->isScopeDsymbol();
+        Dsymbol *s = es->type->toDsymbol(sc);
+        sym = s ? s->isScopeDsymbol() : NULL;
         if (!sym)
-        {   error("%s has no members", es->toChars());
+        {   error("with type %s has no members", es->toChars());
+            if (body)
             body = body->semantic(sc);
             return this;
         }
@@ -4323,7 +4330,7 @@
     this->statement = statement;
     this->tf = NULL;
     this->lblock = NULL;
-    this->isReturnLabel = 0;
+    this->fwdrefs = NULL;
 }
 
 Statement *LabelStatement::syntaxCopy()
diff -aruw dmd62/statement.h dmd63/statement.h
--- dmd62/statement.h	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/statement.h	2010-08-09 14:33:14.000000000 -0400
@@ -791,7 +791,8 @@
     Statement *statement;
     TryFinallyStatement *tf;
     block *lblock;              // back end
-    int isReturnLabel;
+
+    Array *fwdrefs;             // forward references to this LabelStatement
 
     LabelStatement(Loc loc, Identifier *ident, Statement *statement);
     Statement *syntaxCopy();
diff -aruw dmd62/tocsym.c dmd63/tocsym.c
--- dmd62/tocsym.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/tocsym.c	2010-08-09 14:33:14.000000000 -0400
@@ -141,7 +141,7 @@
     id = (char *) alloca(6 + strlen(n) + 1 + sizeof(type_paramsize(sym->Stype))*3 + 1);
     if (sym->Stype->Tmangle == mTYman_std && tyfunc(sym->Stype->Tty))
     {
-        sprintf(id,"_imp__%s@%lu",n,type_paramsize(sym->Stype));
+        sprintf(id,"_imp__%s@%lu",n,(unsigned long)type_paramsize(sym->Stype));
     }
     else if (sym->Stype->Tmangle == mTYman_d)
         sprintf(id,"_imp_%s",n);
diff -aruw dmd62/todt.c dmd63/todt.c
--- dmd62/todt.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/todt.c	2010-08-09 14:33:14.000000000 -0400
@@ -1,6 +1,6 @@
 
 // Compiler implementation of the D programming language
-// Copyright (c) 1999-2009 by Digital Mars
+// Copyright (c) 1999-2010 by Digital Mars
 // All Rights Reserved
 // written by Walter Bright
 // http://www.digitalmars.com
@@ -692,7 +692,8 @@
                 assert(sz <= vsz);
 
                 unsigned dim = 1;
-                for (Type *vt = v->type->toBasetype();
+                Type *vt;
+                for (vt = v->type->toBasetype();
                      vt->ty == Tsarray;
                      vt = vt->next->toBasetype())
                 {   TypeSArray *tsa = (TypeSArray *)vt;
@@ -708,7 +709,7 @@
                         if (v->init)
                             d = v->init->toDt();
                         else
-                            v->type->toDt(&d);
+                            vt->toDt(&d);
                     }
                     pdt = dtcat(pdt, d);
                     d = NULL;
diff -aruw dmd62/traits.c dmd63/traits.c
--- dmd62/traits.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/traits.c	2010-08-09 14:33:14.000000000 -0400
@@ -354,7 +354,7 @@
 
             global.gag--;
             if (errors != global.errors)
-            {   if (global.gag == 0)
+            {
                     global.errors = errors;
                 goto Lfalse;
             }
diff -aruw dmd62/util.c dmd63/util.c
--- dmd62/util.c	2010-06-09 19:06:30.000000000 -0400
+++ dmd63/util.c	2010-08-09 14:33:14.000000000 -0400
@@ -265,12 +265,9 @@
 #elif UTIL_PH
     return ph_malloc(n * size);
 #else
-    void *p;
-    unsigned long nbytes;
-
-    nbytes = (unsigned long) n * (unsigned long) size;
-    p = malloc(nbytes);
-    if (!p && (size_t)nbytes)
+    size_t nbytes = (size_t)n * (size_t)size;
+    void *p = malloc(nbytes);
+    if (!p && nbytes)
         err_nomem();
     return p;
 #endif
@@ -292,12 +289,9 @@
 #elif UTIL_PH
     return ph_calloc(n * size);
 #else
-    void *p;
-    unsigned long nbytes;
-
-    nbytes = (unsigned long) n * (unsigned long) size;
-    p = calloc(n,size);
-    if (!p && (size_t)nbytes)
+    size_t nbytes = (size_t) n * (size_t) size;
+    void *p = calloc(n,size);
+    if (!p && nbytes)
         err_nomem();
     return p;
 #endif
@@ -333,12 +327,9 @@
 #elif UTIL_PH
     return ph_realloc(oldp,n * size);
 #else
-    void *p;
-    unsigned long nbytes;
-
-    nbytes = (unsigned long) n * (unsigned long) size;
-    p = realloc(oldp,nbytes);
-    if (!p && (size_t)nbytes)
+    size_t nbytes = (size_t) n * (size_t) size;
+    void *p = realloc(oldp,nbytes);
+    if (!p && nbytes)
         err_nomem();
     return p;
 #endif
diff -aruw dmd62/win32.mak dmd63/win32.mak
--- dmd62/win32.mak	2010-06-09 19:06:32.000000000 -0400
+++ dmd63/win32.mak	2010-08-09 14:33:14.000000000 -0400
@@ -1,5 +1,5 @@
 #_ win32.mak
-# Copyright (C) 1999-2009 by Digital Mars, http://www.digitalmars.com
+# Copyright (C) 1999-2010 by Digital Mars, http://www.digitalmars.com
 # Written by Walter Bright
 # All Rights Reserved
 # Build dmd with Digital Mars C++ compiler
@@ -109,7 +109,7 @@
 	eh.c toctype.c class.c mangle.c bit.c tocsym.c func.c inline.c \
 	access.c complex_t.h unialpha.c irstate.h irstate.c glue.c msc.c \
 	ph.c tk.c s2ir.c todt.c e2ir.c util.c toobj.c cppmangle.c \
-	identifier.h parse.h objfile.h scope.h enum.h import.h \
+	identifier.h parse.h scope.h enum.h import.h \
 	typinf.c tocvdebug.c toelfdebug.c mars.h module.h mtype.h dsymbol.h \
 	declaration.h lexer.h expression.h statement.h doc.h doc.c \
 	macro.h macro.c hdrgen.h hdrgen.c arraytypes.h \
@@ -495,7 +495,7 @@
 	del elxxx.c cdxxx.c optab.c debtab.c fltables.c tytab.c
 	del impcnvtab.c
 
-zip : detab $(MAKEFILES)
+zip : detab tolf $(MAKEFILES)
 	del dmdsrc.zip
 	zip32 dmdsrc $(MAKEFILES)
 	zip32 dmdsrc $(SRCS)
@@ -508,6 +508,9 @@
 detab:
 	detab $(SRCS) $(ROOTSRC) $(TKSRC) $(BACKSRC)
 
+tolf:
+	tolf $(SRCS) $(ROOTSRC) $(TKSRC) $(BACKSRC) $(MAKEFILES)
+
 ################### Install ################
 
 install: detab install2
@@ -527,7 +530,7 @@
 
 ################### Write to SVN ################
 
-svn:	detab svn2
+svn:	detab tolf svn2
 
 svn2:
 	$(CP) $(SRCS) $(DMDSVN)\ 
