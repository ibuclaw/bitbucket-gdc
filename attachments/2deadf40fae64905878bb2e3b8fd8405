diff -r f12bfe124807 d/druntime/import/core/stdc/math.d
--- a/d/druntime/import/core/stdc/math.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/druntime/import/core/stdc/math.d	Thu Oct 14 14:12:53 2010 +0100
@@ -11,6 +11,8 @@
 private import core.stdc.config;
 
 extern (C):
+pure: // Yuck, but needed until @trusted is implemented...
+nothrow:
 
 alias float  float_t;
 alias double double_t;
@@ -925,4 +927,4 @@
     double  fma(double x, double y, double z);
     float   fmaf(float x, float y, float z);
     real    fmal(real x, real y, real z);
-}
\ No newline at end of file
+}
diff -r f12bfe124807 d/phobos2/Makefile.am
--- a/d/phobos2/Makefile.am	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/Makefile.am	Thu Oct 14 14:12:53 2010 +0100
@@ -178,25 +178,26 @@
 std/boxer.t.o: std/boxer.o
 	cp $< $@
 
+# random has deprecated function
+std/random.o: std/random.d
+	$(GDC) -o $@ $(ALL_DFLAGS) -fdeprecated \
+	-I $(srcdir) -I ./$(host_alias) -c $<
+
 unittest: unittest.o libgphobos2_t.a libgphobos2.a
-	$(GDC) -o $@ $(CFLAGS) unittest.o -L./ -lgphobos2_t $(LIBS)
+	$(GDC) -o $@ $(CFLAGS) -fdeprecated unittest.o -L./ -lgphobos2_t $(LIBS)
 
-MAIN_OBJS=std/compiler.o std/system.o std/md5.o std/base64.o \
-	std/string.o std/math.o std/array.o \
-	std/outbuffer.o std/ctype.o std/regexp.o std/random.o \
-	std/stream.o std/cstream.o \
-	std/utf.o std/uri.o \
-	crc32.o std/conv.o \
-	std/syserror.o std/metastrings.o \
-	std/c/stdarg.o std/c/stdio.o std/stdio.o std/format.o \
-	std/openrj.o std/uni.o std/demangle.o std/bitarray.o \
-	std/date.o std/dateparse.o etc/c/zlib.o std/zlib.o std/zip.o \
-	std/stdarg.o \
-	std/signals.o std/cpuid.o std/traits.o std/typetuple.o std/bind.o \
-	std/algorithm.o std/bitmanip.o std/contracts.o std/functional.o \
-	std/getopt.o std/numeric.o std/typecons.o std/variant.o \
-	std/complex.o std/encoding.o std/iterator.o std/xml.o \
-	std/atomics.o std/bigint.o
+MAIN_OBJS=std/algorithm.o std/atomics.o std/array.o std/base64.o \
+	std/bigint.o std/bind.o std/bitarray.o std/bitmanip.o \
+	std/compiler.o std/complex.o std/contracts.o std/conv.o \
+	std/cpuid.o std/cstream.o std/ctype.o std/date.o std/dateparse.o \
+	std/demangle.o std/encoding.o std/format.o std/functional.o \
+	std/getopt.o std/iterator.o std/math.o std/md5.o std/metastrings.o \
+	std/numeric.o std/openrj.o std/outbuffer.o std/signals.o \
+	std/stdarg.o std/stdio.o std/stdiobase.o std/stream.o std/string.o \
+	std/syserror.o std/system.o std/random.o std/range.o std/regexp.o \
+	std/traits.o std/typecons.o std/typetuple.o std/uni.o std/uri.o \
+	std/utf.o std/variant.o std/xml.o std/zip.o std/zlib.o \
+	std/c/stdarg.o std/c/stdio.o crc32.o etc/c/zlib.o
 
 ZLIB_OBJS= zlib/adler32.o zlib/compress.o zlib/crc32.o \
 	zlib/gzio.o zlib/uncompr.o zlib/deflate.o \
@@ -243,16 +244,22 @@
 	$(RANLIB) $(DESTDIR)$(toolexeclibdir)/libgdruntime.a
 
 install-data-local: $(D_PREREQ_SRCS) libgphobos2.a libgdruntime.a
-	for i in etc etc/c \
+	for i in etc/c \
 		gcc std std/c \
-                std/c/darwin std/c/linux std/c/mach std/c/skyos std/c/unix std/c/windows \
+                std/c/linux std/c/osx std/c/unix std/c/windows \
 		std/windows; do \
 		$(mkinstalldirs) $(DESTDIR)$(gdc_include_dir)/$$i; \
 		for f in $(srcdir)/$$i/*.d; do $(INSTALL_HEADER) $$f $(DESTDIR)$(gdc_include_dir)/$$i; done; \
 	done
 	for i in core; do \
 		$(mkinstalldirs) $(DESTDIR)$(gdc_include_dir)/$$i; \
-		for f in $(srcdir)/common/$$i/*.d; do $(INSTALL_HEADER) $$f $(DESTDIR)$(gdc_include_dir)/$$i; done; \
+		for f in $(srcdir)/import/$$i/*.di; do $(INSTALL_HEADER) $$f $(DESTDIR)$(gdc_include_dir)/$$i; done; \
+	done
+	for i in core/stdc core/sys/osx/mach core/sys/posix \
+		core/sys/posix/arpa core/sys/posix/net core/sys/posix/inet \
+		core/sys/posix/sys core/sys/windows; do \
+		$(mkinstalldirs) $(DESTDIR)$(gdc_include_dir)/$$i; \
+		for f in $(srcdir)/import/$$i/*.d; do $(INSTALL_HEADER) $$f $(DESTDIR)$(gdc_include_dir)/$$i; done; \
 	done
 	for i in crc32.d object.di; do \
 		$(INSTALL_HEADER) $(srcdir)/$$i $(DESTDIR)$(gdc_include_dir); done
diff -r f12bfe124807 d/phobos2/Makefile.in
--- a/d/phobos2/Makefile.in	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/Makefile.in	Thu Oct 14 14:12:53 2010 +0100
@@ -284,22 +284,18 @@
 CMAIN_OBJS = compiler/gdc/dmain2.o
 GC_OBJS = $(subst gc_,gc/basic,$(D_GC_MODULES))
 ALL_DRUNTIME_OBJS = $(DRUNTIME_OBJS) $(COMMON_OBJS) $(GC_OBJS) $(GCC_OBJS)
-MAIN_OBJS = std/compiler.o std/system.o std/md5.o std/base64.o \
-	std/string.o std/math.o std/array.o \
-	std/outbuffer.o std/ctype.o std/regexp.o std/random.o \
-	std/stream.o std/cstream.o \
-	std/utf.o std/uri.o \
-	crc32.o std/conv.o \
-	std/syserror.o std/metastrings.o \
-	std/c/stdarg.o std/c/stdio.o std/stdio.o std/format.o \
-	std/openrj.o std/uni.o std/demangle.o std/bitarray.o \
-	std/date.o std/dateparse.o etc/c/zlib.o std/zlib.o std/zip.o \
-	std/stdarg.o \
-	std/signals.o std/cpuid.o std/traits.o std/typetuple.o std/bind.o \
-	std/algorithm.o std/bitmanip.o std/contracts.o std/functional.o \
-	std/getopt.o std/numeric.o std/typecons.o std/variant.o \
-	std/complex.o std/encoding.o std/iterator.o std/xml.o \
-	std/atomics.o std/bigint.o
+MAIN_OBJS = std/algorithm.o std/atomics.o std/array.o std/base64.o \
+	std/bigint.o std/bind.o std/bitarray.o std/bitmanip.o \
+	std/compiler.o std/complex.o std/contracts.o std/conv.o \
+	std/cpuid.o std/cstream.o std/ctype.o std/date.o std/dateparse.o \
+	std/demangle.o std/encoding.o std/format.o std/functional.o \
+	std/getopt.o std/iterator.o std/math.o std/md5.o std/metastrings.o \
+	std/numeric.o std/openrj.o std/outbuffer.o std/signals.o \
+	std/stdarg.o std/stdio.o std/stdiobase.o std/stream.o std/string.o \
+	std/syserror.o std/system.o std/random.o std/range.o std/regexp.o \
+	std/traits.o std/typecons.o std/typetuple.o std/uni.o std/uri.o \
+	std/utf.o std/variant.o std/xml.o std/zip.o std/zlib.o \
+	std/c/stdarg.o std/c/stdio.o crc32.o etc/c/zlib.o
 
 ZLIB_OBJS = zlib/adler32.o zlib/compress.o zlib/crc32.o \
 	zlib/gzio.o zlib/uncompr.o zlib/deflate.o \
@@ -749,6 +745,11 @@
 std/boxer.t.o: std/boxer.o
 	cp $< $@
 
+# random has deprecated function
+std/random.o: std/random.d
+	$(GDC) -o $@ $(ALL_DFLAGS) -fdeprecated \
+	-I $(srcdir) -I ./$(host_alias) -c $<
+
 unittest: unittest.o libgphobos2_t.a libgphobos2.a
 	$(GDC) -o $@ $(CFLAGS) unittest.o -L./ -lgphobos2_t $(LIBS)
 
@@ -777,16 +778,22 @@
 	$(RANLIB) $(DESTDIR)$(toolexeclibdir)/libgdruntime.a
 
 install-data-local: $(D_PREREQ_SRCS) libgphobos2.a libgdruntime.a
-	for i in etc etc/c \
+	for i in etc/c \
 		gcc std std/c \
-                std/c/darwin std/c/linux std/c/mach std/c/skyos std/c/unix std/c/windows \
+                std/c/linux std/c/osx std/c/unix std/c/windows \
 		std/windows; do \
 		$(mkinstalldirs) $(DESTDIR)$(gdc_include_dir)/$$i; \
 		for f in $(srcdir)/$$i/*.d; do $(INSTALL_HEADER) $$f $(DESTDIR)$(gdc_include_dir)/$$i; done; \
 	done
 	for i in core; do \
 		$(mkinstalldirs) $(DESTDIR)$(gdc_include_dir)/$$i; \
-		for f in $(srcdir)/common/$$i/*.d; do $(INSTALL_HEADER) $$f $(DESTDIR)$(gdc_include_dir)/$$i; done; \
+		for f in $(srcdir)/import/$$i/*.di; do $(INSTALL_HEADER) $$f $(DESTDIR)$(gdc_include_dir)/$$i; done; \
+	done
+	for i in core/stdc core/sys/osx/mach core/sys/posix \
+		core/sys/posix/arpa core/sys/posix/net core/sys/posix/inet \
+		core/sys/posix/sys core/sys/windows; do \
+		$(mkinstalldirs) $(DESTDIR)$(gdc_include_dir)/$$i; \
+		for f in $(srcdir)/import/$$i/*.d; do $(INSTALL_HEADER) $$f $(DESTDIR)$(gdc_include_dir)/$$i; done; \
 	done
 	for i in crc32.d object.di; do \
 		$(INSTALL_HEADER) $(srcdir)/$$i $(DESTDIR)$(gdc_include_dir); done
diff -r f12bfe124807 d/phobos2/acinclude.m4
--- a/d/phobos2/acinclude.m4	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/acinclude.m4	Thu Oct 14 14:12:53 2010 +0100
@@ -79,7 +79,7 @@
 AC_CHECK_FUNC(getpwnam_r,DCFG_GETPWNAM_R="GNU_Unix_Have_getpwnam_r",[])
 
 
-D_EXTRA_OBJS="std/c/dirent.o std/c/unix/unix.o $D_EXTRA_OBJS"
+D_EXTRA_OBJS="std/c/unix/unix.o $D_EXTRA_OBJS"
 DRUNTIME_OBJS="gcc/config/unix.o gcc/cbridge_fdset.o $DRUNTIME_OBJS"
 # Add "linux" module for compatibility even if not Linux
 D_EXTRA_OBJS="std/c/linux/linux.o $D_EXTRA_OBJS"
diff -r f12bfe124807 d/phobos2/config/ldfuncs-darwin
--- a/d/phobos2/config/ldfuncs-darwin	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/config/ldfuncs-darwin	Thu Oct 14 14:12:53 2010 +0100
@@ -1,5 +1,5 @@
 
-private import std.c.darwin.ldblcompat;
+private import gcc.ldblcompat;
 
 extern (C) {
 
diff -r f12bfe124807 d/phobos2/config/ldfuncs-ppclinux
--- a/d/phobos2/config/ldfuncs-ppclinux	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/config/ldfuncs-ppclinux	Thu Oct 14 14:12:53 2010 +0100
@@ -1,5 +1,5 @@
 
-private import std.c.linux.ldblcompat;
+private import gcc.ldblcompat;
 
 extern (C) {
 
diff -r f12bfe124807 d/phobos2/config/unix.x3
--- a/d/phobos2/config/unix.x3	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/config/unix.x3	Thu Oct 14 14:12:53 2010 +0100
@@ -1,7 +1,6 @@
 x3_out_text(""
     "module gcc.config.unix;\n"
-    "private import gcc.config.config;\n"
-    "private import std.stdint;\n");
+    "private import gcc.config.config;\n");
 
 x3_gi_push_header("\"config.h\"");
 x3_gi_push_header("<sys/types.h>"); // pretty much need this..
diff -r f12bfe124807 d/phobos2/configure
--- a/d/phobos2/configure	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/configure	Thu Oct 14 14:12:53 2010 +0100
@@ -5737,7 +5737,7 @@
 
 
 
-D_EXTRA_OBJS="std/c/dirent.o std/c/unix/unix.o $D_EXTRA_OBJS"
+D_EXTRA_OBJS="std/c/unix/unix.o $D_EXTRA_OBJS"
 DRUNTIME_OBJS="gcc/config/unix.o gcc/cbridge_fdset.o $DRUNTIME_OBJS"
 # Add "linux" module for compatibility even if not Linux
 D_EXTRA_OBJS="std/c/linux/linux.o $D_EXTRA_OBJS"
diff -r f12bfe124807 d/phobos2/gcc/deh.d
--- a/d/phobos2/gcc/deh.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/gcc/deh.d	Thu Oct 14 14:12:53 2010 +0100
@@ -27,7 +27,6 @@
 
 private import core.memory;
 private import core.stdc.stdlib;
-//private import std.c.process;
 
 static if (Use_ARM_EABI_Unwinder)
     const _Unwind_Exception_Class GDC_Exception_Class =
diff -r f12bfe124807 d/phobos2/gcc/threadsem.d
--- a/d/phobos2/gcc/threadsem.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/gcc/threadsem.d	Thu Oct 14 14:12:53 2010 +0100
@@ -20,7 +20,7 @@
 
 version (GNU_Semaphore_POSIX)
 {
-    private import std.c.unix.unix;
+    private import core.sys.posix.semaphore;
     struct Semaphore {
 	sem_t sem;
 	bool create() {  return sem_init(& sem, 0, 0) == 0; }
@@ -31,7 +31,7 @@
 }
 else version (GNU_Semaphore_Mach)
 {
-    private import std.c.mach.mach;
+    private import core.sys.osx.mach.semaphore;
     struct Semaphore {
 	semaphore_t sem;
 	bool create() {
@@ -43,7 +43,7 @@
 }
 else version (GNU_Sempahore_Pthreads)
 {
-    private import std.c.unix.unix;
+    private import core.sys.posix.semaphore;
     struct Semaphore {
 	pthread_mutex_t lock;
 	pthread_cond_t  cond;
diff -r f12bfe124807 d/phobos2/std/algorithm.d
--- a/d/phobos2/std/algorithm.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/algorithm.d	Thu Oct 14 14:12:53 2010 +0100
@@ -3,8 +3,9 @@
 /**
 Implements algorithms oriented mainly towards processing of
 sequences. Some functions are semantic equivalents or supersets of
-those found in the $(D algorithm) header in $(WEB sgi.com/tech/stl/,
-Alexander Stepanov's Standard Template Library) for C++.
+those found in the $(D $(LESS)_algorithm$(GREATER)) header in $(WEB
+sgi.com/tech/stl/, Alexander Stepanov's Standard Template Library) for
+C++.
 
 Author:
 $(WEB erdani.org, Andrei Alexandrescu)
@@ -36,163 +37,119 @@
 sort(a);            // no predicate, "a < b" is implicit
 ----
 
-Some functions are additionally parameterized with primitives such as
-$(D move) (defaulting to $(XREF _algorithm,move)) or $(D iterSwap)
-primitive (defaulting to $(XREF _algorithm,iterSwap)). These
-parameters distill the way in which data is manipulated, and the
-algorithms guarantee they only use them to touch values. There is
-sometimes a need to override that default behavior. Possible uses
-include notifying observers, counting the number of operations, or
-manipulating multiple collections in lockstep.
-
 Macros:
 WIKI = Phobos/StdAlgorithm
 */
 
-/*
- *  Copyright (C) 2004-2006 by Digital Mars, www.digitalmars.com
- *  Written by Andrei Alexandrescu, www.erdani.org
- *
- *  This software is provided 'as-is', without any express or implied
- *  warranty. In no event will the authors be held liable for any damages
- *  arising from the use of this software.
- *
- *  Permission is granted to anyone to use this software for any purpose,
- *  including commercial applications, and to alter it and redistribute it
- *  freely, subject to the following restrictions:
- *
- *  o  The origin of this software must not be misrepresented; you must not
- *     claim that you wrote the original software. If you use this software
- *     in a product, an acknowledgment in the product documentation would be
- *     appreciated but is not required.
- *  o  Altered source versions must be plainly marked as such, and must not
- *     be misrepresented as being the original software.
- *  o  This notice may not be removed or altered from any source
- *     distribution.
- */
-
 module std.algorithm;
-private import std.math;
-private import std.date;
-private import std.functional;
-private import std.iterator;
-private import std.conv;
-private import std.typecons;
-private import std.typetuple;
-private import std.metastrings;
-private import std.contracts;
-private import std.traits;
-private import std.c.string;
+import std.c.string;
+import std.array;
+import std.contracts;
+import std.conv;
+import std.date;
+import std.functional;
+import std.math;
+import std.metastrings;
+import std.range;
+import std.traits;
+import std.typecons;
+import std.typetuple;
 
 version(unittest)
 {
-    private import std.stdio;
-    private import std.random;
-    import std.string;
+    import std.random, std.stdio, std.string;
 }
 
 /**
 Implements the homonym function (also known as $(D transform)) present
-in many languages of functional flavor. The call $(D map!(fun)(range1,
-range2, ..., rangeN)) returns a new range of which elements are
-obtained by applying $(D fun(x)) left to right for all $(D x) in $(D
-range1), then all $(D x) in $(D range2), ..., all $(D x) in $(D
-rangeN). The original ranges are not changed.
+in many languages of functional flavor. The call $(D map!(fun)(range))
+returns a range of which elements are obtained by applying $(D fun(x))
+left to right for all $(D x) in $(D range). The original ranges are
+not changed. Evaluation is done lazily. The range returned by $(D map)
+caches the last value such that evaluating $(D front) multiple times
+does not result in multiple calls to $(D fun).
 
 Example:
 ----
 int[] arr1 = [ 1, 2, 3, 4 ];
 int[] arr2 = [ 5, 6 ];
-auto squares = map!("a * a")(arr1, arr2);
-assert(squares == [ 1, 4, 9, 16, 25, 36 ]);
+auto squares = map!("a * a")(chain(arr1, arr2));
+assert(equal(squares, [ 1, 4, 9, 16, 25, 36 ]));
 ----
 
-In all cases, the type of the result is the same as of the type of the
-first range passed in. If a different type of range is needed, just
-supply an empty range of the needed type as the first argument.
+Multiple functions can be passed to $(D map). In that case, the
+element type of $(D map) is a tuple containing one element for each
+function.
 
 Example:
+
 ----
-short[] arr = [ 1, 2 ];
-auto squares = map!("a * a")(cast(int[]) null, arr);
-assert(is(typeof(squares) == int[]));
+auto arr1 = [ 1, 2, 3, 4 ];
+foreach (e; map!("a + a", "a * a")(arr1))
+{
+    writeln(e.field[0], " ", e.field[1]);
+}
 ----
-*/
+ */
 template map(fun...)
 {
-    alias mapImpl!(fun).map map;
-}
-
-template mapImpl(fun...)
-{
-    alias unaryFun!(fun[0]) headFun;
-    typeof(headFun(*begin(Ranges[0])))[] map(Ranges...)(Ranges rs)
+    static if (fun.length > 1)
     {
-        //static assert(fun.length == 1, "Multiple funs not yet supported");
-        typeof(return) result;
-        foreach (r, R; Ranges)
+        // alias Map!(Adjoin!(staticMap!(unaryFun, fun))
+        //         .For!(staticMap!(ElementType, Range)).fun,
+        //         Chain!(Range)).doIt
+        //     map;
+        Map!(adjoin!(staticMap!(unaryFun, fun)), Range)
+            map(Range)(Range r)
         {
-            foreach (i; begin(rs[r]) .. end(rs[r]))
-            {
-                result ~= headFun(*i);
-            }
+            return typeof(return)(r);
         }
-        return result;
+    }
+    else
+    {
+        //alias Map!(unaryFun!(fun), Chain!(Range)).doIt map;
+        Map!(unaryFun!(fun), Range) map(Range)(Range r)
+        {
+            return typeof(return)(r);
+        }
     }
 }
-    
+
+struct Map(alias fun, Range) if (isInputRange!(Range))
+{
+    alias typeof(fun(.ElementType!(Range))) ElementType;
+    Range _input;
+    ElementType _cache;
+
+    private void fillCache() { if (!_input.empty) _cache = fun(_input.front); }
+
+    this(Range input) { _input = input; fillCache; }
+    ref Map opSlice()
+    {
+        return this;
+    }
+    bool empty() { return _input.empty; }
+    void popFront() { _input.popFront; fillCache; }
+    ElementType front() { return _cache; }
+}
+
 unittest
 {
     int[] arr1 = [ 1, 2, 3, 4 ];
     int[] arr2 = [ 5, 6 ];
-    auto squares = map!("a * a")(arr1, arr2);
-    assert(squares == [ 1, 4, 9, 16, 25, 36 ]);
-
-    short[] arr = [ 1, 2 ];
-    auto squares2 = map!("a * a")(cast(int[])null, arr);
-    assert(is(typeof(squares2) == int[]));
-}
-
-// reduce
-/*private*/ template NxNHelper(F...)
-{
-    /*private*/ template For(Args...)
+    auto squares = map!("a * a")(arr1);
+    assert(equal(squares, [ 1, 4, 9, 16 ][]));
+    assert(equal(map!("a * a")(chain(arr1, arr2)), [ 1, 4, 9, 16, 25, 36 ][]));
+
+    uint i;
+    foreach (e; map!("a", "a * a")(arr1))
     {
-        enum uint fs = TypeTuple!(F).length;
-        static assert(
-            fs,
-            "reduce: too few arguments. You must pass at least a function");
-        static assert(
-            Args.length > fs,
-            "reduce: too few arguments. You must pass one seed for"
-            " each function (total "~ToString!(fs)~")"
-            ", followed by the ranges to operate on.");
-        // Result type
-        static if (F.length > 1)
-            alias Tuple!(Args[0 .. F.length]) Result;
-        else
-            alias Args[0] Result;
-
-        // Element type
-        enum functions = F.length;
-        //alias typeof(*Args[functions]) Element;
-
-        // Apply predicate
-        R apply(uint n, R, E)(R a, E b)
-        {
-            alias typeof(F[n]) thisFun;
-            static if (is(typeof(thisFun~""))) // (!is(typeof(F[n](a, b))))
-            {
-                return binaryFun!(""~F[n])(a, b);
-            }
-            else
-            {
-                return F[n](a, b);
-            }
-        }
+        assert(e.field[0] == ++i);
+        assert(e.field[1] == i * i);
     }
 }
 
+// reduce
 /**
 Implements the homonym function (also known as $(D accumulate), $(D
 compress), $(D inject), or $(D foldl)) present in various programming
@@ -200,9 +157,13 @@
 range)) first assigns $(D seed) to an internal variable $(D result),
 also called the accumulator. Then, for each element $(D x) in $(D
 range), $(D result = fun(result, x)) gets evaluated. Finally, $(D
-result) is returned. Many aggregate range operations turn out to be
-solved with $(D reduce) quickly and easily. The example below
-illustrates $(D reduce)'s remarkable power and flexibility.
+result) is returned. The one-argument version $(D reduce!(fun)(range))
+works similarly, but it uses the first element of the range as the
+seed (the range must be non-empty).
+
+Many aggregate range operations turn out to be solved with $(D reduce)
+quickly and easily. The example below illustrates $(D reduce)'s
+remarkable power and flexibility.
 
 Example:
 ----
@@ -212,7 +173,7 @@
 assert(sum == 15);
 
 // Compute the maximum of all elements
-auto largest = reduce!(max)(arr[0], arr[1 .. $]);
+auto largest = reduce!(max)(arr);
 assert(largest == 5);
 
 // Compute the number of odd elements
@@ -222,23 +183,16 @@
 // Compute the sum of squares
 auto ssquares = reduce!("a + b * b")(0, arr);
 assert(ssquares == 55);
-----
-
-$(DDOC_SECTION_H Multiple ranges:) It is possible to pass any number
-of ranges to $(D reduce), as in $(D reduce!(fun)(seed, range1, range2,
-range3)). Then $(D reduce) will simply apply its algorithm in
-succession to each range, from left to right.
-
-Example:
-----
+
+// Chain multiple ranges into seed
 int[] a = [ 3, 4 ];
 int[] b = [ 100 ];
-auto r = reduce!("a + b")(0, a, b);
+auto r = reduce!("a + b")(chain(a, b));
 assert(r == 107);
 
 // Mixing convertible types is fair game, too
 double[] c = [ 2.5, 3.0 ];
-auto r1 = reduce!("a + b")(0.0, a, b, c);
+auto r1 = reduce!("a + b")(chain(a, b, c));
 assert(r1 == 112.5);
 ----
 
@@ -254,81 +208,85 @@
 ----
 double[] a = [ 3.0, 4, 7, 11, 3, 2, 5 ];
 // Compute minimum and maximum in one pass
-auto r = reduce!(min, max)(double.max, -double.max, a);
+auto r = reduce!(min, max)(a);
 // The type of r is Tuple!(double, double)
-assert(r._0 == 2);  // minimum
-assert(r._1 == 11); // maximum
+assert(r.field[0] == 2);  // minimum
+assert(r.field[1] == 11); // maximum
 
 // Compute sum and sum of squares in one pass
 r = reduce!("a + b", "a + b * b")(0.0, 0.0, a);
-assert(r._0 == 35);  // sum
-assert(r._1 == 233); // sum of squares
+assert(r.field[0] == 35);  // sum
+assert(r.field[1] == 233); // sum of squares
 // Compute average and standard deviation from the above
-auto avg = r._0 / a.length;
-auto stdev = sqrt(r._1 / a.length - avg * avg);
+auto avg = r.field[0] / a.length;
+auto stdev = sqrt(r.field[1] / a.length - avg * avg);
 ----
-
-$(DDOC_SECTION_H Multiple ranges and functions:) The most general form
-of $(D reduce) accepts multiple functions and multiple ranges
-simultaneously. The call $(D reduce!(fun1, ..., funN)(seed1, ...,
-seedN, range1, ..., rangeM)) applies the reduction algorithm for all
-functions and all ranges.
-
-Example:
-----
-int[] a = [ 3, 4, 7, 11, 3, 2, 5 ];
-double[] b = [ 2.5, 4, -4.5, 2, 10.9 ];
-// Compute minimum and maximum in one pass over a and b
-auto r = reduce!(min, max)(double.max, -double.max, a, b);
-assert(r._0 == -4.5);  // minimum
-assert(r._1 == 11);    // maximum
-----
-*/
-
-template reduce(F...)
+ */
+
+template reduce(fun...)
 {
-    NxNHelper!(F).For!(Args).Result reduce(Args...)(Args args)
+    alias Reduce!(fun).reduce reduce;
+}
+
+template Reduce(fun...)
+{
+private:
+    static if (fun.length > 1)
     {
-        alias NxNHelper!(F).For!(Args) Aux;
-        typeof(return) result;
-        // Prime the result
-        static if (F.length > 1)
+        template TypeTupleN(E, int n)
         {
-            foreach (j, unused; args[0 .. F.length]) // for all functions
+            static if (n == 1) alias E TypeTupleN;
+            else alias TypeTuple!(E, TypeTupleN!(E, n - 1)) TypeTupleN;
+        }
+        enum L = fun.length;
+        template ReturnType(E)
+        {
+            alias Tuple!(TypeTupleN!(E, L)) ReturnType;
+        }
+    }
+    else
+    {
+        template ReturnType(E)
+        {
+            alias E ReturnType;
+        }
+    }
+
+public:
+    E reduce(E, Range)(E e0, Range r)
+    {
+        Unqual!(typeof(return)) result = e0;
+        foreach (e; r)
+        {
+            static if (fun.length == 1)
+                result = binaryFun!(fun[0])(result, e);
+            else
             {
-                // @@@BUG@@@
-                auto p = mixin("&result.field!("~ToString!(j)~")");
-                *p = args[j];
-            }
-        }
-        else
-        {
-            result = args[0];
-        }
-        // Accumulate
-        foreach (i, range; args[F.length .. $]) // all inputs
-        {
-            foreach (it; begin(range) .. end(range)) // current input
-            {
-                // @@@BUG@@@
-                //foreach (j, f; F) // for all functions
-                foreach (j, unused; Args[0 .. F.length]) // for all functions
+                foreach (i, Unused; typeof(E.field))
                 {
-                    static if (F.length > 1)
-                    {
-                        // @@@BUG@@@
-                        auto p = mixin("&result.field!("~ToString!(j)~")");
-                    }
-                    else
-                    {
-                        auto p = &result;
-                    }
-                    *p = Aux.apply!(j, typeof(*p), typeof(*it))(*p, *it);
+                    result.field[i] = binaryFun!(fun[i])(result.field[i], e);
                 }
             }
         }
         return result;
     }
+
+    ReturnType!(ElementType!(Range))
+    reduce(Range)(Range r) if (isInputRange!Range)
+    {
+        static if (fun.length == 1)
+            auto e = r.front;
+        else
+        {
+            typeof(return) e;
+            foreach (i, Unused; typeof(typeof(return).field))
+            {
+                e.field[i] = r.front;
+            }
+        }
+        r.popFront;
+        return reduce(e, r);
+    }
 }
 
 unittest
@@ -336,86 +294,95 @@
     int[] a = [ 3, 4 ];
     auto r = reduce!("a + b")(0, a);
     assert(r == 7);
-    r = reduce!(min)(int.max, a);
+    r = reduce!("a + b")(a);
+    assert(r == 7);
+    r = reduce!(min)(a);
     assert(r == 3);
     double[] b = [ 100 ];
-    auto r1 = reduce!("a + b")(0.0, a, b);
-    assert(r1 == 107);    
+    auto r1 = reduce!("a + b")(chain(a, b));
+    assert(r1 == 107);
+
+    // two funs
+    auto r2 = reduce!("a + b", "a - b")(tuple(0, 0), a);
+    assert(r2.field[0] == 7 && r2.field[1] == -7);
+    auto r3 = reduce!("a + b", "a - b")(a);
+    assert(r3.field[0] == 7 && r3.field[1] == -1);
 
     a = [ 1, 2, 3, 4, 5 ];
     // Stringize with commas
-    string rep = reduce!("a ~ `, ` ~ to!(string)(b)")(cast(string) null, a);
+    string rep = reduce!("a ~ `, ` ~ to!(string)(b)")("", a);
     assert(rep[2 .. $] == "1, 2, 3, 4, 5");
 }
-// overlap
+
 /**
-Returns the overlapping range, if any, of two ranges. Unlike $(D
-equal), $(D overlap) only compares the iterators in the ranges, not
-the values referred by them. If $(D r1) and $(D r2) have an
-overlapping range, returns that range. Otherwise, returns an empty
-range. Performs $(BIGOH min(r1.length, r2.length)) iterator increment
-operations and comparisons if the ranges are forward, and $(BIGOH 1)
-operations if the ranges have random access.
+Fills a range with a value.
 
 Example:
 ----
-int[] a = [ 10, 11, 12, 13, 14 ];
-int[] b = a[1 .. 3];
-assert(overlap(a, b) == [ 11, 12 ]);
-b = b.dup;
-// overlap disappears even though the content is the same
-assert(isEmpty(overlap(a, b)));
+int[] a = [ 1, 2, 3, 4 ];
+fill(a, 5);
+assert(a == [ 5, 5, 5, 5 ]);
 ----
-*/
-Range overlap(Range)(Range r1, Range r2)
+ */
+void fill(Range, Value)(Range range, Value filler)
+if (isForwardRange!Range && is(typeof(Range.init.front = Value.init)))
 {
-    auto b = max(begin(r1), begin(r2));
-    auto e = min(end(r1), end(r2));
-    return b < e ? range(b, e) : null;
+    for (; !range.empty; range.popFront)
+    {
+        range.front = filler;
+    }
 }
 
 unittest
 {
-    int[] a = [ 10, 11, 12, 13, 14 ];
-    int[] b = a[1 .. 3];
-    a[1] = 100;
-    assert(overlap(a, b) == [ 100, 12 ]);
+    int[] a = [ 1, 2, 3 ];
+    fill(a, 6);
+    assert(a == [ 6, 6, 6 ]);
+    void fun0()
+    {
+        foreach (i; 0 .. 1000)
+        {
+            foreach (ref e; a) e = 6;
+        }
+    }
+    void fun1() { foreach (i; 0 .. 1000) fill(a, 6); }
+    //void fun2() { foreach (i; 0 .. 1000) fill2(a, 6); }
+    //writeln(benchmark!(fun0, fun1, fun2)(10000));
 }
 
-
-// overlap
 /**
-Returns the overlapping range, if any, of two ranges. Unlike $(D
-equal), $(D overlap) only compares the iterators in the ranges, not
-the values referred by them. If $(D r1) and $(D r2) have an
-overlapping range, returns that range. Otherwise, returns an empty
-range. Performs $(BIGOH min(r1.length, r2.length)) iterator increment
-operations and comparisons if the ranges are forward, and $(BIGOH 1)
-operations if the ranges have random access.
+Fills $(D range) with a pattern copied from $(D filler). The length of
+$(D range) does not have to be a multiple of the length of $(D
+filler). If $(D filler) is empty, an exception is thrown.
 
 Example:
 ----
-int[] a = [ 10, 11, 12, 13, 14 ];
-int[] b = a[1 .. 3];
-assert(overlap(a, b) == [ 11, 12 ]);
-b = b.dup;
-// overlap disappears even though the content is the same
-assert(isEmpty(overlap(a, b)));
+int[] a = [ 1, 2, 3, 4, 5 ];
+int[] b = [ 8, 9 ]; 
+fill(a, b);
+assert(a == [ 8, 9, 8, 9, 8 ]);
 ----
-*/
-Range overlap(Range)(Range r1, Range r2)
+ */
+
+void fill(Range1, Range2)(Range1 range, Range2 filler)
+if (isForwardRange!Range1 && isForwardRange!Range2
+        && is(typeof(Range1.init.front = Range2.init.front)))
 {
-    auto b = max(begin(r1), begin(r2));
-    auto e = min(end(r1), end(r2));
-    return b < e ? range(b, e) : null;
+    enforce(!filler.empty);
+    auto t = filler;
+    for (; !range.empty; range.popFront, t.popFront)
+    {
+        if (t.empty) t = filler;
+        range.front = t.front;
+    }
 }
 
-version(wyda) unittest
+unittest
 {
-    int[] a = [ 10, 11, 12, 13, 14 ];
-    int[] b = a[1 .. 3];
-    a[1] = 100;
-    assert(overlap(a, b) == [ 100, 12 ]);
+    int[] a = [ 1, 2, 3, 4, 5 ];
+    int[] b = [1, 2];
+    fill(a, b);
+    assert(a == [ 1, 2, 1, 2, 1 ]);
 }
 
 // filter
@@ -431,104 +398,69 @@
 // Sum all elements
 auto small = filter!("a < 3")(arr);
 assert(small == [ 1, 2 ]);
-----
-
-$(DDOC_SECTION_H Multiple ranges:) It is possible to pass any number
-of ranges to $(D filter), as in $(D filter!(fun)(range1, range2,
-range3)). Then $(D filter) will simply apply its algorithm in
-succession to each range, from left to right. The type returned is
-that of the first range.
-
-Example:
-----
+// In combination with chain() to span multiple ranges
 int[] a = [ 3, -2, 400 ];
 int[] b = [ 100, -101, 102 ];
-auto r = filter!("a > 0")(a, b);
-assert(r == [ 3, 400, 100, 102 ]);
-
+auto r = filter!("a > 0")(chain(a, b));
+assert(equals(r, [ 3, 400, 100, 102 ]));
 // Mixing convertible types is fair game, too
 double[] c = [ 2.5, 3.0 ];
-auto r1 = filter!("cast(int) a != a")(c, a, b);
+auto r1 = filter!("cast(int) a != a")(chain(c, a, b));
 assert(r1 == [ 2.5 ]);
 ----
-*/
-
-Ranges[0] filter(alias pred, Ranges...)(Ranges rs)
+ */
+
+Filter!(unaryFun!(pred), Range)
+filter(alias pred, Range)(Range rs)
 {
-    alias unaryFun!(pred) fun;
-    typeof(return) result;
-    // Accumulate
-    foreach (i, range; rs[0 .. $]) // all inputs
+    return typeof(return)(rs);
+}
+
+struct Filter(alias pred, Range) if (isInputRange!(Range))
+{
+    Range _input;
+
+    this(Range r)
     {
-        foreach (it; begin(range) .. end(range)) // current input
+        _input = r;
+        while (!_input.empty && !pred(_input.front)) _input.popFront;
+    }
+    
+    ref Filter opSlice()
+    {
+        return this;
+    }
+
+    bool empty() { return _input.empty; }
+    void popFront()
+    {
+        do
         {
-            if (fun(*it)) result ~= *it;
-        }
+            _input.popFront;
+        } while (!_input.empty && !pred(_input.front));
     }
-    return result;
+
+    ElementType!(Range) front()
+    {
+        return _input.front;
+    }
 }
 
 unittest
 {
     int[] a = [ 3, 4 ];
     auto r = filter!("a > 3")(a);
-    assert(r == [ 4 ]);
+    assert(equal(r, [ 4 ][]));
 
     a = [ 1, 22, 3, 42, 5 ];
     auto under10 = filter!("a < 10")(a);
-    assert(under10 == [1, 3, 5]);
-}
-
-// inPlace
-/**
-Similar to $(D map), but it manipulates the passed-in ranges in place
-and returns $(D void). The call $(D inPlace!(fun)(range1, range2, ...,
-rangeN)) applies $(D fun(x)) left to right for all $(D ref x) in $(D
-range1), then all $(D ref x) in $(D range2), ..., all $(D ref x) in
-$(D rangeN).
-
-Example:
-----
-int[] arr1 = [ 1, 2, 3 ];
-inPlace!(writeln)(arr1); // print the array
-double[] arr2 = [ 4.0, 8.5, 13 ];
-inPlace!("++a")(arr1, arr2);
-assert(arr1 == [ 2, 3, 4 ]);
-assert(arr2 == [ 5.0, 9.5, 14 ]);
-----
-*/
-void inPlace(alias fun, Range, Ranges...)(Range r, Ranges rs)
-// @@@BUG@@ This should work:
-// void inPlace(alias fun, Ranges...)(Ranges rs)
-{
-    alias unaryFun!(fun, true) todo;
-    foreach (j; begin(r) .. end(r)) todo(*j);
-    foreach (i, x; rs)
-    {
-        foreach (j; begin(x) .. end(x)) todo(*j);
-    }
-}
-
-unittest
-{
-    // fill with 42
-    int[] a = [ 1, 2 ];
-    double[] b =  [ 2, 4 ];
-    inPlace!("a = 42")(a);
-    assert(a[0] == 42 && a[1] == 42);
-    //assert(b[0] == 42 && b[1] == 42);
-    
-    int[] arr1 = [ 1, 2, 3 ];
-    double[] arr2 = [ 4.0, 8.5, 13 ];
-    inPlace!("++a")(arr1, arr2);
-    assert(arr1 == [ 2, 3, 4 ]);
-    assert(arr2 == [ 5.0, 9.5, 14 ]);
+    assert(equal(under10, [1, 3, 5][]));
 }
 
 // move
 /**
 Moves $(D source) into $(D target) via a destructive
-copy. Specifically: $(UL $(LI If $(D hasAliasing!(T)) is true (see
+copy. Specifically: $(UL $(LI If $(D hasAliasing!T) is true (see
 $(XREF traits, hasAliasing)), then the representation of $(D source)
 is bitwise copied into $(D target) and then $(D source = T.init) is
 evaluated.)  $(LI Otherwise, $(D target = source) is evaluated.)) See
@@ -539,6 +471,7 @@
 */
 void move(T)(ref T source, ref T target)
 {
+    if (&source == &target) return;
     assert(!pointsTo(source, source));
     static if (hasAliasing!(T))
     {
@@ -579,6 +512,61 @@
     assert(s21.a == 1 && s21.b == null && s22.a == 10 && s22.b != null);
 }
 
+// moveAll
+/**
+For each element $(D a) in $(D src) and each element $(D b) in $(D
+tgt) in lockstep in increasing order, calls $(D move(a, b)). Returns
+the leftover portion of $(D tgt). Throws an exeption if there is not
+enough room in $(D tgt) to acommodate all of $(D src).
+
+Preconditions:
+$(D walkLength(src) >= walkLength(tgt))
+ */
+Range2 moveAll(Range1, Range2)(Range1 src, Range2 tgt)
+{
+    for (; !src.empty; src.popFront, tgt.popFront)
+    {
+        enforce(!tgt.empty);
+        move(src.front, tgt.front);
+    }
+    return tgt;
+}
+
+unittest
+{
+    int[] a = [ 1, 2, 3 ];
+    int[] b = new int[5];
+    assert(moveAll(a, b) is b[3 .. $]);
+    assert(a == b[0 .. 3]);
+    assert(a == [ 1, 2, 3 ]);
+}
+
+// moveSome
+/**
+For each element $(D a) in $(D src) and each element $(D b) in $(D
+tgt) in lockstep in increasing order, calls $(D move(a, b)). Stops
+when either $(D src) or $(D tgt) have been exhausted. Returns the
+leftover portion of the two ranges.
+ */
+Tuple!(Range1, Range2) moveSome(Range1, Range2)(Range1 src, Range2 tgt)
+{
+    for (; !src.empty && !tgt.empty; src.popFront, tgt.popFront)
+    {
+        enforce(!tgt.empty);
+        move(src.front, tgt.front);
+    }
+    return tuple(src, tgt);
+}
+
+unittest
+{
+    int[] a = [ 1, 2, 3, 4, 5 ];
+    int[] b = new int[3];
+    assert(moveSome(a, b).field[0] is a[3 .. $]);
+    assert(a[0 .. 3] == b);
+    assert(a == [ 1, 2, 3, 4, 5 ]);
+}
+
 // swap
 /**
 Swaps $(D lhs) and $(D rhs). See also $(XREF contracts, pointsTo).
@@ -588,17 +576,189 @@
 $(D !pointsTo(lhs, lhs) && !pointsTo(lhs, rhs) && !pointsTo(rhs, lhs)
 && !pointsTo(rhs, rhs))
 */
-void swap(T)(ref T lhs, ref T rhs)
+void swap(T)(ref T lhs, ref T rhs) if (!is(typeof(T.init.proxySwap(T.init))))
 {
     assert(!pointsTo(lhs, lhs) && !pointsTo(lhs, rhs)
-           && !pointsTo(rhs, lhs) && !pointsTo(rhs, rhs));
+            && !pointsTo(rhs, lhs) && !pointsTo(rhs, rhs));
     auto t = lhs;
     lhs = rhs;
     rhs = t;
 }
 
+// Not yet documented
+void swap(T)(T lhs, T rhs) if (is(typeof(T.init.proxySwap(T.init))))
+{
+    lhs.proxySwap(rhs);
+}
+
+// split
+/**
+Splits a range using another range or an element as a separator. This
+can be used with any range type, but is most popular with string
+types.
+
+Example:
+---
+int[] a = [ 1, 2, 0, 3, 0, 4, 5, 0 ];
+int[][] w = [ [1, 2], [3], [4, 5] ];
+uint i;
+foreach (e; splitter(a)) assert(e == w[i++]);
+assert(i == 3);
+----
+*/
+struct Splitter(Range, Separator)
+{
+    Range _input;
+    Separator _separator;
+    size_t _chunkLength;
+
+    private Range search()
+    {
+        return find(_input, _separator);
+    }
+
+    private void advance()
+    {
+        static if (is(typeof(_separator.length)))
+        {
+            _chunkLength += _separator.length;
+        }
+        else
+        {
+            ++_chunkLength;
+        }
+    }
+
+    this(Range input, Separator separator)
+    {
+        _input = input;
+        _separator = separator;
+        _chunkLength = _input.length - search().length;
+    }
+
+    ref auto opSlice()
+    {
+        return this;
+    }
+
+    Range front()
+    {
+        return _input[0 .. _chunkLength];
+    }
+
+    bool empty()
+    {
+        return _input.empty;
+    }
+
+    void popFront()
+    {
+        if (_chunkLength == _input.length)
+        {
+            _input = _input[_chunkLength .. _input.length];
+            return;
+        }
+        advance;
+        _input = _input[_chunkLength .. _input.length];
+        _chunkLength = _input.length - search().length;
+    }
+}
+
+/// Ditto
+Splitter!(Range, Separator) splitter(Range, Separator)(Range r, Separator s)
+if (is(typeof(ElementType!(Range).init == ElementType!(Separator).init)) ||
+        is(typeof(ElementType!(Range).init == Separator.init)))
+{
+    return typeof(return)(r, s);
+}
+
+unittest
+{
+    auto s = ",abc, de, fg,hi,";
+    auto sp0 = splitter(s, ',');
+    //foreach (e; sp) writeln("[", e, "]");
+    assert(equal(sp0, ["", "abc", " de", " fg", "hi"][]));
+
+    auto s1 = ", abc, de,  fg, hi, ";
+    auto sp1 = splitter(s1, ", ");
+    //foreach (e; sp1) writeln("[", e, "]");
+    assert(equal(sp1, ["", "abc", "de", " fg", "hi"][]));
+
+    int[] a = [ 1, 2, 0, 3, 0, 4, 5, 0 ];
+    int[][] w = [ [1, 2], [3], [4, 5] ];
+    uint i;
+    foreach (e; splitter(a, 0)) assert(e == w[i++]);
+    assert(i == 3);
+}
+
+// uniq
+/**
+Iterates unique consecutive elements of the given range (functionality
+akin to the $(WEB wikipedia.org/wiki/_Uniq, _uniq) system
+utility). Equivalence of elements is assessed by using the predicate
+$(D pred), by default $(D "a == b"). If the given range is
+bidirectional, $(D uniq) also yields a bidirectional range.
+
+Example:
+----
+int[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];
+assert(equal(uniq(arr), [ 1, 2, 3, 4, 5 ][]));
+----
+*/
+struct Uniq(alias pred, R)
+{
+    R _input;
+    
+    this(R input)
+    {
+        _input = input;
+    }
+
+    ref Uniq opSlice()
+    {
+        return this;
+    }
+
+    void popFront()
+    {
+        auto last = _input.front;
+        do
+        {
+            _input.popFront;
+        }
+        while (!_input.empty && binaryFun!(pred)(last, _input.front));
+    }
+
+    void popBack()
+    {
+        auto last = _input.back;
+        do
+        {
+            _input.popBack;
+        }
+        while (!_input.empty && binaryFun!(pred)(last, _input.back));
+    }
+
+    bool empty() { return _input.empty; }
+    ElementType!(R) front() { return _input.front; }
+    ElementType!(R) back() { return _input.back; }
+}
+
+/// Ditto
+Uniq!(pred, Range) uniq(alias pred = "a == b", Range)(Range r)
+{
+    return Uniq!(pred, Range)(r);
+}
+
+unittest
+{
+    int[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];
+    auto r = uniq(arr);
+    assert(equal(r, [ 1, 2, 3, 4, 5 ][]));
+}
+
 // overwriteAdjacent
-/**
+/*
 Reduces $(D r) by shifting it to the left until no adjacent elements
 $(D a), $(D b) remain in $(D r) such that $(D pred(a, b)). Shifting is
 performed by evaluating $(D move(source, target)) as a primitive. The
@@ -619,90 +779,337 @@
 assert(r == [ 1, 2, 3, 4, 5 ]);
 ----
 */
-Range overwriteAdjacent(alias pred, alias move, Range)(Range r)
-{
-    if (isEmpty(r)) return r;
-    auto target = begin(r), e = end(r);
-    foreach (source; target + 1 .. e)
-    {
-        if (!pred(*target, *source))
-        {
-            ++target;
-            continue;
-        }
-        // found an equal *source and *target
-        for (;;)
-        {
-            move(*source, *target);
-            ++source;
-            if (source == e) break;
-            if (!pred(*target, *source)) ++target;
-        }
-        break;
-    }
-    return range(begin(r), target + 1);
-}
-
-/// Ditto
-Range overwriteAdjacent(
-    string fun = "a == b",
-    alias move = .move,
-    Range)(Range r)
-{
-    return .overwriteAdjacent!(binaryFun!(fun), move, Range)(r);
-}
-
-unittest
-{
-    int[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];
-    auto r = overwriteAdjacent(arr);
-    assert(r == [ 1, 2, 3, 4, 5 ]);
-    assert(arr == [ 1, 2, 3, 4, 5, 3, 4, 4, 4, 5 ]);
+// Range overwriteAdjacent(alias pred, alias move, Range)(Range r)
+// {
+//     if (r.empty) return r;
+//     //auto target = begin(r), e = end(r);
+//     auto target = r;
+//     auto source = r;
+//     source.popFront;
+//     while (!source.empty)
+//     {
+//         if (!pred(target.front, source.front))
+//         {
+//             target.popFront;
+//             continue;
+//         }
+//         // found an equal *source and *target
+//         for (;;)
+//         {
+//             //@@@
+//             //move(source.front, target.front);
+//             target[0] = source[0];
+//             source.popFront;
+//             if (source.empty) break;
+//             if (!pred(target.front, source.front)) target.popFront;
+//         }
+//         break;
+//     }
+//     return range(begin(r), target + 1);
+// }
+
+// /// Ditto
+// Range overwriteAdjacent(
+//     string fun = "a == b",
+//     alias move = .move,
+//     Range)(Range r)
+// {
+//     return .overwriteAdjacent!(binaryFun!(fun), move, Range)(r);
+// }
+
+// unittest
+// {
+//     int[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];
+//     auto r = overwriteAdjacent(arr);
+//     assert(r == [ 1, 2, 3, 4, 5 ]);
+//     assert(arr == [ 1, 2, 3, 4, 5, 3, 4, 4, 4, 5 ]);
     
-}
+// }
 
 // find
-/**
-Finds the first occurrence of $(D needle) in $(D haystack) by linear
-search and returns an iterator to it.  An optional binary predicate
-$(D pred) instructs $(D find) on how to perform the comparison (with
-the current collection element in the first position and $(D needle)
-in the second position). By default, comparison is for
-equality. Performs $(BIGOH haystack.length) evaluations of $(D
-pred). See also $(WEB sgi.com/tech/stl/_find.html, STL's _find).
+/* * Advances $(D haystack) by calling $(D haystack.popFront) up to the
+first occurrence of $(D needle), or until $(D haystack) becomes empty.
+An optional binary predicate $(D pred) instructs $(D find) on how to
+perform the comparison (with the current $(D haystack) element in the
+first position and $(D needle) in the second position). By default,
+comparison is for equality. Performs $(BIGOH n) evaluations of $(D
+pred), where $(D n) is the length of $(D haystack). See also $(WEB
+sgi.com/tech/stl/_find.html, STL's _find).
 
 To find the last occurence of $(D needle) in $(D haystack), call $(D
-find(retro(haystack), needle)) and compare the result against $(D
-rEnd(haystack)). See also $(XREF iterator, retro).
+find(retro(haystack), needle)). See also $(XREF range, retro).
 
 Example:
 ----
 auto a = [ 1, 2, 3 ];
-assert(find(a, 5) == end(a));       // not found
-assert(find(a, 2) == begin(a) + 1); // found
+assert(find(a, 5).empty);       // not found
+assert(!find(a, 2).empty);      // found
 
 // Case-insensitive find of a string
 string[] s = [ "Hello", "world", "!" ];
-assert(find!("toupper(a) == toupper(b)")(s, "hello") == begin(s));
+assert(!find!("toupper(a) == toupper(b)")(s, "hello").empty);
 ----
-*/
-Iterator!(Range) find(alias pred = "a == b", Range, E)(Range haystack, E needle)
+ */
+
+template FindResult(H, N...)
 {
-    alias binaryFun!(pred) test;
-    // @@@BUG@@@
-    //foreach (i; begin(haystack) .. end(haystack))
-    for (auto i = begin(haystack); i != end(haystack); ++i)
+    static if (is(H.AssumeSorted))
     {
-        if (test(*i, needle)) return i;
+        alias Select!(N.length == 1, H.AssumeSorted,
+                Tuple!(H.AssumeSorted, uint))
+            FindResult;
     }
-    return end(haystack);
+    else
+    {
+        alias Select!(N.length == 1, H, Tuple!(H, uint))
+            FindResult;
+    }
+}
+
+// find
+/**
+Generalized routine for finding one or more $(D needles) into a $(D
+haystack). Some or all of $(D haystack) and $(D needles) may be
+structured in various ways, which translates in the speed of $(D
+find). The predicate $(D pred) is used throughout to compare
+elements. By default, elements are compared for equality.
+
+Params:
+
+haystack = The target of the search. Must be an $(GLOSSARY input
+range). If any of $(D needles) is a range with elements comparable to
+elements in $(D haystack), then $(D haystack) must be a $(GLOSSARY
+forward range) such that the search can backtrack.
+
+needles = One or more items to search for. Each of $(D needles) must
+be either comparable to one element in $(D haystack), or be itself a
+$(GLOSSARY forward range) with elements comparable with elements in
+$(D haystack).
+
+Returns:
+
+$(UL $(LI If $(D needles.length == 1), returns $(D haystack) advanced
+such that $(D needles[0]) is a prefix of it (if no such position
+exists, returns an empty range).)  $(LI If $(D needles.length > 1),
+returns a tuple containing $(D haystack) positioned as above and also
+the 1-based index of the matching element in $(D needles) (0 if none
+of $(D needles) matched, 1 if $(D needles[0]) matched, 2 if $(D
+needles[1]) matched...).))
+
+The relationship between $(D haystack) and $(D needles) simply means
+that one can e.g. search for individual $(D int)s, or arrays of $(D
+int)s, in an array of $(D int)s. In addition, if elements are
+individually comparable, searches of heterogeneous types are allowed
+as well: a $(D double[]) can be searched for an $(D int) or a $(D
+short[]), and conversely a $(D long) can be searched for a $(D float)
+or a $(D double[]). This makes for efficient searches without the need
+to coerce one side of the comparison into the other's side type.
+
+Example:
+----
+int[] a = [ 1, 4, 2, 3 ];
+assert(find(a, 4) == [ 4, 2, 3 ]);
+assert(find(a, [ 1, 4 ]) == [ 1, 4, 2, 3 ]);
+assert(find(a, [ 1, 3 ], 4) == tuple([ 4, 2, 3 ], 2));
+// Mixed types allowed if comparable
+assert(find(a, 5, [ 1.2, 3.5 ], 2.0, [ 1 ]) == tuple([ 2, 3 ], 3));
+----
+
+The complexity of the search is $(BIGOH haystack.length *
+max(needles.length)). (For needles that are individual items, length
+is considered to be 1.) The strategy used in searching several
+subranges at once maximizes cache usage by moving in $(D haystack) as
+few times as possible.
+
+BoyerMoore:
+
+If one or more of the $(D needles) has type $(D BoyerMooreFinder), the
+search for those particular needles is performed by using the $(WEB
+www-igm.univ-mlv.fr/~lecroq/string/node14.html, Boyer-Moore
+algorithm). In this case $(D haystack) must offer random access. The
+algorithm has an upfront cost but scales sublinearly, so it is most
+suitable for large sequences. Performs $(BIGOH haystack.length)
+evaluations of $(D pred) in the worst case and $(BIGOH haystack.length
+/ needle.length) evaluations in the best case.
+
+The $(D BoyerMooreFinder)-structured $(D needles), if any, must be
+placed at the front of the searched items. This is because they will
+be searched separately, not in lockstep with any other $(D
+needles). To add Boyer-Moore structure to any of $(D needles), simply
+wrap it in a $(D boyerMooreFinder) call as shown below.
+
+Example:
+----
+int[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
+int[] b = [ 1, 2, 3 ];
+assert(find(a, boyerMooreFinder(b), 1) == tuple([ 1, 2, 3, 4, 5 ], 1));
+assert(find(b, boyerMooreFinder(a)).empty);
+----
+
+Sorted:
+
+Searching can be sped up considerably if $(D haystack) is already
+sorted by an ordering predicate $(D less). The speedup can only occur
+it the following relation between $(D pred) and $(D less) holds:
+
+$(D pred(a, b) == (!less(a, b) && !less(b, a)))
+
+The default predicate for $(D find), which is $(D "a == b"), and the
+default predicate for $(D assumeSorted), which is $(D "a < b"),
+already satisfy the relation.
+
+If the above condition is satisfied, only $(BIGOH
+log(haystack.length)) steps are needed to position $(D haystack) at
+the beginning of the search. Also, once positioned, the search will
+continue only as long as haystack and the needle start with equal
+elements. To inform $(D find) that you want to perform a binary
+search, wrap $(D haystack) with a call to $(XREF contracts,
+assumeSorted). Then $(D find) will assume that $(D pred) and $(D less)
+are in the right relation and also that $(D haystack) is already
+sorted by $(D less).
+
+Example:
+----
+int[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
+assert(find(assumeSorted(a), 3) == [ 3, 4, 5 ]);
+assert(find(assumeSorted(a), [3, 4]) == [ 3, 4, 5 ]);
+assert(find(assumeSorted(a), [3, 5], [1, 3], 8).empty);
+----
+ */
+FindResult!(Range, Ranges)
+find(alias pred = "a == b", Range, Ranges...)
+(Range haystack, Ranges needles)
+//if (allSatisfy!(isInputRange, Ranges))
+//if (!is(typeof(Ranges[0].init.findReflect(Range.init))))
+{
+    static if (Ranges.length == 1 && isArray!(Range) && isArray!(Ranges[0])
+            && is(typeof(binaryFun!(pred)(haystack[1], needles[0][1]))))
+    {
+        // Optimization for built-in arrays
+        alias needles[0] needle;
+        if (haystack.length < needle.length) return haystack[$ .. $];
+      searching:
+        foreach (i; 0 .. haystack.length - needle.length + 1)
+        {
+            foreach (j; 0 .. needle.length)
+            {
+                if (!binaryFun!(pred)(needle[j], haystack[i + j]))
+                    continue searching;
+            }
+            // found!
+            return haystack[i .. $];
+        }
+        // not found
+        return haystack[$ .. $];
+    }
+    else static if (is(Range.AssumeSorted)
+            // @@@ BUG static if can't do alias parms - this shouldn't
+            // be here
+            && pred == "a == b")
+    {
+        auto lhs = haystack.assumeSorted;
+        foreach (i, Unused; Ranges)
+        {
+            alias needles[i] rhs;
+            static if (is(typeof(binaryFun!(pred)(lhs.front, rhs))))
+            {
+                // Single-element lookup
+                auto r = lowerBound!(Range.assumeSortedBy)(lhs, rhs);
+                // found?
+                if (r.length < lhs.length
+                        && binaryFun!(pred)(lhs[r.length], rhs))
+                    return select!(Ranges.length == 1)(
+                        lhs[r.length .. lhs.length],
+                        tuple(lhs[r.length .. lhs.length], i + 1));
+                // not found, march on
+            }
+            else
+            {
+                // Subrange lookup
+                if (rhs.empty) continue;
+                auto lb = lowerBound!(Range.assumeSortedBy)(lhs, rhs.front);
+                if (lb.length == lhs.length) continue; // not found
+                auto eq = equalRange!(Range.assumeSortedBy)(lb, rhs.front);
+                foreach (j; lb.length .. lb.length + eq.length)
+                {
+                    if (startsWith!(pred)(lhs[j .. $], rhs))
+                        return select!(Ranges.length == 1)(
+                            lhs[j .. $], tuple(lhs[j .. $], i + 1));
+                }
+            }
+        }
+        // not found
+        return select!(Ranges.length == 1)(lhs.init, tuple(lhs.init, 0u));
+    }
+    else static if (is(typeof(needles[0].findReflect(haystack))))
+    {
+        // The first needle is organized for fast finding
+        auto result = needles[0].findReflect(haystack);
+        static if (Ranges.length == 1)
+        {
+            return result; // found or not, that's all we could do
+        }
+        else
+        {
+            auto r = find!(pred)(lhs, rhs[1 .. $]);
+            if (r.field[1]) ++r.field[1];
+            return r;
+        }
+    }
+    else
+    {
+        static if (Ranges.length == 1 && allSatisfy!(hasLength, Ranges, Range)
+                && is(typeof(binaryFun!(pred)(haystack[1], needles[0][1]))))
+        {
+            alias needles[0] needle;
+            if (haystack.length < needle.length) return haystack[$ .. $];
+            foreach (i; 0 .. haystack.length - needle.length + 1)
+            {
+                auto h = haystack[i .. $];
+                auto r = startsWith!(pred)(h, needle);
+                if (r) return h;
+            }
+            return haystack[$ .. $];
+        }
+        else
+        {
+            for (;; haystack.popFront)
+            {
+                auto r = startsWith!(pred)(haystack, needles);
+                if (r || haystack.empty)
+                {
+                    static if (Ranges.length == 1) return haystack;
+                    else return tuple(haystack, r);
+                }
+            }
+        }
+    }
+}
+
+unittest
+{
+    int[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
+    assert(find(assumeSorted(a), 3) == [3, 4, 5]);
+    assert(find(assumeSorted(a), 9).empty);
+    assert(find(assumeSorted(a), 5) == [5]);
+    assert(find(assumeSorted(a), -2).empty);
+    assert(find(assumeSorted(a), [3, 5]).empty);
+    assert(find(assumeSorted(a), [3, 5], [1, 3], 8).field[1] == 0);
+}
+
+unittest
+{
+    auto s1 = "Mary has a little lamb";
+    //writeln(find(s1, "has a", "has an"));
+    assert(find(s1, "has a", "has an") == tuple("has a little lamb", 1));
+    assert(find("abc", "bc").length == 2);
 }
 
 unittest
 {
     int[] a = [ 1, 2, 3 ];
-    assert(find(a, 5) == end(a));
-    assert(find(a, 2) == begin(a) + 1);
+    assert(find(a, 5).empty);
+    assert(find(a, 2) == [2, 3]);
 
     foreach (T; TypeTuple!(int, double))
     {
@@ -710,22 +1117,23 @@
         if (!b.length) continue;
         b[$ / 2] = 200;
         b[$ / 4] = 200;
-        assert(find(b, 200) == begin(b) + b.length / 4);
+        assert(find(b, 200).length == b.length - b.length / 4);
     }
 
 // Case-insensitive find of a string
     string[] s = [ "Hello", "world", "!" ];
-    assert(find!("toupper(a) == toupper(b)")(s, "hello") == begin(s));
+    //writeln(find!("toupper(a) == toupper(b)")(s, "hello"));
+    assert(find!("toupper(a) == toupper(b)")(s, "hello").length == 3);
 
     static bool f(string a, string b) { return toupper(a) == toupper(b); }
-    assert(find!(f)(s, "hello") == begin(s));
+    assert(find!(f)(s, "hello").length == 3);
 }
 
 unittest
 {
     int[] a = [ 1, 2, 3, 2, 6 ];
-    assert(find(retro(a), 5) == rEnd(a));
-    assert(find(retro(a), 2) == rBegin(a) + 1);
+    assert(find(std.range.retro(a), 5).empty);
+    assert(equal(find(std.range.retro(a), 2), [ 2, 3, 2, 1 ][]));
 
     foreach (T; TypeTuple!(int, double))
     {
@@ -733,107 +1141,40 @@
         if (!b.length) continue;
         b[$ / 2] = 200;
         b[$ / 4] = 200;
-        assert(find(retro(b), 200) == rBegin(b) + (b.length - 1) / 2);
+        assert(find(std.range.retro(b), 200).length ==
+                b.length - (b.length - 1) / 2);
     }
 }
 
-/**
-Finds the first element in a range satisfying the unary predicate $(D
-pred). Performs $(BIGOH haystack.length) evaluations of $(D pred). See
-also $(WEB sgi.com/tech/stl/find_if.html, STL's find_if).
-
-To find the last element of $(D haystack) satisfying $(D pred), call
-$(D find!(pred)(retro(haystack))) and compare the result against $(D
-rEnd(haystack)). See also $(XREF iterator, retro).
-
-Example:
-----
-auto arr = [ 1, 2, 3 ];
-assert(find!("a > 2")(arr) == end(arr) - 1);
-
-// with predicate alias
-bool pred(int x) { return x + 1 > 1.5; }
-assert(find!(pred)(arr) == begin(arr));
-----
-*/
-Iterator!(Range) find(alias pred, Range)(Range haystack)
-{
-    alias unaryFun!(pred) predFun;
-    foreach (i; begin(haystack) .. end(haystack))
-    {
-        if (predFun(*i)) return i;
-    }
-    return end(haystack);
-}
-
-unittest
-{
-    auto a = [ 1, 2, 3 ];
-    assert(find!("a > 2")(a) == end(a) - 1);
-    bool pred(int x) { return x + 1 > 1.5; }
-    assert(find!(pred)(a) == begin(a));
-}
-
-// findRange
-/**
-Finds the first occurrence of $(D subseq) in $(D seq) by repeated
-linear searches.  Performs $(BIGOH seq.length * subseq.length)
-evaluations of $(D pred), which makes it unrecommended for very large
-ranges, for which $(XREF algorithm, findBoyerMoore) may be more
-appropriate. See also $(WEB sgi.com/tech/stl/search.html, STL's
-search).
-
-Example:
-----
-int[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
-int[] b = [ 1, 2, 3 ];
-assert(findRange(a, b) == begin(a) + 2);
-assert(findRange(b, a) == end(b));
-----
-*/
-Iterator!(Range1) findRange(alias pred = "a == b", Range1, Range2)
-    (Range1 seq, Range2 subseq)
-{
-    auto e1 = end(seq);
-    if (seq.length < subseq.length) return e1;
-    auto e11 = e1 - subseq.length + 1;
-    auto e2 = end(subseq);
-    foreach (i; begin(seq) .. e11)
-    {
-        auto m = mismatch!(pred)(range(i, e1), subseq);
-        if (m._1 == e2) return i;
-    }
-    return e1;
-}
-
 unittest
 {
     int[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
     int[] b = [ 1, 2, 3 ];
-    assert(findRange(a, b) == begin(a) + 2);
-    assert(findRange(b, a) == end(b));
+    assert(find(a, b) == [ 1, 2, 3, 4, 5 ]);
+    assert(find(b, a).empty);
 }
 
-// findBoyerMoore
-private struct BoyerMooreFinder(alias pred, Range)
+/// Ditto
+struct BoyerMooreFinder(alias pred, Range)
 {
 private:
     size_t skip[];
-    int[typeof(Range[0])] occ;
+    int[ElementType!(Range)] occ;
     Range needle;
   
-    int occurrence(char c)
+    int occurrence(ElementType!(Range) c)
     {
         auto p = c in occ;
         return p ? *p : -1;
     }
 
-/* This helper function checks, whether the last "portion" bytes
- * of "needle" (which is "nlen" bytes long) exist within the "needle"
- * at offset "offset" (counted from the end of the string),
- * and whether the character preceding "offset" is not a match.
- * Notice that the range being checked may reach beyond the
- * beginning of the string. Such range is ignored.
+/*
+This helper function checks whether the last "portion" bytes of
+"needle" (which is "nlen" bytes long) exist within the "needle" at
+offset "offset" (counted from the end of the string), and whether the
+character preceding "offset" is not a match.  Notice that the range
+being checked may reach beyond the beginning of the string. Such range
+is ignored.
  */
     static bool needlematch(R)(R needle,
                               size_t portion, size_t offset)
@@ -849,27 +1190,25 @@
             return 0;
         
         invariant delta = portion - ignore;
-        return equal(range(end(needle) - delta, end(needle)),
-                     range(begin(needle) + virtual_begin,
-                           begin(needle) + virtual_begin + delta));
+        return equal(needle[needle.length - delta .. needle.length],
+                needle[virtual_begin .. virtual_begin + delta]);
     }
 
 public:
-    static BoyerMooreFinder opCall(Range needle)
+    this(Range needle)
     {
-        BoyerMooreFinder result;
-        if (!needle.length) return result;
-        result.needle = needle;
+        if (!needle.length) return;
+        this.needle = needle;
         /* Populate table with the analysis of the needle */
         /* But ignoring the last letter */
         foreach (i, n ; needle[0 .. $ - 1])
         {
-            result.occ[n] = i;
+            this.occ[n] = i;
         }
         /* Preprocess #2: init skip[] */  
         /* Note: This step could be made a lot faster.
          * A simple implementation is shown here. */
-        result.skip = new size_t[needle.length];
+        this.skip = new size_t[needle.length];
         foreach (a; 0 .. needle.length)
         {
             size_t value = 0;
@@ -878,15 +1217,14 @@
             {
                 ++value;
             }
-            result.skip[needle.length - a - 1] = value;
+            this.skip[needle.length - a - 1] = value;
         }
-        return result;
     }
 
-    Iterator!(Range) inspect(Range haystack)
+    Range findReflect(Range haystack)
     {
-        if (!needle.length) return begin(haystack);
-        if (needle.length > haystack.length) return end(haystack);
+        if (!needle.length) return haystack;
+        if (needle.length > haystack.length) return haystack[$ .. $];
         /* Search: */
         auto limit = haystack.length - needle.length;
         for (size_t hpos = 0; hpos <= limit; )
@@ -894,12 +1232,12 @@
             size_t npos = needle.length - 1;
             while (pred(needle[npos], haystack[npos+hpos]))
             {
-                if (npos == 0) return begin(haystack) + hpos;
+                if (npos == 0) return haystack[hpos .. $];
                 --npos;
             }
             hpos += max(skip[npos], npos - occurrence(haystack[npos+hpos]));
         }
-        return end(haystack);
+        return haystack[$ .. $];
     }
 
     size_t length()
@@ -909,30 +1247,13 @@
 }
 
 /**
-Finds the first occurrence of $(D subseq) in $(D seq) by using the
-$(WEB www-igm.univ-mlv.fr/~lecroq/string/node14.html, Boyer-Moore
-algorithm).  The algorithm has an upfront cost but scales sublinearly,
-so it is most suitable for large sequences. Performs $(BIGOH
-seq.length) evaluations of $(D pred) in the worst case and $(BIGOH
-seq.length / subseq.length) evaluations in the best case.
-
-Example:
-----
-int[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
-int[] b = [ 1, 2, 3 ];
-assert(findBoyerMoore(a, b) == begin(a) + 2);
-assert(findBoyerMoore(b, a) == end(b));
-----
-
-BUGS:
-
-Should cache the scaffolding built for the last $(D subseq) in
-thread-safe storage so it is not rebuilt repeatedly.
-*/
-Iterator!(Range) findBoyerMoore(alias pred = "a == b", Range)
-    (Range seq, Range subseq)
+Ditto
+ */
+BoyerMooreFinder!(binaryFun!(pred), Range) boyerMooreFinder
+(alias pred = "a == b", Range)
+(Range needle) if (isRandomAccessRange!(Range))
 {
-    return BoyerMooreFinder!(binaryFun!(pred), Range)(subseq).inspect(seq);
+    return typeof(return)(needle);
 }
 
 unittest
@@ -942,60 +1263,284 @@
         " to `_Dmain':";
     string[] ns = ["libphobos", "function", " undefined", "`", ":"];
     foreach (n ; ns) {
-        auto p = findBoyerMoore(h, n);
-        assert(p != end(h) && range(p, p + n.length) == n);
+        auto p = find(h, boyerMooreFinder(n));
+        assert(!p.empty);
     }
 
     int[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
     int[] b = [ 1, 2, 3 ];
-    assert(findBoyerMoore(a, b) == begin(a) + 2);
-    assert(findBoyerMoore(b, a) == end(b));
+    //writeln(find(a, boyerMooreFinder(b)));
+    assert(find(a, boyerMooreFinder(b)) == [ 1, 2, 3, 4, 5 ]);
+    assert(find(b, boyerMooreFinder(a)).empty);
+}
+
+/**
+Advances the input range $(D haystack) by calling $(D haystack.popFront)
+until either $(D pred(haystack.front)), or $(D
+haystack.empty). Performs $(BIGOH haystack.length) evaluations of $(D
+pred). See also $(WEB sgi.com/tech/stl/find_if.html, STL's find_if).
+
+To find the last element of a bidirectional $(D haystack) satisfying
+$(D pred), call $(D find!(pred)(retro(haystack))). See also $(XREF
+range, retro).
+
+Example:
+----
+auto arr = [ 1, 2, 3, 4, 1 ];
+assert(find!("a > 2")(arr) == [ 3, 4, 1 ]);
+
+// with predicate alias
+bool pred(int x) { return x + 1 > 1.5; }
+assert(find!(pred)(arr) == arr);
+----
+*/
+Range find(alias pred, Range)(Range haystack) if (isInputRange!(Range))
+{
+    alias unaryFun!(pred) predFun;
+    for (; !haystack.empty && !predFun(haystack.front); haystack.popFront)
+    {
+    }
+    return haystack;
+}
+
+unittest
+{
+    int[] a = [ 1, 2, 3 ];
+    assert(find!("a > 2")(a) == [3]);
+    bool pred(int x) { return x + 1 > 1.5; }
+    assert(find!(pred)(a) == a);
+}
+
+/**
+If the range $(D doesThisStart) starts with $(I any) of the $(D
+withOneOfThese) ranges or elements, returns 1 if it starts with $(D
+withOneOfThese[0]), 2 if it starts with $(D withOneOfThese[1]), and so
+on. If no match, returns 0.
+
+Example:
+----
+assert(startsWith("abc", ""));
+assert(startsWith("abc", "a"));
+assert(!startsWith("abc", "b"));
+assert(startsWith("abc", 'a', "b") == 1);
+assert(startsWith("abc", "b", "a") == 2);
+assert(startsWith("abc", "a", "a") == 1);
+assert(startsWith("abc", "x", "a", "b") == 2);
+assert(startsWith("abc", "x", "aa", "ab") == 3);
+assert(startsWith("abc", "x", "aaa", "sab") == 0);
+assert(startsWith("abc", "x", "aaa", 'a', "sab") == 3);
+----
+ */
+uint startsWith(alias pred = "a == b", Range, Ranges...)
+(Range doesThisStart, Ranges withOneOfThese)
+if (isInputRange!(Range))
+{
+    static assert(Ranges.length > 0);
+    alias doesThisStart lhs;
+    alias withOneOfThese rhs;
+    static if (Ranges.length == 1 && isArray!(Range) && isArray!(Ranges[0])
+            && is(typeof(binaryFun!(pred)(lhs[0], rhs[0][0]))))
+    {
+        alias doesThisStart haystack;
+        alias withOneOfThese[0] needle;
+        if (haystack.length < needle.length) return 0;
+        foreach (j; 0 .. needle.length)
+        {
+            if (!binaryFun!(pred)(needle[j], haystack[j]))
+                // not found
+                return 0u;
+        }
+        // found!
+        return 1u;
+    }
+    else
+    {
+        for (;; lhs.popFront)
+        {
+            // Has any of the rhs's fell off its end?
+            foreach (i, Unused; Ranges)
+            {
+                static if (!is(typeof(binaryFun!(pred)(lhs.front, rhs[i]))))
+                    if (rhs[i].empty) return i + 1; // found!
+            }
+            if (lhs.empty) return 0; // exhausted lhs, nothing found
+            foreach (i, Unused; Ranges)
+            {
+                static if (is(typeof(binaryFun!(pred)(lhs.front, rhs[i]))))
+                {
+                    // single-element comparison
+                    if (binaryFun!(pred)(lhs.front, rhs[i]))
+                        return i + 1;
+                    // mismatch, fall through
+                }
+                else
+                {
+                    assert(!rhs[i].empty);
+                    if (binaryFun!(pred)(lhs.front, rhs[i].front))
+                    {
+                        rhs[i].popFront;
+                        continue;
+                    }
+                }
+                // found a mismatch, only continue searching the others
+                static if (Ranges.length == 1) 
+                {
+                    return 0;
+                }
+                else
+                {
+                    auto r = startsWith!(pred)(lhs, rhs[0 .. i],
+                            rhs[i + 1 .. $]);
+                    if (!r) return 0u;
+                    return cast(uint) (r <= i ? r : r + 1);
+                }
+            }
+        }
+    }
+}
+
+unittest
+{
+    assert(startsWith("abc", ""));
+    assert(startsWith("abc", "a"));
+    assert(!startsWith("abc", "b"));
+    assert(startsWith("abc", "a", "b") == 1);
+    assert(startsWith("abc", "b", "a") == 2);
+    assert(startsWith("abc", "a", "a") == 1);
+    assert(startsWith("abc", "x", "a", "b") == 2);
+    assert(startsWith("abc", "x", "aa", "ab") == 3);
+    assert(startsWith("abc", "x", "aaa", "sab") == 0);
+    assert(startsWith("abc", "x", "aaa", 'a', "sab") == 3);
+}
+
+/**
+The reciprocal of $(D startsWith).
+
+Example:
+----
+assert(endsWith("abc", ""));
+assert(!endsWith("abc", "b"));
+assert(endsWith("abc", "a", 'c') == 2);
+assert(endsWith("abc", "c", "a") == 1);
+assert(endsWith("abc", "c", "c") == 1);
+assert(endsWith("abc", "x", "c", "b") == 2);
+assert(endsWith("abc", "x", "aa", "bc") == 3);
+assert(endsWith("abc", "x", "aaa", "sab") == 0);
+assert(endsWith("abc", "x", "aaa", 'c', "sab") == 3);
+----
+ */
+uint
+endsWith(alias pred = "a == b", Range, Ranges...)
+(Range doesThisEnd, Ranges withOneOfThese)
+if (isInputRange!(Range))
+{
+    alias doesThisEnd lhs;
+    alias withOneOfThese rhs;
+    for (; !lhs.empty; lhs.popBack)
+    {
+        foreach (i, Unused; Ranges)
+        {
+            static if (is(typeof(binaryFun!(pred)(lhs.back, rhs[i]))))
+            {
+                if (binaryFun!(pred)(lhs.back, rhs[i]))
+                    return i + 1;
+                // mismatch, fall through
+            }
+            else
+            {
+                if (rhs[i].empty)
+                {
+                    // found a match!!!
+                    return i + 1;
+                }
+                if (binaryFun!(pred)(lhs.back, rhs[i].back))
+                {
+                    rhs[i].popBack;
+                    continue;
+                }
+            }
+            // found a mismatch, only continue searching the others
+            static if (Ranges.length == 1) 
+            {
+                return 0;
+            }
+            else
+            {
+                auto r = endsWith!(pred)(lhs, rhs[0 .. i], rhs[i + 1 .. $]);
+                if (!r) return 0;
+                return r <= i ? r : r + 1;
+            }
+        }
+    }
+    // fell off the lhs range
+    foreach (i, Unused; Ranges)
+    {
+        static if (!is(typeof(binaryFun!(pred)(lhs.front, rhs[i]))))
+            if (rhs[i].empty) return i + 1;
+    }
+    return 0;
+}
+
+unittest
+{
+    assert(endsWith("abc", ""));
+    assert(!endsWith("abc", "a"));
+    assert(!endsWith("abc", "b"));
+    assert(endsWith("abc", "a", 'c') == 2);
+    assert(endsWith("abc", "c", "a") == 1);
+    assert(endsWith("abc", "c", "c") == 1);
+    assert(endsWith("abc", "x", "c", "b") == 2);
+    assert(endsWith("abc", "x", "aa", "bc") == 3);
+    assert(endsWith("abc", "x", "aaa", "sab") == 0);
+    assert(endsWith("abc", "x", "aaa", 'c', "sab") == 3);
 }
 
 // findAdjacent
 /**
-Finds the first two adjacent elements $(D a), $(D b) in the range $(D
-r) that satisfy $(D pred(a, b)). Performs $(BIGOH r.length)
+Advances $(D r) until it finds the first two adjacent elements $(D a),
+$(D b) that satisfy $(D pred(a, b)). Performs $(BIGOH r.length)
 evaluations of $(D pred). See also $(WEB
 sgi.com/tech/stl/adjacent_find.html, STL's adjacent_find).
 
 Example:
 ----
 int[] a = [ 11, 10, 10, 9, 8, 8, 7, 8, 9 ];
-auto p = findAdjacent(a);
-assert(p == begin(a) + 1);
+auto r = findAdjacent(a);
+assert(r == [ 10, 10, 9, 8, 8, 7, 8, 9 ]);
 p = findAdjacent!("a < b")(a);
-assert(p == begin(a) + 6);
+assert(p == [ 7, 8, 9 ]);
 ----
 */
-Iterator!(Range) findAdjacent(alias pred = "a == b", Range)(Range r)
+Range findAdjacent(alias pred = "a == b", Range)(Range r)
+    if (isForwardRange!(Range))
 {
-    auto first = begin(r), last = end(r);
-    auto next = first;
-    if (first != last)
+    auto ahead = r;
+    if (!ahead.empty)
     {
-        for (++next; next != last; ++first, ++next)
-            if (binaryFun!(pred)(*first, *next)) return first;
+        for (ahead.popFront; !ahead.empty; r.popFront, ahead.popFront)
+        {
+            if (binaryFun!(pred)(r.front, ahead.front)) break;
+        }
     }
-    return last;
+    return r;
 }
 
 unittest
 {
     int[] a = [ 11, 10, 10, 9, 8, 8, 7, 8, 9 ];
     auto p = findAdjacent(a);
-    assert(p == begin(a) + 1);
+    assert(p == [10, 10, 9, 8, 8, 7, 8, 9 ]);
     p = findAdjacent!("a < b")(a);
-    assert(p == begin(a) + 6);
+    assert(p == [7, 8, 9]);
 }
 
 // findAmong
 /**
-Finds the first element in $(D seq) that compares equal (according to
-$(D pred)) with some element in $(D choices). Choices are sought by
-linear search. Performs $(BIGOH seq.length * choices.length)
-evaluations of $(D pred). See also $(WEB
-sgi.com/tech/stl/find_first_of.html, STL's find_first_of).
+Advances $(D seq) by calling $(D seq.popFront) until either $(D
+find!(pred)(choices, seq.front)) is $(D true), or $(D seq) becomes
+empty. Performs $(BIGOH seq.length * choices.length) evaluations of
+$(D pred). See also $(WEB sgi.com/tech/stl/find_first_of.html, STL's
+find_first_of).
 
 Example:
 ----
@@ -1005,24 +1550,24 @@
 assert(findAmong(b, a) == begin(b));
 ----
 */
-Iterator!(Range1) findAmong(alias pred = "a == b", Range1, Range2)(
+Range1 findAmong(alias pred = "a == b", Range1, Range2)(
     Range1 seq, Range2 choices)
+    if (isInputRange!(Range1) && isForwardRange!(Range2))
 {
-    foreach (i, e; seq)
+    for (; !seq.empty && find!(pred)(choices, seq.front).empty; seq.popFront)
     {
-        if (find!(pred)(choices, e) != end(choices)) return begin(seq) + i;
     }
-    return end(seq);
+    return seq;
 }
 
 unittest
 {
     int[] a = [ -1, 0, 2, 1, 2, 3, 4, 5 ];
     int[] b = [ 1, 2, 3 ];
-    assert(findAmong(a, b) == begin(a) + 2);
-    assert(findAmong(b, [ 4, 6, 7 ]) == end(b));
-    assert(findAmong!("a==b")(a, b) == begin(a) + 2);
-    assert(findAmong!("a==b")(b, [ 4, 6, 7 ]) == end(b));
+    assert(findAmong(a, b) == [2, 1, 2, 3, 4, 5 ]);
+    assert(findAmong(b, [ 4, 6, 7 ][]).empty);
+    assert(findAmong!("a==b")(a, b).length == a.length - 2);
+    assert(findAmong!("a==b")(b, [ 4, 6, 7 ][]).empty);
 }
 
 // findAmongSorted
@@ -1036,7 +1581,7 @@
 
 To find the last element of $(D seq) instead of the first, call $(D
 findAmongSorted(retro(seq), choices)) and compare the result against
-$(D rEnd(seq)). See also $(XREF iterator, retro).
+$(D rEnd(seq)). See also $(XREF range, retro).
 
 Example:
 ----
@@ -1046,64 +1591,25 @@
 assert(findAmongSorted(b, a) == end(b));
 ----
 */
-Iterator!(Range1) findAmongSorted(alias less = "a < b", Range1, Range2)(
+Range1 findAmongSorted(alias less = "a < b", Range1, Range2)(
     Range1 seq, in Range2 choices)
+    if (isInputRange!(Range1) && isRandomAccessRange!(Range2))
 {
     alias binaryFun!(less) lessFun; // pun not intended
     assert(isSorted!(lessFun)(choices));
-    foreach (i, e; seq)
+    for (; !seq.empty; seq.popFront)
     {
-        if (canFindSorted!(lessFun)(choices, e)) return begin(seq) + i;
+        if (canFindSorted!(lessFun)(choices, seq.front)) break;
     }
-    return end(seq);
+    return seq;
 }
 
 unittest
 {
     int[] a = [ -1, 0, 2, 1, 2, 3, 4, 5 ];
     int[] b = [ 1, 2, 3 ];
-    assert(findAmongSorted(a, b) == begin(a) + 2);
-    assert(findAmongSorted(b, [ 4, 6, 7 ]) == end(b));
-}
-
-// canFind
-/**
-Convenience functions returning $(D true) if and only if the
-corresponding $(D find*) functions return an iterator different from
-$(D end(r)). They are handy in the numerous situations when the
-success of the $(D find*) functions is queried but the actual position
-found is unimportant.
-
-Example:
-----
-int[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
-assert(canFind(a, 4));
-assert(!canFind(a, 10));
-assert(canFind!("a - 1 < b")(a, 4));
-assert(!canFind!("a > 5")(a));
-----
-*/
-bool canFind(alias pred = "a == b", Range, E)(Range haystack, E needle)
-{
-    return find!(pred)(haystack, needle) != end(haystack);
-}
-
-/// Ditto
-bool canFind(alias pred, Range)(Range haystack)
-{
-    return find!(pred)(haystack) != end(haystack);
-}
-
-/// Ditto
-bool canFindAmong(alias pred, Range1, Range2)(Range1 seq, Range2 choices)
-{
-    return findAmong!(pred)(seq, choices) != end(seq);
-}
-
-/// Ditto
-bool canFindAmongSorted(alias pred, Range1, Range2)(Range1 seq, Range2 choices)
-{
-    return findAmongSorted!(pred)(seq, choices) != end(seq);
+    assert(findAmongSorted(a, b) == [2, 1, 2, 3, 4, 5]);
+    assert(findAmongSorted(b, [ 4, 6, 7 ][]).empty);
 }
 
 // count
@@ -1121,16 +1627,17 @@
 */
 
 size_t count(alias pred = "a == b", Range, E)(Range r, E value)
+    if (isInputRange!(Range))
 {
-    bool pred2(typeof(*begin(r)) a) { return binaryFun!(pred)(a, value); }
+    bool pred2(ElementType!(Range) a) { return binaryFun!(pred)(a, value); }
     return count!(pred2)(r);
 }
 
 unittest
 {
     int[] a = [ 1, 2, 4, 3, 2, 5, 3, 2, 4 ];
-    assert(count(a, 2) == 3);
-    assert(count!("a > b")(a, 2) == 5);
+    assert(count(a, 2) == 3, text(count(a, 2)));
+    assert(count!("a > b")(a, 2) == 5, text(count!("a > b")(a, 2)));
 }
 
 /**
@@ -1143,12 +1650,12 @@
 assert(count!("a > 1")(a) == 8);
 ----
 */
-size_t count(alias pred, Range)(Range r)
+size_t count(alias pred, Range)(Range r) if (isInputRange!(Range))
 {
     size_t result;
-    foreach (i; begin(r) .. end(r))
+    foreach (e; r)
     {
-        if (unaryFun!(pred)(*i)) ++result;
+        if (unaryFun!(pred)(e)) ++result;
     }
     return result;
 }
@@ -1185,10 +1692,15 @@
 ----
 */
 bool equal(alias pred = "a == b", Range1, Range2)(Range1 r1, Range2 r2)
+    if (isInputRange!(Range1) && isInputRange!(Range2))
 {
-    if (r1.length != r2.length) return false;
-    auto result = mismatch!(pred)(r1, r2);
-    return result._0 == end(r1) && result._1 == end(r2);
+    foreach (e1; r1)
+    {
+        if (r2.empty) return false;
+        if (!binaryFun!(pred)(e1, r2.front)) return false;
+        r2.popFront;
+    }
+    return r2.empty;
 }
 
 unittest
@@ -1347,12 +1859,60 @@
     assert(max(a, f) == 5);
 }
 
+/**
+Returns the minimum element of a range together with the number of
+occurrences. The function can actually be used for counting the
+maximum or any other ordering predicate (that's why $(D maxCount) is
+not provided).
+
+Example:
+----
+int[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];
+// Minimum is 1 and occurs 3 times
+assert(minCount(a) == tuple(1, 3));
+// Maximum is 4 and occurs 2 times
+assert(minCount!("a > b")(a) == tuple(4, 2));
+----
+ */
+Tuple!(ElementType!(Range), size_t)
+minCount(alias pred = "a < b", Range)(Range range)
+{
+    if (range.empty) return typeof(return)();
+    auto p = &(range.front);
+    size_t occurrences = 1;
+    for (range.popFront; !range.empty; range.popFront)
+    {
+        if (binaryFun!(pred)(*p, range.front)) continue;
+        if (binaryFun!(pred)(range.front, *p))
+        {
+            // change the min
+            p = &(range.front);
+            occurrences = 1;
+        }
+        else
+        {
+            ++occurrences;
+        }
+    }
+    return tuple(*p, occurrences);
+}
+
+unittest
+{
+    int[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];
+    assert(minCount(a) == tuple(1, 3));
+    assert(minCount!("a > b")(a) == tuple(4, 2));
+    int[][] b = [ [4], [2, 4], [4], [4] ];
+    auto c = minCount!("a[0] < b[0]")(b);
+    assert(c == tuple([2, 4], 1), text(c.field[0]));
+}
+
 // mismatch
 /**
 Sequentially compares elements in $(D r1) and $(D r2) in lockstep, and
 stops at the first mismatch (according to $(D pred), by default
-equality). Returns a tuple with the iterators that refer to the two
-mismatched values. Performs $(BIGOH min(r1.length, r2.length))
+equality). Returns a tuple with the reduced ranges that start with the
+two mismatched values. Performs $(BIGOH min(r1.length, r2.length))
 evaluations of $(D pred). See also $(WEB
 sgi.com/tech/stl/_mismatch.html, STL's mismatch).
 
@@ -1361,20 +1921,20 @@
 int[]    x = [ 1,  5, 2, 7,   4, 3 ];
 double[] y = [ 1., 5, 2, 7.3, 4, 8 ];
 auto m = mismatch(x, y);
-assert(m._0 == begin(x) + 3);
-assert(m._1 == begin(y) + 3);
+assert(m.field[0] == begin(x) + 3);
+assert(m.field[1] == begin(y) + 3);
 ----
 */
 
-Tuple!(Iterator!(Range1), Iterator!(Range2))
+Tuple!(Range1, Range2)
 mismatch(alias pred = "a == b", Range1, Range2)(Range1 r1, Range2 r2)
+    if (isInputRange!(Range1) && isInputRange!(Range2))
 {
-    auto i1 = begin(r1), i2 = begin(r2), e1 = end(r1), e2 = end(r2);
-    for (; i1 != e1 && i2 != e2; ++i1, ++i2)
+    for (; !r1.empty && !r2.empty; r1.popFront(), r2.popFront())
     {
-        if (!binaryFun!(pred)(*i1, *i2)) break;
+        if (!binaryFun!(pred)(r1.front, r2.front)) break;
     }
-    return tuple(i1, i2);
+    return tuple(r1, r2);
 }
 
 unittest
@@ -1383,14 +1943,14 @@
     int[]    x = [ 1,  5, 2, 7,   4, 3 ];
     double[] y = [ 1., 5, 2, 7.3, 4, 8 ];
     auto m = mismatch(x, y);
-    assert(m._0 == begin(x) + 3);
-    assert(m._1 == begin(y) + 3);
+    assert(m.field[0] == [ 7, 4, 3 ]);
+    assert(m.field[1] == [ 7.3, 4, 8 ]);
 
     int[] a = [ 1, 2, 3 ];
     int[] b = [ 1, 2, 4, 5 ];    
     auto mm = mismatch(a, b);
-    assert(mm._0 == begin(a) + 2);
-    assert(mm._1 == begin(b) + 2);
+    assert(mm.field[0] == [3]);
+    assert(mm.field[1] == [4, 5]);
 }
 
 // levenshteinDistance
@@ -1558,19 +2118,14 @@
     ("parks", "SPARK") == 2);
 ----
 */
-size_t levenshteinDistance(alias equals, Range1, Range2)(Range1 s, Range2 t)
+size_t levenshteinDistance(alias equals = "a == b", Range1, Range2)
+    (Range1 s, Range2 t)
+    if (isRandomAccessRange!(Range1) && isRandomAccessRange!(Range2))
 {
-    Levenshtein!(typeof(range(begin(s), end(s))), equals, uint) lev;
+    Levenshtein!(Range1, binaryFun!(equals), uint) lev;
     return lev.distance(s, t);
 }
 
-/// Ditto
-size_t levenshteinDistance(string equals = "a == b", Range1, Range2)(
-    Range1 s, Range2 t)
-{
-    return levenshteinDistance!(binaryFun!(equals), Range1, Range2)(s, t);
-}
-
 /**
 Returns the Levenshtein distance and the edit path between $(D s) and
 $(D t).
@@ -1579,27 +2134,20 @@
 ---
 string a = "Saturday", b = "Sunday";
 auto p = levenshteinDistanceAndPath(a, b);
-assert(p._0, 3);
-assert(equals(p._1, "nrrnsnnn"));
+assert(p.field[0], 3);
+assert(equals(p.field[1], "nrrnsnnn"));
 ---
 */
 Tuple!(size_t, EditOp[])
-levenshteinDistanceAndPath(alias equals, Range1, Range2)(Range1 s, Range2 t)
+levenshteinDistanceAndPath(alias equals = "a == b", Range1, Range2)
+    (Range1 s, Range2 t)
+    if (isRandomAccessRange!(Range1) && isRandomAccessRange!(Range2))
 {
-    Levenshtein!(Range, equals) lev;
+    Levenshtein!(Range, binaryFun!(equals)) lev;
     auto d = lev.distance(s, t);
     return tuple(d, lev.path);
 }
 
-/// Ditto
-Tuple!(size_t, EditOp[])
-levenshteinDistanceAndPath(string equals = "a == b",
-                           Range1, Range2)(Range1 s, Range2 t)
-{
-    return levenshteinDistanceAndPath!(binaryFun!(equals), Range1, Range2)(
-        s, t);
-}
-
 unittest
 {
     assert(levenshteinDistance("a", "a") == 0);
@@ -1614,7 +2162,7 @@
     // @@@BUG@@@
     //auto p = levenshteinDistanceAndPath(a, b);
     //writefln(p);
-    //assert(cast(string) p._1 == "nrrnsnnn", cast(string) p);
+    //assert(cast(string) p.field[1] == "nrrnsnnn", cast(string) p);
 }
 
 // copy
@@ -1624,7 +2172,7 @@
 sgi.com/tech/stl/_copy.html, STL's copy). If a behavior similar to
 $(WEB sgi.com/tech/stl/copy_backward.html, STL's copy_backward) is
 needed, use $(D copy(retro(source), retro(target))). See also $(XREF
-iterator, retro).
+range, retro).
 
 Example:
 ----
@@ -1645,129 +2193,95 @@
 double[] b = new double[a.length];
 auto d = copy(a, b);
 ----
-*/
-
-Range2 copy(Range1, Range2)(Range1 source, Range2 target)
-{
-    auto t = begin(target), te = end(target);
-    foreach (s; begin(source) .. end(source))
-    {
-        if (t == te) enforce(false,
-                             "copy: insufficient space in target range");
-        *t = *s;
-        ++t;
-    }
-    return range(t, te);
-}
-
-unittest
-{
-    int[] a = [ 1, 5 ];
-    int[] b = [ 9, 8 ];
-    int[] c = new int[a.length + b.length + 10];
-    auto d = copy(b, copy(a, c));
-    assert(c[0 .. a.length + b.length] == a ~ b);
-    assert(d.length == 10);
-}
-
-// copyIf
-/**
-Copies in increasing order the elements $(D x) of $(D source)
-satisfying $(D pred(x)) into $(D target) and returns the remaining
-(unfilled) part of $(D target). See also $(WEB
-sgi.com/tech/stl/copy_if.html, STL's copy_if).
+
+To copy at most $(D n) elements from range $(D a) to range $(D b), you
+may want to use $(D copy(take(n, a), b)). To copy those elements from
+range $(D a) that satisfy predicate $(D pred) to range $(D b), you may
+want to use $(D copy(filter!(pred)(a), b)).
 
 Example:
 ----
 int[] a = [ 1, 5, 8, 9, 10, 1, 2, 0 ];
 auto b = new int[a.length];
-auto c = copyIf!("(a & 1) == 1")(a, b);
+auto c = copy(filter!("(a & 1) == 1")(a), b);
 assert(b[0 .. $ - c.length] == [ 1, 5, 9, 1 ]);
 ----
 
-As long as the target range elements support assignment from source
-range elements, different types of ranges are accepted.
-
-Example:
-----
-float[] a = [ 1.0f, 5, -3, -5, 0, 4, -3 ];
-double[] b = new double[a.length];
-auto d = copyIf!("a > 0")(a, b);
-assert(a == [ 1.0f, 5, 0, 4 ]);
-----
-*/
-
-Range2 copyIf(alias pred, Range1, Range2)(Range1 source, Range2 target)
+ */
+Range2 copy(Range1, Range2)(Range1 source, Range2 target)
+    if (isInputRange!(Range1)
+            && isOutputRange!(Range2, ElementType!(Range1)))
 {
-    //static assert(false, "Not yet implemented due to bugs in the compiler");
-    auto t = begin(target), te = end(target);
-    foreach (s; begin(source) .. end(source))
+    foreach (e; source)
     {
-        if (!unaryFun!(pred)(*s)) continue;
-        if (t == te) enforce(false,
-                             "copyIf: insufficient space in target range");
-        *t = *s;
-        ++t;
+        target.put(e);
     }
-    return range(t, te);
+    return target;
 }
 
 unittest
 {
-    int[] a = [ 1, 5 ];
-    int[] b = [ 9, 8 ];
-    auto e = copyIf!("a > 1")(a, b);
-    assert(b[0] == 5 && e.length == 1);
-}
-
-// iterSwap
-/**
-Swaps $(D *lhs) and $(D *rhs).
-
-Preconditions:
-Same as for $(D swap(*lhs, *rhs)).
-*/
-void iterSwap(It)(It lhs, It rhs)
-{
-    assert(!pointsTo(*lhs, *lhs), It.stringof);
-    swap(*lhs, *rhs);
+    {
+        int[] a = [ 1, 5 ];
+        int[] b = [ 9, 8 ];
+        int[] c = new int[a.length + b.length + 10];
+        auto d = copy(b, copy(a, c));
+        assert(c[0 .. a.length + b.length] == a ~ b);
+        assert(d.length == 10);
+    }
+    {
+        int[] a = [ 1, 5 ];
+        int[] b = [ 9, 8 ];
+        auto e = copy(filter!("a > 1")(a), b);
+        assert(b[0] == 5 && e.length == 1);
+    }
 }
 
 // swapRanges
 /**
-Swaps all elements of $(D r1) with successive elements in $(D r2)
-using $(D iterSwap) as a primitive. $(D r1) must contain less or the
-same number of elements as $(D r2); an exception will be thrown
-otherwise. Returns the tail portion of $(D r2) that was not swapped.
+Swaps all elements of $(D r1) with successive elements in $(D r2).
+Returns a tuple containing the remainder portions of $(D r1) and $(D
+r2) that were not swapped (one of them will be empty). The ranges may
+be of different types but must have the same element type and support
+swapping.
 
 Example:
 ----
 int[] a = [ 100, 101, 102, 103 ];
 int[] b = [ 0, 1, 2, 3 ];
-auto c = swapRanges(a[1 .. 2], b[2 .. 3]);
-assert(!c.length);
+auto c = swapRanges(a[1 .. 3], b[2 .. 4]);
+assert(c.at!(0).empty && c.at!(1).empty);
 assert(a == [ 100, 2, 3, 103 ]);
 assert(b == [ 0, 1, 101, 102 ]);
 ----
 */
-Range2 swapRanges(alias iterSwap = .iterSwap, Range1, Range2)(T r1, T r2)
+Tuple!(Range1, Range2)
+swapRanges(Range1, Range2)(Range1 r1, Range2 r2)
+    if (isInputRange!(Range1) && isInputRange!(Range2)
+            && hasSwappableElements!(Range1) && hasSwappableElements!(Range2)
+            && is(ElementType!(Range1) == ElementType!(Range2)))
 {
-    enforce(r1.length <= r2.length,
-        "swapRanges: too short range in the second position");
-    auto t = begin(r2);
-    foreach (s; begin(r1) .. end(r1))
+    for (; !r1.empty && !r2.empty; r1.popFront, r2.popFront)
     {
-        iterSwap(t, s);
-        ++t;
+        swap(r1.front, r2.front);
     }
-    return range(t, end(r2));
+    return tuple(r1, r2);
+}
+
+unittest
+{
+    int[] a = [ 100, 101, 102, 103 ];
+    int[] b = [ 0, 1, 2, 3 ];
+    auto c = swapRanges(a[1 .. 3], b[2 .. 4]);
+    assert(c.field[0].empty && c.field[1].empty);
+    assert(a == [ 100, 2, 3, 103 ]);
+    assert(b == [ 0, 1, 101, 102 ]);
 }
 
 // reverse
 /**
 Reverses $(D r) in-place.  Performs $(D r.length) evaluations of $(D
-iterSwap). See also $(WEB sgi.com/tech/stl/_reverse.html, STL's
-reverse).
+swap). See also $(WEB sgi.com/tech/stl/_reverse.html, STL's reverse).
 
 Example:
 ----
@@ -1776,15 +2290,15 @@
 assert(arr == [ 3, 2, 1 ]);
 ----
 */
-void reverse(alias iterSwap = .iterSwap, Range)(Range r)
+void reverse(Range)(Range r)
+//if (isBidirectionalRange!(Range) && hasSwappableElements!(Range))
 {
-    auto b = begin(r), e = end(r);
-    assert(b <= e);
-    for (; b != e; ++b)
+    while (!r.empty)
     {
-        --e;
-        if (b == e) break;
-        iterSwap(b, e);
+        swap(r.front, r.back);
+        r.popFront;
+        if (r.empty) break;
+        r.popBack;
     }
 }
 
@@ -1803,21 +2317,65 @@
     assert(range == [3, 2, 1]);
 }
 
-// rotate
+// bringToFront
 /**
-Rotates the range $(D r = [first, last$(RPAREN)) such that the slice
-$(D [middle, last$(RPAREN)) gets moved in front of the slice $(D
-[first, middle$(RPAREN)). Performs $(BIGOH r.length) evaluations of
-$(D iterSwap). See also $(WEB sgi.com/tech/stl/_rotate.html, STL's
-rotate).
+The $(D bringToFront) function has considerable flexibility and
+usefulness. It can rotate elements in one buffer left or right, swap
+buffers of equal length, and even move elements across disjoint
+buffers of different types and different lengths.
+
+$(D bringToFront) takes two ranges $(D front) and $(D back), which may
+be of different types. Considering the concatenation of $(D front) and
+$(D back) one unified range, $(D bringToFront) rotates that unified
+range such that all elements in $(D back) are brought to the beginning
+of the unified range. The relative ordering of elements in $(D front)
+and $(D back), respectively, remains unchanged.
+
+The simplest use of $(D bringToFront) is for rotating elements in a
+buffer. For example:
+
+----
+auto arr = [4, 5, 6, 7, 1, 2, 3];
+bringToFront(arr[0 .. 4], arr[4 .. $]);
+assert(arr == [ 1, 2, 3, 4, 5, 6, 7 ]);
+----
+
+The $(D front) range may actually "step over" the $(D back)
+range. This is very useful with forward ranges that cannot compute
+comfortably right-bounded subranges like $(D arr[0 .. 4]) above. In
+the example below, $(D list1) is a right subrange of $(D list).
+
+----
+auto list = SList!(int)(4, 5, 6, 7, 1, 2, 3);
+auto list1 = list.drop(4);
+assert(equal(list1, [ 1, 2, 3 ][]));
+bringToFront(list, list1);
+assert(equal(list, [ 1, 2, 3, 4, 5, 6, 7 ][]));
+----
+
+Elements can be swapped across ranges of different types:
+
+----
+auto list = SList!(int)(4, 5, 6, 7);
+auto vec = [ 1, 2, 3 ];
+bringToFront(list, vec);
+assert(equal(list, [ 1, 2, 3, 4 ][]));
+assert(equal(vec, [ 5, 6, 7 ][]));
+----
+
+Performs $(BIGOH max(front.length, back.length)) evaluations of $(D
+swap). See also $(WEB sgi.com/tech/stl/_rotate.html, STL's rotate).
 
 Preconditions:
 
-$(D first <= middle && middle <= last);
+Either $(D front) and $(D back) are disjoint, or $(D back) is
+reachable from $(D front) and $(D front) is not reachable from $(D
+back).
 
 Returns:
 
-The position in which $(D first) has been rotated.
+The number of elements brought to the front, i.e., the length of $(D
+back).
 
 Example:
 
@@ -1828,69 +2386,100 @@
 assert(arr == [ 1, 2, 3, 4, 5, 6, 7 ]);
 ----
 */
-It rotate(alias iterSwap = .iterSwap, Range, It)(Range r, It middle)
+size_t bringToFront(Range1, Range2)(Range1 front, Range2 back)
+    if (isForwardRange!(Range1) && isForwardRange!(Range2))
 {
-    auto first = begin(r), last = end(r);
-    if (first == middle) return last;
-    if (last == middle) return first;
-
-    auto first2 = middle;
-    do
+    enum bool sameHeadExists = is(typeof(front.sameHead(back)));
+    size_t result;
+    for (;;)
     {
-        iterSwap(first, first2);
-        ++first;
-        ++first2;
-        if (first == middle)
-            middle = first2;
+        if (back.empty || front.empty) return result;
+        static if (sameHeadExists)
+            if (front.sameHead(back)) return result;
+        
+        auto front2 = front;
+        auto back2 = back;
+
+        for (;;)
+        {
+            swap(front2.front, back2.front);
+        
+            front2.popFront;
+            back2.popFront;
+            ++result;
+            bool leftShorter = front2.empty;
+            static if (sameHeadExists)
+                if (!leftShorter)
+                    leftShorter = front2.sameHead(back);
+            if (leftShorter)
+            {
+                // Left side was shorter than the right one
+                static if (is(Range1 == Range2))
+                {
+                    front = back;
+                    back = back2;
+                    break;
+                }
+                else
+                {
+                    return result + bringToFront(back, back2);
+                }
+            }
+            if (back2.empty)
+            {
+                // Right side was shorter than the left one
+                front = front2;
+                break;
+                ///*return*/ bringToFront(front2, back);
+                //return front2;
+            }
+        }
     }
-    while (first2 != last);
-
-    auto newMiddle = first;
-    first2 = middle;
-
-    while (first2 != last) {
-        iterSwap(first, first2);
-        ++first;
-        ++first2;
-        if (first == middle)
-            middle = first2;
-        else if (first2 == last)
-            first2 = middle;
-    }
-
-    return newMiddle;
 }
 
 unittest
 {
-    // doc example
-    auto arr = [4, 5, 6, 7, 1, 2, 3];
-    auto p = rotate(arr, arr.ptr + 4);
-    assert(p - arr.ptr == 3);
+    // // doc example
+    int[] arr = [4, 5, 6, 7, 1, 2, 3];
+    // auto p = rotate(arr, arr.ptr + 4);
+    auto p = bringToFront(arr[0 .. 4], arr[4 .. $]);
+    //assert(p - arr.ptr == 3);
+    assert(arr == [ 1, 2, 3, 4, 5, 6, 7 ], text(arr));
+    //assert(p is arr[3 .. $], text(p));
+
+    // // The signature taking range and mid
+    arr[] = [4, 5, 6, 7, 1, 2, 3];
+    // p = rotate(arr, arr.ptr + 4);
+    p = bringToFront(arr, arr[4 .. $]);
+    //assert(p - arr.ptr == 3);
+    //assert(p is arr[3 .. $]);
     assert(arr == [ 1, 2, 3, 4, 5, 6, 7 ]);
 
-    // The signature taking range and mid
-    arr[] = [4, 5, 6, 7, 1, 2, 3];
-    p = rotate(arr, arr.ptr + 4);
-    assert(p - arr.ptr == 3);
-    assert(arr == [ 1, 2, 3, 4, 5, 6, 7 ]);
-
-    // a more elaborate test
+    // // a more elaborate test
     auto rnd = Random(unpredictableSeed);
-    int[] a = new int[uniform!(int)(rnd, 100, 200)];
-    int[] b = new int[uniform!(int)(rnd, 100, 200)];
-    foreach (ref e; a) e = uniform!(int)(rnd, -100, 100);
-    foreach (ref e; b) e = uniform!(int)(rnd, -100, 100);
+    int[] a = new int[uniform(100, 200, rnd)];
+    int[] b = new int[uniform(100, 200, rnd)];
+    foreach (ref e; a) e = uniform(-100, 100, rnd);
+    foreach (ref e; b) e = uniform(-100, 100, rnd);
     int[] c = a ~ b;
-    auto n = rotate(c, c.ptr + a.length);
-    assert(n == c.ptr + b.length);
+    // auto n = rotate(c, c.ptr + a.length);
+    auto n = bringToFront(c, c[a.length .. $]);
+    // assert(n == c.ptr + b.length);
+    //assert(n is c[b.length .. $]);
     assert(c == b ~ a);
 
-    // test with custom iterSwap
-    bool called;
-    void mySwap(int* a, int* b) { iterSwap(a, b); called = true; }
-    rotate!(mySwap)(c, c.ptr + a.length);
-    assert(called);
+    // test with a SList
+    auto lst = SListRange!(int)(1, 2, 3, 4, 5);
+    assert(equal(lst, [1, 2, 3, 4, 5][]));
+    auto lst1 = lst; lst1.popFront; lst1.popFront;
+    assert(equal(lst1, [3, 4, 5][]));
+    auto m = bringToFront(lst, lst1);
+    //assert(equal(m, [1, 2][]));
+    assert(equal(lst, [3, 4, 5, 1, 2][]));
+    arr = [ 6, 7, 8 ];
+    bringToFront(lst, arr);
+    assert(equal(lst, [6, 7, 8, 3, 4 ][]));
+    assert(equal(arr, [5, 1, 2][]));
 }
 
 // SwapStrategy
@@ -1944,8 +2533,320 @@
     stable,     
 }
 
+/**
+Eliminates elements at given offsets from $(D range) and returns the
+shortened range. In the simplest call, one element is removed.
+
+----
+int[] a = [ 3, 5, 7, 8 ];
+assert(remove(a, 1) == [ 3, 7, 8 ]);
+assert(a == [ 3, 7, 8, 8 ]);
+----
+
+In the case above the element at offset $(D 1) is removed and $(D
+remove) returns the range smaller by one element. The original array
+has remained of the same length because all functions in $(D
+std.algorithm) only change $(I content), not $(I topology). The value
+$(D 8) is repeated because $(XREF algorithm, move) was invoked to move
+elements around and on integers $(D move) simply copies the source to
+the destination. To replace $(D a) with the effect of the removal,
+simply assign $(D a = remove(a, 1)). The slice will be rebound to the
+shorter array and the operation completes with maximal efficiency.
+
+Multiple indices can be passed into $(D remove). In that case,
+elements at the respective indices are all removed. The indices must
+be passed in increasing order, otherwise an exception occurs.
+
+----
+int[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
+assert(remove(a, 1, 3, 5) ==
+    [ 0, 2, 4, 6, 7, 8, 9, 10 ]);
+----
+
+(Note how all indices refer to slots in the $(I original) array, not
+in the array as it is being progressively shortened.) Finally, any
+combination of integral offsets and tuples composed of two integral
+offsets can be passed in.
+
+----
+int[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
+assert(remove(a, 1, tuple(3, 5), 9) == [ 0, 2, 6, 7, 8, 10 ]);
+----
+
+In this case, the slots at positions 1, 3, 4, and 9 are removed from
+the array. The tuple passes in a range closed to the left and open to
+the right (consistent with built-in slices), e.g. $(D tuple(3, 5))
+means indices $(D 3) and $(D 4) but not $(D 5).
+
+If the need is to remove some elements in the range but the order of
+the remaining elements does not have to be preserved, you may want to
+pass $(D SwapStrategy.unstable) to $(D remove).
+
+----
+int[] a = [ 0, 1, 2, 3 ];
+assert(remove!(SwapStrategy.unstable)(a, 1) == [ 0, 3, 2 ]);
+----
+
+In the case above, the element at slot $(D 1) is removed, but replaced
+with the last element of the range. Taking advantage of the relaxation
+of the stability requirement, $(D remove) moved elements from the end
+of the array over the slots to be removed. This way there is less data
+movement to be done which improves the execution time of the function.
+
+The function $(D remove) works on any forward range. The moving
+strategy is (listed from fastest to slowest): $(UL $(LI If $(D s ==
+SwapStrategy.unstable && isRandomAccessRange!Range &&
+hasLength!Range), then elements are moved from the end of the range
+into the slots to be filled. In this case, the absolute minimum of
+moves is performed.)  $(LI Otherwise, if $(D s ==
+SwapStrategy.unstable && isBidirectionalRange!Range &&
+hasLength!Range), then elements are still moved from the end of the
+range, but time is spent on advancing between slots by repeated calls
+to $(D range.popFront).)  $(LI Otherwise, elements are moved incrementally
+towards the front of $(D range); a given element is never moved
+several times, but more elements are moved than in the previous
+cases.))
+ */
+Range remove
+(SwapStrategy s = SwapStrategy.stable, Range, Offset...)
+(Range range, Offset offset)
+if (isBidirectionalRange!Range && hasLength!Range && s != SwapStrategy.stable)
+{
+    enum bool tupleLeft = is(typeof(offset[0].field[0]))
+        && is(typeof(offset[0].field[1]));
+    enum bool tupleRight = is(typeof(offset[$ - 1].field[0]))
+        && is(typeof(offset[$ - 1].field[1]));
+    static if (!tupleLeft)
+    {
+        alias offset[0] lStart;
+        auto lEnd = lStart + 1;
+    }
+    else
+    {
+        auto lStart = offset[0].field[0];
+        auto lEnd = offset[0].field[1];
+    }
+    static if (!tupleRight)
+    {
+        alias offset[$ - 1] rStart;
+        auto rEnd = rStart + 1;
+    }
+    else
+    {
+        auto rStart = offset[$ - 1].field[0];
+        auto rEnd = offset[$ - 1].field[1];
+    }
+    // Begin. Test first to see if we need to remove the rightmost
+    // element(s) in the range. In that case, life is simple - chop
+    // and recurse.
+    if (rEnd == range.length)
+    {
+        // must remove the last elements of the range
+        range.retreatN(rEnd - rStart);
+        static if (Offset.length > 1)
+        {
+            return .remove!(s, Range, Offset[0 .. $ - 1])
+                (range, offset[0 .. $ - 1]);
+        }
+        else
+        {
+            return range;
+        }
+    }
+    
+    // Ok, there are "live" elements at the end of the range
+    auto t = range;
+    auto lDelta = lEnd - lStart, rDelta = rEnd - rStart;
+    auto rid = min(lDelta, rDelta);
+    foreach (i; 0 .. rid)
+    {
+        move(range.back, t.front);
+        range.popBack;
+        t.popFront;
+    }
+    if (rEnd - rStart == lEnd - lStart)
+    {
+        // We got rid of both left and right
+        static if (Offset.length > 2)
+        {
+            return .remove!(s, Range, Offset[1 .. $ - 1])
+                (range, offset[1 .. $ - 1]);
+        }
+        else
+        {
+            return range;
+        }
+    }
+    else if (rEnd - rStart < lEnd - lStart)
+    {
+        // We got rid of the entire right subrange
+        static if (Offset.length > 2)
+        {
+            return .remove!(s, Range)
+                (range, tuple(lStart + rid, lEnd),
+                        offset[1 .. $ - 1]);
+        }
+        else
+        {
+            auto tmp = tuple(lStart + rid, lEnd);
+            return .remove!(s, Range, typeof(tmp))
+                (range, tmp);
+        }
+    }
+    else
+    {
+        // We got rid of the entire left subrange
+        static if (Offset.length > 2)
+        {
+            return .remove!(s, Range)
+                (range, offset[1 .. $ - 1],
+                        tuple(rStart, lEnd - rid));
+        }
+        else
+        {
+            auto tmp = tuple(rStart, lEnd - rid);
+            return .remove!(s, Range, typeof(tmp))
+                (range, tmp);
+        }
+    }
+}
+
+// Ditto
+Range remove
+(SwapStrategy s = SwapStrategy.stable, Range, Offset...)
+(Range range, Offset offset)
+if (isForwardRange!Range && !isBidirectionalRange!Range
+        || !hasLength!Range || s == SwapStrategy.stable)
+{
+    auto result = range;
+    auto src = range, tgt = range;
+    size_t pos;
+    foreach (i; offset)
+    {
+        static if (is(typeof(i.field[0])) && is(typeof(i.field[1])))
+        {
+            auto from = i.field[0], delta = i.field[1] - i.field[0];
+        }
+        else
+        {
+            auto from = i;
+            enum delta = 1;
+        }
+        assert(pos <= from);
+        for (; pos < from; ++pos, src.popFront, tgt.popFront)
+        {
+            move(src.front, tgt.front);
+        }
+        // now skip source to the "to" position
+        src.advance(delta);
+        pos += delta;
+        foreach (j; 0 .. delta) result.popBack;
+    }
+    // leftover move
+    moveAll(src, tgt);
+    return result;
+}
+
+unittest
+{
+    int[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
+    //writeln(remove!(SwapStrategy.stable)(a, 1));
+    a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
+    assert(remove!(SwapStrategy.stable)(a, 1) ==
+        [ 0, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);
+
+    a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
+    assert(remove!(SwapStrategy.unstable)(a, 0, 10) ==
+            [ 9, 1, 2, 3, 4, 5, 6, 7, 8 ]);
+
+    a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
+    assert(remove!(SwapStrategy.unstable)(a, 0, tuple(9, 11)) ==
+            [ 8, 1, 2, 3, 4, 5, 6, 7 ]);
+
+    a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
+    //writeln(remove!(SwapStrategy.stable)(a, 1, 5));
+    a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
+    assert(remove!(SwapStrategy.stable)(a, 1, 5) ==
+        [ 0, 2, 3, 4, 6, 7, 8, 9, 10 ]);
+
+    a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
+    //writeln(remove!(SwapStrategy.stable)(a, 1, 3, 5));
+    a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
+    assert(remove!(SwapStrategy.stable)(a, 1, 3, 5)
+            == [ 0, 2, 4, 6, 7, 8, 9, 10]);
+    a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
+    //writeln(remove!(SwapStrategy.stable)(a, 1, tuple(3, 5)));
+    a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
+    assert(remove!(SwapStrategy.stable)(a, 1, tuple(3, 5))
+            == [ 0, 2, 5, 6, 7, 8, 9, 10]);
+}
+
+/**
+Reduces the length of the bidirectional range $(D range) by only
+keeping elements that satisfy $(D pred). If $(s =
+SwapStrategy.unstable), elements are moved from the right end of the
+range over the elements to eliminate. If $(D s = SwapStrategy.stable)
+(the default), elements are moved progressively to front such that
+their relative order is preserved. Returns the tail portion of the
+range that was moved.
+
+Example:
+----
+int[] a = [ 1, 2, 3, 2, 3, 4, 5, 2, 5, 6 ];
+assert(a[0 .. $ - remove!("a == 2")(a).length] == [ 1, 3, 3, 4, 5, 5, 6 ]);
+----
+ */
+Range remove(alias pred, SwapStrategy s = SwapStrategy.stable, Range)
+(Range range)
+if (isBidirectionalRange!Range)
+{
+    auto result = range;
+    static if (s != SwapStrategy.stable)
+    {
+        for (;!range.empty;)
+        {
+            if (!unaryFun!(pred)(range.front))
+            {
+                range.popFront;
+                continue;
+            }
+            move(range.back, range.front);
+            range.popBack;
+            result.popBack;
+        }
+    }
+    else
+    {
+        auto tgt = range;
+        for (; !range.empty; range.popFront)
+        {
+            if (unaryFun!(pred)(range.front))
+            {
+                // yank this guy
+                result.popBack;
+                continue;
+            }
+            // keep this guy
+            move(range.front, tgt.front);
+            tgt.popFront;
+        }
+    }
+    return result;
+}
+
+unittest
+{
+    int[] a = [ 1, 2, 3, 2, 3, 4, 5, 2, 5, 6 ];
+    assert(remove!("a == 2", SwapStrategy.unstable)(a) ==
+            [ 1, 6, 3, 5, 3, 4, 5 ]);
+    a = [ 1, 2, 3, 2, 3, 4, 5, 2, 5, 6 ];
+    //writeln(remove!("a != 2", SwapStrategy.stable)(a));
+    assert(remove!("a == 2", SwapStrategy.stable)(a) ==
+            [ 1, 3, 3, 4, 5, 5, 6 ]);
+}
+
 // eliminate
-/**
+/* *
 Reduces $(D r) by overwriting all elements $(D x) that satisfy $(D
 pred(x)). Returns the reduced range.
 
@@ -1958,25 +2859,25 @@
 assert(arr == [ 1, 3, 5, 4, 5 ]);
 ----
 */
-Range eliminate(alias pred,
-                SwapStrategy ss = SwapStrategy.unstable,
-                alias move = .move,
-                Range)(Range r)
-{
-    alias Iterator!(Range) It;
-    static void assignIter(It a, It b) { move(*b, *a); }
-    return range(begin(r), partition!(not!(pred), ss, assignIter, Range)(r));
-}
-
-unittest
-{
-    int[] arr = [ 1, 2, 3, 4, 5 ];
-// eliminate even elements
-    auto r = eliminate!("(a & 1) == 0")(arr);
-    assert(find!("(a & 1) == 0")(r) == end(r));
-}
-
-/**
+// Range eliminate(alias pred,
+//                 SwapStrategy ss = SwapStrategy.unstable,
+//                 alias move = .move,
+//                 Range)(Range r)
+// {
+//     alias Iterator!(Range) It;
+//     static void assignIter(It a, It b) { move(*b, *a); }
+//     return range(begin(r), partitionold!(not!(pred), ss, assignIter, Range)(r));
+// }
+
+// unittest
+// {
+//     int[] arr = [ 1, 2, 3, 4, 5 ];
+// // eliminate even elements
+//     auto r = eliminate!("(a & 1) == 0")(arr);
+//     assert(find!("(a & 1) == 0")(r).empty);
+// }
+
+/* *
 Reduces $(D r) by overwriting all elements $(D x) that satisfy $(D
 pred(x, v)). Returns the reduced range.
 
@@ -1989,61 +2890,48 @@
 assert(arr == [ 1, 3, 4, 5, 4, 5, 2  ]);
 ----
 */
-Range eliminate(alias pred = "a == b",
-                SwapStrategy ss = SwapStrategy.semistable,
-                Range, Value)(Range r, Value v)
-{
-    alias Iterator!(Range) It;
-    bool comp(typeof(*It) a) { return !binaryFun!(pred)(a, v); }
-    static void assignIterB(It a, It b) { *a = *b; }
-    return range(begin(r), 
-            partition!(comp,
-                    ss, assignIterB, Range)(r));
-}
-
-unittest
-{
-    int[] arr = [ 1, 2, 3, 2, 4, 5, 2 ];
-// keep elements different from 2
-    auto r = eliminate(arr, 2);
-    assert(r == [ 1, 3, 4, 5 ]);
-    assert(arr == [ 1, 3, 4, 5, 4, 5, 2  ]);
-}
+// Range eliminate(alias pred = "a == b",
+//                 SwapStrategy ss = SwapStrategy.semistable,
+//                 Range, Value)(Range r, Value v)
+// {
+//     alias Iterator!(Range) It;
+//     bool comp(typeof(*It) a) { return !binaryFun!(pred)(a, v); }
+//     static void assignIterB(It a, It b) { *a = *b; }
+//     return range(begin(r), 
+//             partitionold!(comp,
+//                     ss, assignIterB, Range)(r));
+// }
+
+// unittest
+// {
+//     int[] arr = [ 1, 2, 3, 2, 4, 5, 2 ];
+// // keep elements different from 2
+//     auto r = eliminate(arr, 2);
+//     assert(r == [ 1, 3, 4, 5 ]);
+//     assert(arr == [ 1, 3, 4, 5, 4, 5, 2  ]);
+// }
 
 // partition
 /**
-Partitions a range in two using $(D pred) as a predicate and $(D
-iterSwap) as a primitive to swap two elements. Specifically, reorders
-the range $(D r = [left, right$(RPAREN)) using $(D iterSwap) such that
-all elements $(D i) for which $(D pred(i)) is $(D true) come before
-all elements $(D j) for which $(D pred(j)) returns $(D false).
+Partitions a range in two using $(D pred) as a
+predicate. Specifically, reorders the range $(D r = [left,
+right$(RPAREN)) using $(D swap) such that all elements $(D i) for
+which $(D pred(i)) is $(D true) come before all elements $(D j) for
+which $(D pred(j)) returns $(D false).
 
 Performs $(BIGOH r.length) (if unstable or semistable) or $(BIGOH
 r.length * log(r.length)) (if stable) evaluations of $(D less) and $(D
-iterSwap). The unstable version computes the minimum possible
-evaluations of $(D iterSwap) (roughly half of those performed by the
-semistable version).
-
-$(D partition) always calls $(D iterSwap(i, j)) for iterators
-satisfying $(D i < j && !pred(*i) && pred(*j)). After the call to $(D
-iterSwap(i, j)), $(D partition) makes no assumption on the values of
-$(D *i) and $(D *j). Therefore, $(D partition) can be used to actually
-copy partitioned data to a different container or overwrite part of
-the array (in fact $(D eliminate) uses $(D partition) with a custom
-$(D iterSwap)).
+swap). The unstable version computes the minimum possible evaluations
+of $(D swap) (roughly half of those performed by the semistable
+version).
 
 See also STL's $(WEB sgi.com/tech/stl/_partition.html, partition) and
 $(WEB sgi.com/tech/stl/stable_partition.html, stable_partition).
 
 Returns:
 
-An iterator $(D p) such that the following conditions are
-simultaneously true:
-$(OL
-$(LI $(D pred(*p1)) for all $(D p1) in [$(D left),
-$(D p)$(RPAREN), if any)
-$(LI $(D !pred(*p2)) for all $(D p2) in [$(D p),
-$(D right)$(RPAREN), if any))
+The right part of $(D r) after partitioning.
+
 If $(D ss == SwapStrategy.stable), $(D partition) preserves the
 relative ordering of all elements $(D a), $(D b) in $(D r) for which
 $(D pred(a) == pred(b)). If $(D ss == SwapStrategy.semistable), $(D
@@ -2086,46 +2974,44 @@
 assert(arr == [4, 5, 6, 7, 8, 9, 10, 2, 3, 1] && p == arr.ptr + 7);
 ----
 */
-Iterator!(Range) partition(alias predOrStr,
-                           SwapStrategy ss = SwapStrategy.unstable,
-                           alias iterSwap = .iterSwap, Range)(Range r)
+Range partition(alias predicate,
+        SwapStrategy ss = SwapStrategy.unstable, Range)(Range r)
+    if ((ss == SwapStrategy.stable && isRandomAccessRange!(Range))
+            || (ss != SwapStrategy.stable && isForwardRange!(Range)))
 {
-    alias unaryFun!(predOrStr) pred;
-    typeof(return) result = void;
-    auto left = begin(r), right = end(r);
-    if (left == right) return left;
+    alias unaryFun!(predicate) pred;
+    if (r.empty) return r;
     static if (ss == SwapStrategy.stable)
     {
-        if (right - left == 1)
+        if (r.length == 1)
         {
-            result = pred(*left) ? right : left;
-            return result;
+            if (pred(r.front)) r.popFront;
+            return r;
         }
-        auto middle = left + (right - left) / 2;
-        alias .partition!(pred, ss, iterSwap, Range) recurse;
-        auto lower = recurse(range(left, middle));
-        auto upper = recurse(range(middle, right));
-        result = rotate!(iterSwap, Range, Iterator!(Range))(
-            range(lower, upper), middle);
+        const middle = r.length / 2;
+        alias .partition!(pred, ss, Range) recurse;
+        auto lower = recurse(r[0 .. middle]);
+        auto upper = recurse(r[middle .. $]);
+        bringToFront(lower, r[middle .. $ - upper.length]);
+        return r[$ - lower.length - upper.length .. $];
     }
     else static if (ss == SwapStrategy.semistable)
     {
-        result = right;
-        auto i = left;
-        for (; i != right; ++i)
+        for (; !r.empty; r.popFront)
         {
             // skip the initial portion of "correct" elements
-            if (pred(*i)) continue;
+            if (pred(r.front)) continue;
             // hit the first "bad" element
-            result = i;
-            for (++i; i != right; ++i)
+            auto result = r;
+            for (r.popFront; !r.empty; r.popFront)
             {
-                if (!pred(*i)) continue;
-                iterSwap(result, i);
-                ++result;
+                if (!pred(r.front)) continue;
+                swap(result.front, r.front);
+                result.popFront;
             }
-            break;
+            return result;
         }
+        return r;
     }
     else // ss == SwapStrategy.unstable
     {
@@ -2135,57 +3021,61 @@
         {
             for (;;)
             {
-                if (left == right) return left;
-                if (!pred(*left)) break;
-                ++left;
+                if (r.empty) return r;
+                if (!pred(r.front)) break;
+                r.popFront;
             }
             // found the left bound
-            assert(left != right);
+            assert(!r.empty);
+            auto r1 = r;
             for (;;)
             {
-                --right;
-                if (left == right) return left;
-                if (pred(*right)) break;
+                if (pred(r1.back)) break;
+                r1.popBack;
+                if (r1.empty) return r;
             }
             // found the right bound, swap & make progress
-            iterSwap(left, right);
-            ++left;
+            swap(r.front, r1.back);
+            r.popFront;
+            r1.popBack;
         }
-        result = left;
     }
-    return result;
 }
 
-unittest // partition
+unittest // partitionold
 {
     auto Arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
     auto arr = Arr.dup;
     static bool even(int a) { return (a & 1) == 0; }
-// Partition a such that even numbers come first
-    auto p = partition!(even)(arr);
+// Partitionold a such that even numbers come first
+    //auto p = partitionold!(even)(arr);
+    auto p1 = partition!(even)(arr);
 // Now arr is separated in evens and odds.
-    assert(p == arr.ptr + 5);
-    assert(count!(even)(range(begin(arr), p)) == p - begin(arr));
-    assert(find!(even)(range(p, end(arr))) == end(arr));
+    //assert(p == arr.ptr + 5);
+    assert(p1 == arr[5 .. $], text(p1));
+    //assert(count!(even)(range(begin(arr), p)) == p - begin(arr));
+    assert(count!(even)(arr[0 .. $ - p1.length]) == p1.length);
+    assert(find!(even)(p1).empty);
 // Notice that numbers have become shuffled due to instability
     arr[] = Arr[];
 // Can also specify the predicate as a string.
 // Use 'a' as the predicate argument name
-    p = partition!(q{(a & 1) == 0})(arr);
-    assert(p == arr.ptr + 5);
-// Same result as above. Now for a stable partition:
+    p1 = partition!(q{(a & 1) == 0})(arr);
+    assert(p1 == arr[5 .. $]);
+// Same result as above. Now for a stable partitionold:
     arr[] = Arr[];
-    p = partition!(q{(a & 1) == 0}, SwapStrategy.stable)(arr);
+    p1 = partition!(q{(a & 1) == 0}, SwapStrategy.stable)(arr);
 // Now arr is [2 4 6 8 10 1 3 5 7 9], and p points to 1
-    assert(arr == [2, 4, 6, 8, 10, 1, 3, 5, 7, 9] && p == arr.ptr + 5);
+    assert(arr == [2, 4, 6, 8, 10, 1, 3, 5, 7, 9], text(arr));
+    assert(p1 == arr[5 .. $], text(p1));
 // In case the predicate needs to hold its own state, use a delegate:
     arr[] = Arr[];
     int x = 3;
 // Put stuff greater than 3 on the left
     bool fun(int a) { return a > x; }
-    p = partition!(fun, SwapStrategy.semistable)(arr);
+    p1 = partition!(fun, SwapStrategy.semistable)(arr);
 // Now arr is [4 5 6 7 8 9 10 2 3 1] and p points to 2
-    assert(arr == [4, 5, 6, 7, 8, 9, 10, 2, 3, 1] && p == arr.ptr + 7);
+    assert(arr == [4, 5, 6, 7, 8, 9, 10, 2, 3, 1] && p1 == arr[7 .. $]);
 
     // test with random data
     auto a = rndstuff!(int)();
@@ -2196,140 +3086,59 @@
     assert(isPartitioned!(`a.length < 5`)(b));
 }
 
-// // partitionPivot
-// /**
-// Partitions $(D r) algorithm around a pivot
-// $(D m). Specifically, reorders the range $(D r = left ..  right) such
-// that elements less than $(D *m) are on the left and elements greater
-// than or equal to $(D *m) are on the right, then returns an iterator
-// pointing to the first element in the second partition. Performs
-// $(BIGOH r.length) (if unstable or semistable) or $(BIGOH r.length *
-// log(r.length)) (if stable) evaluations of $(D less) and $(D iterSwap).
-
-// Precondition:
-
-// $(D left <= pivot && pivot < right).
-
-// Returns:
-
-// Let $(D pivotVal) be $(D *pivot) before the
-// call. The result of $(D partitionPivot) is a value $(D
-// mid) such that:
-// $(OL
-// $(LI $(D less(*p1, pivotVal)) for all $(D p1) in
-// [$(D left), $(D mid)$(RPAREN))
-// $(LI $(D !less(*p2, pivotVal)) for all $(D p2) in [$(D mid), $(D right)$(RPAREN)))
-// For the unstable and semistable partitions, the following condition
-// also holds: $(D *mid == pivotVal).
-// */
-// It partitionPivot(alias less,
-//                  SwapStrategy ss = SwapStrategy.unstable,
-//                  alias iterSwap = .iterSwap, Range, It)(Range r, It m)
-// {
-//     auto b = begin(r), e = end(r);
-//     if (b == e) return b;
-//     assert(b <= m && m < e);
-//     alias typeof(*b) E;
-//     static if (ss == SwapStrategy.unstable)
-//     {
-//         --e;
-//         // swap the pivot to end
-//         iterSwap(m, e);
-//         // partition on predicate
-//         auto pivotCached = *e;
-//         bool pred(E a) { return less(a, pivotCached); }
-//         auto result = partition!(pred, ss, iterSwap)(range(b, e));
-//         // swap back
-//         iterSwap(result, e);
-//     }
-//     else
-//     {
-//         // copy the pivot so it's not messed up
-//         auto pivot = *m;
-//         bool pred(E a) { return less(a, pivot); }
-//         auto result = partition!(pred, ss, iterSwap)(r);
-//     }
-//     return result;
-// }
-
-// /// Ditto
-// It partitionPivot(string less = q{a < b},
-//                  SwapStrategy ss = SwapStrategy.unstable,
-//                  alias iterSwap = .iterSwap, Range, It)(Range r, It m)
-// {
-//     return .partitionPivot!(binaryFun!(less), ss, iterSwap, Range, It)(r, m);
-// }
-
-// version (wyda) unittest
-// {
-//     auto a = [3, 3, 2];
-//     bool less(int a, int b) { return a < b; }
-//     auto p = partitionPivot!(less)(a, a.ptr);
-//     assert(p == a.ptr + 1 && a == [2, 3, 3]);
-//     // Use default less
-//     a[] = [3, 3, 2];
-//     p = partitionPivot(a, a.ptr);
-//     assert(p == a.ptr + 1 && a == [2, 3, 3]);
-
-//     // test with random data
-//     // @@@BUG@@@ The whole type tuple should work
-//     foreach (T; TypeTuple!(int/*, double, string*/))
-//     {{
-//         auto i = rndstuff!(T)();
-//         if (!i.length) continue;
-//         auto pivot = i[0];
-//         partitionPivot!(`a > b`)(i, begin(i));
-//         bool pred2(int a) { return a > pivot; }
-//         assert(isPartitioned!(pred2)(i));
-//     }}
-// }
-
-template isPartitioned(alias pred)
+/**
+Returns $(D true) if $(D r) is partitioned according to predicate $(D
+pred).
+
+Example:
+----
+int[] r = [ 1, 3, 5, 7, 8, 2, 4, ];
+assert(isPartitioned!("a & 1")(r));
+----
+ */
+bool isPartitioned(alias pred, Range)(Range r)
+    if (isForwardRange!(Range))
 {
-    bool isPartitioned(T)(T range)
+    for (; !r.empty; r.popFront)
     {
-        auto left = begin(range), right = end(range);
-        if (left == right) return true;
-        for (; left != right; ++left)
+        if (unaryFun!(pred)(r.front)) continue;
+        for (r.popFront; !r.empty; r.popFront)
         {
-            if (!pred(*left)) break;
+            if (unaryFun!(pred)(r.front)) return false;
         }
-        for (; left != right; ++left)
-        {
-            if (pred(*left)) return false;
-        }
-        return true;
+        break;
     }
+    return true;
 }
 
-template isPartitioned(string pred)
+unittest
 {
-    alias .isPartitioned!(unaryFun!(pred)) isPartitioned;
+    int[] r = [ 1, 3, 5, 7, 8, 2, 4, ];
+    assert(isPartitioned!("a & 1")(r));
 }
 
 // topN
 /**
-Reorders the range $(D r = [first, last$(RPAREN)) using $(D iterSwap)
-as a swapping primitive such that $(D nth) points to the element that
-would fall there if the range were fully sorted. Effectively, it finds
-the nth smallest (according to $(D less)) element in $(D r). In
-addition, it also partitions $(D r) such that all elements $(D p1) in
-$(D [first, nth$(RPAREN)) satisfy $(D less(*p1, *nth)), and all
-elements $(D p2) in $(D [nth, last$(RPAREN)) satisfy $(D !less(*p2,
-nth)). Performs $(BIGOH r.length) (if unstable) or $(BIGOH r.length *
-log(r.length)) (if stable) evaluations of $(D less) and $(D
-iterSwap). See also $(WEB sgi.com/tech/stl/nth_element.html, STL's
-nth_element).
+Reorders the range $(D r = [first, last$(RPAREN)) using $(D swap) such
+that $(D nth) points to the element that would fall there if the range
+were fully sorted. Effectively, it finds the nth smallest (according
+to $(D less)) element in $(D r). In addition, it also partitions $(D
+r) such that all elements $(D p1) in $(D [first, nth$(RPAREN)) satisfy
+$(D less(*p1, *nth)), and all elements $(D p2) in $(D [nth,
+last$(RPAREN)) satisfy $(D !less(*p2, nth)). Performs $(BIGOH
+r.length) (if unstable) or $(BIGOH r.length * log(r.length)) (if
+stable) evaluations of $(D less) and $(D swap). See also $(WEB
+sgi.com/tech/stl/nth_element.html, STL's nth_element).
 
 Example:
 
 ----
 int[] v = [ 25, 7, 9, 2, 0, 5, 21 ];
 auto n = 4;
-topN!(less)(v, begin(v) + n);
+topN!(less)(v, n);
 assert(v[n] == 9);
 // Equivalent form:
-topN!("a < b")(v, begin(v) + n);
+topN!("a < b")(v, n);
 assert(v[n] == 9);
 ----
 
@@ -2338,58 +3147,56 @@
 Stable topN has not been implemented yet.
 */
 void topN(alias less = "a < b",
-                SwapStrategy ss = SwapStrategy.unstable,
-                alias iterSwap = .iterSwap, Range, It)(Range r, It nth)
+        SwapStrategy ss = SwapStrategy.unstable,
+        Range)(Range r, size_t nth)
+    if (isRandomAccessRange!(Range))
 {
     static assert(ss == SwapStrategy.unstable,
-                  "stable topN not yet implemented");
-    auto b = begin(r), e = end(r);
-    assert(b < e);
-    assert(b <= nth && nth < e);
-    for (;;)
+            "Stable topN not yet implemented");
+    while (!r.empty)
     {
-        auto pivot = b + (e - b) / 2;
-        auto pivotVal = *pivot;
+        auto pivot = r.length / 2;
+        swap(r[pivot], r.back);
         bool pred(ElementType!(Range) a)
         {
-            return binaryFun!(less)(a, pivotVal);
+            return binaryFun!(less)(a, r.back);
         }
-        iterSwap(pivot, e - 1);
-        pivot = partition!(pred, ss, iterSwap)(range(b, e));
-        iterSwap(pivot, e - 1);
+        auto right = partition!(pred, ss)(r);
+        swap(right.front, r.back);
+        pivot = r.length - right.length;
         if (pivot == nth) return;
-        if (pivot < nth) b = pivot + 1;
-        else e = pivot;
+        if (pivot < nth) r = r[pivot + 1 .. $];
+        else r = r[0 ..pivot];
     }
 }
 
 unittest
 {
-    scope(failure) writeln(stderr, "Failure testing algorithm");
+    //scope(failure) writeln(stderr, "Failure testing algorithm");
     //auto v = ([ 25, 7, 9, 2, 0, 5, 21 ]).dup;
     int[] v = [ 7, 6, 5, 4, 3, 2, 1, 0 ];
     auto n = 3;
-    topN!("a < b")(v, v.ptr + n);
+    topN!("a < b")(v, n);
     assert(v[n] == n);
     //
     v = ([3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5]).dup;
     n = 3;
-    topN(v, v.ptr + n);
+    topN(v, n);
     assert(v[n] == 3);
     //
     v = ([3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5]).dup;
     n = 1;
-    topN(v, v.ptr + n);
+    topN(v, n);
     assert(v[n] == 2);
     //
     v = ([3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5]).dup;
     n = v.length - 1;
-    topN(v, v.ptr + n);
+    topN(v, n);
     assert(v[n] == 7);
     //
     v = ([3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5]).dup;
     n = 0;
-    topN(v, v.ptr + n);
+    topN(v, n);
     assert(v[n] == 1);
 }
 
@@ -2398,8 +3205,8 @@
 Sorts a random-access range according to predicate $(D less). Performs
 $(BIGOH r.length * log(r.length)) (if unstable) or $(BIGOH r.length *
 log(r.length) * log(r.length)) (if stable) evaluations of $(D less)
-and $(D iterSwap). See also STL's $(WEB sgi.com/tech/stl/_sort.html,
-sort) and $(WEB sgi.com/tech/stl/stable_sort.html, stable_sort).
+and $(D swap). See also STL's $(WEB sgi.com/tech/stl/_sort.html, sort)
+and $(WEB sgi.com/tech/stl/stable_sort.html, stable_sort).
 
 Example:
 
@@ -2423,17 +3230,17 @@
 */
 
 void sort(alias less = "a < b", SwapStrategy ss = SwapStrategy.unstable,
-          alias iterSwap = .iterSwap, Range)(Range r)
+        Range)(Range r)
 {
     alias binaryFun!(less) lessFun;
-    static if (is(typeof(lessFun(*begin(r), *end(r))) == bool))
+    static if (is(typeof(lessFun(r.front, r.front)) == bool))
     {
-        sortImpl!(lessFun, ss, iterSwap)(r);
+        sortImpl!(lessFun, ss)(r);
         assert(isSorted!(lessFun)(r));
     }
     else
     {
-        static assert(false, "Invalid predicate passed to sort");
+        static assert(false, "Invalid predicate passed to sort: "~less);
     }
 }
 
@@ -2443,7 +3250,7 @@
     int a[] = new int[100];
     auto rnd = Random(unpredictableSeed);
     foreach (ref e; a) {
-        e = uniform!(int)(rnd, -100, 100);
+        e = uniform(-100, 100, rnd);
     }
     
     int i = 0;
@@ -2483,106 +3290,114 @@
 
 // @@@BUG1904
 /*private*/
-Iter getPivot(alias less, Iter)(Iter b, Iter e)
+size_t getPivot(alias less, Range)(Range r)
 {
-    auto r = b + (e - b) / 2;
-    return r;
+    return r.length / 2;
 }
 
 // @@@BUG1904
 /*private*/
-void optimisticInsertionSort(alias less, alias iterSwap, Range)(Range r)
+void optimisticInsertionSort(alias less, Range)(Range r)
 {
-    auto b = begin(r), e = end(r);
-    if (e - b <= 1) return;
-    for (auto i = 1 + b; i != e; )
+    if (r.length <= 1) return;
+    for (auto i = 1; i != r.length; )
     {
         // move down to find the insertion point
         auto p = i - 1;
         for (;;)
         {
-            if (!less(*i, *p))
+            if (!less(r[i], r[p]))
             {
                 ++p;
                 break;
             }
-            if (p == b) break;
+            if (p == 0) break;
             --p;
         }
         // move up to see how many we can insert
         auto iOld = i, iPrev = i;
         ++i;
-        while (i != e && less(*i, *p) && !less(*i, *iPrev)) ++i, ++iPrev;
+        while (i != e && less(r[i], r[p]) && !less(r[i], r[iPrev]))
+        {
+            ++i;
+            ++iPrev;
+        }
         // do the insertion
-        rotate!(iterSwap)(range(p, i), iOld);
+        rotate(r[p .. i], r[iOld .. $]);
     }
 }
 
 // @@@BUG1904
 /*private*/
-void sortImpl(alias less, SwapStrategy ss, alias iterSwap, Range)(Range r)
+void sortImpl(alias less, SwapStrategy ss, Range)(Range r)
 {
     alias ElementType!(Range) Elem;
     enum uint optimisticInsertionSortGetsBetter = 1;
     static assert(optimisticInsertionSortGetsBetter >= 1);
-    auto b = begin(r), e = end(r);
-    while (e - b > optimisticInsertionSortGetsBetter)
+    
+    while (r.length > optimisticInsertionSortGetsBetter)
     {
-        auto pivotPtr = getPivot!(less)(b, e);
-        auto pivot = *pivotPtr;
+        const pivotIdx = getPivot!(less)(r);
         // partition
         static if (ss == SwapStrategy.unstable)
         {
             // partition
-            iterSwap(pivotPtr, e - 1);
-            bool pred(Elem a) { return less(a, pivot); }
-            auto mid = partition!(pred, ss, iterSwap)(range(b, e));
-            iterSwap(mid, e - 1);
+            swap(r[pivotIdx], r[r.length - 1]);
+            bool pred(ElementType!(Range) a)
+            {
+                return less(a, r[r.length - 1]);
+            }
+            auto right = partition!(pred, ss)(r);
+            swap(right.front, r.back);
             // done with partitioning
-            assert(!less(pivot, *mid) && !less(*mid, pivot));
-            if (b == mid)
+            if (r.length == right.length)
             {
                 // worst case: *b <= everything (also pivot <= everything)
                 // avoid quadratic behavior
-                do ++b; while (b != e && !less(pivot, *b));
+                do r.popFront; while (!r.empty && !less(right.front, r.front));
             }
             else
             {
-                .sortImpl!(less, ss, iterSwap, Range)(range(b, mid));
-                b = mid + 1;
+                .sortImpl!(less, ss, Range)(r[0 .. r.length - right.length]);
+                r = right[1 .. right.length];
             }
         }
         else // handle semistable and stable the same
         {
+            auto pivot = r[pivotIdx];
             static assert(ss != SwapStrategy.semistable);
             bool pred(Elem a) { return less(a, pivot); }
-            auto mid = partition!(pred, ss, iterSwap)(range(b, e));
-            if (b == mid)
+            auto right = partition!(pred, ss)(r);
+            if (r.length == right.length)
             {
                 // bad, bad pivot. pivot <= everything
                 // find the first occurrence of the pivot                
                 bool pred1(Elem a) { return !less(pivot, a); }
-                auto firstPivotPos = find!(pred1)(range(b, e));
-                assert(firstPivotPos != e);
-                assert(!less(*firstPivotPos, pivot)
-                       && !less(pivot, *firstPivotPos));
+                //auto firstPivotPos = find!(pred1)(r).ptr;
+                auto pivotSpan = find!(pred1)(r);
+                assert(!pivotSpan.empty);
+                assert(!less(pivotSpan.front, pivot)
+                       && !less(pivot, pivotSpan.front));
                 // find the last occurrence of the pivot
                 bool pred2(Elem a) { return less(pivot, a); }
-                auto lastPivotPos = find!(pred2)(range(firstPivotPos + 1, e));
+                //auto lastPivotPos = find!(pred2)(pivotsRight[1 .. $]).ptr;
+                auto pivotRunLen = find!(pred2)(pivotSpan[1 .. $]).length;
+                pivotSpan = pivotSpan[0 .. pivotRunLen + 1];
                 // now rotate firstPivotPos..lastPivotPos to the front
-                b = rotate!(iterSwap)(range(b, lastPivotPos), firstPivotPos);
+                bringToFront(r, pivotSpan);
+                r = r[pivotSpan.length .. $];
             }
             else
             {
-                .sortImpl!(less, ss, iterSwap, Range)(range(b, mid));
-                b = mid;
+                .sortImpl!(less, ss, Range)(r[0 .. r.length - right.length]);
+                r = right;
             }
         }
     }
     // residual sort
     static if (optimisticInsertionSortGetsBetter > 1)
     {
-        optimisticInsertionSort!(less, iterSwap, Range)(r);
+        optimisticInsertionSort!(less, Range)(r);
     }
 }
     
@@ -2614,26 +3429,29 @@
 present in Python and Lisp. This is because sorting is done in-place
 and only minimal extra data (one array of transformed elements) is
 created.
-*/
+
+To check whether an array was sorted and benefit of the speedup of
+Schwartz sorting, a function $(D schwartzIsSorted) is not provided
+because the effect can be achieved by calling $(D
+isSorted!(less)(map!(transform)(r))).
+ */
 void schwartzSort(alias transform, alias less = "a < b",
-                  SwapStrategy ss = SwapStrategy.unstable, Range)(Range r)
+        SwapStrategy ss = SwapStrategy.unstable, Range)(Range r)
+    if (isRandomAccessRange!(Range) && hasLength!(Range))
 {
-    alias typeof(transform(*begin(r))) XformType;
+    alias typeof(transform(r.front)) XformType;
     auto xform = new XformType[r.length];
-    alias Iterator!(XformType[]) InnerIter;
     foreach (i, e; r)
     {
         xform[i] = transform(e);
     }
-    // primitive to swap the two collections in lockstep
-    void mySwap(InnerIter a, InnerIter b)
+    auto z = zip(xform, r);
+    alias typeof(z.front()) ProxyType;
+    bool myLess(ProxyType a, ProxyType b)
     {
-        iterSwap(a, b);
-        invariant i = a - begin(xform), j = b - begin(xform);
-        assert(i >= 0 && i < xform.length && j >= 0 && j < xform.length);
-        swap(r[i], r[j]);
+        return binaryFun!(less)(a.at!(0), b.at!(0));
     }
-    sort!(less, ss, mySwap)(xform);
+    sort!(myLess)(z);
 }
 
 unittest
@@ -2643,7 +3461,7 @@
         foreach (p; probs) {
             if (!p) continue;
             //enforce(p > 0 && p <= 1, "Wrong probability passed to entropy");
-            result -= p * log(p);
+            result -= p * log2(p);
         }
         return result;
     }
@@ -2655,58 +3473,103 @@
     arr[0] = midEnt;
     arr[1] = lowEnt;
     arr[2] = highEnt;
+
     schwartzSort!(entropy, q{a < b})(arr);
     assert(arr[0] == lowEnt);
     assert(arr[1] == midEnt);
     assert(arr[2] == highEnt);
+    assert(isSorted!("a < b")(map!(entropy)(arr)));
 
     schwartzSort!(entropy, q{a > b})(arr);
     assert(arr[0] == highEnt);
     assert(arr[1] == midEnt);
     assert(arr[2] == lowEnt);
+    assert(isSorted!("a > b")(map!(entropy)(arr)));
 
     // random data
     auto b = rndstuff!(string);
     schwartzSort!(tolower)(b);
     assert(isSorted!("toupper(a) < toupper(b)")(b));
+    assert(isSorted(map!(toupper)(b)));
 }
 
 // partialSort
 /**
-Reorders $(D r) such that the range $(D begin(r) .. mid) is the same
-as if $(D r) were sorted, and leaves the range $(D mid .. end(r)) in
-no particular order. Performs $(BIGOH r.length * log(mid - begin(r)))
-evaluations of $(D pred).
+Reorders the random-access range $(D r) such that the range $(D r[0
+.. mid]) is the same as if the entire $(D r) were sorted, and leaves
+the range $(D r[mid .. r.length]) in no particular order. Performs
+$(BIGOH r.length * log(mid)) evaluations of $(D pred). The
+implementation simply calls $(D topN!(less, ss)(r, n)) and then $(D
+sort!(less, ss)(r[0 .. n])).
 
 Example:
 ----
 int[] a = [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ];
-partialSort(a, begin(a) + 5);
+partialSort(a, 5);
 assert(a[0 .. 5] == [ 0, 1, 2, 3, 4 ]);
 ----
 */
 void partialSort(alias less = "a < b", SwapStrategy ss = SwapStrategy.unstable,
-    alias iterSwap = .iterSwap, Range, It)(Range r, It mid)
+    Range)(Range r, size_t n)
+    if (isRandomAccessRange!(Range) && hasLength!(Range) && hasSlicing!(Range))
 {
-    topN!(less, ss, iterSwap)(r, mid);
-    sort!(less, ss, iterSwap, Range)(range(begin(r), mid));
+    topN!(less, ss)(r, n);
+    sort!(less, ss)(r[0 .. n]);
 }
 
 unittest
 {
     int[] a = [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ];
-    partialSort(a, begin(a) + 5);
+    partialSort(a, 5);
     assert(a[0 .. 5] == [ 0, 1, 2, 3, 4 ]);
 }
 
+// completeSort
+/**
+Sorts the random-access range $(D chain(lhs, rhs)) according to
+predicate $(D less). The left-hand side of the range $(D lhs) is
+assumed to be already sorted; $(D rhs) is assumed to be unsorted. The
+exact strategy chosen depends on the relative sizes of $(D lhs) and
+$(D rhs).  Performs $(BIGOH n * log(n)) (best case) to $(BIGOH n *
+log(n)) (worst-case) evaluations of $(D swap).
+
+Example:
+----
+int[] a = [ 1, 2, 3 ];
+int[] b = [ 4, 0, 6, 5 ];
+completeSort(a, b);
+assert(a == [ 0, 1, 2 ]);
+assert(b == [ 3, 4, 5, 6 ]);
+----
+*/
+void completeSort(alias less = "a < b", SwapStrategy ss = SwapStrategy.unstable,
+        Range1, Range2)(Range1 lhs, Range2 rhs)
+    if (isRandomAccessRange!(Range1) && hasLength!(Range1) && hasSlicing!(Range1))
+{
+    foreach (i; 0 .. rhs.length)
+    {
+        auto ub = upperBound!(less)(chain(lhs, rhs[0 .. i]), rhs[i]);
+        if (!ub.length) continue;
+        bringToFront(ub, rhs[i .. i + 1]);
+    }
+}
+
+unittest
+{
+    int[] a = [ 1, 2, 3 ];
+    int[] b = [ 4, 0, 6, 5 ];
+    completeSort(a, b);
+    assert(a == [ 0, 1, 2 ]);
+    assert(b == [ 3, 4, 5, 6 ]);
+}
+
 // isSorted
 /**
 Checks whether a random-access range is sorted according to the
 comparison operation $(D less). Performs $(BIGOH r.length) evaluations
 of $(D less).
 
-   Example:
-
+Example:
 ----
 int[] arr = [4, 3, 2, 1];
 assert(!isSorted(arr));
@@ -2717,74 +3580,217 @@
 ----
 */
 
-bool isSorted(alias less, Range)(Range r)
+bool isSorted(alias less = "a < b", Range)(Range r)
+    if (isForwardRange!(Range))
 {
-    bool pred(typeof(*begin(r)) a, typeof(*begin(r)) b) { return less(b, a); }
-    return findAdjacent!(pred)(r) == end(r);
+    // @@@TODO: make this work with findAdjacent
+    if (r.empty) return true;
+    static if (is(ElementType!(Range) == const))
+    {
+        auto ahead = r;
+        for (ahead.popFront; !ahead.empty; r.popFront, ahead.popFront)
+        {
+            if (binaryFun!(less)(ahead.front, r.front)) return false;
+        }
+    }
+    else
+    {
+        // cache the last element so we avoid calling r.front twice
+        auto last = r.front;
+        for (r.popFront; !r.empty; r.popFront)
+        {
+            auto popFront = r.front;
+            if (binaryFun!(less)(popFront, last)) return false;
+            move(popFront, last);
+        }
+    }
+    return true;
 }
 
+// makeIndex
+/**
+Computes an index for $(D r) based on the comparison $(D less). The
+index is a sorted array of pointers or indices into the original
+range. This technique is similar to sorting, but it is more flexible
+because (1) it allows "sorting" of invariant collections, (2) allows
+binary search even if the original collection does not offer random
+access, (3) allows multiple indexes, each on a different predicate,
+and (4) may be faster when dealing with large objects. However, using
+an index may also be slower under certain circumstances due to the
+extra indirection, and is always larger than a sorting-based solution
+because it needs space for the index in addition to the original
+collection. The complexity is the same as $(D sort)'s.
+
+$(D makeIndex) overwrites its second argument with the result, but
+never reallocates it. If the second argument's length is less than
+that of the range indexed, an exception is thrown.
+
+The first overload of $(D makeIndex) writes to a range containing
+pointers, and the second writes to a range containing offsets. The
+first overload requires $(D Range) to be a forward range, and the
+latter requires it to be a random-access range.
+
+Example:
+----
+immutable(int[]) arr = [ 2, 3, 1, 5, 0 ];
+// index using pointers
+auto index1 = new immutable(int)*[arr.length];
+makeIndex!("a < b")(arr, index1);
+assert(isSorted!("*a < *b")(index1));
+// index using offsets
+auto index2 = new size_t[arr.length];
+makeIndex!("a < b")(arr, index2);
+assert(isSorted!
+    ((size_t a, size_t b){ return arr[a] < arr[b];})
+    (index2));
+----
+*/
+void makeIndex(
+    alias less = "a < b",
+    SwapStrategy ss = SwapStrategy.unstable,
+    Range,
+    RangeIndex)
+(Range r, RangeIndex index)
+    if (isForwardRange!(Range) && isRandomAccessRange!(RangeIndex)
+            && is(ElementType!(RangeIndex) : ElementType!(Range)*))
+{
+    // assume collection already ordered
+    size_t i;
+    for (; !r.empty; r.popFront, ++i)
+        index[i] = &(r.front);
+    enforce(index.length == i);
+    // sort the index
+    static bool indirectLess(ElementType!(RangeIndex) a,
+            ElementType!(RangeIndex) b)
+    {
+        return binaryFun!(less)(*a, *b);
+    }
+    sort!(indirectLess, ss)(index);
+}
+
 /// Ditto
-bool isSorted(string less = "a < b", Range)(Range r)
+void makeIndex(
+    alias less = "a < b",
+    SwapStrategy ss = SwapStrategy.unstable,
+    Range,
+    RangeIndex)
+(Range r, RangeIndex index)
+    if (isRandomAccessRange!(Range) && isRandomAccessRange!(RangeIndex)
+            && isIntegral!(ElementType!(RangeIndex)))
 {
-    return .isSorted!(binaryFun!(less), Range)(r);
+    // assume collection already ordered
+    size_t i;
+    auto r1 = r;
+    for (; !r1.empty; r1.popFront, ++i)
+        index[i] = i;
+    enforce(index.length == i);
+    // sort the index
+    bool indirectLess(ElementType!(RangeIndex) a, ElementType!(RangeIndex) b)
+    {
+        return binaryFun!(less)(r[a], r[b]);
+    }
+    sort!(indirectLess, ss)(index);
 }
 
-// // makeIndex
-// /**
-// Computes an index for $(D r) based on the comparison $(D less). The
-// returned index is a sorted array of iterators into the original
-// range. This technique is similar to sorting, but it is more flexible
-// because (1) it allows "sorting" of invariant collections, (2) allows
-// binary search even if the original collection does not offer random
-// access, (3) allows multiple indexes, each on a different predicate,
-// and (4) may be faster when dealing with large objects. However, using
-// an index may also be slower under certain circumstances due to the
-// extra indirection, and is always larger than a sorting-based solution
-// because it needs space for the index in addition to the original
-// collection. The complexity is the same as $(D sort)'s.
-
-// Example:
-
-// ----
-// invariant arr = [ 2, 3, 1 ];
-// auto index = makeIndex!(less)(arr);
-// assert(*index[0] == 1 && *index[1] == 2 && *index[2] == 3);
-// assert(isSorted!("*a < *b")(index));
-// ----
-// */
-// Iterator!(Range)[] makeIndex(
-//     alias less,
-//     SwapStrategy ss = SwapStrategy.unstable,
-//     alias iterSwap = .iterSwap,
-//     Range)(Range r)
-// {
-//     alias Iterator!(Range) Iter;
-//     auto result = new Iter[r.length];
-//     // assume collection already ordered
-//     size_t i = 0;
-//     foreach (it; begin(r) .. end(r))
-//     {
-//         result[i++] = it;
-//     }
-//     // sort the index
-//     static bool indirectLess(Iter a, Iter b)
-//     {
-//         return less(*a, *b);
-//     }
-//     sort!(indirectLess, ss, iterSwap)(result);
-//     return result;
-// }
-
-
-// /// Ditto
-// Iterator!(Range)[] makeIndex(
-//     string less = q{a < b},
-//     SwapStrategy ss = SwapStrategy.unstable,
-//     alias iterSwap = .iterSwap,
-//     Range)(Range r)
-// {
-//     return .makeIndex!(binaryFun!(less), ss, iterSwap, Range)(r);
-// }
+unittest
+{
+    immutable(int)[] arr = [ 2, 3, 1, 5, 0 ];
+    // index using pointers
+    auto index1 = new immutable(int)*[arr.length];
+    alias typeof(arr) ImmRange;
+    alias typeof(index1) ImmIndex;
+    static assert(isForwardRange!(ImmRange));
+    static assert(isRandomAccessRange!(ImmIndex));
+    static assert(!isIntegral!(ElementType!(ImmIndex)));
+    static assert(is(ElementType!(ImmIndex) : ElementType!(ImmRange)*));
+    makeIndex!("a < b")(arr, index1);
+    assert(isSorted!("*a < *b")(index1));
+
+    // index using offsets
+    auto index2 = new size_t[arr.length];
+    makeIndex(arr, index2);
+    assert(isSorted!
+            ((size_t a, size_t b){ return arr[a] < arr[b];})
+            (index2));
+
+    // index strings using offsets
+    string[] arr1 = ["I", "have", "no", "chocolate"];
+    auto index3 = new size_t[arr1.length];
+    makeIndex(arr1, index3);
+    assert(isSorted!
+            ((size_t a, size_t b){ return arr1[a] < arr1[b];})
+            (index3));
+}
+
+void topNIndex(
+    alias less = "a < b",
+    SwapStrategy ss = SwapStrategy.unstable,
+    Range, RangeIndex)(Range r, RangeIndex index, bool sorted = false)
+if (isIntegral!(ElementType!(RangeIndex)))
+{
+    {
+        size_t i;
+        enforce(ElementType!(RangeIndex).max >= index.length,
+                "Index type too small");
+        foreach (ref e; index) e = cast(typeof(e)) i++;
+    }
+    bool indirectLess(ElementType!(RangeIndex) a, ElementType!(RangeIndex) b)
+    {
+        return binaryFun!(less)(r[a], r[b]);
+    }
+    auto heap = BinaryHeap!(RangeIndex, indirectLess)(index);
+    foreach (i; index.length .. r.length)
+    {
+        if (!indirectLess(cast(ElementType!(RangeIndex)) i, heap.top)) continue;
+        // replace the top with e
+        heap.replaceTop(cast(ElementType!(RangeIndex)) i);
+    }
+    if (sorted) heap.pop(heap.length);
+}
+
+void topNIndex(
+    alias less = "a < b",
+    SwapStrategy ss = SwapStrategy.unstable,
+    Range, RangeIndex)(Range r, RangeIndex index, bool sorted = false)
+if (is(ElementType!(RangeIndex) == ElementType!(Range)*))
+{
+    {
+        size_t i;
+        foreach (ref e; index) e = &r[i++];
+    }
+    static bool indirectLess(const ElementType!(RangeIndex) a,
+            const ElementType!(RangeIndex) b)
+    {
+        return binaryFun!(less)(*a, *b);
+    }
+    auto heap = BinaryHeap!(RangeIndex, indirectLess)(index);
+    foreach (i; index.length .. r.length)
+    {
+        if (!indirectLess(&r[i], heap.top)) continue;
+        // replace the top with e
+        heap.replaceTop(&r[i]);
+    }
+    if (sorted) heap.pop(heap.length);
+}
+
+unittest
+{
+    {
+        int[] a = [ 10, 8, 9, 2, 4, 6, 7, 1, 3, 5 ];
+        int*[] b = new int*[5];
+        topNIndex!("a > b")(a, b, true);
+        //foreach (e; b) writeln(*e);
+        assert(b == [ &a[0], &a[2], &a[1], &a[6], &a[5]]);
+    }
+    {
+        int[] a = [ 10, 8, 9, 2, 4, 6, 7, 1, 3, 5 ];
+        auto b = new ubyte[5];
+        topNIndex!("a > b")(a, b, true);
+        //foreach (e; b) writeln(e, ":", a[e]);
+        assert(b == [ cast(ubyte) 0, 2, 1, 6, 5]);
+    }
+}
+/+
 
 // topNIndexImpl
 // @@@BUG1904
@@ -2792,14 +3798,13 @@
     alias less,
     bool sortAfter,
     SwapStrategy ss,
-    alias iterSwap,
     SRange, TRange)(SRange source, TRange target)
 {
     alias binaryFun!(less) lessFun;
     static assert(ss == SwapStrategy.unstable,
-                  "Stable indexing not yet implemented");
+            "Stable indexing not yet implemented");
     alias Iterator!(SRange) SIter;
-    alias ElementType!(TRange) TElem;
+    alias std.iterator.ElementType!(TRange) TElem;
     enum usingInt = isIntegral!(TElem);
 
     static if (usingInt)
@@ -2842,7 +3847,7 @@
     if (sb == se)
     {
         // everything in source is now in target... just sort the thing
-        static if (sortAfter) sort!(indirectLess, ss, iterSwap)(target);
+        static if (sortAfter) sort!(indirectLess, ss)(target);
     }
     else
     {
@@ -2850,16 +3855,16 @@
         te = tb;
         tb = begin(target);
         target = range(tb, te);
-        makeHeap!(indirectLess, iterSwap)(target);
+        makeHeap!(indirectLess)(target);
         // add stuff to heap
         for (; sb != se; ++sb)
         {
             if (!lessFun(*sb, *index2iter(*tb))) continue;
             // copy the source over the smallest
             indirectCopy(sb, *tb);
-            heapify!(indirectLess, iterSwap)(target, tb);
+            heapify!(indirectLess)(target, tb);
         }
-        static if (sortAfter) sortHeap!(indirectLess, iterSwap)(target);
+        static if (sortAfter) sortHeap!(indirectLess)(target);
     }
 }
 
@@ -2869,20 +3874,18 @@
 void topNIndex(
     alias less,
     SwapStrategy ss = SwapStrategy.unstable,
-    alias iterSwap = .iterSwap,
     SRange, TRange)(SRange source, TRange target)
 {
-    return .topNIndexImpl!(less, false, ss, iterSwap)(source, target);
+    return .topNIndexImpl!(less, false, ss)(source, target);
 }
 
 /// Ditto
 void topNIndex(
     string less,
     SwapStrategy ss = SwapStrategy.unstable,
-    alias iterSwap = .iterSwap,
     SRange, TRange)(SRange source, TRange target)
 {
-    return .topNIndexImpl!(binaryFun!(less), false, ss, iterSwap)(source, target);
+    return .topNIndexImpl!(binaryFun!(less), false, ss)(source, target);
 }
 
 // partialIndex
@@ -2923,10 +3926,9 @@
 void partialIndex(
     alias less,
     SwapStrategy ss = SwapStrategy.unstable,
-    alias iterSwap = .iterSwap,
     SRange, TRange)(SRange source, TRange target)
 {
-    return .topNIndexImpl!(less, true, ss, iterSwap)(source, target);
+    return .topNIndexImpl!(less, true, ss)(source, target);
 }
 
 unittest
@@ -3004,7 +4006,6 @@
 //     alias transform,
 //     alias less,
 //     SwapStrategy ss = SwapStrategy.unstable,
-//     alias iterSwap = .iterSwap,
 //     Range)(Range r)
 // {
 //     alias Iterator!(Range) Iter;
@@ -3034,11 +4035,10 @@
 //     alias transform,
 //     string less = q{a < b},
 //     SwapStrategy ss = SwapStrategy.unstable,
-//     alias iterSwap = .iterSwap,
 //     Range)(Range r)
 // {
 //     return .schwartzMakeIndex!(
-//         transform, binaryFun!(less), ss, iterSwap, Range)(r);
+//         transform, binaryFun!(less), ss, Range)(r);
 // }
 
 // version (wyda) unittest
@@ -3056,75 +4056,43 @@
 //     assert(isSorted!("toupper(*a) < toupper(*b)")(index1));
 // }
 
-// schwartzIsSorted
-/**
-Checks whether a random-access range is sorted according to the
-comparison operation $(D less(transform(a), transform(b))). Performs
-$(BIGOH r.length) evaluations of $(D less) and $(D transform). The
-advantage over $(D isSorted) is that it evaluates $(D transform) only
-half as many times.
-
-   Example:
-
-----
-int[] arr = [ "ab", "Ab", "aB", "bc", "Bc" ];
-assert(!schwartzIsSorted!(toupper, "a < b")(arr));
-----
-*/
-
-bool schwartzIsSorted(alias transform, alias less, Range)(Range r)
-{
-    if (isEmpty(r)) return true;
-    auto i = begin(r), e = end(r);
-    auto last = transform(*i);
-    for (++i; i != e; ++i)
-    {
-        auto next = transform(*i);
-        if (less(next, last)) return false;
-        move(next, last);
-    }
-    return true;
-}
-
-/// Ditto
-bool schwartzIsSorted(alias transform, string less = "a < b", Range)(Range r)
-{
-    return .schwartzIsSorted!(transform, binaryFun!(less), Range)(r);
-}
-      
++/
+
 // lowerBound
 /**
-Returns the leftmost position in $(D range) such that all other values
-$(D x) to the left of that position satisfy $(D less(x,
-value)). Performs $(BIGOH log(r.length)) evaluations of $(D less). See
-also STL's $(WEB sgi.com/tech/stl/lower_bound.html, lower_bound).
-
-Precondition:
-$(D isSorted!(less)(r))
-
-Returns:
-$(D i) such that $(D less(*p, i)) for all p in $(D [begin(r), i$(RPAREN)).
+This function assumes that range $(D r) consists of a subrange $(D r1)
+of elements $(D e1) for which $(D pred(e1, value)) is $(D true),
+followed by a subrange $(D r2) of elements $(D e2) for which $(D
+pred(e2, value)) is $(D false). Using this assumption, $(D lowerBound)
+uses binary search to find $(D r1), i.e. the left subrange on which
+$(D pred) is always $(D true). Performs $(BIGOH log(r.length))
+evaluations of $(D pred).  The precondition is not verified because it
+would deteriorate function's complexity. It is possible that the types
+of $(D value) and $(D ElementType!(Range)) are different, if the
+predicate accepts them. See also STL's $(WEB
+sgi.com/tech/stl/lower_bound.html, lower_bound).
+
+Precondition: $(D find!(not!(pred))(r, value).length +
+find!(pred)(retro(r), value).length == r.length)
 
 Example:
 ----
 int[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];
-auto p = lowerBound!(less)(a, 4);
-assert(*p == 4);
-p = lowerBound(a, 4); // uses less by default
-assert(*p == 4);
-p = lowerBound!("a < b")(a, 4); // predicate as string
-assert(*p == 4);
+auto p = lowerBound!("a < b")(a, 4);
+assert(p == [ 0, 1, 2, 3 ]);
+p = lowerBound(a, 4); // uses "a < b" by default
+assert(p == [ 0, 1, 2, 3 ]);
 ----
 */
-Iterator!(Range) lowerBound(alias less = "a < b", Range, V)(Range r, V value)
+Range lowerBound(alias pred = "a < b", Range, V)(Range r, V value)
+    if (isRandomAccessRange!(Range) && hasLength!(Range))
 {
-    auto first = begin(r);
-    auto count = end(r) - first;
+    auto first = 0, count = r.length;
     while (count > 0)
     {
-        invariant step = count / 2;
+        immutable step = count / 2;
         auto it = first + step;
-        if (binaryFun!(less)(*it, value))
+        if (binaryFun!(pred)(r[it], value))
         {
             first = it + 1;
             count -= step + 1;
@@ -3134,32 +4102,38 @@
             count = step;
         }
     }
-    return first;
+    return r[0 .. first];
 }
 
 unittest
 {
     int[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];
     auto p = lowerBound!("a < b")(a, 4);
-    assert(*p == 4);
+    assert(p == [0, 1, 2, 3]);
     p = lowerBound(a, 5);
-    assert(*p == 5);
+    assert(p == [0, 1, 2, 3, 4]);
     p = lowerBound!(q{a < b})(a, 6);
-    assert(*p == 6);
+    assert(p == [ 0, 1, 2, 3, 4, 5]);
 }
 
 // upperBound
 /**
-Returns the rightmost position in $(D r) such that all other elements
-$(D x) to the left of that position satisfy $(D !less(value, x)).
-Performs $(BIGOH log(r.length)) evaluations of $(D less). See also
-STL's $(WEB sgi.com/tech/stl/upper_bound.html, upper_bound).
-
-Precondition:
-$(D isSorted!(less)(r))
-
-Returns: $(D i) such that $(D less(*p, value)) for all p in $(D
-[begin(r), i$(RPAREN)).
+This function assumes that range $(D r) consists of a subrange $(D r1)
+of elements $(D e1) for which $(D pred(value, e1)) is $(D false),
+followed by a subrange $(D r2) of elements $(D e2) for which $(D
+pred(value, e2)) is $(D true). (Note the differences in subrange
+definition and argument order for $(D pred) compared to $(D
+lowerBound).) Using this assumption, $(D upperBound) uses binary
+search to find $(D r2), i.e. the right subrange on which $(D pred) is
+always $(D true). Performs $(BIGOH log(r.length)) evaluations of $(D
+pred).  The precondition is not verified because it would deteriorate
+function's complexity. It is possible that the types of $(D value) and
+$(D ElementType!(Range)) are different, if the predicate accepts
+them. See also STL's $(WEB sgi.com/tech/stl/lower_bound.html,
+upper_bound).
+
+Precondition: $(D find!(pred)(r, value).length +
+find!(not!(pred))(retro(r), value).length == r.length)
 
 Example:
 ----
@@ -3168,46 +4142,45 @@
 assert(p == begin(a) + 5);
 ----
 */
-Iterator!(Range) upperBound(alias less = "a < b", Range, V)(Range r, V value)
+Range upperBound(alias pred = "a < b", Range, V)(Range r, V value)
+    if (isRandomAccessRange!(Range))
 {
-    auto first = begin(r);
-    size_t count = end(r) - first;
+    auto first = 0;
+    size_t count = r.length;
     while (count > 0)
     {
         auto step = count / 2;
         auto it = first + step;
-        if (!binaryFun!(less)(value,*it))
+        if (!binaryFun!(pred)(value, r[it]))
         {
             first = it + 1;
             count -= step + 1;
         }
         else count = step;
-  }
-  return first;
+    }
+    return r[first .. r.length];
 }
 
 unittest
 {
-    auto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];
+    int[] a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];
     auto p = upperBound(a, 3);
-    assert(p == begin(a) + 5);
+    assert(p == [4, 4, 5, 6 ]);
 }
 
 // equalRange
 /**
-The call $(D equalRange!(less)(r, v)) returns $(D range($(D
-lowerBound!(less)(r, v), $(D upperBound!(less)(r, v))))) but a bit
-more efficiently than calling both functions.  Performs $(BIGOH
-log(r.length)) evaluations of $(D less). See also STL's $(WEB
+Assuming a range satisfying both preconditions for $(D
+lowerBound!(pred)(r, value)) and $(D upperBound!(pred)(r, value)), the
+call $(D equalRange!(pred)(r, v)) returns the subrange containing all
+elements $(D e) for which both $(D pred(e, value)) and $(D pred(value,
+e)) evaluate to $(D false). Performs $(BIGOH log(r.length))
+evaluations of $(D pred). See also STL's $(WEB
 sgi.com/tech/stl/equal_range.html, equal_range).
 
-Precondition:
-$(D isSorted!(less)(range))
-
-Returns:
-
-The largest subrange of $(D r) such that for all $(D p) in that range,
-$(D !less(*p, value) && !less(value, *p)).
+Precondition: $(D find!(not!(pred))(r, value).length +
+find!(pred)(retro(r), value).length == r.length) && $(D find!(pred)(r,
+value).length + find!(not!(pred))(retro(r), value).length == r.length)
 
 Example:
 ----
@@ -3217,41 +4190,21 @@
 ----
 */
 Range equalRange(alias less = "a < b", Range, V)(Range r, V value)
+    if (isRandomAccessRange!(Range) && hasLength!(Range))
 {
     alias binaryFun!(less) lessFun;
-    auto first = begin(r), last = end(r);
-    for (size_t count = last - first; count > 0; )
-    {
-        auto step = count / 2;
-        auto middle = first + step;
-        if (lessFun(*middle, value))
-        {
-            first = middle + 1;
-            count -= step + 1;
-        }
-        else if (lessFun(value, *middle))
-        {
-            count = step;
-        }
-        else
-        {
-            // we're straight in the range!
-            auto left = lowerBound!(less)(range(first, middle), value);
-            first += count;
-            auto right = upperBound!(less)(range(++middle, first), value);
-            return range(left, right);
-        }
-    }
-    return range(first, first);
+    auto left = lowerBound!(less)(r, value);
+    auto right = upperBound!(less)(r[left.length .. r.length], value);
+    return r[left.length .. r.length - right.length];
 }
 
 unittest
 {
     int[] a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];
     auto p = equalRange(a, 3);
-    assert(p == [ 3, 3, 3 ]);
+    assert(p == [ 3, 3, 3 ], text(p));
     p = equalRange(a, 4);
-    assert(p == [ 4, 4 ]);
+    assert(p == [ 4, 4 ], text(p));
     p = equalRange(a, 2);
     assert(p == [ 2 ]);
 }
@@ -3264,10 +4217,12 @@
 sgi.com/tech/stl/binary_search.html, binary_search).
 */
 
-bool canFindSorted(alias less = "a < b", T, V)(T range, V value)
+bool canFindSorted(alias less = "a < b", Range, V)(Range range, V value)
+    if (isRandomAccessRange!(Range) && hasLength!(Range))
 {
-    auto p = lowerBound!(less)(range, value);
-    return p != end(range) && !binaryFun!(less)(value, *p);
+    auto lb = lowerBound!(less)(range, value);
+    return lb.length < range.length &&
+        !binaryFun!(less)(value, range[lb.length]);
 }
 
 unittest
@@ -3282,131 +4237,482 @@
 }
 
 /**
+Implements a $(WEB en.wikipedia.org/wiki/Binary_heap, binary heap)
+collection on top of a given range type (usually $(D T[])). The binary
+heap structures the underlying range such that extracting the largest
+element is done fast in $(BIGOH log n). Successive extractions of the
+largest element effect the heapsort algorithm.
+
+Example:
+----
+int[] a = [ 4, 1, 3, 2, 16, 9, 10, 14, 8, 7 ];
+auto h = BinaryHeap!(int[])(a);
+auto b = h.pop(5);
+assert(b == [ 8, 9, 10, 14, 16 ]);
+b = h.pop(5);
+assert(b == [ 1, 2, 3, 4, 7 ]);
+assert(h.length == 0);
+----
+ */
+struct BinaryHeap(Range, alias less = "a < b") if (isRandomAccessRange!(Range))
+{
+    private Range _store;
+    private alias binaryFun!(less) comp;
+
+    //@@@BUG
+    //private static void heapify(Range r, size_t i)
+    void heapify(Range r, size_t i)
+    {
+        auto b = 0;
+        for (;;)
+        {
+            auto left = b + (i - b) * 2 + 1, right = left + 1;
+            if (right == r.length)
+            {
+                if (binaryFun!(less)(r[i], r[left])) swap(r[i], r[left]);
+                return;
+            }
+            if (right > r.length) return;
+            assert(left < r.length && right < r.length);
+            auto largest = comp(r[i], r[left])
+                ? (comp(r[left], r[right]) ? right : left)
+                : (comp(r[i], r[right]) ? right : i);
+            if (largest == i) return;
+            swap(r[i], r[largest]);
+            i = largest;
+        }
+    }
+
+    private void pop(Range store)
+    {
+        if (store.length <= 1) return;
+        auto newEnd = store.length - 1;
+        swap(store.front, store[newEnd]);
+        heapify(store[0 .. newEnd], 0);
+    }
+
+public:
+/**
 Converts the range $(D r) into a heap. Performs $(BIGOH r.length)
-evaluations of $(D less).
+evaluations of $(D comp).
 */
-
-void makeHeap(alias less = "a < b", alias iterSwap = .iterSwap, Range)(Range r)
-{
-    if (r.length < 2) return;
-    auto i = begin(r) + (r.length - 2) / 2;
-    for (;; --i)
+    this(Range r)
     {
-        heapify!(less, iterSwap)(r, i);
-        if (i == begin(r)) return;
+        _store = r;
+        if (_store.length < 2) return;
+        auto i = (_store.length - 2) / 2;
+        // @@@BUG: statement not reachable
+        // for (;;)
+        // {
+        //     this.heapify(_store, i);
+        //     if (i == 0) return;
+        //     --i;
+        // }
+        this.heapify(_store, i);
+        for (; i-- != 0;)
+        {
+            this.heapify(_store, i);
+        }
+    }
+
+/**
+Takes ownership of a range. The old content of the store is destroyed.
+ */    
+    void acquire(Range r)
+    {
+        swap(r, _store);
+    }
+
+/**
+Clears the heap. Returns the contents of the store.
+ */    
+    Range release()
+    {
+        Range result;
+        swap(result, _store);
+        return result;
+    }
+
+/**
+Get the _top element (the largest according to the predicate $(D
+less)).
+ */
+    ref const(ElementType!(Range)) top()
+    {
+        return _store[0];
+    }
+    
+/**
+Pops the largest element (according to the predicate $(D less)).
+ */
+    void pop()
+    {
+        enforce(_store.length);
+        if (_store.length > 1) swap(_store.front, _store.back);
+        _store.popBack;
+        heapify(_store, 0);
+    }
+
+/**
+Pops the $(D n) largest elements (according to the predicate $(D
+less)) and returns a range containing them (which is in fact a
+subrange of the heap's underlying range). The returned range is sorted
+in increasing order by $(D less), and after the call the heap does not
+contain those elements anymore. If $(D n >= this.length), the entire
+heap is sorted and returned.
+ */
+    Range pop(size_t n)
+    {
+        immutable size_t newSize = n >= _store.length
+            ? (n = _store.length, 0)
+            : _store.length - n;
+        auto result = _store[newSize .. _store.length];
+        while  (_store.length > newSize)
+        {
+            swap(_store.front, _store.back);
+            _store.popBack;
+            heapify(_store, 0);
+        }
+        return result;
+    }
+
+/**
+Replaces the top element (largest according to $(D less)) with $(D
+newTop).
+ */
+    void replaceTop(ElementType!(Range) newTop)
+    {
+        _store.front = newTop;
+        heapify!(less)(_store, 0);
+    }
+
+/**
+Returns the _length of the heap.
+ */    
+    size_t length()
+    {
+        return _store.length;
     }
 }
 
 unittest
 {
-    // example from "Introduction to Algorithms" Cormen et al., p 146
-    int[] a = [ 4, 1, 3, 2, 16, 9, 10, 14, 8, 7 ];
-    makeHeap!(binaryFun!("a < b"))(a);
-    assert(a == [ 16, 14, 10, 8, 7, 9, 3, 2, 4, 1 ]);
+    {
+        // example from "Introduction to Algorithms" Cormen et al., p 146
+        int[] a = [ 4, 1, 3, 2, 16, 9, 10, 14, 8, 7 ];
+        //vnBinaryHeap!(int[]) h = BinaryHeap!(int[])(a);
+        //makeBinaryHeap!(binaryFun!("a < b"))(a);
+//        assert(a == [ 16, 14, 10, 8, 7, 9, 3, 2, 4, 1 ]);
+    }
+    // {
+    //     int[] a = [ 4, 1, 3, 2, 16, 9, 10, 14, 8, 7 ];
+    //     BinaryHeap!(int[]) h = BinaryHeap!(int[])(a);
+    //     //makeBinaryHeap!(binaryFun!("a < b"))(a);
+    //     auto b = h.pop(5);
+    //     assert(b == [ 8, 9, 10, 14, 16 ]);
+    //     b = h.pop(5);
+    //     assert(b == [ 1, 2, 3, 4, 7 ]);
+    //     assert(h.length == 0);
+    // }
 }
 
-/*private*/
-void heapify(alias less, alias iterSwap, Range, It)(Range r, It i)
-{
-    auto b = begin(r);
-    for (;;)
-    {
-        auto left = b + (i - b) * 2 + 1, right = left + 1;
-        if (right == end(r))
-        {
-            if (less(*i, *left)) iterSwap(i, left);
-            return;
-        }
-        if (right > end(r)) return;
-        assert(left < end(r) && right < end(r));
-        auto largest = less(*i, *left)
-            ? (less(*left, *right) ? right : left)
-            : (less(*i, *right) ? right : i);
-        if (largest == i) return;
-        iterSwap(i, largest);
-        i = largest;
-    }
-}
-
-unittest
+version(none) unittest
 {
     // example from "Introduction to Algorithms" Cormen et al., p 143
     int[] a = [ 16, 4, 10, 14, 7, 9, 3, 2, 8, 1 ];
-    heapify!(binaryFun!("a < b"), iterSwap)(a, begin(a) + 1);
+    BinaryHeap!(int[]) h = BinaryHeap!(int[])(a);
     assert(a == [ 16, 14, 10, 8, 7, 9, 3, 2, 4, 1 ]);
 }
 
 /**
-popHeap 
-*/
-void popHeap(alias less, alias iterSwap = .iterSwap, Range)(Range r)
-{
-    if (r.length <= 1) return;
-    auto newEnd = end(r) - 1;
-    iterSwap(begin(r), newEnd);
-    heapify!(less, iterSwap)(range(begin(r), newEnd), begin(r));
-}
-
-/**
-sortHeap
-*/
-void sortHeap(alias less, alias iterSwap = .iterSwap, Range)(Range r)
-{
-    auto b = begin(r), e = end(r);
-    for (; e - b > 1; --e)
-    {
-        popHeap!(less, iterSwap)(range(b, e));
-    }
-}
-
-/**
-topNCopy 
-*/
-void topNCopy(alias less, alias iterSwap = .iterSwap, SRange, TRange)(
-    SRange source, TRange target)
+Copies the top $(D n) elements of the input range $(D source) into the
+random-access range $(D target), where $(D n =
+target.length). Elements of $(D source) are not touched. If $(D
+sorted) is $(D true), the target is sorted. Otherwise, the target
+respects the $(WEB en.wikipedia.org/wiki/Binary_heap, heap property).
+
+Example:
+----
+int[] a = [ 10, 16, 2, 3, 1, 5, 0 ];
+int[] b = new int[3];
+topNCopy(a, b, true);
+assert(b == [ 0, 1, 2 ]);
+----
+ */
+TRange topNCopy(alias less = "a < b", SRange, TRange)
+    (SRange source, TRange target, bool sorted = false)
+    if (isInputRange!(SRange) && isRandomAccessRange!(TRange)
+            && hasLength!(TRange) && hasSlicing!(TRange))
 {
     // make an initial heap in the target
-    auto tb = begin(target), te = tb;
-    auto sb = begin(source), se = end(source);
-    for (; sb != se; ++sb)
+    foreach (i; 0 .. target.length)
     {
-        if (te == end(target)) break;
-        *te = *sb;
-        ++te;
+        if (source.empty)
+        {
+            target = target[0 .. i];
+            break;
+        }
+        target[i] = source.front;
+        source.popFront;
     }
-    if (te < end(target)) target = range(tb, te);
-    makeHeap!(less, iterSwap)(target);
-
+    if (target.empty) return target;
+
+    auto heap = BinaryHeap!(TRange, less)(target);
     // now copy stuff into the target if it's smaller
-    for (; sb != se; ++sb)
+    for (; !source.empty; source.popFront)
     {
-        if (!less(*sb, *tb)) continue;
-        *tb = *sb;
-        heapify!(less, iterSwap)(target, tb);
+        if (!binaryFun!(less)(source.front, heap.top)) continue;
+        heap.replaceTop(source.front);
     }
+    return sorted ? heap.pop(heap.length) : heap.release;
 }
 
-/**
-partialSortCopy
-*/
-void partialSortCopy(alias less, alias iterSwap = .iterSwap, SRange, TRange)(
-    SRange source, TRange target)
+version(none) unittest
 {
-    topNCopy!(less, iterSwap)(source, target);
-    sortHeap!(less, iterSwap)(target);
+    int[] a = [ 10, 16, 2, 3, 1, 5, 0 ];
+    int[] b = new int[3];
+    topNCopy(a, b, true);
+    assert(b == [ 0, 1, 2 ]);
 }
 
-unittest
+version(none) unittest
 {
     auto r = Random(unpredictableSeed);
-    int[] a = new int[uniform(r, 0, 1000)];
+    int[] a = new int[uniform(1, 1000, r)];
     foreach (i, ref e; a) e = i;
     randomShuffle(a, r);
-    int[] b = new int[uniform(r, 0, a.length)];
-    partialSortCopy!(binaryFun!("a < b"))(a, b);
+    auto n = uniform(0, a.length, r);
+    int[] b = new int[n];
+    topNCopy!(binaryFun!("a < b"))(a, b, true);
     assert(isSorted!(binaryFun!("a < b"))(b));
 }
 
+/**
+Lazily computes the union of $(D r1) and $(D r2). The two ranges are
+assumed to be sorted by $(D less). The element types of the two ranges
+must have a common type.
+ */
+struct SetUnion(alias less = "a < b", R1, R2)
+    if (isInputRange!(R1) && isInputRange!(R2))
+{
+private:
+    R1 r1;
+    R2 r2;
+    alias binaryFun!(less) comp;
+    enum State { usingR1, usingR2, r1Empty, r2Empty, bothEmpty }
+    State state = State.bothEmpty;
+
+public:
+    this(R1 r1, R2 r2)
+    {
+        this.r1 = r1;
+        this.r2 = r2;
+        if (r1.empty) state = r2.empty ? State.bothEmpty : State.r1Empty;
+        else if (r2.empty) state = State.r2Empty;
+        else if (comp(r2.front, r1.front)) state = State.usingR2;
+        else state = State.usingR1;
+    }
+    
+    void popFront()
+    {
+        switch (state)
+        {
+        case State.usingR1: 
+            r1.popFront;
+            if (r1.empty) state = State.r1Empty;
+            else state = comp(r2.front, r1.front) ? State.usingR2 : State.usingR1;
+            break;
+        case State.r2Empty:
+            r1.popFront;
+            if (r1.empty) state = State.bothEmpty;
+            break;
+        case State.usingR2:
+            r2.popFront;
+            if (r2.empty) state = State.r2Empty;
+            else state = comp(r2.front, r1.front) ? State.usingR2 : State.usingR1;
+            break;
+        case State.r1Empty:
+            r2.popFront;
+            if (r2.empty) state = State.bothEmpty;
+            break;
+        default:
+            break;
+        }
+    }
+
+    CommonType!(ElementType!(R1), ElementType!(R2)) front()
+    {
+        switch (state)
+        {
+        case State.usingR1: case State.r2Empty:
+            return r1.front;
+        case State.usingR2: case State.r1Empty:
+            return r2.front;
+        default:
+            break;
+        }
+        assert(false, text(state));
+    }
+
+    bool empty() { return state == State.bothEmpty; }
+}
+
+/// Ditto
+SetUnion!(less, R1, R2) setUnion(alias less = "a < b", R1, R2)
+(R1 r1, R2 r2)
+{
+    return typeof(return)(r1, r2);
+}
+
+version(none) unittest
+{
+    int[] a = [ 1, 2, 4, 5, 7, 9 ];
+    int[] b = [ 0, 1, 2, 4, 7, 8 ];
+    //foreach (e; setUnion(a, b)) writeln(e);
+    assert(equal(setUnion(a, b), [0, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9][]));
+}
+
+/**
+Lazily computes the intersection of $(D r1) and $(D r2). The two
+ranges are assumed to be sorted by $(D less). The element types of the
+two ranges must have a common type.
+ */
+struct SetIntersection(alias less = "a < b", R1, R2)
+    if (isInputRange!(R1) && isInputRange!(R2))
+{
+private:
+    R1 r1;
+    R2 r2;
+    alias binaryFun!(less) comp;
+
+    void adjustPosition()
+    {
+        if (empty) return;
+        for (;;)
+        {
+            if (comp(r1.front, r2.front))
+            {
+                r1.popFront;
+                if (r1.empty) return;
+            }
+            else if (comp(r2.front, r1.front))
+            {
+                r2.popFront;
+                if (r2.empty) return;
+            }
+            else break;
+        }
+    }
+    
+public:
+    this(R1 r1, R2 r2)
+    {
+        this.r1 = r1;
+        this.r2 = r2;
+        // position to the first element
+        adjustPosition;
+    }
+    
+    void popFront()
+    {
+        r1.popFront;
+        r2.popFront;
+        adjustPosition;
+    }
+
+    CommonType!(ElementType!(R1), ElementType!(R2)) front()
+    {
+        assert(!empty);
+        return r1.front;
+    }
+
+    bool empty() { return r1.empty || r2.empty; }
+}
+
+/// Ditto
+SetIntersection!(less, R1, R2) setIntersection(alias less = "a < b", R1, R2)
+(R1 r1, R2 r2)
+{
+    return typeof(return)(r1, r2);
+}
+
+version(none) unittest
+{
+    int[] a = [ 1, 2, 4, 5, 7, 9 ];
+    int[] b = [ 0, 1, 2, 4, 7, 8 ];
+    assert(equal(setIntersection(a, b), [1, 2, 4, 7][]));
+}
+
+/**
+Lazily computes the difference of $(D r1) and $(D r2). The two ranges
+are assumed to be sorted by $(D less). The element types of the two
+ranges must have a common type.
+ */
+struct SetDifference(alias less = "a < b", R1, R2)
+    if (isInputRange!(R1) && isInputRange!(R2))
+{
+private:
+    R1 r1;
+    R2 r2;
+    alias binaryFun!(less) comp;
+
+    void adjustPosition()
+    {
+        while (!r1.empty)
+        {
+            if (r2.empty || comp(r1.front, r2.front)) break;
+            if (comp(r2.front, r1.front))
+            {
+                r2.popFront;
+            }
+            else
+            {
+                // both are equal
+                r1.popFront;
+                r2.popFront;
+            }
+        }
+    }
+    
+public:
+    this(R1 r1, R2 r2)
+    {
+        this.r1 = r1;
+        this.r2 = r2;
+        // position to the first element
+        adjustPosition;
+    }
+    
+    void popFront()
+    {
+        r1.popFront;
+        adjustPosition;
+    }
+
+    ElementType!(R1) front()
+    {
+        assert(!empty);
+        return r1.front;
+    }
+
+    bool empty() { return r1.empty; }
+}
+
+/// Ditto
+SetDifference!(less, R1, R2) setDifference(alias less = "a < b", R1, R2)
+(R1 r1, R2 r2)
+{
+    return typeof(return)(r1, r2);
+}
+
+version(none) unittest
+{
+    int[] a = [ 1, 2, 4, 5, 7, 9 ];
+    int[] b = [ 0, 1, 2, 4, 7, 8 ];
+    //foreach (e; setDifference(a, b)) writeln(e);
+    assert(equal(setDifference(a, b), [5, 9][]));
+}
+
 // Internal random array generators
 
 version(unittest)
@@ -3424,13 +4730,13 @@
             first = false;
         }
         string[] result =
-            new string[uniform(rnd, minArraySize, maxArraySize)];
+            new string[uniform(minArraySize, maxArraySize, rnd)];
         string alpha = "abcdefghijABCDEFGHIJ";
         foreach (ref s; result)
         {
-            foreach (i; 0 .. uniform!(uint)(rnd, 0u, 20u))
+            foreach (i; 0 .. uniform(0u, 20u, rnd))
             {
-                auto j = uniform(rnd, 0, alpha.length - 1);
+                auto j = uniform(0, alpha.length - 1, rnd);
                 s ~= alpha[j];
             }
         }
@@ -3446,10 +4752,10 @@
             rnd = Random(unpredictableSeed);
             first = false;
         }
-        int[] result = new int[uniform(rnd, minArraySize, maxArraySize)];
+        int[] result = new int[uniform(minArraySize, maxArraySize, rnd)];
         foreach (ref i; result)
         {
-            i = uniform(rnd, -100, 100);
+            i = uniform(-100, 100, rnd);
         }
         return result;
     }
@@ -3464,3 +4770,25 @@
         return result;
     }
 }
+
+/*
+ *  Copyright (C) 2004-2006 by Digital Mars, www.digitalmars.com
+ *  Written by Andrei Alexandrescu, www.erdani.org
+ *
+ *  This software is provided 'as-is', without any express or implied
+ *  warranty. In no event will the authors be held liable for any damages
+ *  arising from the use of this software.
+ *
+ *  Permission is granted to anyone to use this software for any purpose,
+ *  including commercial applications, and to alter it and redistribute it
+ *  freely, subject to the following restrictions:
+ *
+ *  o  The origin of this software must not be misrepresented; you must not
+ *     claim that you wrote the original software. If you use this software
+ *     in a product, an acknowledgment in the product documentation would be
+ *     appreciated but is not required.
+ *  o  Altered source versions must be plainly marked as such, and must not
+ *     be misrepresented as being the original software.
+ *  o  This notice may not be removed or altered from any source
+ *     distribution.
+ */
diff -r f12bfe124807 d/phobos2/std/array.d
--- a/d/phobos2/std/array.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/array.d	Thu Oct 14 14:12:53 2010 +0100
@@ -2,12 +2,14 @@
 
 module std.array;
 
-private import std.c.stdio;
-private import core.memory;
-private import std.contracts;
-private import std.traits;
-private import std.string;
-private import std.algorithm;
+import std.c.stdio;
+import core.memory;
+import std.contracts;
+import std.traits;
+import std.string;
+import std.algorithm;
+import std.encoding;
+import std.typecons;
 version(unittest) private import std.stdio;
 
 /*
@@ -103,6 +105,189 @@
 }
 
 /**
+Implements the range interface primitive $(D empty) for built-in
+arrays. Due to the fact that nonmember functions can be called with
+the first argument using the dot notation, $(D array.empty) is
+equivalent to $(D empty(array)).
+
+Example:
+----
+void main()
+{
+    auto a = [ 1, 2, 3 ];
+    assert(!a.empty);
+    assert(a[3 .. $].empty);
+}
+----
+ */
+
+bool empty(T)(in T[] a) { return !a.length; }
+
+unittest
+{
+    auto a = [ 1, 2, 3 ];
+    assert(!a.empty);
+    assert(a[3 .. $].empty);
+}
+
+/**
+Implements the range interface primitive $(D popFront) for built-in
+arrays. Due to the fact that nonmember functions can be called with
+the first argument using the dot notation, $(D array.popFront) is
+equivalent to $(D popFront(array)).
+
+
+Example:
+----
+void main()
+{
+    int[] a = [ 1, 2, 3 ];
+    a.popFront;
+    assert(a == [ 2, 3 ]);
+}
+----
+*/
+
+void popFront(T)(ref T[] a)
+{
+    assert(a.length, "Attempting to popFront() past the end of an array of "
+            ~ T.stringof);
+    a = a[1 .. $];
+}
+
+unittest
+{
+    //@@@BUG 2608@@@
+    //auto a = [ 1, 2, 3 ];
+    int[] a = [ 1, 2, 3 ];
+    a.popFront;
+    assert(a == [ 2, 3 ]);
+}
+
+/**
+Implements the range interface primitive $(D popBack) for built-in
+arrays. Due to the fact that nonmember functions can be called with
+the first argument using the dot notation, $(D array.popBack) is
+equivalent to $(D popBack(array)).
+
+
+Example:
+----
+void main()
+{
+    int[] a = [ 1, 2, 3 ];
+    a.popBack;
+    assert(a == [ 1, 2 ]);
+}
+----
+*/
+
+void popBack(T)(ref T[] a) { assert(a.length); a = a[0 .. $ - 1]; }
+
+unittest
+{
+    //@@@BUG 2608@@@
+    //auto a = [ 1, 2, 3 ];
+    int[] a = [ 1, 2, 3 ];
+    a.popBack;
+    assert(a == [ 1, 2 ]);
+}
+
+/**
+Implements the range interface primitive $(D front) for built-in
+arrays. Due to the fact that nonmember functions can be called with
+the first argument using the dot notation, $(D array.front) is
+equivalent to $(D front(array)).
+
+
+Example:
+----
+void main()
+{
+    int[] a = [ 1, 2, 3 ];
+    assert(a.front == 1);
+}
+----
+*/
+ref typeof(A[0]) front(A)(A a) if (is(typeof(A[0])))
+{
+    assert(a.length, "Attempting to fetch the front of an empty array");
+    return a[0];
+}
+
+/// Ditto
+void front(T)(T[] a, T v) { assert(a.length); a[0] = v; }
+
+/**
+Implements the range interface primitive $(D back) for built-in
+arrays. Due to the fact that nonmember functions can be called with
+the first argument using the dot notation, $(D array.back) is
+equivalent to $(D back(array)).
+
+Example:
+----
+void main()
+{
+    int[] a = [ 1, 2, 3 ];
+    assert(a.front == 1);
+}
+----
+*/
+ref T back(T)(T[] a) { assert(a.length); return a[a.length - 1]; }
+
+/**
+Implements the range interface primitive $(D put) for built-in
+arrays. Due to the fact that nonmember functions can be called with
+the first argument using the dot notation, $(D array.put(e)) is
+equivalent to $(D put(array, e)).
+
+Example:
+----
+void main()
+{
+    int[] a = [ 1, 2, 3 ];
+    int[] b = a;
+    a.put(5);
+    assert(a == [ 2, 3 ]);
+    assert(b == [ 5, 2, 3 ]);
+}
+----
+*/
+void put(T, E)(ref T[] a, E e) { assert(a.length); a[0] = e; a = a[1 .. $]; }
+
+// overlap
+/*
+Returns the overlapping portion, if any, of two arrays. Unlike $(D
+equal), $(D overlap) only compares the pointers in the ranges, not the
+values referred by them. If $(D r1) and $(D r2) have an overlapping
+slice, returns that slice. Otherwise, returns the null slice.
+
+Example:
+----
+int[] a = [ 10, 11, 12, 13, 14 ];
+int[] b = a[1 .. 3];
+assert(overlap(a, b) == [ 11, 12 ]);
+b = b.dup;
+// overlap disappears even though the content is the same
+assert(isEmpty(overlap(a, b)));
+----
+*/
+T[] overlap(T)(T[] r1, T[] r2)
+{
+    auto b = max(r1.ptr, r2.ptr);
+    auto e = min(&(r1.ptr[r1.length - 1]) + 1, &(r2.ptr[r2.length - 1]) + 1);
+    return b < e ? b[0 .. e - b] : null;
+}
+
+unittest
+{
+    int[] a = [ 10, 11, 12, 13, 14 ];
+    int[] b = a[1 .. 3];
+    a[1] = 100;
+    assert(overlap(a, b) == [ 100, 12 ]);
+}
+
+/**
 Inserts $(D stuff) in $(D container) at position $(D pos).
  */
 void insert(T, Range)(ref T[] array, size_t pos, Range stuff)
@@ -111,7 +296,7 @@
     {
         // presumably an array
         alias stuff toInsert;
-        assert(!overlap(array, toInsert));
+        //assert(!overlap(array, toInsert));
     }
     else
     {
@@ -130,7 +315,8 @@
         newLength = oldLength + delta;
 
     // Reallocate the array to make space for new content
-    array = (cast(T*) core.memory.GC.realloc(array.ptr, newLength * array[0].sizeof))[0 .. newLength];
+    array = (cast(T*) core.memory.GC.realloc(array.ptr,
+                    newLength * array[0].sizeof))[0 .. newLength];
     assert(array.length == newLength);
 
     // Move data in pos .. pos + stuff.length to the end of the array
@@ -156,26 +342,47 @@
     assert(a == [1, 99, 2, 3, 4, 5]);
 }
 
+// @@@ TODO: document this
+bool sameHead(T)(in T[] lhs, in T[] rhs)
+{
+    return lhs.ptr == rhs.ptr;
+}
+
 /**
 Erases elements from $(D array) with indices ranging from $(D from)
 (inclusive) to $(D to) (exclusive).
  */
-void erase(T)(ref T[] array, size_t from, size_t to)
-{
-    invariant newLength = array.length - (to - from);
-    foreach (i; to .. array.length)
-    {
-        move(array[i], array[from++]);
-    }
-    array.length = newLength;
-}
+// void erase(T)(ref T[] array, size_t from, size_t to)
+// {
+//     invariant newLength = array.length - (to - from);
+//     foreach (i; to .. array.length)
+//     {
+//         move(array[i], array[from++]);
+//     }
+//     array.length = newLength;
+// }
 
-unittest
-{
-    int[] a = [1, 2, 3, 4, 5];
-    erase(a, 1u, 3u);
-    assert(a == [1, 4, 5]);
-}
+// unittest
+// {
+//     int[] a = [1, 2, 3, 4, 5];
+//     erase(a, 1u, 3u);
+//     assert(a == [1, 4, 5]);
+// }
+
+/**
+Erases element from $(D array) at index $(D from).
+ */
+// void erase(T)(ref T[] array, size_t from)
+// {
+//     erase(array, from, from + 1);
+// }
+
+// unittest
+// {
+//     int[] a = [1, 2, 3, 4, 5];
+//     erase(a, 2u);
+//     assert(a == [1, 2, 4, 5]);
+// }
 
 /**
 Replaces elements from $(D array) with indices ranging from $(D from)
@@ -198,7 +405,7 @@
         //invariant stuffEnd = from + stuff.length;
         auto stuffEnd = from + stuff.length;
         array[from .. stuffEnd] = stuff;
-        erase(array, stuffEnd, to);
+        remove(array, tuple(stuffEnd, to));
     }
     else
     {
@@ -217,3 +424,172 @@
     assert(a == [1, 2, 3, 4, 5]);
 }
 
+/**
+Implements an output range that appends data to an array. This is
+recommended over $(D a ~= data) because it is more efficient.
+
+Example:
+----
+auto arr = new char[0];
+auto app = appender(&arr);
+string b = "abcdefg";
+foreach (char c; b) app.put(c);
+assert(app.data == "abcdefg");
+
+int[] a = [ 1, 2 ];
+auto app2 = appender(&a);
+app2.put(3);
+app2.put([ 4, 5, 6 ]);
+assert(app2.data == [ 1, 2, 3, 4, 5, 6 ]);
+----
+ */
+
+struct Appender(A : T[], T)
+{
+private:
+    T[] * pArray;
+    size_t _capacity;
+
+public:
+/**
+Initialize an $(D Appender) with a pointer to an existing array. The
+$(D Appender) object will append to this array. If $(D null) is passed
+(or the default constructor gets called), the $(D Appender) object
+will allocate and use a new array.
+ */
+    this(T[] * p)
+    {
+        pArray = p;
+        if (!pArray) pArray = (new typeof(*pArray)[1]).ptr;
+        _capacity = GC.sizeOf(pArray.ptr) / T.sizeof;
+        //_capacity = .capacity(pArray.ptr) / T.sizeof;
+    }
+
+/**
+Returns the managed array.
+ */ 
+    T[] data()
+    {
+        return pArray ? *pArray : null;
+    }
+
+/**
+Returns the capacity of the array (the maximum number of elements the
+managed array can accommodate before triggering a reallocation).
+ */ 
+    size_t capacity() const { return _capacity; }
+
+    static if (is(const(T) : T))
+    {
+/**
+An alias for the accepted type to be appended.
+ */     
+        alias const(T) AcceptedElementType;
+    }
+    else
+    {
+        alias T AcceptedElementType;
+    }
+    
+/**
+Appends one item to the managed array.
+ */ 
+    void put(AcceptedElementType item)
+    {
+        if (!pArray) pArray = (new typeof(*pArray)[1]).ptr;
+        if (pArray.length < _capacity)
+        {
+            // Should do in-place construction here
+            pArray.ptr[pArray.length] = item;
+            *pArray = pArray.ptr[0 .. pArray.length + 1];
+        }
+        else
+        {
+            // Time to reallocate, do it and cache capacity
+            *pArray ~= item;
+            //_capacity = .capacity(pArray.ptr) / T.sizeof;
+            _capacity = GC.sizeOf(pArray.ptr) / T.sizeof;
+        }
+    }
+
+/**
+Appends another array to the managed array.
+ */ 
+    void put(AcceptedElementType[] items)
+    {
+        for (; !items.empty(); items.popFront()) {
+            put(items.front());
+        }
+    }
+
+    static if (is(Unqual!(T) == wchar) || is(Unqual!(T) == dchar))
+    {
+/**
+In case the managed array has type $(D char[]), $(D wchar[]), or $(D
+dchar[]), all other character widths and arrays thereof are also
+accepted.
+ */
+        void put(in char c) { encode!(T)((&c)[0 .. 1], this); }
+/// Ditto
+        void put(in char[] cs)
+        {
+            encode!(T)(cs, this);
+        }
+    }
+    static if (is(Unqual!(T) == char) || is(Unqual!(T) == dchar))
+    {
+/// Ditto
+        void put(in wchar dc) { assert(false); }
+/// Ditto
+        void put(in wchar[] dcs)
+        {
+            encode!(T)(dcs, this);
+        }
+    }
+    static if (is(Unqual!(T) == char) || is(Unqual!(T) == wchar))
+    {
+/// Ditto
+        void put(in dchar dc) { std.utf.encode(*pArray, dc); }
+/// Ditto
+        void put(in dchar[] wcs)
+        {
+            encode!(T)(wcs, this);
+        }
+    }
+
+/**
+Clears the managed array.
+*/
+    void clear()
+    {
+        if (!pArray) return;
+        pArray.length = 0;
+        //_capacity = .capacity(pArray.ptr) / T.sizeof;
+        _capacity = GC.sizeOf(pArray.ptr) / T.sizeof;
+    }
+}
+
+/**
+Convenience function that returns an $(D Appender!(T)) object
+initialized with $(D t).
+ */ 
+Appender!(E[]) appender(A : E[], E)(A * array = null)
+{
+    return Appender!(E[])(array);
+}
+
+unittest
+{
+    auto arr = new char[0];
+    auto app = appender(&arr);
+    string b = "abcdefg";
+    foreach (char c; b) app.put(c);
+    assert(app.data == "abcdefg");
+
+    int[] a = [ 1, 2 ];
+    auto app2 = appender(&a);
+    app2.put(3);
+    app2.put([ 4, 5, 6 ]);
+    assert(app2.data == [ 1, 2, 3, 4, 5, 6 ]);
+}
+
diff -r f12bfe124807 d/phobos2/std/base64.d
--- a/d/phobos2/std/base64.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/base64.d	Thu Oct 14 14:12:53 2010 +0100
@@ -68,7 +68,7 @@
  * Returns the number of bytes needed to encode a string of length slen.
  */
 
-size_t encodeLength(size_t slen)
+uint encodeLength(uint slen)
 {
 	uint result;
 	result = slen / 3;
@@ -96,9 +96,9 @@
 	if(!str.length)
 		return buf[0 .. 0];
 	
-	size_t stri;
-	size_t strmax = str.length / 3;
-	size_t strleft = str.length % 3;
+	uint stri;
+	uint strmax = str.length / 3;
+	uint strleft = str.length % 3;
 	uint x;
 	const(char)* sp;
 	char* bp;
@@ -168,7 +168,7 @@
  * Returns the number of bytes needed to decode an encoded string of this
  * length.
  */
-size_t decodeLength(size_t elen)
+uint decodeLength(uint elen)
 {
 	return elen / 4 * 3;
 }
@@ -228,8 +228,8 @@
 	if(estr.length % 4)
 		throw new Base64Exception("Invalid encoded base64 string");
 	
-	size_t estri;
-	size_t estrmax = estr.length / 4;
+	uint estri;
+	uint estrmax = estr.length / 4;
 	uint x;
 	const(char)* sp;
 	char* bp;
diff -r f12bfe124807 d/phobos2/std/bigint.d
--- a/d/phobos2/std/bigint.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/bigint.d	Thu Oct 14 14:12:53 2010 +0100
@@ -1439,9 +1439,8 @@
 
 // Unittests
 
-unittest
+debug unittest
 {
-
     // This block of unittests demonstrates that we can shrink arrays correctly
     {
         auto a = makeBig( 0x00000000 );
@@ -1475,7 +1474,6 @@
         auto r = shrink(a);
         assert(r.digits == b.digits, hex(r));
     }
-
     // This block of unittests demonstrates that neg(Big) works
     {
         auto x = makeBig( 0x66666666, 0x66666660 );
diff -r f12bfe124807 d/phobos2/std/bind.d
--- a/d/phobos2/std/bind.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/bind.d	Thu Oct 14 14:12:53 2010 +0100
@@ -19,10 +19,6 @@
 import std.traits;
 import std.typetuple;
 
-
-
-
-
 struct DynArg(int i) {
 	static assert (i >= 0);
 	
@@ -552,7 +548,7 @@
 	}
 	
 	/**
-		Get a delegate. Equivalent to getting it thru &foo.call
+		Get a delegate. Equivalent to getting it thru &amp;foo.call
 	*/
 	PtrType!() ptr() {
 		return &this.func;
diff -r f12bfe124807 d/phobos2/std/bitmanip.d
--- a/d/phobos2/std/bitmanip.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/bitmanip.d	Thu Oct 14 14:12:53 2010 +0100
@@ -35,6 +35,11 @@
         // No need to create any accessor
         enum result = "";
     }
+    else static if (len == 0)
+    {
+        // Fields of length 0 are always zero
+        enum result = "enum "~T.stringof~" "~name~" = 0;\n";
+    }
     else
     {
         static if (len + offset <= uint.sizeof * 8)
@@ -61,7 +66,7 @@
             static assert(len == 1);
             enum result = 
             // getter
-                "bool " ~ name ~ "(){ return "
+                "bool " ~ name ~ "() const { return "
                 ~"("~store~" & "~myToString!(maskAllElse)~") != 0;}\n"
             // setter
                 ~"void " ~ name ~ "(bool v){"
@@ -71,7 +76,7 @@
         else
         {
             // getter
-            enum result = T.stringof~" "~name~"()const{ auto result = "
+            enum result = T.stringof~" "~name~"() const { auto result = "
                 "("~store~" & "
                 ~ myToString!(maskAllElse) ~ ") >>"
                 ~ myToString!(offset) ~ ";"
@@ -199,6 +204,7 @@
                   ubyte, "exponent",  8,
                   bool,  "sign",      1));
     }
+    enum uint bias = 127, fractionBits = 23, exponentBits = 8, signBits = 1;
 }
 ----
 */
@@ -213,6 +219,7 @@
                   ubyte, "exponent",  8,
                   bool,  "sign",      1));
     }
+    enum uint bias = 127, fractionBits = 23, exponentBits = 8, signBits = 1;
 }
 
 /**
@@ -230,6 +237,7 @@
                   ushort,  "exponent", 11,
                   bool,    "sign",      1));
     }
+    enum uint bias = 1023, signBits = 1, fractionBits = 52, exponentBits = 11;
 }
 ----
 */
@@ -244,6 +252,7 @@
                   ushort, "exponent", 11,
                   bool,   "sign",      1));
     }
+    enum uint bias = 1023, signBits = 1, fractionBits = 52, exponentBits = 11;
 }
 
 unittest
@@ -398,7 +407,7 @@
         for (size_t i = 0; i < len; i++)
         {   bool b = opIndex(i);
             result = dg(b);
-            (this)[i] = b;
+            this[i] = b;
             if (result)
                 break;
         }
@@ -413,7 +422,7 @@
         for (size_t i = 0; i < len; i++)
         {   bool b = opIndex(i);
             result = dg(i, b);
-            (this)[i] = b;
+            this[i] = b;
             if (result)
                 break;
         }
@@ -472,9 +481,9 @@
                 hi = len - 1;
                 for (; lo < hi; lo++, hi--)
                 {
-                    t = (this)[lo];
-                    (this)[lo] = (this)[hi];
-                    (this)[hi] = t;
+                    t = this[lo];
+                    this[lo] = this[hi];
+                    this[hi] = t;
                 }
             }
             return this;
@@ -520,7 +529,7 @@
                     {
                         if (lo >= hi)
                             goto Ldone;
-                        if ((this)[lo] == true)
+                        if (this[lo] == true)
                             break;
                         lo++;
                     }
@@ -529,13 +538,13 @@
                     {
                         if (lo >= hi)
                             goto Ldone;
-                        if ((this)[hi] == false)
+                        if (this[hi] == false)
                             break;
                         hi--;
                     }
 
-                    (this)[lo] = false;
-                    (this)[hi] = true;
+                    this[lo] = false;
+                    this[hi] = true;
 
                     lo++;
                     hi--;
@@ -565,23 +574,23 @@
      */
 
     bool opEquals(BitArray a2)
-    {   size_t i;
+    {   int i;
 
         if (this.length != a2.length)
             return 0;                // not equal
-	uint *p1 = cast(uint*)this.ptr;
-	uint *p2 = cast(uint*)a2.ptr;
-	size_t n = this.length / (8 * uint.sizeof);
+        byte *p1 = cast(byte*)this.ptr;
+        byte *p2 = cast(byte*)a2.ptr;
+        uint n = this.length / 8;
         for (i = 0; i < n; i++)
         {
             if (p1[i] != p2[i])
                 return 0;                // not equal
         }
 
-	uint mask;
+        ubyte mask;
 
-	n = this.length & ((8 * uint.sizeof) - 1);
-	mask = (1 << n) - 1;
+        n = this.length & 7;
+        mask = cast(ubyte)((1 << n) - 1);
         //printf("i = %d, n = %d, mask = %x, %x, %x\n", i, n, mask, p1[i], p2[i]);
         return (mask == 0) || (p1[i] & mask) == (p2[i] & mask);
     }
@@ -614,21 +623,20 @@
 
     int opCmp(BitArray a2)
     {
-	size_t len;
-	size_t i;
+        uint len;
+        uint i;
 
         len = this.length;
         if (a2.length < len)
             len = a2.length;
-	uint* p1 = cast(uint*)this.ptr;
-	uint* p2 = cast(uint*)a2.ptr;
-	size_t n = len / (8 * uint.sizeof);
+        ubyte* p1 = cast(ubyte*)this.ptr;
+        ubyte* p2 = cast(ubyte*)a2.ptr;
+        uint n = len / 8;
         for (i = 0; i < n; i++)
         {
             if (p1[i] != p2[i])
                 break;                // not equal
         }
-	/*	
         for (uint j = i * 8; j < len; j++)
         {   ubyte mask = cast(ubyte)(1 << j);
             int c;
@@ -638,22 +646,6 @@
                 return c;
         }
         return cast(int)this.len - cast(int)a2.length;
-	*/
-	uint mask = 1;
-	for (size_t j = i * (8 * uint.sizeof); j < len; j++)
-	{   int c;
-
-	    c = cast(int)(p1[i] & mask) - cast(int)(p2[i] & mask);
-	    if (c)
-		return c;
-	    mask <<= 1;
-	}
-	ptrdiff_t c = cast(ptrdiff_t)this.len - cast(ptrdiff_t)a2.length;
-	if (c < 0)
-	    return -1;
-	else if (c > 0)
-	    return 1;
-	return 0;
     }
 
     unittest
@@ -692,7 +684,7 @@
         length = ba.length;
         foreach (i, b; ba)
         {
-            (this)[i] = b;
+            this[i] = b;
         }
     }
 
@@ -1106,7 +1098,7 @@
     BitArray opCatAssign(bool b)
     {
         length = len + 1;
-        (this)[len - 1] = b;
+        this[len - 1] = b;
         return this;
     }
 
@@ -1139,7 +1131,7 @@
         auto istart = len;
         length = len + b.length;
         for (auto i = istart; i < len; i++)
-            (this)[i] = b[i - istart];
+            this[i] = b[i - istart];
         return this;
     }
 
@@ -1186,7 +1178,7 @@
         r.length = len + 1;
         r[0] = b;
         for (size_t i = 0; i < len; i++)
-            r[1 + i] = (this)[i];
+            r[1 + i] = this[i];
         return r;
     }
 
diff -r f12bfe124807 d/phobos2/std/boxer.d
--- a/d/phobos2/std/boxer.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/boxer.d	Thu Oct 14 14:12:53 2010 +0100
@@ -72,11 +72,10 @@
 /* NOTE: This file has been patched from the original DMD distribution to
    work with the GDC compiler.
 
-   Modified by David Friedman, May 2005
-
    This module make not work on all GCC targets due to assumptions
    about the type of va_list.
 */
+
 module std.boxer;
 
 private import std.format;
@@ -156,11 +155,6 @@
     Other, /**< Any other type, such as delegates, function pointers, struct, void... */
 }
 
-version (DigitalMars)
-    version = DigitalMars_TypeInfo;
-else version (GNU)
-    version = DigitalMars_TypeInfo;
-
 /**
  * Box is a generic container for objects (both value and heap), allowing the
  * user to box them in a generic form and recover them later.
@@ -178,7 +172,7 @@
         void* p_longData; /**< An array of the contained object. */
         void[8] p_shortData; /**< Data used when the object is small. */
     }
-
+    
     private static TypeClass findTypeClass(TypeInfo type)
     {
         if (cast(TypeInfo_Class) type)
@@ -188,7 +182,7 @@
         if (isArrayTypeInfo(type))
             return TypeClass.Array;
 
-        version (DigitalMars_TypeInfo)
+        version (DigitalMars)
         {
             /* Depend upon the name of the base type classes. */
             if (type.classinfo.name.length != "TypeInfo_?".length)
@@ -432,38 +426,7 @@
 }
 body
 {
-    version (GNU)
-    {
-	// Help for promoted types
-	TypeInfo ti_orig = _arguments[0]; 
-	TypeInfo ti = ti_orig;
-	TypeInfo_Typedef ttd;
-	
-	while ( (ttd = cast(TypeInfo_Typedef) ti) !is null )
-	    ti = ttd.base;
-
-	if (ti is typeid(float))
-	{
-	    float f = va_arg!(float)(_argptr);
-	    return box(ti_orig, cast(void *) & f);
-	}
-	else if (ti is typeid(char) || ti is typeid(byte) || ti is typeid(ubyte))
-	{
-	    byte b = va_arg!(byte)(_argptr);
-	    return box(ti_orig, cast(void *) & b);
-	}
-	else if (ti is typeid(wchar) || ti is typeid(short) || ti is typeid(ushort))
-	{
-	    short s = va_arg!(short)(_argptr);
-	    return box(ti_orig, cast(void *) & s);
-	}
-	else if (ti is typeid(bool))
-	{
-	    bool b = va_arg!(bool)(_argptr);
-	    return box(ti_orig, cast(void *) & b);
-	}
-    }
-    return box(_arguments[0], cast(void*) _argptr);
+    return box(_arguments[0], _argptr);
 }
 
 /**
@@ -517,46 +480,7 @@
  */    
 Box[] boxArray(...)
 {
-    version (GNU)
-    {
-	Box[] array = new Box[_arguments.length];
-	
-	foreach(size_t index, TypeInfo ti_orig; _arguments)
-	{
-	    TypeInfo ti = ti_orig;
-	    TypeInfo_Typedef ttd;
-
-	    while ( (ttd = cast(TypeInfo_Typedef) ti) !is null )
-		ti = ttd.base;
-
-	    if (ti is typeid(float))
-	    {
-		float f = va_arg!(float)(_argptr);
-		array[index] = box(ti_orig, cast(void *) & f);
-	    }
-	    else if (ti is typeid(char) || ti is typeid(byte) || ti is typeid(ubyte))
-	    {
-		byte b = va_arg!(byte)(_argptr);
-		array[index] = box(ti_orig, cast(void *) & b);
-	    }
-	    else if (ti is typeid(wchar) || ti is typeid(short) || ti is typeid(ushort))
-	    {
-		short s = va_arg!(short)(_argptr);
-		array[index] = box(ti_orig, cast(void *) & s);
-	    }
-	    else if (ti is typeid(bool))
-	    {
-		bool b = va_arg!(bool)(_argptr);
-		array[index] = box(ti_orig, cast(void *) & b);
-	    }
-	    else
-		array[index] = box(ti_orig, cast(void*) _argptr);
-	}
-
-	return array;
-    }
-    else
-	return boxArray(_arguments, cast(void *) _argptr);
+    return boxArray(_arguments, _argptr);
 }
 
 /**
diff -r f12bfe124807 d/phobos2/std/c/fenv.d
--- a/d/phobos2/std/c/fenv.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/fenv.d	Thu Oct 14 14:12:53 2010 +0100
@@ -9,120 +9,4 @@
 
 module std.c.fenv;
 
-extern (C):
-
-/// Entire floating point environment
-
-struct fenv_t
-{
-    version (Windows)
-    {
-	ushort status;
-	ushort control;
-	ushort round;
-	ushort reserved[2];
-    }
-    else version (linux)
-    {
-	ushort __control_word;
-	ushort __unused1;
-	ushort __status_word;
-	ushort __unused2;
-	ushort __tags;
-	ushort __unused3;
-	uint __eip;
-	ushort __cs_selector;
-	ushort __opcode;
-	uint __data_offset;
-	ushort __data_selector;
-	ushort __unused5;
-	static if (size_t.sizeof == 8)
-	    uint __mxcsr;
-    }
-    else version (OSX)
-    {
-	ushort __control;
-	ushort __status;
-	uint __mxcsr;
-	char[8] __reserved;
-    }
-    else
-    {
-	static assert(0);
-    }
-}
-
-alias int fexcept_t;	/// Floating point status flags
-
-/// The various floating point exceptions
-enum
-{
-    FE_INVALID		= 1,		///
-    FE_DENORMAL		= 2,		///
-    FE_DIVBYZERO	= 4,		///
-    FE_OVERFLOW		= 8,		///
-    FE_UNDERFLOW	= 0x10,		///
-    FE_INEXACT		= 0x20,		///
-    FE_ALL_EXCEPT	= 0x3F,		/// Mask of all the exceptions
-}
-
-/// Rounding modes
-enum
-{
-    FE_TONEAREST	= 0,		///
-    FE_UPWARD		= 0x800,	///
-    FE_DOWNWARD		= 0x400,	///
-    FE_TOWARDZERO	= 0xC00,	///
-}
-
-version (Windows)
-{
-    extern fenv_t _FE_DFL_ENV;
-
-    /// Default floating point environment
-    fenv_t* FE_DFL_ENV = &_FE_DFL_ENV;
-}
-else version (OSX)
-{
-    extern fenv_t _FE_DFL_ENV;
-
-    /// Default floating point environment
-    fenv_t* FE_DFL_ENV = &_FE_DFL_ENV;
-}
-else version (linux)
-{
-    /// Default floating point environment
-    fenv_t* FE_DFL_ENV = cast(fenv_t*)(-1);
-}
-else
-{
-    static assert(0);
-}
-
-/// Floating point precision
-enum
-{
-    FE_FLTPREC	= 0,			///
-    FE_DBLPREC	= 0x200,		///
-    FE_LDBLPREC	= 0x300,		///
-}
-
-int fetestexcept(int excepts);		///
-int feraiseexcept(int excepts);		///
-int feclearexcept(int excepts);		///
-//int fegetexcept(fexcept_t *flagp,int excepts);	///
-//int fesetexcept(fexcept_t *flagp,int excepts);	///
-int fegetround();			///
-int fesetround(int round);		///
-int fegetprec();			///
-int fesetprec(int prec);		///
-int fegetenv(fenv_t *envp);		///
-int fesetenv(in fenv_t *envp);		///
-//void feprocentry(fenv_t *envp);	///
-//void feprocexit(const fenv_t *envp);	///
-
-int fegetexceptflag(fexcept_t *flagp,int excepts);	///
-int fesetexceptflag(in fexcept_t *flagp,int excepts);	///
-int feholdexcept(fenv_t *envp);		///
-int feupdateenv(in fenv_t *envp);		///
-
+public import core.stdc.fenv;
diff -r f12bfe124807 d/phobos2/std/c/linux/linux.d
--- a/d/phobos2/std/c/linux/linux.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/linux/linux.d	Thu Oct 14 14:12:53 2010 +0100
@@ -1,20 +1,51 @@
-// This is a backwards compatibility module for the DMD std.c.linux.linux
+
+/* Written by Walter Bright, Christopher E. Miller, and many others.
+ * http://www.digitalmars.com/d/
+ * Placed into public domain.
+ * Linux(R) is the registered trademark of Linus Torvalds in the U.S. and other
+ * countries.
+ */
 
 module std.c.linux.linux;
 
-public import std.c.unix.unix;
 public import std.c.linux.linuxextern;
+public import std.c.linux.pthread;
 
-extern (C)
+struct struct_stat64	// distinguish it from the stat() function
 {
-    /* From <dlfcn.h>
-     * See http://www.opengroup.org/onlinepubs/007908799/xsh/dlsym.html
-     */
+    ulong st_dev;	/// device
+    uint __pad1;
+    uint st_ino;	/// file serial number
+    uint st_mode;	/// file mode
+    uint st_nlink;	/// link count
+    uint st_uid;	/// user ID of file's owner
+    uint st_gid;	/// user ID of group's owner
+    ulong st_rdev;	/// if device then device number
+    uint __pad2;
+    align(4) ulong st_size;
+    int st_blksize;	/// optimal I/O block size
+    ulong st_blocks;	/// number of allocated 512 byte blocks
+    int st_atime;
+    uint st_atimensec;
+    int st_mtime;
+    uint st_mtimensec;
+    int st_ctime;
+    uint st_ctimensec;
 
-    const int RTLD_NOW = 0x00002;	// Correct for Red Hat 8
+    ulong st_ino64;
+}
+int fstat64(int, struct_stat64*);
+int fstat64(in char*, struct_stat64*);
 
-    void* dlopen(in char* file, int mode);
-    int   dlclose(void* handle);
-    void* dlsym(void* handle, const(char)* name);
-    char* dlerror();
-}
+public import core.sys.posix.dirent;
+public import core.sys.posix.dlfcn;
+public import core.sys.posix.fcntl;
+public import core.sys.posix.pwd;
+public import core.sys.posix.time;
+public import core.sys.posix.unistd;
+public import core.sys.posix.utime;
+public import core.sys.posix.sys.mman;
+public import core.sys.posix.sys.stat;
+public import core.sys.posix.sys.time;
+public import core.sys.posix.sys.types;
+public import core.sys.posix.sys.wait;
diff -r f12bfe124807 d/phobos2/std/c/linux/linuxextern.d
--- a/d/phobos2/std/c/linux/linuxextern.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/linux/linuxextern.d	Thu Oct 14 14:12:53 2010 +0100
@@ -11,14 +11,13 @@
  */
 
 module std.c.linux.linuxextern;
-private import std.stdint;
 
 extern (C)
 {
     extern void* __libc_stack_end;
     extern int __data_start;
     extern int _end;
-    extern Clong_t timezone;
+    extern int timezone;
 
     extern void *_deh_beg;
     extern void *_deh_end;
diff -r f12bfe124807 d/phobos2/std/c/linux/socket.d
--- a/d/phobos2/std/c/linux/socket.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/linux/socket.d	Thu Oct 14 14:12:53 2010 +0100
@@ -1,511 +1,131 @@
 /*
-	Written by Christopher E. Miller
-	Placed into public domain.
+    Written by Christopher E. Miller
+    Placed into public domain.
 */
 
 
 module std.c.linux.socket;
 
-private import std.stdint;
-private import std.c.linux.linux;
+private import core.stdc.stdint;
+public import core.sys.posix.arpa.inet;
+public import core.sys.posix.netinet.tcp;
+public import core.sys.posix.netinet.in_;
+public import core.sys.posix.sys.select;
+public import core.sys.posix.sys.socket;
 
 extern(C):
 
-version (linux)
+enum: int
 {
-    alias int socklen_t;
+    AF_IPX =        4,
+    AF_APPLETALK =  5,
+    PF_IPX =        AF_IPX,
+    PF_APPLETALK =  AF_APPLETALK,
+} 
 
-    enum: int
+enum: int
+{
+    SOCK_RDM =      4,
+} 
+
+enum: int
+{
+    IPPROTO_IGMP =  2,
+    IPPROTO_GGP =   3,
+    IPPROTO_PUP =   12,
+    IPPROTO_IDP =   22,
+    IPPROTO_ND =    77,
+    IPPROTO_RAW =   255,
+
+    IPPROTO_MAX =   256,
+}
+
+struct protoent
+{
+    char* p_name;
+    char** p_aliases;
+    int32_t p_proto;
+} 
+
+protoent* getprotobyname(in char* name);
+protoent* getprotobynumber(int number);
+
+struct servent
+{
+    char* s_name;
+    char** s_aliases;
+    int32_t s_port;
+    char* s_proto;
+}
+
+servent* getservbyname(in char* name, in char* proto);
+servent* getservbyport(int port, in char* proto);
+
+struct hostent
+{
+    char* h_name;
+    char** h_aliases;
+    int32_t h_addrtype;
+    int32_t h_length;
+    char** h_addr_list;
+
+
+    char* h_addr()
     {
-	AF_UNSPEC =     0,
-	AF_UNIX =       1,
-	AF_INET =       2,
-	AF_IPX =        4,
-	AF_APPLETALK =  5,
-	AF_INET6 =      10,
-	// ...
-	
-	PF_UNSPEC =     AF_UNSPEC,
-	PF_UNIX =       AF_UNIX,
-	PF_INET =       AF_INET,
-	PF_IPX =        AF_IPX,
-	PF_APPLETALK =  AF_APPLETALK,
-	PF_INET6 =      AF_INET6,
-    }
-
-    enum: int
-    {
-	SOL_SOCKET =  1,
-    }
-
-    enum: int
-    {
-	SO_DEBUG =       1,
-	SO_BROADCAST =   6,
-	SO_REUSEADDR =   2,
-	SO_LINGER =      13,
-	SO_DONTLINGER =  ~SO_LINGER,
-	SO_OOBINLINE =   10,
-	SO_SNDBUF =      7,
-	SO_RCVBUF =      8,
-	SO_ACCEPTCONN =  30,
-	SO_DONTROUTE =   5,
-	SO_TYPE =        3,
-	
-	TCP_NODELAY =    1,
-	
-	IP_MULTICAST_LOOP =  34,
-	IP_ADD_MEMBERSHIP =  35,
-	IP_DROP_MEMBERSHIP = 36,
-	
-	// ...
-	
-	IPV6_ADDRFORM =        1,
-	IPV6_PKTINFO =         2,
-	IPV6_HOPOPTS =         3,
-	IPV6_DSTOPTS =         4,
-	IPV6_RTHDR =           5,
-	IPV6_PKTOPTIONS =      6,
-	IPV6_CHECKSUM =        7,
-	IPV6_HOPLIMIT =        8,
-	IPV6_NEXTHOP =         9,
-	IPV6_AUTHHDR =         10,
-	IPV6_UNICAST_HOPS =    16,
-	IPV6_MULTICAST_IF =    17,
-	IPV6_MULTICAST_HOPS =  18,
-	IPV6_MULTICAST_LOOP =  19,
-	IPV6_JOIN_GROUP =      20,
-	IPV6_LEAVE_GROUP =     21,
-	IPV6_ROUTER_ALERT =    22,
-	IPV6_MTU_DISCOVER =    23,
-	IPV6_MTU =             24,
-	IPV6_RECVERR =         25,
-	IPV6_V6ONLY =          26,
-	IPV6_JOIN_ANYCAST =    27,
-	IPV6_LEAVE_ANYCAST =   28,
-	IPV6_IPSEC_POLICY =    34,
-	IPV6_XFRM_POLICY =     35,
-    }
-
-    enum: int
-    {
-	MSG_OOB =        0x1,
-	MSG_PEEK =       0x2,
-	MSG_DONTROUTE =  0x4,
-        MSG_NOSIGNAL =   0x4000,
-    }
-
-    enum: int
-    {
-	SD_RECEIVE =  0,
-	SD_SEND =     1,
-	SD_BOTH =     2,
-    }
-
-    struct sockaddr
-    {
-	int16_t sa_family;               
-	ubyte[14] sa_data;             
-    }
-
-    struct sockaddr_in
-    {
-	int16_t sin_family = AF_INET;
-	uint16_t sin_port;
-	in_addr sin_addr;
-	ubyte[8] sin_zero;
-    }
-
-    struct sockaddr_in6
-    {
-	int16_t sin6_family = AF_INET6;
-	uint16_t sin6_port;
-	uint32_t sin6_flowinfo;
-	in6_addr sin6_addr;
-	uint32_t sin6_scope_id;
-    }
-
-    struct addrinfo
-    {
-	int32_t ai_flags; 
-	int32_t ai_family;
-	int32_t ai_socktype;
-	int32_t ai_protocol;
-	size_t ai_addrlen;
-	sockaddr* ai_addr;
-	char* ai_canonname;
-	addrinfo* ai_next;
+        return h_addr_list[0];
     }
 }
-else version (OSX)
-{
-    alias uint socklen_t;
 
-    enum: int
-    {
-	AF_UNSPEC =     0,
-	AF_UNIX =       1,
-	AF_INET =       2,
-	AF_IPX =        23,
-	AF_APPLETALK =  16,
-	AF_INET6 =      30,
-	// ...
-	
-	PF_UNSPEC =     AF_UNSPEC,
-	PF_UNIX =       AF_UNIX,
-	PF_INET =       AF_INET,
-	PF_IPX =        AF_IPX,
-	PF_APPLETALK =  AF_APPLETALK,
-	PF_INET6 =      AF_INET6,
-    }
-
-    enum: int
-    {
-	SOL_SOCKET =  0xFFFF,
-    }
-
-    enum: int
-    {
-	SO_DEBUG =       1,
-	SO_BROADCAST =   0x20,
-	SO_REUSEADDR =   4,
-	SO_LINGER =      0x80,
-	//SO_DONTLINGER =  ~SO_LINGER,
-	SO_OOBINLINE =   0x100,
-	SO_SNDBUF =      0x1001,
-	SO_RCVBUF =      0x1002,
-	SO_ACCEPTCONN =  2,
-	SO_DONTROUTE =   0x10,
-	SO_TYPE =        0x1008,
-
-	TCP_NODELAY =    1,
-
-	IP_MULTICAST_LOOP =  11,
-	IP_ADD_MEMBERSHIP =  12,
-	IP_DROP_MEMBERSHIP = 13,
-	
-	// ...
-	
-	//IPV6_ADDRFORM =        1,
-	IPV6_PKTINFO =         19,
-	IPV6_HOPOPTS =         22,
-	IPV6_DSTOPTS =         23,
-	IPV6_RTHDR =           24,
-	IPV6_PKTOPTIONS =      25,
-	IPV6_CHECKSUM =        26,
-	IPV6_HOPLIMIT =        20,
-	IPV6_NEXTHOP =         21,
-	//IPV6_AUTHHDR =         10,
-	IPV6_UNICAST_HOPS =    4,
-	IPV6_MULTICAST_IF =    9,
-	IPV6_MULTICAST_HOPS =  10,
-	IPV6_MULTICAST_LOOP =  11,
-	IPV6_JOIN_GROUP =      12,
-	IPV6_LEAVE_GROUP =     13,
-	//IPV6_ROUTER_ALERT =    22,
-	//IPV6_MTU_DISCOVER =    23,
-	//IPV6_MTU =             24,
-	//IPV6_RECVERR =         25,
-	IPV6_V6ONLY =          27,
-	//IPV6_JOIN_ANYCAST =    27,
-	//IPV6_LEAVE_ANYCAST =   28,
-	IPV6_IPSEC_POLICY =    28,
-	//IPV6_XFRM_POLICY =     35,
-    }
-    enum: int
-    {
-	MSG_OOB =        0x1,
-	MSG_PEEK =       0x2,
-	MSG_DONTROUTE =  0x4,
-        MSG_NOSIGNAL =   0x4000,
-    }
-
-    enum: int
-    {
-	SHUT_RD   =  0,
-	SHUT_WR   =  1,
-	SHUT_RDWR =  2,
-    }
-
-    enum: int	// not defined in OSX, but we'll do it
-    {
-	SD_RECEIVE =  SHUT_RD,
-	SD_SEND =     SHUT_WR,
-	SD_BOTH =     SHUT_RDWR,
-    }
-
-    alias ubyte sa_family_t;
-    struct sockaddr
-    {
-	ubyte sa_len;
-	sa_family_t sa_family;               
-	ubyte[14] sa_data;             
-    }
-
-    alias uint in_addr_t;
-    alias ushort in_port_t;
-
-    struct sockaddr_in
-    {
-	ubyte sin_len;
-	sa_family_t sin_family;
-	in_port_t sin_port;
-	in_addr sin_addr;
-	ubyte[8] sin_zero;
-    }
-
-    struct sockaddr_in6
-    {
-	ubyte sin6_len;
-	sa_family_t sin6_family;
-	in_port_t sin6_port;
-	uint sin6_flowinfo;
-	in6_addr sin6_addr;
-	uint sin6_scope_id;
-    }
-
-    struct addrinfo
-    {
-	int ai_flags; 
-	int ai_family;
-	int ai_socktype;
-	int ai_protocol;
-	socklen_t ai_addrlen;
-	char* ai_canonname;
-	sockaddr* ai_addr;
-	addrinfo* ai_next;
-    }
-}
-else
-{
-    static assert(0);
-}
-
-const int F_GETFL =       3;
-const int F_SETFL =       4;
-
-int socket(int af, int type, int protocol);
-int bind(int s, sockaddr* name, int namelen);
-int connect(int s, sockaddr* name, int namelen);
-int listen(int s, int backlog);
-int accept(int s, sockaddr* addr, int* addrlen);
-int shutdown(int s, int how);
-int getpeername(int s, sockaddr* name, int* namelen);
-int getsockname(int s, sockaddr* name, int* namelen);
-int send(int s, const(void)* buf, int len, int flags);
-int sendto(int s, const(void)* buf, int len, int flags, sockaddr* to, int tolen);
-int recv(int s, void* buf, int len, int flags);
-int recvfrom(int s, void* buf, int len, int flags, sockaddr* from, int* fromlen);
-int getsockopt(int s, int level, int optname, void* optval, int* optlen);
-int setsockopt(int s, int level, int optname, void* optval, int optlen);
-uint inet_addr(in char* cp);
-char* inet_ntoa(in_addr ina);
 hostent* gethostbyname(in char* name);
 int gethostbyname_r(in char* name, hostent* ret, void* buf, size_t buflen, hostent** result, int* h_errnop);
 int gethostbyname2_r(in char* name, int af, hostent* ret, void* buf, size_t buflen, hostent** result, int* h_errnop);
 hostent* gethostbyaddr(void* addr, int len, int type);
-protoent* getprotobyname(in char* name);
-protoent* getprotobynumber(int number);
-servent* getservbyname(in char* name, in char* proto);
-servent* getservbyport(int port, in char* proto);
-int gethostname(in char* name, int namelen);
-int getaddrinfo(in char* nodename, in char* servname, addrinfo* hints, addrinfo** res);
-void freeaddrinfo(addrinfo* ai);
-int getnameinfo(sockaddr* sa, socklen_t salen, in char* node, socklen_t nodelen, char* service, socklen_t servicelen, int flags);
-
-
-struct linger
-{
-	int32_t l_onoff;
-	int32_t l_linger;
-}
-
-struct protoent
-{
-	char* p_name;
-	char** p_aliases;
-	int32_t p_proto;
-}
-
-
-struct servent
-{
-	char* s_name;
-	char** s_aliases;
-	int32_t s_port;
-	char* s_proto;
-}
-
-
-version(BigEndian)
-{
-	uint16_t htons(uint16_t x)
-	{
-		return x;
-	}
-	
-	
-	uint32_t htonl(uint32_t x)
-	{
-		return x;
-	}
-}
-else version(LittleEndian)
-{
-	private import std.intrinsic;
-	
-	
-	uint16_t htons(uint16_t x)
-	{
-		return cast(uint16_t)((x >> 8) | (x << 8));
-	}
-
-
-	uint32_t htonl(uint32_t x)
-	{
-		return bswap(x);
-	}
-}
-else
-{
-	static assert(0);
-}
-
-
-uint16_t ntohs(uint16_t x)
-{
-	return htons(x);
-}
-
-
-uint32_t ntohl(uint32_t x)
-{
-	return htonl(x);
-}
-
 
 enum: int
 {
-	SOCK_STREAM =     1,
-	SOCK_DGRAM =      2,
-	SOCK_RAW =        3,
-	SOCK_RDM =        4,
-	SOCK_SEQPACKET =  5,
+    SD_RECEIVE =  0,
+    SD_SEND =     1,
+    SD_BOTH =     2,
 }
 
-
 enum: int
 {
-	IPPROTO_IP =    0,
-	IPPROTO_ICMP =  1,
-	IPPROTO_IGMP =  2,
-	IPPROTO_GGP =   3,
-	IPPROTO_TCP =   6,
-	IPPROTO_PUP =   12,
-	IPPROTO_UDP =   17,
-	IPPROTO_IDP =   22,
-	IPPROTO_IPV6 =  41,
-	IPPROTO_ND =    77,
-	IPPROTO_RAW =   255,
-	
-	IPPROTO_MAX =   256,
+    MSG_NOSIGNAL =   0x4000,
 }
 
+enum: int
+{   
+    IP_MULTICAST_LOOP =  34,
+    IP_ADD_MEMBERSHIP =  35,
+    IP_DROP_MEMBERSHIP = 36,
+
+    // ...
+
+    IPV6_ADDRFORM =        1,
+    IPV6_PKTINFO =         2,
+    IPV6_HOPOPTS =         3,
+    IPV6_DSTOPTS =         4,
+    IPV6_RTHDR =           5,
+    IPV6_PKTOPTIONS =      6,
+    IPV6_CHECKSUM =        7,
+    IPV6_HOPLIMIT =        8,
+    IPV6_NEXTHOP =         9,
+    IPV6_AUTHHDR =         10,
+    IPV6_MULTICAST_HOPS =  18,
+    IPV6_ROUTER_ALERT =    22,
+    IPV6_MTU_DISCOVER =    23,
+    IPV6_MTU =             24,
+    IPV6_RECVERR =         25,
+    IPV6_V6ONLY =          26,
+    IPV6_JOIN_ANYCAST =    27,
+    IPV6_LEAVE_ANYCAST =   28,
+    IPV6_IPSEC_POLICY =    34,
+    IPV6_XFRM_POLICY =     35,
+}
 
 enum: uint
 {
-	INADDR_ANY =        0,
-	INADDR_LOOPBACK =   0x7F000001,
-	INADDR_BROADCAST =  0xFFFFFFFF,
-	INADDR_NONE =       0xFFFFFFFF,
-	ADDR_ANY =          INADDR_ANY,
+    INADDR_LOOPBACK =   0x7F000001,
+    INADDR_BROADCAST =  0xFFFFFFFF,
+    INADDR_NONE =       0xFFFFFFFF,
 }
-
-
-enum: int
-{
-	AI_PASSIVE = 0x1,
-	AI_CANONNAME = 0x2,
-	AI_NUMERICHOST = 0x4,
-}
-
-
-union in_addr
-{
-	private union _S_un_t
-	{
-		private struct _S_un_b_t
-		{
-			uint8_t s_b1, s_b2, s_b3, s_b4;
-		}
-		_S_un_b_t S_un_b;
-		
-		private struct _S_un_w_t
-		{
-			uint16_t s_w1, s_w2;
-		}
-		_S_un_w_t S_un_w;
-		
-		uint32_t S_addr;
-	}
-	_S_un_t S_un;
-	
-	uint32_t s_addr;
-	
-	struct
-	{
-		uint8_t s_net, s_host;
-		
-		union
-		{
-			uint16_t s_imp;
-			
-			struct
-			{
-				uint8_t s_lh, s_impno;
-			}
-		}
-	}
-}
-
-
-union in6_addr
-{
-	private union _in6_u_t
-	{
-		uint8_t[16] u6_addr8;
-		uint16_t[8] u6_addr16;
-		uint32_t[4] u6_addr32;
-	}
-	_in6_u_t in6_u;
-	
-	uint8_t[16] s6_addr8;
-	uint16_t[8] s6_addr16;
-	uint32_t[4] s6_addr32;
-}
-
-
-const in6_addr IN6ADDR_ANY = { s6_addr8: [0] };
-const in6_addr IN6ADDR_LOOPBACK = { s6_addr8: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1] };
-//alias IN6ADDR_ANY IN6ADDR_ANY_INIT;
-//alias IN6ADDR_LOOPBACK IN6ADDR_LOOPBACK_INIT;
-	
-const uint INET_ADDRSTRLEN = 16;
-const uint INET6_ADDRSTRLEN = 46;
-
-
-struct hostent
-{
-	char* h_name;
-	char** h_aliases;
-	int32_t h_addrtype;
-	int32_t h_length;
-	char** h_addr_list;
-	
-	
-	char* h_addr()
-	{
-		return h_addr_list[0];
-	}
-}
-
diff -r f12bfe124807 d/phobos2/std/c/linux/termios.d
--- a/d/phobos2/std/c/linux/termios.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/linux/termios.d	Thu Oct 14 14:12:53 2010 +0100
@@ -1,4 +1,7 @@
-// This is a compatibility module for the DMD std.c.linux.termios
 
-public import std.c.unix.unix;
 
+module std.c.linux.termios;
+
+extern (C):
+
+public import core.sys.posix.termios;
diff -r f12bfe124807 d/phobos2/std/c/locale.d
--- a/d/phobos2/std/c/locale.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/locale.d	Thu Oct 14 14:12:53 2010 +0100
@@ -2,150 +2,10 @@
  * C's &lt;locale.h&gt;
  * License: Public Domain
  * Standards:
- *	ISO/IEC 9899:1999 7.11 
+ *	ISO/IEC 9899:1999 7.11
  * Macros:
  *	WIKI=Phobos/StdCLocale
  */
 module std.c.locale;
 
-extern(C):
-
-/// Structure giving information about numeric and monetary notation.
-struct lconv{
-	/// The decimal-point character used to format nonmonetary quantities.
-	char* decimal_point;
-
-	/** The character used to separate groups of digits before the
-	 * decimal-point character in formatted nonmonetary quantities.
-	 **/
-	char* thousands_sep;
-
-	/** A string whose elements indicate the size of each group of digits
-	 * in formatted nonmonetary quantities.
-	 **/
-	char* grouping;
-
-	/** The international currency symbol applicable to the current locale.
-	 * The first three characters contain the alphabetic international
-	 * currency symbol in accordance with those specified in ISO 4217.
-	 * The fourth character	(immediately preceding the null character)
-	 * is the character used to separate the international currency symbol
-	 * from the monetary quantity.
-	 **/
-	char* int_curr_symbol;
-
-	/// The local currency symbol applicable to the current locale.
-	char* currency_symbol;
-
-	/// The decimal-point used to format monetary quantities.
-	char* mon_decimal_point;
-
-	/** The separator for groups of digits before the decimal-point in
-	 * formatted monetary quantities.
-	 **/
-	char* mon_thousands_sep;
-
-	/** A string whose elements indicate the size of each group of digits
-	 * in formatted monetary quantities.
-	 **/
-	char* mon_grouping;
-
-	/** The string used to indicate a nonnegative-valued formatted
-	 * monetary quantity.
-	 **/
-	char* positive_sign;
-
-	/** The string used to indicate a negative-valued formatted monetary
-	 * quantity.
-	 **/
-	char* negative_sign;
-
-	/** The number of fractional digits (those after the decimal-point) to
-	 * be displayed in an internationally formatted monetary quantity.
-	 **/
-	char int_frac_digits;
-
-	/** The number of fractional digits (those after the decimal-point) to
-	 * be displayed in a locally formatted monetary quantity.
-	 **/
-	char frac_digits;
-
-	/// 1 if currency_symbol precedes a positive value, 0 if succeeds.
-	char p_cs_precedes;
-	
-	/// 1 if a space separates currency_symbol from a positive value.
-	char p_sep_by_space;
-	
-	/// 1 if currency_symbol precedes a negative value, 0 if succeeds.
-	char n_cs_precedes;
-
-	/// 1 if a space separates currency_symbol from a negative value.
-	char n_sep_by_space;
-
-  /* Positive and negative sign positions:
-     0 Parentheses surround the quantity and currency_symbol.
-     1 The sign string precedes the quantity and currency_symbol.
-     2 The sign string follows the quantity and currency_symbol.
-     3 The sign string immediately precedes the currency_symbol.
-     4 The sign string immediately follows the currency_symbol.  */
-  char p_sign_posn;
-  char n_sign_posn;
-  
-	/// 1 if int_curr_symbol precedes a positive value, 0 if succeeds.
-	char int_p_cs_precedes;
-	
-	/// 1 iff a space separates int_curr_symbol from a positive value.
-	char int_p_sep_by_space;
-	
-	/// 1 if int_curr_symbol precedes a negative value, 0 if succeeds.
-	char int_n_cs_precedes;
-	
-	/// 1 iff a space separates int_curr_symbol from a negative value.
-	char int_n_sep_by_space;
-
-  /* Positive and negative sign positions:
-     0 Parentheses surround the quantity and int_curr_symbol.
-     1 The sign string precedes the quantity and int_curr_symbol.
-     2 The sign string follows the quantity and int_curr_symbol.
-     3 The sign string immediately precedes the int_curr_symbol.
-     4 The sign string immediately follows the int_curr_symbol.  */
-  char int_p_sign_posn;
-  char int_n_sign_posn;
-}
-
-/** Affects the behavior of C's character handling functions and C's multibyte
- * and wide character functions.
- **/
-const LC_CTYPE = 0; 
-
-/** Affects the decimal-point character for C's formatted input/output functions
- * and C's string conversion functions, as well as C's nonmonetary formatting
- * information returned by the localeconv function.
- **/
-const LC_NUMERIC = 1;
-
-/// Affects the behavior of the strftime and wcsftime functions.
-const LC_TIME = 2;
-
-/// Affects the behavior of the strcoll and strxfrm functions.
-const LC_COLLATE = 3;
-
-/** Affects the monetary formatting information returned by the localeconv
- * function.
- **/
-const LC_MONETARY = 4;
-
-/// The program's entire locale.
-const LC_ALL = 6;
-
-/** The setlocale function selects the appropriate portion of the program's
- * locale as specified by the category and locale arguments.
- **/
-char* setlocale(int category, const char* locale);
-
-/** The localeconv function sets the components of an object with type
- * lconv with values appropriate for the formatting of numeric quantities
- * (monetary and otherwise) according to the rules of the current locale.
- **/
-lconv* localeconv();
-
+public import core.stdc.locale;
diff -r f12bfe124807 d/phobos2/std/c/math.d
--- a/d/phobos2/std/c/math.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/math.d	Thu Oct 14 14:12:53 2010 +0100
@@ -7,460 +7,6 @@
  *	WIKI=Phobos/StdCMath
  */
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, September 2007
-*/
-
 module std.c.math;
 
-private import std.stdint;
-
-extern (C):
-
-alias float float_t;	///
-alias double double_t;	///
-
-const double HUGE_VAL  = double.infinity;	///
-const float HUGE_VALF = float.infinity;	/// ditto
-const real HUGE_VALL = real.infinity;	/// ditto
-
-const float INFINITY = float.infinity;	///
-const float NAN = float.nan;	///
-
-public import gcc.fpcls;
-
-enum
-{
-    FP_FAST_FMA  = 0,	///
-    FP_FAST_FMAF = 0,	///
-    FP_FAST_FMAL = 0,	///
-}
-
-const int FP_ILOGB0   = int.min;	///
-const int FP_ILOGBNAN = int.min;	///
-
-const int MATH_ERRNO     = 1;	///
-const int MATH_ERREXCEPT = 2;	///
-const int math_errhandling   = MATH_ERRNO | MATH_ERREXCEPT;	///
-
-version (GNU)
-{
-    private import gcc.builtins;
-    
-    double acos(double x);
-    float  acosf(float x);
-    
-    double asin(double x);
-    float  asinf(float x);
-    
-    double atan(double x);
-    float  atanf(float x);
-    
-    double atan2(double y, double x);
-    float  atan2f(float y, float x);
-    
-    double cos(double x);
-    float  cosf(float x);
-    
-    double sin(double x);
-    float  sinf(float x);
-    
-    double tan(double x);
-    float  tanf(float x);
-    
-    double acosh(double x);
-    float  acoshf(float x);
-    
-    double asinh(double x);
-    float  asinhf(float x);
-    
-    double atanh(double x);
-    float  atanhf(float x);
-    
-    double cosh(double x);
-    float  coshf(float x);
-    
-    double sinh(double x);
-    float  sinhf(float x);
-    
-    double tanh(double x);
-    float  tanhf(float x);
-    
-    double exp(double x);
-    float  expf(float x);
-    
-    double exp2(double x);
-    float  exp2f(float x);
-    
-    double expm1(double x);
-    float  expm1f(float x);
-    
-    double frexp(double value, int *exp);
-    float  frexpf(float value, int *exp);
-    
-    int    ilogb(double x);
-    int    ilogbf(float x);
-    
-    double ldexp(double x, int exp);
-    float  ldexpf(float x, int exp);
-    
-    double log(double x);
-    float  logf(float x);
-    
-    double log10(double x);
-    float  log10f(float x);
-    
-    double log1p(double x);
-    float  log1pf(float x);
-    
-    double log2(double x);
-    float  log2f(float x);
-    
-    double logb(double x);
-    float  logbf(float x);
-    
-    double modf(double value, double *iptr);
-    float  modff(float value, float *iptr);
-    
-    double scalbn(double x, int n);
-    float  scalbnf(float x, int n);
-    
-    double scalbln(double x, int n);
-    float  scalblnf(float x, int n);
-    
-    double cbrt(double x);
-    float  cbrtf(float x);
-    
-    double fabs(double x);
-    float  fabsf(float x);
-    
-    double hypot(double x, double y);
-    float  hypotf(float x, float y);
-    
-    double pow(double x, double y);
-    float  powf(float x, float y);
-    
-    double sqrt(double x);
-    float  sqrtf(float x);
-    
-    double erf(double x);
-    float  erff(float x);
-    
-    double erfc(double x);
-    float  erfcf(float x);
-    
-    double lgamma(double x);
-    float  lgammaf(float x);
-    
-    double tgamma(double x);
-    float  tgammaf(float x);
-    
-    double ceil(double x);
-    float  ceilf(float x);
-    
-    double floor(double x);
-    float  floorf(float x);
-    
-    double nearbyint(double x);
-    float  nearbyintf(float x);
-    
-    double rint(double x);
-    float  rintf(float x);
-    
-    Clong_t lrint(double x);
-    Clong_t lrintf(float x);
-    
-    long   llrint(double x);
-    long   llrintf(float x);
-    
-    double round(double x);
-    float  roundf(float x);
-    
-    Clong_t lround(double x);
-    Clong_t lroundf(float x);
-    
-    long   llround(double x);
-    long   llroundf(float x);
-    
-    double trunc(double x);
-    float  truncf(float x);
-    
-    double fmod(double x, double y);
-    float  fmodf(float x, float y);
-    
-    double remainder(double x, double y);
-    float  remainderf(float x, float y);
-    
-    double remquo(double x, double y, int *quo);
-    float  remquof(float x, float y, int *quo);
-    
-    double copysign(double x, double y);
-    float  copysignf(float x, float y);
-    
-    double nan(in char *tagp);
-    float  nanf(in char *tagp);
-    
-    double nextafter(double x, double y);
-    float  nextafterf(float x, float y);
-    
-    double nexttoward(double x, real y);
-    float  nexttowardf(float x, real y);
-    
-    double fdim(double x, double y);
-    float  fdimf(float x, float y);
-    
-    double fmax(double x, double y);
-    float  fmaxf(float x, float y);
-    
-    double fmin(double x, double y);
-    float  fminf(float x, float y);
-    
-    double fma(double x, double y, double z);
-    float  fmaf(float x, float y, float z);
-    
-    public import gcc.config.mathfuncs;
-} else {
-double acos(double x);	///
-float  acosf(float x);	/// ditto
-real   acosl(real x);	/// ditto
-
-double asin(double x);	///
-float  asinf(float x);	/// ditto
-real   asinl(real x);	/// ditto
-
-double atan(double x);	///
-float  atanf(float x);	/// ditto
-real   atanl(real x);	/// ditto
-
-double atan2(double y, double x);	///
-float  atan2f(float y, float x);	/// ditto
-real   atan2l(real y, real x);		/// ditto
-
-double cos(double x);	///
-float  cosf(float x);	/// ditto
-real   cosl(real x);	/// ditto
-
-double sin(double x);	///
-float  sinf(float x);	/// ditto
-real   sinl(real x);	/// ditto
-
-double tan(double x);	///
-float  tanf(float x);	/// ditto
-real   tanl(real x);	/// ditto
-
-double acosh(double x);	///
-float  acoshf(float x);	/// ditto
-real   acoshl(real x);	/// ditto
-
-double asinh(double x);	///
-float  asinhf(float x);	/// ditto
-real   asinhl(real x);	/// ditto
-
-double atanh(double x);	///
-float  atanhf(float x);	/// ditto
-real   atanhl(real x);	/// ditto
-
-double cosh(double x);	///
-float  coshf(float x);	/// ditto
-real   coshl(real x);	/// ditto
-
-double sinh(double x);	///
-float  sinhf(float x);	/// ditto
-real   sinhl(real x);	/// ditto
-
-double tanh(double x);	///
-float  tanhf(float x);	/// ditto
-real   tanhl(real x);	/// ditto
-
-double exp(double x);	///
-float  expf(float x);	/// ditto
-real   expl(real x);	/// ditto
-
-double exp2(double x);	///
-float  exp2f(float x);	/// ditto
-real   exp2l(real x);	/// ditto
-
-double expm1(double x);	///
-float  expm1f(float x);	/// ditto
-real   expm1l(real x);	/// ditto
-
-double frexp(double value, int *exp);	///
-float  frexpf(float value, int *exp);	/// ditto
-real   frexpl(real value, int *exp);	/// ditto
-
-int    ilogb(double x);	///
-int    ilogbf(float x);	/// ditto
-int    ilogbl(real x);	/// ditto
-
-double ldexp(double x, int exp);	///
-float  ldexpf(float x, int exp);	/// ditto
-real   ldexpl(real x, int exp);		/// ditto
-
-double log(double x);	///
-float  logf(float x);	/// ditto
-real   logl(real x);	/// ditto
-
-double log10(double x);	///
-float  log10f(float x);	/// ditto
-real   log10l(real x);	/// ditto
-
-double log1p(double x);	///
-float  log1pf(float x);	/// ditto
-real   log1pl(real x);	/// ditto
-
-double log2(double x);	///
-float  log2f(float x);	/// ditto
-real   log2l(real x);	/// ditto
-
-double logb(double x);	///
-float  logbf(float x);	/// ditto
-real   logbl(real x);	/// ditto
-
-double modf(double value, double *iptr);	///
-float  modff(float value, float *iptr);		/// ditto
-real   modfl(real value, real *iptr);		/// ditto
-
-double scalbn(double x, int n);	///
-float  scalbnf(float x, int n);	/// ditto
-real   scalbnl(real x, int n);	/// ditto
-
-double scalbln(double x, int n);	///
-float  scalblnf(float x, int n);	/// ditto
-real   scalblnl(real x, int n);		/// ditto
-
-double cbrt(double x);	///
-float  cbrtf(float x);	/// ditto
-real   cbrtl(real x);	/// ditto
-
-double fabs(double x);	///
-float  fabsf(float x);	/// ditto
-real   fabsl(real x);	/// ditto
-
-double hypot(double x, double y);	///
-float  hypotf(float x, float y);	/// ditto
-real   hypotl(real x, real y);		/// ditto
-
-double pow(double x, double y);	///
-float  powf(float x, float y);	/// ditto
-real   powl(real x, real y);	/// ditto
-
-double sqrt(double x);	///
-float  sqrtf(float x);	/// ditto
-real   sqrtl(real x);	/// ditto
-
-double erf(double x);	///
-float  erff(float x);	/// ditto
-real   erfl(real x);	/// ditto
-
-double erfc(double x);	///
-float  erfcf(float x);	/// ditto
-real   erfcl(real x);	/// ditto
-
-double lgamma(double x);	///
-float  lgammaf(float x);	/// ditto
-real   lgammal(real x);		/// ditto
-
-double tgamma(double x);	///
-float  tgammaf(float x);	/// ditto
-real   tgammal(real x);		/// ditto
-
-double ceil(double x);	///
-float  ceilf(float x);	/// ditto
-real   ceill(real x);	/// ditto
-
-double floor(double x);	///
-float  floorf(float x);	/// ditto
-real   floorl(real x);	/// ditto
-
-double nearbyint(double x);	///
-float  nearbyintf(float x);	/// ditto
-real   nearbyintl(real x);	/// ditto
-
-double rint(double x);	///
-float  rintf(float x);	/// ditto
-real   rintl(real x);	/// ditto
-
-Clong_t lrint(double x);	///
-Clong_t lrintf(float x);	/// ditto
-Clong_t lrintl(real x);	/// ditto
-
-long   llrint(double x);	///
-long   llrintf(float x);	/// ditto
-long   llrintl(real x);		/// ditto
-
-double round(double x);	///
-float  roundf(float x);	/// ditto
-real   roundl(real x);	/// ditto
-
-Clong_t lround(double x);	///
-Clong_t lroundf(float x);	/// ditto
-Clong_t lroundl(real x);		/// ditto
-
-long   llround(double x);	///
-long   llroundf(float x);	/// ditto
-long   llroundl(real x);	/// ditto
-
-double trunc(double x);	///
-float  truncf(float x);	/// ditto
-real   truncl(real x);	/// ditto
-
-double fmod(double x, double y);	///
-float  fmodf(float x, float y);		/// ditto
-real   fmodl(real x, real y);		/// ditto
-
-double remainder(double x, double y);	///
-float  remainderf(float x, float y);	/// ditto
-real   remainderl(real x, real y);	/// ditto
-
-double remquo(double x, double y, int *quo);	///
-float  remquof(float x, float y, int *quo);	/// ditto
-real   remquol(real x, real y, int *quo);	/// ditto
-
-double copysign(double x, double y);	///
-float  copysignf(float x, float y);	/// ditto
-real   copysignl(real x, real y);	/// ditto
-
-double nan(in char *tagp);		///
-float  nanf(in char *tagp);	/// ditto
-real   nanl(in char *tagp);	/// ditto
-
-double nextafter(double x, double y);	///
-float  nextafterf(float x, float y);	/// ditto
-real   nextafterl(real x, real y);	/// ditto
-
-double nexttoward(double x, real y);	///
-float  nexttowardf(float x, real y);	/// ditto
-real   nexttowardl(real x, real y);	/// ditto
-
-double fdim(double x, double y);	///
-float  fdimf(float x, float y);		/// ditto
-real   fdiml(real x, real y);		/// ditto
-
-double fmax(double x, double y);	///
-float  fmaxf(float x, float y);		/// ditto
-real   fmaxl(real x, real y);		/// ditto
-
-double fmin(double x, double y);	///
-float  fminf(float x, float y);		/// ditto
-real   fminl(real x, real y);		/// ditto
-
-double fma(double x, double y, double z);	///
-float  fmaf(float x, float y, float z);		/// ditto
-real   fmal(real x, real y, real z);		/// ditto
-}
-
-///
-int isgreater(real x, real y)		{ return !(x !>  y); }
-///
-int isgreaterequal(real x, real y)	{ return !(x !>= y); }
-///
-int isless(real x, real y)		{ return !(x !<  y); }
-///
-int islessequal(real x, real y)		{ return !(x !<= y); }
-///
-int islessgreater(real x, real y)	{ return !(x !<> y); }
-///
-int isunordered(real x, real y)		{ return (x !<>= y); }
-
+public import core.stdc.math;
\ No newline at end of file
diff -r f12bfe124807 d/phobos2/std/c/stdarg.d
--- a/d/phobos2/std/c/stdarg.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/stdarg.d	Thu Oct 14 14:12:53 2010 +0100
@@ -9,63 +9,6 @@
 
 /* This is for use with extern(C) variable argument lists. */
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, September 2004
-*/
-
 module std.c.stdarg;
 
-version (GNU) {
-    private import gcc.builtins;
-    alias __builtin_va_list va_list;
-    alias __builtin_va_end va_end;
-    alias __builtin_va_copy va_copy;
-
-    // The va_start and va_arg template functions are magically
-    // handled by the compiler.
-} else {
-
-alias void* va_list;
-
-void va_end(va_list ap)
-{
-
-}
-
-void va_copy(out va_list dest, va_list src)
-{
-    static if ( is( dest T == T[1]) ) {
-	dest[0] = src[0];
-    } else {
-	dest = src;
-    }
-}
-
-}
-
-template va_start(T)
-{
-    void va_start(out va_list ap, inout T parmn)
-    {
-	/*
-	ap = cast(va_list)(cast(void*)&parmn + ((T.sizeof + int.sizeof - 1) & ~(int.sizeof - 1)));
-	*/
-    }
-}
-
-template va_arg(T)
-{
-    T va_arg(inout va_list ap)
-    {
-	/*
-	T arg = *cast(T*)ap;
-	ap = cast(va_list)(cast(void*)ap + ((T.sizeof + int.sizeof - 1) & ~(int.sizeof - 1)));
-	return arg;
-	*/
-	T t;
-	return t;
-    }
-}
-
+public import core.stdc.stdarg;
diff -r f12bfe124807 d/phobos2/std/c/stddef.d
--- a/d/phobos2/std/c/stddef.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/stddef.d	Thu Oct 14 14:12:53 2010 +0100
@@ -9,28 +9,4 @@
 
 module std.c.stddef;
 
-version (GNU)
-{
-    import gcc.config.libc;
-    alias gcc.config.libc.wchar_t wchar_t;
-} 
-else version (Win32)
-{
-    alias wchar wchar_t;
-}
-else version (linux)
-{
-    alias dchar wchar_t;
-}
-else version (Unix)
-{
-    alias dchar wchar_t;
-}
-else version (OSX)
-{
-    alias dchar wchar_t;
-}
-else
-{
-    static assert(0);
-}
+public import core.stdc.stddef;
diff -r f12bfe124807 d/phobos2/std/c/stdio.d
--- a/d/phobos2/std/c/stdio.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/stdio.d	Thu Oct 14 14:12:53 2010 +0100
@@ -7,541 +7,26 @@
  *	WIKI=Phobos/StdCStdio
  */
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, September 2007
-*/
-
 
 
 module std.c.stdio;
 
-private import std.stdint;
-import std.c.stddef;
-private import std.c.stdarg;
+public import core.stdc.stdio;
 
 extern (C):
 
-version (GNU)
+version (Win32)
 {
-    private import gcc.builtins;
-    static import libc = gcc.config.libc;
-    alias libc.EOF EOF;
-    alias libc.FOPEN_MAX FOPEN_MAX;
-    alias libc.FILENAME_MAX FILENAME_MAX;
-    alias libc.TMP_MAX TMP_MAX;
-    alias libc.L_tmpnam L_tmpnam;
-}
-else version (Win32)
-{
+    extern FILE _iob[_NFILE];
+    extern void function() _fcloseallp;
+    extern ubyte __fhnd_info[_NFILE];
+
     enum
     {
-	int _NFILE = 60,	///
-	int BUFSIZ = 0x4000,	///
-	int EOF = -1,		///
-	int FOPEN_MAX = 20,	///
-	int FILENAME_MAX = 256,  /// 255 plus NULL
-	int TMP_MAX = 32767,	///
-	int _SYS_OPEN = 20,	///
-	int SYS_OPEN = _SYS_OPEN,	///
-	wchar WEOF = 0xFFFF,		///
+	FHND_APPEND	= 0x04,
+	FHND_DEVICE	= 0x08,
+	FHND_TEXT	= 0x10,
+	FHND_BYTE	= 0x20,
+	FHND_WCHAR	= 0x40,
     }
 }
-else version (linux)
-{
-    enum
-    {
-	int EOF = -1,
-	int FOPEN_MAX = 16,
-	int FILENAME_MAX = 4095,
-	int TMP_MAX = 238328,
-	int L_tmpnam = 20,
-    }
-}
-
-version (OSX)
-{
-    enum
-    {
-	int EOF = -1,
-	int BUFSIZ = 1024,
-	int FOPEN_MAX = 20,
-	int FILENAME_MAX = 1024,
-	int TMP_MAX = 308915776,
-	int L_tmpnam = 1024,
-    }
-
-    struct __sbuf
-    {
-	char* _base;
-	int _size;
-    }
-}
-
-version (FreeBSD)
-{
-    enum
-    {
-	int EOF = -1,
-	int BUFSIZ = 1024,
-	int FOPEN_MAX = 20,
-	int FILENAME_MAX = 1024,
-	int TMP_MAX = 308915776,
-	int L_tmpnam = 1024,
-    }
-
-    struct __sbuf
-    {
-	char* _base;
-	int _size;
-    }
-}
-
-enum { SEEK_SET, SEEK_CUR, SEEK_END }
-
-struct _iobuf
-{
-    align (1):
-    version (Win32)
-    {
-	char	*_ptr;
-	int	_cnt;
-	char	*_base;
-	int	_flag;
-	int	_file;
-	int	_charbuf;
-	int	_bufsiz;
-	int	__tmpnum;
-    }
-    else version (linux)
-    {
-	char*	_read_ptr;
-	char*	_read_end;
-	char*	_read_base;
-	char*	_write_base;
-	char*	_write_ptr;
-	char*	_write_end;
-	char*	_buf_base;
-	char*	_buf_end;
-	char*	_save_base;
-	char*	_backup_base;
-	char*	_save_end;
-	void*	_markers;
-	_iobuf*	_chain;
-	int	_fileno;
-	int	_blksize;
-	int	_old_offset;
-	ushort	_cur_column;
-	byte	_vtable_offset;
-	char[1]	_shortbuf;
-	void*	_lock;
-    }
-    else version (GNU) {
-	byte[libc.FILE_struct_size] opaque;
-    }
-    
-}
-
-alias _iobuf FILE;	///
-
-enum
-{
-    _F_RDWR = 0x0003,
-    _F_READ = 0x0001,
-    _F_WRIT = 0x0002,
-    _F_BUF  = 0x0004,
-    _F_LBUF = 0x0008,
-    _F_ERR  = 0x0010,
-    _F_EOF  = 0x0020,
-    _F_BIN  = 0x0040,
-    _F_IN   = 0x0080,
-    _F_OUT  = 0x0100,
-    _F_TERM = 0x0200,
-}
-
-version (Win32)
-{
-    version (GNU) {
-	// _NFILE is not defined anywhere
-	extern export FILE _iob[5];
-    } else {
-	extern FILE _iob[_NFILE];
-	extern void function() _fcloseallp;
-	extern ubyte __fhnd_info[_NFILE];
-
-	enum
-	{
-	    FHND_APPEND	= 0x04,
-	    FHND_DEVICE	= 0x08,
-	    FHND_TEXT	= 0x10,
-	    FHND_BYTE	= 0x20,
-	    FHND_WCHAR	= 0x40,
-	}
-    }
-    version (OSX)
-    {
-	char* _p;
-	int _r;
-	int _w;
-	short _flags;
-	short _file;
-	__sbuf _bf;
-	int _lbfsize;
-	void* _cookie;
-	int function(void*) _close;
-	int function(void*, char*, int) _read;
-	fpos_t function(void*, fpos_t, int) _seek;
-	int function(void*, char*, int) _write;
-	__sbuf _ub;
-	void* _extra;
-	int _ur;
-	char[3] _ubuf;
-	char[1] _nbuf;
-	__sbuf _lb;
-	int _blksize;
-	fpos_t _offset;
-    }
-    version (FreeBSD)
-    {
-	char* _p;
-	int _r;
-	int _w;
-	short _flags;
-	short _file;
-	__sbuf _bf;
-	int _lbfsize;
-	void* _cookie;
-	int function(void*) _close;
-	int function(void*, char*, int) _read;
-	fpos_t function(void*, fpos_t, int) _seek;
-	int function(void*, char*, int) _write;
-	__sbuf _ub;
-	void* _extra;
-	int _ur;
-	char[3] _ubuf;
-	char[1] _nbuf;
-	__sbuf _lb;
-	int _blksize;
-	fpos_t _offset;
-    }
-}
-
-version (Win32)
-{
-    enum
-    {
-	    _IOREAD	= 1,
-	    _IOWRT	= 2,
-	    _IONBF	= 4,
-	    _IOMYBUF	= 8,
-	    _IOEOF	= 0x10,
-	    _IOERR	= 0x20,
-	    _IOLBF	= 0x40,
-	    _IOSTRG	= 0x40,
-	    _IORW	= 0x80,
-	    _IOFBF	= 0,
-	    _IOAPP	= 0x200,
-	    _IOTRAN	= 0x100,
-    }
-}
-
-version (Posix)
-{
-    enum
-    {
-	    _IOFBF = 0,
-	    _IOLBF = 1,
-	    _IONBF = 2,
-    }
-}
-
-
-version (GNU_CBridge_Stdio)
-{
-    extern FILE * _d_gnu_cbridge_stdin;
-    extern FILE * _d_gnu_cbridge_stdout;
-    extern FILE * _d_gnu_cbridge_stderr;
-
-    /* Call from dgccmain2.  Can't use a static constructor here
-       because std.c.stdio is not compiled. */
-    extern void _d_gnu_cbridge_init_stdio();
-    
-    alias _d_gnu_cbridge_stdin stdin;
-    alias _d_gnu_cbridge_stdout stdout;
-    alias _d_gnu_cbridge_stderr stderr;
-}
-else version (Win32)
-{
-    // _iob is DLL-imported data for the MSVCRT version which
-    // means &_iob[n] is not a constant expression.  Just use
-    // property syntax..
-    /*
-    final FILE *stdin  = &_iob[0];	///
-    final FILE *stdout = &_iob[1];	///
-    final FILE *stderr = &_iob[2];	///
-    final FILE *stdaux = &_iob[3];	///
-    final FILE *stdprn = &_iob[4];	///
-    */
-    extern (D)
-    {
-	FILE * stdin()  { return &_iob[0]; }	///
-	FILE * stdout() { return &_iob[1]; }	///
-	FILE * stderr() { return &_iob[2]; }	///
-	FILE * stdaux() { return &_iob[3]; }	///
-	FILE * stdprn() { return &_iob[4]; }	///
-    }
-}
-else version (aix)
-{
-    // 32- and 64-bit
-    extern FILE _iob[16];
-    FILE *stdin  = &_iob[0];
-    FILE *stdout = &_iob[1];
-    FILE *stderr = &_iob[2];
-}
-else version (darwin)
-{
-    static if (size_t.sizeof == 4)
-    {
- 	static assert(libc.FILE_struct_size != 0);
-	extern FILE[3] __sF;
-	FILE * stdin  = &__sF[0];
-	FILE * stdout = &__sF[1];
-	FILE * stderr = &__sF[2];
-    }
-    else static if (size_t.sizeof == 8)
-    {
-	extern FILE *__stdinp;
-	extern FILE *__stdoutp;
-	extern FILE *__stderrp;
-	alias __stdinp  stdin;
-	alias __stdoutp stdout;
-	alias __stderrp stderr;
-    }
-}
-else version (linux)
-{
-    extern FILE *stdin;
-    extern FILE *stdout;
-    extern FILE *stderr;
-}
-
-version (Win32)
-{
-    const char[] _P_tmpdir = "\\";
-    const wchar[] _wP_tmpdir = "\\";
-    version (GNU) { }
-    else
-    {
-	const int L_tmpnam = _P_tmpdir.length + 12;
-    }
-}
-
-
-alias libc.fpos_t fpos_t;
-
-char *	 tmpnam(char *);	///
-FILE *	 fopen(in char *,in char *);	///
-version(linux)
-{
-    FILE * fopen64(in char *,in char *);	///
-}
-FILE *	 _fsopen(in char *,in char *,int );	///
-FILE *	 freopen(in char *,in char *,FILE *);	///
-int	 fseek(FILE *,Clong_t,int);	///
-Clong_t  ftell(FILE *);	///
-char *	 fgets(char *,int,FILE *);	///
-int	 fgetc(FILE *);	///
-int	 _fgetchar();	///
-int	 fflush(FILE *);	///
-int	 fclose(FILE *);	///
-int	 fputs(in char *,FILE *);	///
-char *	 gets(char *);	///
-int	 fputc(int,FILE *);	///
-int	 _fputchar(int);	///
-int	 puts(in char *);	///
-int	 ungetc(int,FILE *);	///
-size_t	 fread(void *,size_t,size_t,FILE *);	///
-size_t	 fwrite(in void *,size_t,size_t,FILE *);	///
-int	 printf(in char *,...);	///
-int	 fprintf(FILE *,in char *,...);	///
-int	 vfprintf(FILE *,in char *,va_list);	///
-int	 vprintf(in char *,va_list);	///
-int	 sprintf(char *,in char *,...);	///
-int	 vsprintf(char *,in char *,va_list);	///
-int	 scanf(in char *,...);	///
-int	 fscanf(FILE *,in char *,...);	///
-int	 sscanf(char *,in char *,...);	///
-void	 setbuf(FILE *,char *);	///
-int	 setvbuf(FILE *,char *,int,size_t);	///
-int	 remove(in char *);	///
-int	 rename(in char *,in char *);	///
-void	 perror(in char *);	///
-int	 fgetpos(FILE *,fpos_t *);	///
-int	 fsetpos(FILE *,fpos_t *);	///
-FILE *	 tmpfile();	///
-int	 _rmtmp();
-int      _fillbuf(FILE *);
-int      _flushbu(int, FILE *);
-
-int  getw(FILE *FHdl);	///
-int  putw(int Word, FILE *FilePtr);	///
-
-int  getchar(); ///
-int  putchar(int c); ///
-int  getc(FILE *fp); ///
-int  putc(int c,FILE *fp); ///
-
-version(PPC)
-    version(Linux)
-	version=PPCLinux;
-
-version (Win32)
-{
-    ///
-    int  ferror(FILE *fp);
-    ///
-    int  feof(FILE *fp);
-    ///
-    void clearerr(FILE *fp);
-    ///
-    void rewind(FILE *fp);
-    int  _bufsize(FILE *fp);
-    ///
-    version (GNU) // msvcrt, really
-    {
-	int  _fileno(FILE *fp);
-	alias _fileno fileno;
-    }
-    else
-	int  fileno(FILE *fp);
-    int  _snprintf(char *,size_t,const char *,...);
-    int  _vsnprintf(char *,size_t,const char *,va_list);
-}
-else version (darwin)
-{
-    private import std.c.darwin.ldblcompat;
-    
-    extern (C) int ferror(FILE *);
-    extern (C) int feof(FILE *);
-    extern (C) void clearerr(FILE *);
-    extern (C) void rewind(FILE *);
-    extern (C) int _bufsize(FILE *);
-    extern (C) int fileno(FILE *);
-   
-    int snprintf(char *, size_t, in char *, ...);
-    int vsnprintf(char *, size_t, in char *, va_list);
-
-    // printf is declared in object, but it won't be fixed unless std.c.stdio is imported...
-    pragma(GNU_asm,printf,"printf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,fprintf,"fprintf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,vfprintf,"vfprintf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,vprintf,"vprintf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,sprintf,"sprintf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,vsprintf,"vsprintf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,scanf,"scanf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,fscanf,"fscanf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,sscanf,"sscanf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,snprintf,"snprintf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,vsnprintf,"vsnprintf" ~ __DARWIN_LDBL_COMPAT);
-}
-else version (PPCLinux)
-{
-    private import std.c.linux.ldblcompat;
-    
-    extern (C) int ferror(FILE *);
-    extern (C) int feof(FILE *);
-    extern (C) void clearerr(FILE *);
-    extern (C) void rewind(FILE *);
-    extern (C) int _bufsize(FILE *);
-    extern (C) int fileno(FILE *);
-   
-    int snprintf(char *, size_t, char *, ...);
-    int vsnprintf(char *, size_t, char *, va_list);
-
-    // printf is declared in object, but it won't be fixed unless std.c.stdio is imported...
-    pragma(GNU_asm,printf,__LDBL_COMPAT_PFX ~ "printf");
-    pragma(GNU_asm,fprintf,__LDBL_COMPAT_PFX ~ "fprintf");
-    pragma(GNU_asm,vfprintf,__LDBL_COMPAT_PFX ~ "vfprintf");
-    pragma(GNU_asm,vprintf,__LDBL_COMPAT_PFX ~ "vprintf");
-    pragma(GNU_asm,sprintf,__LDBL_COMPAT_PFX ~ "sprintf");
-    pragma(GNU_asm,vsprintf,__LDBL_COMPAT_PFX ~ "vsprintf");
-    pragma(GNU_asm,scanf,__LDBL_COMPAT_PFX ~ "scanf");
-    pragma(GNU_asm,fscanf,__LDBL_COMPAT_PFX ~ "fscanf");
-    pragma(GNU_asm,sscanf,__LDBL_COMPAT_PFX ~ "sscanf");
-    pragma(GNU_asm,snprintf,__LDBL_COMPAT_PFX ~ "snprintf");
-    pragma(GNU_asm,vsnprintf,__LDBL_COMPAT_PFX ~ "vsnprintf");
-}
-else version (GNU)
-{
-    extern (C) int ferror(FILE *);
-    extern (C) int feof(FILE *);
-    extern (C) void clearerr(FILE *);
-    extern (C) void rewind(FILE *);
-    extern (C) int _bufsize(FILE *);
-    extern (C) int fileno(FILE *);
-
-    alias __builtin_snprintf snprintf;
-    alias __builtin_vsnprintf vsnprintf;
-}
-else version (Posix)
-{
-    int  ferror(FILE *fp);
-    int  feof(FILE *fp);
-    void clearerr(FILE *fp);
-    void rewind(FILE *fp);
-    int  _bufsize(FILE *fp);
-    int  fileno(FILE *fp);
-    int  snprintf(char *,size_t,const char *,...);
-    int  vsnprintf(char *,size_t,const char *,va_list);
-}
-
-int      unlink(in char *);	///
-FILE *	 fdopen(int, in char *);	///
-int	 fgetchar();	///
-int	 fputchar(int);	///
-int	 fcloseall();	///
-int	 filesize(in char *);	///
-int	 flushall();	///
-int	 getch();	///
-int	 getche();	///
-int      kbhit();	///
-char *   tempnam (in char *dir, in char *pfx);	///
-
-wchar_t *  _wtmpnam(wchar_t *);	///
-FILE *  _wfopen(in wchar_t *, in wchar_t *);
-FILE *  _wfsopen(in wchar_t *, in wchar_t *, int);
-FILE *  _wfreopen(in wchar_t *, in wchar_t *, FILE *);
-wchar_t *  fgetws(wchar_t *, int, FILE *);	///
-int  fputws(in wchar_t *, FILE *);	///
-wchar_t *  _getws(wchar_t *);
-int  _putws(in wchar_t *);
-int  wprintf(in wchar_t *, ...);	///
-int  fwprintf(FILE *, in wchar_t *, ...);	///
-int  vwprintf(in wchar_t *, va_list);	///
-int  vfwprintf(FILE *, in wchar_t *, va_list);	///
-int  swprintf(wchar_t *, in wchar_t *, ...);	///
-int  vswprintf(wchar_t *, in wchar_t *, va_list);	///
-int  _snwprintf(wchar_t *, size_t, in wchar_t *, ...);
-int  _vsnwprintf(wchar_t *, size_t, in wchar_t *, va_list);
-int  wscanf(in wchar_t *, ...);	///
-int  fwscanf(FILE *, in wchar_t *, ...);	///
-int  swscanf(wchar_t *, in wchar_t *, ...);	///
-int  _wremove(in wchar_t *);
-void  _wperror(in wchar_t *);
-FILE *  _wfdopen(int, in wchar_t *);
-wchar_t *  _wtempnam(in wchar_t *, in wchar_t *);
-wchar_t  fgetwc(FILE *);	///
-wchar_t  _fgetwchar_t();
-wchar_t  fputwc(wchar_t, FILE *);	///
-wchar_t  _fputwchar_t(wchar_t);
-wchar_t  ungetwc(wchar_t, FILE *);	///
-
-wchar_t	 getwchar_t(); ///
-wchar_t	 putwchar_t(wchar_t c); ///
-wchar_t	 getwc(FILE *fp); ///
-wchar_t	 putwc(wchar_t c, FILE *fp) ///
-;
-
-int fwide(FILE* fp, int mode);	///
diff -r f12bfe124807 d/phobos2/std/c/stdlib.d
--- a/d/phobos2/std/c/stdlib.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/stdlib.d	Thu Oct 14 14:12:53 2010 +0100
@@ -8,144 +8,11 @@
  */
 
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, February 2007
-*/
-
 module std.c.stdlib;
 
-private import std.c.stddef;
-private import std.stdint;
+public import core.stdc.stdlib;
 
 extern (C):
 
-enum
-{
-    _MAX_PATH   = 260,
-    _MAX_DRIVE  = 3,
-    _MAX_DIR    = 256,
-    _MAX_FNAME  = 256,
-    _MAX_EXT    = 256,
-}
-
-///
-struct div_t { int  quot,rem; }
-///
-struct ldiv_t { Clong_t quot,rem; }
-///
-struct lldiv_t { long quot,rem; }
-
-    div_t div(int,int);	///
-    ldiv_t ldiv(Clong_t, Clong_t); /// ditto
-    lldiv_t lldiv(long, long); /// ditto
-
-    const int EXIT_SUCCESS = 0;	///
-    const int EXIT_FAILURE = 1;	/// ditto
-
-    int    atexit(void (*)());	///
-    void   exit(int);	/// ditto
-    void   _exit(int);	/// ditto
-
-    int system(const char *);
-
-    version (GNU)
-    {
-	private import gcc.builtins;
-	alias gcc.builtins.__builtin_alloca alloca;	///
-    } else {
-	void *alloca(size_t);	///
-    }
-
-    void *calloc(size_t, size_t);	///
-    void *malloc(size_t);	/// ditto
-    void *realloc(void *, size_t);	/// ditto
-    void free(void *);	/// ditto
-
-    void *bsearch(in void *,in void *,size_t,size_t,
-       int function(in void *,in void *));	///
-    void qsort(void *base, size_t nelems, size_t elemsize,
-	int (*compare)(in void *elem1, in void *elem2));	/// ditto
-
-    char* getenv(const char*);	///
-    int   setenv(const char*, const char*, int); /// extension to ISO C standard, not available on all platforms
-    int unsetenv(const char*); /// extension to ISO C standard, not available on all platforms
-
-    version (GNU)
-    {
-	static import gcc.config.libc;
-	alias gcc.config.libc.RAND_MAX RAND_MAX;
-    }
-
-    int    rand();	///
-    void   srand(uint);	/// ditto
-    Clong_t random(int num);	/// ditto
-    void   randomize();	/// ditto
-
-    int getErrno();	/// ditto
-    int setErrno(int);	/// ditto
-
-    version (GNU)
-    {
-	private import gcc.config.errno;
-	alias gcc.config.errno.ERANGE ERANGE;
-    }
-    else
-	enum int ERANGE = 34;	// on Windows, linux and OSX
-
-double atof(in char *);	///
-int    atoi(in char *);	/// ditto
-Clong_t atol(in char *);	/// ditto
-float  strtof(in char *,char **);	/// ditto
-double strtod(in char *,char **);	/// ditto
-
-//real   strtold(char *,char **);
-version (darwin)
-    version (GNU_Have_strtold)
-	version = darwin_strtold;
-version(PPC)
-    version(Linux)
-	version=PPCLinux;
-version (darwin_strtold)
-{
-    private import std.c.darwin.ldblcompat;
-    real strtold(in char *, char **);	/// ditto
-    pragma(GNU_asm,strtold,"strtold"~__DARWIN_LDBL_COMPAT);
-}
-else version (PPCLinux)
-{
-    private import std.c.linux.ldblcompat;
-    static if (std.c.linux.ldblcompat.__No_Long_Double_Math)
-	alias strtod strtold; 	/// ditto
-    else
-	version = Default_Strtold;
-}
-else
-    version = Default_Strtold;
-version (Default_Strtold)
-{
-    private import gcc.config.config;
-    static if (gcc.config.config.Have_strtold)
-	extern (C) real strtold(in char*, char**); 	/// ditto
-    else
-    {
-	static import gcc.support;
-	alias gcc.support.strtold strtold; /// ditto
-    }
-}
-
-long   strtol(in char *,char **,int);	/// ditto
-uint   strtoul(in char *,char **,int);	/// ditto
-long   atoll(in char *);	/// ditto
-long   strtoll(in char *,char **,int);	/// ditto
-ulong  strtoull(in char *,char **,int);	/// ditto
-
-char* itoa(int, char*, int);
-char* ultoa(Culong_t, char*, int);
-
-int mblen(in char *s, size_t n);	///
-int mbtowc(wchar_t *pwc, char *s, size_t n);	/// ditto
-int wctomb(char *s, wchar_t wc);	/// ditto
-size_t mbstowcs(wchar_t *pwcs, in char *s, size_t n);	/// ditto
-size_t wcstombs(in char *s, wchar_t *pwcs, size_t n);	/// ditto
+int setenv(const char*, const char*, int); /// extension to ISO C standard, not available on all platforms
+int unsetenv(const char*); /// extension to ISO C standard, not available on all platforms
diff -r f12bfe124807 d/phobos2/std/c/string.d
--- a/d/phobos2/std/c/string.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/string.d	Thu Oct 14 14:12:53 2010 +0100
@@ -7,68 +7,23 @@
  *	WIKI=Phobos/StdCString
  */
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
+module std.c.string;
 
-   Modified by David Friedman, May 2006
-*/
-
-
-module std.c.string;
+public import core.stdc.string;
 
 extern (C):
 
-version (GNU)
-{
-    private import gcc.builtins;
-    alias __builtin_memcpy memcpy;	///
-    alias __builtin_strcpy strcpy;	///
-    alias __builtin_strncpy strncpy;	///
-    alias __builtin_strncat strncat;	///
-    alias __builtin_strncmp strncmp;	///
-    alias __builtin_strchr strchr;	///
-    alias __builtin_strcspn strcspn;	///
-    alias __builtin_strpbrk strpbrk;	///
-    alias __builtin_strrchr strrchr;	///
-    alias __builtin_strspn strspn;	///
-    alias __builtin_strstr strstr;	///
-    alias __builtin_memset memset;	///
-    alias __builtin_strlen strlen;	///
-    alias __builtin_strcmp strcmp;	///
-    alias __builtin_strcat strcat;	///
-    alias __builtin_memcmp memcmp;	///
-}
-else
-{
-void* memcpy(void* s1, in void* s2, size_t n);	///
-char* strcpy(char* s1, in char* s2);		///
-char* strncpy(char* s1, in char* s2, size_t n);	///
-char* strncat(char*  s1, in char*  s2, size_t n);	///
-int strncmp(in char* s1, in char* s2, size_t n);	///
-char* strchr(in char* s, int c);			///
-size_t strcspn(in char* s1, in char* s2);		///
-char* strpbrk(in char* s1, in char* s2);		///
-char* strrchr(char* s, int c);			///
-size_t strspn(in char* s1, in char* s2);		///
-char* strstr(in char* s1, in char* s2);		///
-void* memset(void* s, int c, size_t n);		///
-size_t strlen(in char* s);				///
-int strcmp(in char* s1, in char* s2);			///
-char* strcat(char* s1, in char* s2);		///
-int memcmp(in void* s1, in void* s2, size_t n);	///
-}
-void* memmove(void* s1, void* s2, size_t n);	///
-size_t strxfrm(char*  s1, in char*  s2, size_t n);	///
-int strcoll(in char* s1, in char* s2);		///
-void* memchr(in void* s, int c, size_t n);		///
-char* strtok(char*  s1, in char*  s2);		///
-const(char)* strerror(int errnum);			///
-const(char)* strerror_r(int errnum, char* buf, size_t buflen);	///
-
 version (Windows)
 {
-    int memicmp(in char* s1, in char* s2, size_t n);	///
+    int memicmp(in char* s1, in char* s2, size_t n);
 }
 
-// Original DMD strerror_r is non-portable glibc version
-const(char*) _d_gnu_cbridge_strerror(int errnum, char* buf, size_t buflen);
+version (linux)
+{
+    const(char)* strerror_r(int errnum, char* buf, size_t buflen);
+}
+
+version (OSX)
+{
+    int strerror_r(int errnum, char* buf, size_t buflen);
+}
diff -r f12bfe124807 d/phobos2/std/c/time.d
--- a/d/phobos2/std/c/time.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/time.d	Thu Oct 14 14:12:53 2010 +0100
@@ -9,100 +9,4 @@
 
 module std.c.time;
 
-private import std.c.stddef;
-private import std.stdint;
-
-extern (C):
-
-version (GNU)
-{
-    public import gcc.config.libc : CLOCKS_PER_SEC, clock_t, time_t, tm;
-    /*
-    alias gcc.config.libc.CLOCKS_PER_SEC CLOCKS_PER_SEC;
-    alias gcc.config.libc.clock_t clock_t;
-    alias gcc.config.libc.time_t time_t;
-    alias gcc.config.libc.tm tm;
-    */
-    extern int daylight;
-    extern int timezone;
-    extern int altzone;
-    extern char *tzname[2];
-    version (Windows)
-    {
-	const clock_t CLK_TCK        = 1000;
-    }
-    // Else: not implemented yet.  Could be be a constant or
-    // a sysconf() call depending on the OS.
-}
-else
-{
-alias Clong_t clock_t;
-
-version (Windows)
-{   const clock_t CLOCKS_PER_SEC = 1000;
-    const clock_t CLK_TCK        = 1000;
-}
-else version (linux)
-{   const clock_t CLOCKS_PER_SEC = 1000000;
-    extern (C) int sysconf(int);
-    extern clock_t CLK_TCK;
-    /*static this()
-    {
-	CLK_TCK = cast(clock_t) sysconf(2);
-    }*/
-}
-else version (OSX)
-{
-    const clock_t CLOCKS_PER_SEC = 100;
-    const clock_t CLK_TCK        = 100;
-}
-else
-{
-    static assert(0);
-}
-
-const uint TIMEOFFSET     = 315558000;
-
-alias Clong_t time_t;
-
-extern int daylight;
-extern int timezone;
-extern int altzone;
-extern char *tzname[2];
-
-struct tm
-{      int     tm_sec,
-               tm_min,
-               tm_hour,
-               tm_mday,
-               tm_mon,
-               tm_year,
-               tm_wday,
-               tm_yday,
-               tm_isdst;
-}
-}
-
-clock_t clock();
-time_t time(time_t *);
-time_t mktime(tm *);
-char *asctime(in tm *);
-char *ctime(in time_t *);
-tm *localtime(in time_t *);
-tm *gmtime(in time_t *);
-size_t strftime(char *, size_t, in char *, in tm *);
-char *_strdate(char *dstring);
-char *_strtime(char *timestr);
-double difftime(time_t t1, time_t t2);
-void _tzset();
-void tzset();
-
-void sleep(time_t);
-void usleep(uint);
-void msleep(uint);
-
-wchar_t *_wasctime(in tm *);
-wchar_t *_wctime(in time_t *);
-size_t wcsftime(wchar_t *, size_t, in wchar_t *, in tm *);
-wchar_t *_wstrdate(wchar_t *);
-wchar_t *_wstrtime(wchar_t *);
+public import core.stdc.time;
diff -r f12bfe124807 d/phobos2/std/c/unix/unix.d
--- a/d/phobos2/std/c/unix/unix.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/unix/unix.d	Thu Oct 14 14:12:53 2010 +0100
@@ -1,5 +1,4 @@
 /* GDC -- D front-end for GCC
-   Copyright (C) 2004 David Friedman
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -16,333 +15,28 @@
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
+/* This module imports posix modules from druntime to sufficiently
+   cover what used to be here in the old phobos2 module; though
+   may mark this for deprecation in the future.
+
+   Written by Iain Buclaw, October 2010.
+ */ 
+
+
 module std.c.unix.unix;
 
-/* This module imports the unix module for the currect
-   target system.  Currently, all targets can be
-   handled with the autoconf'd version. */
+extern char** environ;
 
-public import gcc.config.libc : tm, time_t;
-private import std.stdint : Clong_t, Culong_t;
-public import gcc.config.unix;
-public import gcc.config.errno;
+public import core.sys.posix.arpa.inet;
+public import core.sys.posix.dirent;
+public import core.sys.posix.fcntl;
+public import core.sys.posix.pthread;
+public import core.sys.posix.pwd;
+public import core.sys.posix.semaphore;
+public import core.sys.posix.stdio;
+public import core.sys.posix.stdlib;
+public import core.sys.posix.sys.mman;
+public import core.sys.posix.termios;
+public import core.sys.posix.time;
+public import core.sys.posix.unistd;
 
-extern (C):
-
-// DMD linux.d has dirent.h declarations
-DIR * opendir(in char *);
-dirent * readdir(DIR *);
-void rewinddir(DIR *);
-int closedir(DIR *);
-off_t telldir(DIR* dir);
-void seekdir(DIR* dir, off_t offset);
-int dirfd(DIR*);
-
-public import std.c.stdio;
-int fseeko(FILE*, off_t, int);
-off_t ftello(FILE*);
-
-int open(in char*, int, ...);
-ssize_t read(int, void*, size_t);
-ssize_t write(int, in void*, size_t);
-int close(int);
-off_t lseek(int, off_t, int);
-int access(in char *path, int mode);
-int utimes(const char *path, timeval* times);
-int utime(const char *path, utimbuf *buf);
-int fstat(int, struct_stat*);
-int stat(in char*, struct_stat*);
-int	lstat(in char *, struct_stat *);
-int	chmod(in char *, mode_t);
-int chdir(in char*);
-int mkdir(in char*, mode_t);
-int rmdir(in char*);
-char* getcwd(char*, size_t);
-
-pid_t fork();
-int dup(int);
-int dup2(int, int);
-int pipe(int[2]);
-pid_t wait(int*);
-pid_t waitpid(pid_t, int*, int);
-int kill(pid_t, int);
-int killpg(pid_t, int);
-
-gid_t getgid();
-uid_t getuid();
-int setpgid(pid_t pid, pid_t pgid);
-pid_t getpgid(pid_t pid);
-int setpgrp();
-pid_t getpgrp();
-
-int gettimeofday(timeval*, void*);
-int settimeofday(in timeval *, in void *);
-time_t time(time_t*);
-tm *localtime(time_t*);
-
-int sem_init (sem_t *, int, uint);
-int sem_destroy (sem_t *);
-sem_t * sem_open (in char *, int, ...);
-int sem_close(sem_t *);
-int sem_wait(sem_t*);
-int sem_post(sem_t*);
-int sem_trywait(sem_t*);
-int sem_getvalue(sem_t*, int*);
-
-int sigemptyset(sigset_t*);
-int sigfillset(sigset_t*);
-int sigdelset(sigset_t*, int);
-int sigismember(sigset_t *set, int);
-int sigaction(int, sigaction_t*, sigaction_t*);
-int sigsuspend(sigset_t*);
-
-Clong_t sysconf(int name);
-
-// version ( Unix_Pthread )...
-enum
-{
-    PTHREAD_MUTEX_TIMED_NP,
-    PTHREAD_MUTEX_RECURSIVE_NP,
-    PTHREAD_MUTEX_ERRORCHECK_NP,
-    PTHREAD_MUTEX_ADAPTIVE_NP
-}
-
-int pthread_attr_init(pthread_attr_t *);
-int pthread_attr_destroy(pthread_attr_t *);
-int pthread_attr_setdetachstate(pthread_attr_t *, int);
-int pthread_attr_getdetachstate(pthread_attr_t *, int *);
-int pthread_attr_setguardsize(pthread_attr_t*, size_t);
-int pthread_attr_getguardsize(pthread_attr_t*, size_t *);
-int pthread_attr_setinheritsched(pthread_attr_t *, int);
-int pthread_attr_getinheritsched(pthread_attr_t *, int *);
-int pthread_attr_setschedparam(pthread_attr_t *, sched_param *);
-int pthread_attr_getschedparam(pthread_attr_t *, sched_param *);
-int pthread_attr_setschedpolicy(pthread_attr_t *, int);
-int pthread_attr_getschedpolicy(pthread_attr_t *, int*);
-int pthread_attr_setscope(pthread_attr_t *, int);
-int pthread_attr_getscope(pthread_attr_t *, int*);
-int pthread_attr_setstack(pthread_attr_t *, void*, size_t);
-int pthread_attr_getstack(pthread_attr_t *, void**, size_t *);
-int pthread_attr_setstackaddr(pthread_attr_t *, void *);
-int pthread_attr_getstackaddr(pthread_attr_t *, void **);
-int pthread_attr_setstacksize(pthread_attr_t *, size_t);
-int pthread_attr_getstacksize(pthread_attr_t *, size_t *);
-
-int pthread_create(pthread_t*, pthread_attr_t*, void* (*)(void*), void*);
-int pthread_join(pthread_t, void**);
-int pthread_kill(pthread_t, int);
-pthread_t pthread_self();
-int pthread_equal(pthread_t, pthread_t);
-int pthread_suspend_np(pthread_t);
-int pthread_continue_np(pthread_t);
-int pthread_cancel(pthread_t);
-int pthread_setcancelstate(int state, int *oldstate);
-int pthread_setcanceltype(int type, int *oldtype);
-void pthread_testcancel();    
-int pthread_detach(pthread_t);
-void pthread_exit(void*);
-int pthread_getattr_np(pthread_t, pthread_attr_t*);
-int pthread_getconcurrency();
-int pthread_getcpuclockid(pthread_t, clockid_t*);
-
-int pthread_cond_init(pthread_cond_t *, pthread_condattr_t *);
-int pthread_cond_destroy(pthread_cond_t *);
-int pthread_cond_signal(pthread_cond_t *);
-int pthread_cond_broadcast(pthread_cond_t *);
-int pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *);
-int pthread_cond_timedwait(pthread_cond_t *, pthread_mutex_t *, timespec *);
-int pthread_condattr_init(pthread_condattr_t *);
-int pthread_condattr_destroy(pthread_condattr_t *);
-int pthread_condattr_getpshared(pthread_condattr_t *, int *);
-int pthread_condattr_setpshared(pthread_condattr_t *, int);
-
-int pthread_mutex_init(pthread_mutex_t *, pthread_mutexattr_t *);
-int pthread_mutex_lock(pthread_mutex_t *);
-int pthread_mutex_trylock(pthread_mutex_t *);
-int pthread_mutex_unlock(pthread_mutex_t *);
-int pthread_mutex_destroy(pthread_mutex_t *);
-int pthread_mutexattr_init(pthread_mutexattr_t *);
-int pthread_mutexattr_destroy(pthread_mutexattr_t *);
-int pthread_mutexattr_getpshared(pthread_mutexattr_t *, int *);
-int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
-int pthread_mutexattr_gettype(pthread_mutexattr_t*, int *);
-int pthread_mutexattr_settype(pthread_mutexattr_t*, int);
-
-int pthread_barrierattr_init(pthread_barrierattr_t*);
-int pthread_barrierattr_getpshared(pthread_barrierattr_t*, int*);
-int pthread_barrierattr_destroy(pthread_barrierattr_t*);
-int pthread_barrierattr_setpshared(pthread_barrierattr_t*, int);
-
-int pthread_barrier_init(pthread_barrier_t*, pthread_barrierattr_t*, uint);
-int pthread_barrier_destroy(pthread_barrier_t*);
-int pthread_barrier_wait(pthread_barrier_t*);
-
-// version ( Unix_Sched )
-void sched_yield();
-
-// from <sys/mman.h>
-void* mmap(void* addr, size_t len, int prot, int flags, int fd, off_t offset);
-int munmap(void* addr, size_t len);
-int msync(void* start, size_t length, int flags);
-int madvise(void*, size_t, int);
-int mlock(void*, size_t);
-int munlock(void*, size_t);
-int mlockall(int);
-int munlockall();
-void* mremap(void*, size_t, size_t, Culong_t); // Linux specific
-int mincore(void*, size_t, ubyte*);
-int remap_file_pages(void*, size_t, int, ssize_t, int); // Linux specific
-int shm_open(in char*, int, mode_t);
-int shm_unlink(in char*);
-
-// from <fcntl.h>
-int fcntl(int fd, int cmd, ...);
-
-int select(int n, fd_set *, fd_set *, fd_set *, timeval *);
-
-// could probably rewrite fd_set stuff in D, but for now...
-private void _d_gnu_fd_set(int n, fd_set * p);
-private void _d_gnu_fd_clr(int n, fd_set * p);
-private int  _d_gnu_fd_isset(int n, fd_set * p);
-private void _d_gnu_fd_copy(fd_set * f, fd_set * t);
-private void _d_gnu_fd_zero(fd_set * p);
-// maybe these should go away in favor of fd_set methods
-version (none)
-{
-    void FD_SET(int n, inout fd_set p) { return _d_gnu_fd_set(n, & p); }
-    void FD_CLR(int n, inout fd_set p) { return _d_gnu_fd_clr(n, & p); }
-    int FD_ISSET(int n, inout fd_set p) { return _d_gnu_fd_isset(n, & p); }
-    void FD_COPY(inout fd_set f, inout fd_set t) { return _d_gnu_fd_copy(& f, & t); }
-    void FD_ZERO(inout fd_set p) { return _d_gnu_fd_zero(& p); }
-}
-void FD_SET(int n,  fd_set * p) { return _d_gnu_fd_set(n, p); }
-void FD_CLR(int n,  fd_set * p) { return _d_gnu_fd_clr(n, p); }
-int FD_ISSET(int n, fd_set * p) { return _d_gnu_fd_isset(n, p); }
-void FD_COPY(fd_set * f, inout fd_set * t) { return _d_gnu_fd_copy(f, t); }
-void FD_ZERO(fd_set * p) { return _d_gnu_fd_zero(p); }
-
-// from <pwd.h>
-passwd *getpwnam(in char *name);
-passwd *getpwuid(uid_t uid);
-int getpwnam_r(const(char) *name, passwd *pwbuf, char *buf, size_t buflen, passwd **pwbufp);
-int getpwuid_r(uid_t uid, passwd *pwbuf, char *buf, size_t buflen, passwd **pwbufp);
-
-// std/socket.d
-enum: int
-{
-    SD_RECEIVE =  0,
-    SD_SEND =     1,
-    SD_BOTH =     2,
-}
-
-int socket(int af, int type, int protocol);
-int bind(int s, sockaddr* name, int namelen);
-int connect(int s, sockaddr* name, int namelen);
-int listen(int s, int backlog);
-int accept(int s, sockaddr* addr, int* addrlen);
-int shutdown(int s, int how);
-int getpeername(int s, sockaddr* name, int* namelen);
-int getsockname(int s, sockaddr* name, int* namelen);
-ssize_t send(int s, const(void)* buf, size_t len, int flags);
-ssize_t sendto(int s, const(void)* buf, size_t len, int flags, sockaddr* to, int tolen);
-ssize_t recv(int s, void* buf, size_t len, int flags);
-ssize_t recvfrom(int s, void* buf, size_t len, int flags, sockaddr* from, int* fromlen);
-int getsockopt(int s, int level, int optname, void* optval, int* optlen);
-int setsockopt(int s, int level, int optname, void* optval, int optlen);
-uint inet_addr(in char* cp);
-char* inet_ntoa(in_addr ina);
-hostent* gethostbyname(in char* name);
-int gethostbyname_r(in char* name, hostent* ret, void* buf, size_t buflen, hostent** result, int* h_errnop);
-int gethostbyname2_r(in char* name, int af, hostent* ret, void* buf, size_t buflen, hostent** result, int* h_errnop);
-hostent* gethostbyaddr(void* addr, int len, int type);
-protoent* getprotobyname(in char* name);
-protoent* getprotobynumber(int number);
-servent* getservbyname(in char* name, in char* proto);
-servent* getservbyport(int port, in char* proto);
-int gethostname(in char* name, int namelen);
-int getaddrinfo(in char* nodename, in char* servname, addrinfo* hints, addrinfo** res);
-void freeaddrinfo(addrinfo* ai);
-int getnameinfo(sockaddr* sa, socklen_t salen, in char* node, socklen_t nodelen, char* service, socklen_t servicelen, int flags);
-
-private import std.stdint;
-
-version(BigEndian)
-{
-	uint16_t htons(uint16_t x)
-	{
-		return x;
-	}
-
-
-	uint32_t htonl(uint32_t x)
-	{
-		return x;
-	}
-}
-else version(LittleEndian)
-{
-	private import std.intrinsic;
-
-
-	uint16_t htons(uint16_t x)
-	{
-		return (x >> 8) | (x << 8);
-	}
-
-
-	uint32_t htonl(uint32_t x)
-	{
-		return bswap(x);
-	}
-}
-else
-{
-	static assert(0);
-}
-
-alias htons ntohs;
-alias htonl ntohl;
-
-// from <time.h>
-char* asctime_r(in tm* t, char* buf);
-char* ctime_r(in time_t* timep, char* buf);
-tm* gmtime_r(in time_t* timep, tm* result);
-tm* localtime_r(in time_t* timep, tm* result);
-
-// from <termios.h>
-int tcgetattr(int fd, termios* p);
-int tcsetattr(int fd, int tcsa, const termios* p);
-
-void cfmakeraw(termios* p);
-int tcflush(int fd, int tc_flush);
-int tcflow(int fd, int tc);
-
-int tcsendbreak(int fd, int duration);
-int tcdrain(int fd);
-
-int cfsetspeed(termios* p, speed_t speed);
-int cfsetispeed(termios* p, speed_t speed);
-int cfsetospeed(termios* p, speed_t speed);
-
-speed_t cfgetispeed(termios* p);
-speed_t cfgetospeed(termios* p);
-
-
-// misc.
-uint alarm(uint);
-char* basename(char*);
-//wint_t btowc(int);
-int chown(in char*, uid_t, gid_t);
-int chroot(in char*);
-size_t confstr(int, char*, size_t);
-int creat(in char*, mode_t);
-char* ctermid(char*);
-char* dirname(char*);
-int fattach(int, char*);
-int fchmod(int, mode_t);
-int fdatasync(int);
-int ffs(int);
-int fmtmsg(int, char*, int, char*, char*, char*);
-int fpathconf(int, int);
-
-extern char** environ;
diff -r f12bfe124807 d/phobos2/std/c/wcharh.d
--- a/d/phobos2/std/c/wcharh.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/wcharh.d	Thu Oct 14 14:12:53 2010 +0100
@@ -9,98 +9,4 @@
 
 module std.c.wcharh;
 
-private import std.c.stdio;
-private import std.c.stddef;
-private import std.c.stdarg;
-private import std.c.time;
-
-extern (C):
-
-version (Windows)
-{
-    alias int mbstate_t;
-    alias wchar_t wint_t;
-    const wint_t WEOF = 0xFFFF;
-}
-else version (linux)
-{
-    struct mbstate_t
-    {
-	int __count;
-	union U
-	{
-	    wint_t __wch;
-	    ubyte[4] __wchb;
-	}
-	U __value;
-    }
-    alias uint wint_t;
-    const wint_t WEOF = 0xFFFFFFFFu;
-}
-else
-{
-    static assert(0);
-}
-
-const wchar_t WCHAR_MAX = wchar_t.max;
-const wchar_t WCHAR_MIN = wchar_t.min;
-
-int fwprintf(FILE* stream, in wchar_t* format, ...);
-int fwscanf(FILE* stream, in wchar_t* format, ...);
-int swprintf(wchar_t* s, size_t n, in wchar_t* format, ...);
-int swscanf(wchar_t* s, in wchar_t* format, ...);
-int vfwprintf(FILE* stream, in wchar_t* format, va_list arg);
-int vfwscanf(FILE* stream, in wchar_t* format, va_list arg);
-int vswprintf(wchar_t* s, size_t n, in wchar_t* format, va_list arg);
-int vswscanf(wchar_t* s, in wchar_t* format, va_list arg);
-int vwprintf(in wchar_t* format, va_list arg);
-int vwscanf(in wchar_t* format, va_list arg);
-int wprintf(in wchar_t* format, ...);
-int wscanf(in wchar_t* format, ...);
-wint_t fgetwc(FILE *stream);
-wchar_t *fgetws(wchar_t* s, int n, FILE* stream);
-wint_t fputwc(wchar_t c, FILE *stream);
-int fputws(in wchar_t* s, FILE* stream);
-int fwide(FILE *stream, int mode);
-wint_t getwc(FILE *stream);
-wint_t getwchar();
-wint_t putwc(wchar_t c, FILE *stream);
-wint_t putwchar(wchar_t c);
-wint_t ungetwc(wint_t c, FILE *stream);
-double wcstod(wchar_t* nptr, wchar_t** endptr);
-float wcstof(wchar_t* nptr, wchar_t** endptr);
-real wcstold(wchar_t* nptr, wchar_t** endptr);
-int wcstol(wchar_t* nptr, wchar_t** endptr, int base);
-long wcstoll(wchar_t* nptr, wchar_t** endptr, int base);
-uint wcstoul(wchar_t* nptr, wchar_t** endptr, int base);
-ulong wcstoull(wchar_t* nptr, wchar_t** endptr, int base);
-wchar_t *wcscpy(wchar_t* s1, in wchar_t* s2);
-wchar_t *wcsncpy(wchar_t* s1, in wchar_t* s2, size_t n);
-wchar_t *wcscat(wchar_t* s1, in wchar_t* s2);
-wchar_t *wcsncat(wchar_t* s1, in wchar_t* s2, size_t n);
-int wcscmp(in wchar_t *s1, in wchar_t *s2);
-int wcscoll(in wchar_t *s1, in wchar_t *s2);
-int wcsncmp(in wchar_t *s1, in wchar_t *s2, size_t n);
-size_t wcsxfrm(wchar_t* s1, in wchar_t* s2, size_t n);
-wchar_t *wcschr(wchar_t *s, wchar_t c);
-size_t wcscspn(in wchar_t *s1, in wchar_t *s2);
-size_t wcslen(in wchar_t *s);
-wchar_t *wcspbrk(wchar_t *s1, in wchar_t *s2);
-wchar_t *wcsrchr(wchar_t *s, wchar_t c);
-size_t wcsspn(in wchar_t *s1, in wchar_t *s2);
-wchar_t *wcsstr(wchar_t *s1, in wchar_t *s2);
-wchar_t *wcstok(wchar_t* s1, in wchar_t* s2, wchar_t** ptr);
-wchar_t *wmemchr(wchar_t *s, wchar_t c, size_t n);
-int wmemcmp(in wchar_t* s1, in wchar_t* s2, size_t n);
-wchar_t *wmemcpy(wchar_t* s1, in wchar_t* s2, size_t n);
-wchar_t *wmemmove(wchar_t *s1, in wchar_t *s2, size_t n);
-wchar_t *wmemset(wchar_t *s, wchar_t c, size_t n);
-size_t wcsftime(wchar_t* s, size_t maxsize, in wchar_t* format, in tm* timeptr);
-wint_t btowc(int c);
-int wctob(wint_t c);
-int mbsinit(in mbstate_t *ps);
-size_t mbrlen(in char* s, size_t n, mbstate_t* ps);
-size_t mbrtowc(wchar_t* pwc, in char* s, size_t n, mbstate_t* ps);
-size_t wcrtomb(char* s, wchar_t wc, mbstate_t* ps);
-size_t mbsrtowcs(wchar_t* dst, const (char*)* src, size_t len, mbstate_t* ps);
-size_t wcsrtombs(char* dst, wchar_t** src, size_t len, mbstate_t* ps);
+public import core.stdc.wchar_;
diff -r f12bfe124807 d/phobos2/std/c/windows/windows.d
--- a/d/phobos2/std/c/windows/windows.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/windows/windows.d	Thu Oct 14 14:12:53 2010 +0100
@@ -4,6 +4,8 @@
 
 module std.c.windows.windows;
 
+public import core.sys.windows.windows;
+
 version (Windows)
 {
 }
@@ -11,3134 +13,3 @@
 {
     static assert(0);		// Windows only
 }
-
-extern (Windows)
-{
-    alias uint ULONG;
-    alias ULONG *PULONG;
-    alias ushort USHORT;
-    alias USHORT *PUSHORT;
-    alias ubyte UCHAR;
-    alias UCHAR *PUCHAR;
-    alias char *PSZ;
-    alias wchar WCHAR;
-
-    alias void VOID;
-    alias char CHAR;
-    alias short SHORT;
-    alias int LONG;
-    alias CHAR *LPSTR;
-    alias CHAR *PSTR;
-    alias const(CHAR) *LPCSTR;
-    alias const(CHAR) *PCSTR;
-    alias LPSTR LPTCH, PTCH;
-    alias LPSTR PTSTR, LPTSTR;
-    alias LPCSTR LPCTSTR;
-
-    alias WCHAR* LPWSTR;
-    alias const(WCHAR)* LPCWSTR, PCWSTR;
-
-    alias uint DWORD;
-    alias int BOOL;
-    alias ubyte BYTE;
-    alias ushort WORD;
-    alias float FLOAT;
-    alias FLOAT *PFLOAT;
-    alias BOOL *PBOOL;
-    alias BOOL *LPBOOL;
-    alias BYTE *PBYTE;
-    alias BYTE *LPBYTE;
-    alias int *PINT;
-    alias int *LPINT;
-    alias WORD *PWORD;
-    alias WORD *LPWORD;
-    alias int *LPLONG;
-    alias DWORD *PDWORD;
-    alias DWORD *LPDWORD;
-    alias void *LPVOID;
-    alias void *LPCVOID;
-
-    alias int INT;
-    alias uint UINT;
-    alias uint *PUINT;
-
-// ULONG_PTR must be able to store a pointer as an integral type
-version(Win64)
-{
-	alias  long INT_PTR;
-	alias ulong UINT_PTR;
-	alias  long LONG_PTR;
-	alias ulong ULONG_PTR;
-	alias  long * PINT_PTR;
-	alias ulong * PUINT_PTR;
-	alias  long * PLONG_PTR;
-	alias ulong * PULONG_PTR;
-}
-version(Win32)
-{
-    alias  int INT_PTR;
-    alias uint UINT_PTR;
-    alias  int LONG_PTR;
-    alias uint ULONG_PTR;
-    alias  int * PINT_PTR;
-    alias uint * PUINT_PTR;
-    alias  int * PLONG_PTR;
-    alias uint * PULONG_PTR;
-}
-
-    typedef void *HANDLE;
-    alias void *PVOID;
-    alias HANDLE HGLOBAL;
-    alias HANDLE HLOCAL;
-    alias LONG HRESULT;
-    alias LONG SCODE;
-    alias HANDLE HINSTANCE;
-    alias HINSTANCE HMODULE;
-    alias HANDLE HWND;
-
-    alias HANDLE HGDIOBJ;
-    alias HANDLE HACCEL;
-    alias HANDLE HBITMAP;
-    alias HANDLE HBRUSH;
-    alias HANDLE HCOLORSPACE;
-    alias HANDLE HDC;
-    alias HANDLE HGLRC;
-    alias HANDLE HDESK;
-    alias HANDLE HENHMETAFILE;
-    alias HANDLE HFONT;
-    alias HANDLE HICON;
-    alias HANDLE HMENU;
-    alias HANDLE HMETAFILE;
-    alias HANDLE HPALETTE;
-    alias HANDLE HPEN;
-    alias HANDLE HRGN;
-    alias HANDLE HRSRC;
-    alias HANDLE HSTR;
-    alias HANDLE HTASK;
-    alias HANDLE HWINSTA;
-    alias HANDLE HKL;
-    alias HICON HCURSOR;
-
-    alias HANDLE HKEY;
-    alias HKEY *PHKEY;
-    alias DWORD ACCESS_MASK;
-    alias ACCESS_MASK *PACCESS_MASK;
-    alias ACCESS_MASK REGSAM;
-
-    alias int (*FARPROC)();
-
-    alias UINT WPARAM;
-    alias LONG LPARAM;
-    alias LONG LRESULT;
-
-    alias DWORD   COLORREF;
-    alias DWORD   *LPCOLORREF;
-    alias WORD    ATOM;
-
-version (0)
-{   // Properly prototyped versions
-    alias BOOL function(HWND, UINT, WPARAM, LPARAM) DLGPROC;
-    alias VOID function(HWND, UINT, UINT, DWORD) TIMERPROC;
-    alias BOOL function(HDC, LPARAM, int) GRAYSTRINGPROC;
-    alias BOOL function(HWND, LPARAM) WNDENUMPROC;
-    alias LRESULT function(int code, WPARAM wParam, LPARAM lParam) HOOKPROC;
-    alias VOID function(HWND, UINT, DWORD, LRESULT) SENDASYNCPROC;
-    alias BOOL function(HWND, LPCSTR, HANDLE) PROPENUMPROCA;
-    alias BOOL function(HWND, LPCWSTR, HANDLE) PROPENUMPROCW;
-    alias BOOL function(HWND, LPSTR, HANDLE, DWORD) PROPENUMPROCEXA;
-    alias BOOL function(HWND, LPWSTR, HANDLE, DWORD) PROPENUMPROCEXW;
-    alias int function(LPSTR lpch, int ichCurrent, int cch, int code)
-       EDITWORDBREAKPROCA;
-    alias int function(LPWSTR lpch, int ichCurrent, int cch, int code)
-       EDITWORDBREAKPROCW;
-    alias BOOL function(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy)
-       DRAWSTATEPROC;
-}
-else
-{
-    alias FARPROC DLGPROC;
-    alias FARPROC TIMERPROC;
-    alias FARPROC GRAYSTRINGPROC;
-    alias FARPROC WNDENUMPROC;
-    alias FARPROC HOOKPROC;
-    alias FARPROC SENDASYNCPROC;
-    alias FARPROC EDITWORDBREAKPROCA;
-    alias FARPROC EDITWORDBREAKPROCW;
-    alias FARPROC PROPENUMPROCA;
-    alias FARPROC PROPENUMPROCW;
-    alias FARPROC PROPENUMPROCEXA;
-    alias FARPROC PROPENUMPROCEXW;
-    alias FARPROC DRAWSTATEPROC;
-}
-
-extern (D)
-{
-WORD HIWORD(int l) { return cast(WORD)((l >> 16) & 0xFFFF); }
-WORD LOWORD(int l) { return cast(WORD)l; }
-bool FAILED(int status) { return status < 0; }
-bool SUCCEEDED(int Status) { return Status >= 0; }
-}
-
-enum : int
-{
-    FALSE = 0,
-    TRUE = 1,
-}
-
-enum : uint
-{
-    MAX_PATH = 260,
-    HINSTANCE_ERROR = 32,
-}
-
-enum
-{
-	ERROR_SUCCESS =                    0,
-	ERROR_INVALID_FUNCTION =           1,
-	ERROR_FILE_NOT_FOUND =             2,
-	ERROR_PATH_NOT_FOUND =             3,
-	ERROR_TOO_MANY_OPEN_FILES =        4,
-	ERROR_ACCESS_DENIED =              5,
-	ERROR_INVALID_HANDLE =             6,
-	ERROR_NO_MORE_FILES =              18,
-	ERROR_MORE_DATA =		   234,
-	ERROR_NO_MORE_ITEMS =		   259,
-}
-
-enum
-{
-	DLL_PROCESS_ATTACH = 1,
-	DLL_THREAD_ATTACH =  2,
-	DLL_THREAD_DETACH =  3,
-	DLL_PROCESS_DETACH = 0,
-}
-
-enum
-{
-    FILE_BEGIN           = 0,
-    FILE_CURRENT         = 1,
-    FILE_END             = 2,
-}
-
-enum : uint
-{
-    DELETE =                           0x00010000,
-    READ_CONTROL =                     0x00020000,
-    WRITE_DAC =                        0x00040000,
-    WRITE_OWNER =                      0x00080000,
-    SYNCHRONIZE =                      0x00100000,
-
-    STANDARD_RIGHTS_REQUIRED =         0x000F0000,
-    STANDARD_RIGHTS_READ =             READ_CONTROL,
-    STANDARD_RIGHTS_WRITE =            READ_CONTROL,
-    STANDARD_RIGHTS_EXECUTE =          READ_CONTROL,
-    STANDARD_RIGHTS_ALL =              0x001F0000,
-    SPECIFIC_RIGHTS_ALL =              0x0000FFFF,
-    ACCESS_SYSTEM_SECURITY =           0x01000000,
-    MAXIMUM_ALLOWED =                  0x02000000,
-
-    GENERIC_READ                     = 0x80000000,
-    GENERIC_WRITE                    = 0x40000000,
-    GENERIC_EXECUTE                  = 0x20000000,
-    GENERIC_ALL                      = 0x10000000,
-}
-
-enum
-{
-    FILE_SHARE_READ                 = 0x00000001,
-    FILE_SHARE_WRITE                = 0x00000002,
-    FILE_SHARE_DELETE               = 0x00000004,  
-    FILE_ATTRIBUTE_READONLY         = 0x00000001,  
-    FILE_ATTRIBUTE_HIDDEN           = 0x00000002,  
-    FILE_ATTRIBUTE_SYSTEM           = 0x00000004,  
-    FILE_ATTRIBUTE_DIRECTORY        = 0x00000010,  
-    FILE_ATTRIBUTE_ARCHIVE          = 0x00000020,  
-    FILE_ATTRIBUTE_NORMAL           = 0x00000080,  
-    FILE_ATTRIBUTE_TEMPORARY        = 0x00000100,  
-    FILE_ATTRIBUTE_COMPRESSED       = 0x00000800,  
-    FILE_ATTRIBUTE_OFFLINE          = 0x00001000,  
-    FILE_NOTIFY_CHANGE_FILE_NAME    = 0x00000001,   
-    FILE_NOTIFY_CHANGE_DIR_NAME     = 0x00000002,   
-    FILE_NOTIFY_CHANGE_ATTRIBUTES   = 0x00000004,   
-    FILE_NOTIFY_CHANGE_SIZE         = 0x00000008,   
-    FILE_NOTIFY_CHANGE_LAST_WRITE   = 0x00000010,   
-    FILE_NOTIFY_CHANGE_LAST_ACCESS  = 0x00000020,   
-    FILE_NOTIFY_CHANGE_CREATION     = 0x00000040,   
-    FILE_NOTIFY_CHANGE_SECURITY     = 0x00000100,   
-    FILE_ACTION_ADDED               = 0x00000001,   
-    FILE_ACTION_REMOVED             = 0x00000002,   
-    FILE_ACTION_MODIFIED            = 0x00000003,   
-    FILE_ACTION_RENAMED_OLD_NAME    = 0x00000004,   
-    FILE_ACTION_RENAMED_NEW_NAME    = 0x00000005,   
-    FILE_CASE_SENSITIVE_SEARCH      = 0x00000001,  
-    FILE_CASE_PRESERVED_NAMES       = 0x00000002,  
-    FILE_UNICODE_ON_DISK            = 0x00000004,  
-    FILE_PERSISTENT_ACLS            = 0x00000008,  
-    FILE_FILE_COMPRESSION           = 0x00000010,  
-    FILE_VOLUME_IS_COMPRESSED       = 0x00008000,  
-}
-
-enum
-{
-    DWORD MAILSLOT_NO_MESSAGE = cast(DWORD)-1,
-    DWORD MAILSLOT_WAIT_FOREVER = cast(DWORD)-1, 
-}
-
-enum : uint
-{
-    FILE_FLAG_WRITE_THROUGH         = 0x80000000,
-    FILE_FLAG_OVERLAPPED            = 0x40000000,
-    FILE_FLAG_NO_BUFFERING          = 0x20000000,
-    FILE_FLAG_RANDOM_ACCESS         = 0x10000000,
-    FILE_FLAG_SEQUENTIAL_SCAN       = 0x08000000,
-    FILE_FLAG_DELETE_ON_CLOSE       = 0x04000000,
-    FILE_FLAG_BACKUP_SEMANTICS      = 0x02000000,
-    FILE_FLAG_POSIX_SEMANTICS       = 0x01000000,
-}
-
-enum
-{
-    CREATE_NEW          = 1,
-    CREATE_ALWAYS       = 2,
-    OPEN_EXISTING       = 3,
-    OPEN_ALWAYS         = 4,
-    TRUNCATE_EXISTING   = 5,
-}
-
-enum
-{
-    HANDLE INVALID_HANDLE_VALUE = cast(HANDLE)-1,
-    DWORD INVALID_SET_FILE_POINTER = cast(DWORD)-1,
-    DWORD INVALID_FILE_SIZE = cast(DWORD)0xFFFFFFFF,
-}
-
-struct OVERLAPPED {
-    DWORD   Internal;
-    DWORD   InternalHigh;
-    DWORD   Offset;
-    DWORD   OffsetHigh;
-    HANDLE  hEvent;
-}
-
-struct SECURITY_ATTRIBUTES {
-    DWORD nLength;
-    void *lpSecurityDescriptor;
-    BOOL bInheritHandle;
-}
-
-alias SECURITY_ATTRIBUTES* PSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES;
-
-struct FILETIME {
-    DWORD dwLowDateTime;
-    DWORD dwHighDateTime;
-}
-alias FILETIME* PFILETIME, LPFILETIME;
-
-struct WIN32_FIND_DATA {
-    DWORD dwFileAttributes;
-    FILETIME ftCreationTime;
-    FILETIME ftLastAccessTime;
-    FILETIME ftLastWriteTime;
-    DWORD nFileSizeHigh;
-    DWORD nFileSizeLow;
-    DWORD dwReserved0;
-    DWORD dwReserved1;
-    char   cFileName[MAX_PATH];
-    char   cAlternateFileName[ 14 ];
-}
-
-struct WIN32_FIND_DATAW {
-    DWORD dwFileAttributes;
-    FILETIME ftCreationTime;
-    FILETIME ftLastAccessTime;
-    FILETIME ftLastWriteTime;
-    DWORD nFileSizeHigh;
-    DWORD nFileSizeLow;
-    DWORD dwReserved0;
-    DWORD dwReserved1;
-    wchar  cFileName[ 260  ];
-    wchar  cAlternateFileName[ 14 ];
-}
-
-// Critical Section
-
-struct _LIST_ENTRY
-{
-	_LIST_ENTRY *Flink;
-	_LIST_ENTRY *Blink;
-}
-alias _LIST_ENTRY LIST_ENTRY;
-
-struct _RTL_CRITICAL_SECTION_DEBUG 
-{
-	WORD   Type;
-	WORD   CreatorBackTraceIndex;
-	_RTL_CRITICAL_SECTION *CriticalSection;
-	LIST_ENTRY ProcessLocksList;
-	DWORD EntryCount;
-	DWORD ContentionCount;
-	DWORD Spare[ 2 ];
-}
-alias _RTL_CRITICAL_SECTION_DEBUG RTL_CRITICAL_SECTION_DEBUG;
-
-struct _RTL_CRITICAL_SECTION 
-{
-	RTL_CRITICAL_SECTION_DEBUG * DebugInfo;
-	
-	//
-	//  The following three fields control entering and exiting the critical
-	//  section for the resource
-	//
-	
-	LONG LockCount;
-	LONG RecursionCount;
-	HANDLE OwningThread;        // from the thread's ClientId->UniqueThread
-	HANDLE LockSemaphore;
-	ULONG_PTR SpinCount;        // force size on 64-bit systems when packed
-}
-alias _RTL_CRITICAL_SECTION CRITICAL_SECTION;
-
-
-enum
-{
-	STD_INPUT_HANDLE =    cast(DWORD)-10,
-	STD_OUTPUT_HANDLE =   cast(DWORD)-11,
-	STD_ERROR_HANDLE =    cast(DWORD)-12,
-}
-
-export
-{
-BOOL SetCurrentDirectoryA(LPCSTR lpPathName);
-BOOL SetCurrentDirectoryW(LPCWSTR lpPathName);
-DWORD GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer);
-DWORD GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer);
-BOOL CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
-BOOL CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
-BOOL CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
-BOOL CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
-BOOL RemoveDirectoryA(LPCSTR lpPathName);
-BOOL RemoveDirectoryW(LPCWSTR lpPathName);
-
-BOOL   CloseHandle(HANDLE hObject);
-
-HANDLE CreateFileA(const(char*) lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode,
-	SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwCreationDisposition,
-	DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
-HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode,
-	SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwCreationDisposition,
-	DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
-
-BOOL   DeleteFileA(const char *lpFileName);
-BOOL   DeleteFileW(LPCWSTR lpFileName);
-
-BOOL   FindClose(HANDLE hFindFile);
-HANDLE FindFirstFileA(const char *lpFileName, WIN32_FIND_DATA* lpFindFileData);
-HANDLE FindFirstFileW(const LPCWSTR lpFileName, WIN32_FIND_DATAW* lpFindFileData);
-BOOL   FindNextFileA(HANDLE hFindFile, WIN32_FIND_DATA* lpFindFileData);
-BOOL   FindNextFileW(HANDLE hFindFile, WIN32_FIND_DATAW* lpFindFileData);
-BOOL   GetExitCodeThread(HANDLE hThread, DWORD *lpExitCode);
-DWORD  GetLastError();
-DWORD  GetFileAttributesA(const char *lpFileName);
-DWORD  GetFileAttributesW(const wchar *lpFileName);
-DWORD  GetFileSize(HANDLE hFile, DWORD *lpFileSizeHigh);
-BOOL   CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
-BOOL   CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
-BOOL   MoveFileA(const char *from, const char *to);
-BOOL   MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
-BOOL   ReadFile(HANDLE hFile, void *lpBuffer, DWORD nNumberOfBytesToRead,
-	DWORD *lpNumberOfBytesRead, OVERLAPPED *lpOverlapped);
-DWORD  SetFilePointer(HANDLE hFile, LONG lDistanceToMove,
-	LONG *lpDistanceToMoveHigh, DWORD dwMoveMethod);
-BOOL   WriteFile(HANDLE hFile, const(void) *lpBuffer, DWORD nNumberOfBytesToWrite,
-	DWORD *lpNumberOfBytesWritten, OVERLAPPED *lpOverlapped);
-DWORD  GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
-HANDLE GetStdHandle(DWORD nStdHandle);
-BOOL   SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
-}
-
-struct MEMORYSTATUS {
-    DWORD dwLength;
-    DWORD dwMemoryLoad;
-    DWORD dwTotalPhys;
-    DWORD dwAvailPhys;
-    DWORD dwTotalPageFile;
-    DWORD dwAvailPageFile;
-    DWORD dwTotalVirtual;
-    DWORD dwAvailVirtual;
-};
-alias MEMORYSTATUS *LPMEMORYSTATUS;
-
-HMODULE LoadLibraryA(LPCSTR lpLibFileName);
-FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
-DWORD GetVersion();
-BOOL FreeLibrary(HMODULE hLibModule);
-void FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode);
-BOOL DisableThreadLibraryCalls(HMODULE hLibModule);
-
-//
-// Registry Specific Access Rights.
-//
-
-enum
-{
-	KEY_QUERY_VALUE =         0x0001,
-	KEY_SET_VALUE =           0x0002,
-	KEY_CREATE_SUB_KEY =      0x0004,
-	KEY_ENUMERATE_SUB_KEYS =  0x0008,
-	KEY_NOTIFY =              0x0010,
-	KEY_CREATE_LINK =         0x0020,
-
-	KEY_READ =       cast(int)((STANDARD_RIGHTS_READ | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_NOTIFY)   & ~SYNCHRONIZE),
-	KEY_WRITE =      cast(int)((STANDARD_RIGHTS_WRITE | KEY_SET_VALUE | KEY_CREATE_SUB_KEY) & ~SYNCHRONIZE),
-	KEY_EXECUTE =    cast(int)(KEY_READ & ~SYNCHRONIZE),
-	KEY_ALL_ACCESS = cast(int)((STANDARD_RIGHTS_ALL | KEY_QUERY_VALUE | KEY_SET_VALUE | KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | KEY_NOTIFY | KEY_CREATE_LINK) & ~SYNCHRONIZE),
-}
-
-//
-// Key creation/open disposition
-//
-
-enum : int
-{
-	REG_CREATED_NEW_KEY =         0x00000001,   // New Registry Key created
-	REG_OPENED_EXISTING_KEY =     0x00000002,   // Existing Key opened
-}
-
-//
-//
-// Predefined Value Types.
-//
-enum
-{
-	REG_NONE =                    0,   // No value type
-	REG_SZ =                      1,   // Unicode nul terminated string
-	REG_EXPAND_SZ =               2,   // Unicode nul terminated string
-                                            // (with environment variable references)
-	REG_BINARY =                  3,   // Free form binary
-	REG_DWORD =                   4,   // 32-bit number
-	REG_DWORD_LITTLE_ENDIAN =     4,   // 32-bit number (same as REG_DWORD)
-	REG_DWORD_BIG_ENDIAN =        5,   // 32-bit number
-	REG_LINK =                    6,   // Symbolic Link (unicode)
-	REG_MULTI_SZ =                7,   // Multiple Unicode strings
-	REG_RESOURCE_LIST =           8,   // Resource list in the resource map
-	REG_FULL_RESOURCE_DESCRIPTOR = 9,  // Resource list in the hardware description
-	REG_RESOURCE_REQUIREMENTS_LIST = 10,
-	REG_QWORD =			11,
-	REG_QWORD_LITTLE_ENDIAN =	11,
-}
-
-/*
- * MessageBox() Flags
- */
-enum
-{
-	MB_OK =                       0x00000000,
-	MB_OKCANCEL =                 0x00000001,
-	MB_ABORTRETRYIGNORE =         0x00000002,
-	MB_YESNOCANCEL =              0x00000003,
-	MB_YESNO =                    0x00000004,
-	MB_RETRYCANCEL =              0x00000005,
-
-
-	MB_ICONHAND =                 0x00000010,
-	MB_ICONQUESTION =             0x00000020,
-	MB_ICONEXCLAMATION =          0x00000030,
-	MB_ICONASTERISK =             0x00000040,
-
-
-	MB_USERICON =                 0x00000080,
-	MB_ICONWARNING =              MB_ICONEXCLAMATION,
-	MB_ICONERROR =                MB_ICONHAND,
-
-
-	MB_ICONINFORMATION =          MB_ICONASTERISK,
-	MB_ICONSTOP =                 MB_ICONHAND,
-
-	MB_DEFBUTTON1 =               0x00000000,
-	MB_DEFBUTTON2 =               0x00000100,
-	MB_DEFBUTTON3 =               0x00000200,
-
-	MB_DEFBUTTON4 =               0x00000300,
-
-
-	MB_APPLMODAL =                0x00000000,
-	MB_SYSTEMMODAL =              0x00001000,
-	MB_TASKMODAL =                0x00002000,
-
-	MB_HELP =                     0x00004000, // Help Button
-
-
-	MB_NOFOCUS =                  0x00008000,
-	MB_SETFOREGROUND =            0x00010000,
-	MB_DEFAULT_DESKTOP_ONLY =     0x00020000,
-
-
-	MB_TOPMOST =                  0x00040000,
-	MB_RIGHT =                    0x00080000,
-	MB_RTLREADING =               0x00100000,
-
-
-	MB_TYPEMASK =                 0x0000000F,
-	MB_ICONMASK =                 0x000000F0,
-	MB_DEFMASK =                  0x00000F00,
-	MB_MODEMASK =                 0x00003000,
-	MB_MISCMASK =                 0x0000C000,
-}
-
-
-int MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
-int MessageBoxExA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType, WORD wLanguageId);
-
-enum : HKEY
-{
-	HKEY_CLASSES_ROOT =           cast(HKEY)(0x80000000),
-	HKEY_CURRENT_USER =           cast(HKEY)(0x80000001),
-	HKEY_LOCAL_MACHINE =          cast(HKEY)(0x80000002),
-	HKEY_USERS =                  cast(HKEY)(0x80000003),
-	HKEY_PERFORMANCE_DATA =       cast(HKEY)(0x80000004),
-	HKEY_PERFORMANCE_TEXT =       cast(HKEY)(0x80000050),
-	HKEY_PERFORMANCE_NLSTEXT =    cast(HKEY)(0x80000060),
-	HKEY_CURRENT_CONFIG =         cast(HKEY)(0x80000005),
-	HKEY_DYN_DATA =               cast(HKEY)(0x80000006),
-}
-
-enum
-{
-	REG_OPTION_RESERVED =         (0x00000000),   // Parameter is reserved
-
-	REG_OPTION_NON_VOLATILE =     (0x00000000),   // Key is preserved
-                                                    // when system is rebooted
-
-	REG_OPTION_VOLATILE =         (0x00000001),   // Key is not preserved
-                                                    // when system is rebooted
-
-	REG_OPTION_CREATE_LINK =      (0x00000002),   // Created key is a
-                                                    // symbolic link
-
-	REG_OPTION_BACKUP_RESTORE =   (0x00000004),   // open for backup or restore
-                                                    // special access rules
-                                                    // privilege required
-
-	REG_OPTION_OPEN_LINK =        (0x00000008),   // Open symbolic link
-
-	REG_LEGAL_OPTION = (REG_OPTION_RESERVED | REG_OPTION_NON_VOLATILE | REG_OPTION_VOLATILE | REG_OPTION_CREATE_LINK | REG_OPTION_BACKUP_RESTORE | REG_OPTION_OPEN_LINK),
-}
-
-export LONG RegDeleteKeyA(HKEY hKey, LPCSTR lpSubKey);
-export LONG RegDeleteValueA(HKEY hKey, LPCSTR lpValueName);
-
-export LONG  RegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcbClass, FILETIME* lpftLastWriteTime);
-export LONG RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved,
-    LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
-
-export LONG RegCloseKey(HKEY hKey);
-export LONG RegFlushKey(HKEY hKey);
-
-export LONG RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
-export LONG RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
-
-export LONG RegQueryInfoKeyA(HKEY hKey, LPSTR lpClass, LPDWORD lpcbClass,
-    LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen,
-    LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor,
-    PFILETIME lpftLastWriteTime);
-
-export LONG RegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpValue,
-    LPLONG lpcbValue);
-
-export LONG RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass,
-   DWORD dwOptions, REGSAM samDesired, SECURITY_ATTRIBUTES* lpSecurityAttributes,
-    PHKEY phkResult, LPDWORD lpdwDisposition);
-
-export LONG RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, BYTE* lpData, DWORD cbData);
-
-struct MEMORY_BASIC_INFORMATION {
-    PVOID BaseAddress;
-    PVOID AllocationBase;
-    DWORD AllocationProtect;
-    DWORD RegionSize;
-    DWORD State;
-    DWORD Protect;
-    DWORD Type;
-}
-alias MEMORY_BASIC_INFORMATION* PMEMORY_BASIC_INFORMATION;
-
-enum
-{
-	SECTION_QUERY       = 0x0001,
-	SECTION_MAP_WRITE   = 0x0002,
-	SECTION_MAP_READ    = 0x0004,
-	SECTION_MAP_EXECUTE = 0x0008,
-	SECTION_EXTEND_SIZE = 0x0010,
-
-	SECTION_ALL_ACCESS = cast(int)(STANDARD_RIGHTS_REQUIRED|SECTION_QUERY| SECTION_MAP_WRITE | SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_EXTEND_SIZE),
-	PAGE_NOACCESS          = 0x01,
-	PAGE_READONLY          = 0x02,
-	PAGE_READWRITE         = 0x04,
-	PAGE_WRITECOPY         = 0x08,
-	PAGE_EXECUTE           = 0x10,
-	PAGE_EXECUTE_READ      = 0x20,
-	PAGE_EXECUTE_READWRITE = 0x40,
-	PAGE_EXECUTE_WRITECOPY = 0x80,
-	PAGE_GUARD            = 0x100,
-	PAGE_NOCACHE          = 0x200,
-	MEM_COMMIT           = 0x1000,
-	MEM_RESERVE          = 0x2000,
-	MEM_DECOMMIT         = 0x4000,
-	MEM_RELEASE          = 0x8000,
-	MEM_FREE            = 0x10000,
-	MEM_PRIVATE         = 0x20000,
-	MEM_MAPPED          = 0x40000,
-	MEM_RESET           = 0x80000,
-	MEM_TOP_DOWN       = 0x100000,
-	SEC_FILE           = 0x800000,
-	SEC_IMAGE         = 0x1000000,
-	SEC_RESERVE       = 0x4000000,
-	SEC_COMMIT        = 0x8000000,
-	SEC_NOCACHE      = 0x10000000,
-	MEM_IMAGE        = SEC_IMAGE,
-}
-
-enum
-{
-	FILE_MAP_COPY =       SECTION_QUERY,
-	FILE_MAP_WRITE =      SECTION_MAP_WRITE,
-	FILE_MAP_READ =       SECTION_MAP_READ,
-	FILE_MAP_ALL_ACCESS = SECTION_ALL_ACCESS,
-}
-
-
-//
-// Define access rights to files and directories
-//
-
-//
-// The FILE_READ_DATA and FILE_WRITE_DATA constants are also defined in
-// devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values for these
-// constants *MUST* always be in sync.
-// The values are redefined in devioctl.h because they must be available to
-// both DOS and NT.
-//
-
-enum
-{
-	FILE_READ_DATA =            ( 0x0001 ),   // file & pipe
-	FILE_LIST_DIRECTORY =       ( 0x0001 ),    // directory
-
-	FILE_WRITE_DATA =           ( 0x0002 ),    // file & pipe
-	FILE_ADD_FILE =             ( 0x0002 ),    // directory
-
-	FILE_APPEND_DATA =          ( 0x0004 ),    // file
-	FILE_ADD_SUBDIRECTORY =     ( 0x0004 ),    // directory
-	FILE_CREATE_PIPE_INSTANCE = ( 0x0004 ),    // named pipe
-
-	FILE_READ_EA =              ( 0x0008 ),    // file & directory
-
-	FILE_WRITE_EA =             ( 0x0010 ),    // file & directory
-
-	FILE_EXECUTE =              ( 0x0020 ),    // file
-	FILE_TRAVERSE =             ( 0x0020 ),    // directory
-
-	FILE_DELETE_CHILD =         ( 0x0040 ),    // directory
-
-	FILE_READ_ATTRIBUTES =      ( 0x0080 ),    // all
-
-	FILE_WRITE_ATTRIBUTES =     ( 0x0100 ),    // all
-
-	FILE_ALL_ACCESS =	    cast(int)(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF),
-
-	FILE_GENERIC_READ =         cast(int)(STANDARD_RIGHTS_READ  | FILE_READ_DATA |  FILE_READ_ATTRIBUTES |                 FILE_READ_EA |  SYNCHRONIZE),
-
-	FILE_GENERIC_WRITE =        cast(int)(STANDARD_RIGHTS_WRITE | FILE_WRITE_DATA |  FILE_WRITE_ATTRIBUTES |                      FILE_WRITE_EA  |  FILE_APPEND_DATA |  SYNCHRONIZE),
-
-	FILE_GENERIC_EXECUTE =      cast(int)(STANDARD_RIGHTS_EXECUTE | FILE_READ_ATTRIBUTES |                 FILE_EXECUTE |  SYNCHRONIZE),
-}
-
-export
-{
- BOOL  FreeResource(HGLOBAL hResData);
- LPVOID LockResource(HGLOBAL hResData);
- BOOL GlobalUnlock(HGLOBAL hMem);
- HGLOBAL GlobalFree(HGLOBAL hMem);
- UINT GlobalCompact(DWORD dwMinFree);
- void GlobalFix(HGLOBAL hMem);
- void GlobalUnfix(HGLOBAL hMem);
- LPVOID GlobalWire(HGLOBAL hMem);
- BOOL GlobalUnWire(HGLOBAL hMem);
- void GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer);
- HLOCAL LocalAlloc(UINT uFlags, UINT uBytes);
- HLOCAL LocalReAlloc(HLOCAL hMem, UINT uBytes, UINT uFlags);
- LPVOID LocalLock(HLOCAL hMem);
- HLOCAL LocalHandle(LPCVOID pMem);
- BOOL LocalUnlock(HLOCAL hMem);
- UINT LocalSize(HLOCAL hMem);
- UINT LocalFlags(HLOCAL hMem);
- HLOCAL LocalFree(HLOCAL hMem);
- UINT LocalShrink(HLOCAL hMem, UINT cbNewSize);
- UINT LocalCompact(UINT uMinFree);
- BOOL FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, DWORD dwSize);
- LPVOID VirtualAlloc(LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect);
- BOOL VirtualFree(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType);
- BOOL VirtualProtect(LPVOID lpAddress, DWORD dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
- DWORD VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, DWORD dwLength);
- LPVOID VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect);
- BOOL VirtualFreeEx(HANDLE hProcess, LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType);
- BOOL VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, DWORD dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
- DWORD VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, DWORD dwLength);
-}
-
-struct SYSTEMTIME
-{
-    WORD wYear;
-    WORD wMonth;
-    WORD wDayOfWeek;
-    WORD wDay;
-    WORD wHour;
-    WORD wMinute;
-    WORD wSecond;
-    WORD wMilliseconds;
-}
-
-struct TIME_ZONE_INFORMATION {
-    LONG Bias;
-    WCHAR StandardName[ 32 ];
-    SYSTEMTIME StandardDate;
-    LONG StandardBias;
-    WCHAR DaylightName[ 32 ];
-    SYSTEMTIME DaylightDate;
-    LONG DaylightBias;
-}
-
-enum
-{
-	TIME_ZONE_ID_UNKNOWN =  0,
-	TIME_ZONE_ID_STANDARD = 1,
-	TIME_ZONE_ID_DAYLIGHT = 2,
-}
-
-export void GetSystemTime(SYSTEMTIME* lpSystemTime);
-export void GetSystemTimeAsFileTime(FILETIME* lpSystemTimeAsFileTime);
-export BOOL SetSystemTime(SYSTEMTIME* lpSystemTime);
-export void GetLocalTime(SYSTEMTIME* lpSystemTime);
-export BOOL SetLocalTime(SYSTEMTIME* lpSystemTime);
-export BOOL SystemTimeToTzSpecificLocalTime(TIME_ZONE_INFORMATION* lpTimeZoneInformation, SYSTEMTIME* lpUniversalTime, SYSTEMTIME* lpLocalTime);
-export DWORD GetTimeZoneInformation(TIME_ZONE_INFORMATION* lpTimeZoneInformation);
-export BOOL SetTimeZoneInformation(TIME_ZONE_INFORMATION* lpTimeZoneInformation);
-
-export BOOL SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, FILETIME* lpFileTime);
-export BOOL FileTimeToLocalFileTime(const FILETIME *lpFileTime, FILETIME* lpLocalFileTime);
-export BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, FILETIME* lpFileTime);
-export BOOL FileTimeToSystemTime(const FILETIME *lpFileTime, SYSTEMTIME* lpSystemTime);
-export LONG CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2);
-export BOOL FileTimeToDosDateTime(const FILETIME *lpFileTime, WORD* lpFatDate, WORD* lpFatTime);
-export BOOL DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, FILETIME* lpFileTime);
-export DWORD GetTickCount();
-export BOOL SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled);
-export BOOL GetSystemTimeAdjustment(DWORD* lpTimeAdjustment, DWORD* lpTimeIncrement, BOOL* lpTimeAdjustmentDisabled);
-export DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, void* *Arguments);export DWORD FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, void* *Arguments);
-
-enum
-{
-	FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100,
-	FORMAT_MESSAGE_IGNORE_INSERTS =  0x00000200,
-	FORMAT_MESSAGE_FROM_STRING =     0x00000400,
-	FORMAT_MESSAGE_FROM_HMODULE =    0x00000800,
-	FORMAT_MESSAGE_FROM_SYSTEM =     0x00001000,
-	FORMAT_MESSAGE_ARGUMENT_ARRAY =  0x00002000,
-	FORMAT_MESSAGE_MAX_WIDTH_MASK =  0x000000FF,
-};
-
-
-//
-//  Language IDs.
-//
-//  The following two combinations of primary language ID and
-//  sublanguage ID have special semantics:
-//
-//    Primary Language ID   Sublanguage ID      Result
-//    -------------------   ---------------     ------------------------
-//    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
-//    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
-//    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
-//
-
-//
-//  Primary language IDs.
-//
-
-enum
-{
-	LANG_NEUTRAL                     = 0x00,
-
-	LANG_AFRIKAANS                   = 0x36,
-	LANG_ALBANIAN                    = 0x1c,
-	LANG_ARABIC                      = 0x01,
-	LANG_BASQUE                      = 0x2d,
-	LANG_BELARUSIAN                  = 0x23,
-	LANG_BULGARIAN                   = 0x02,
-	LANG_CATALAN                     = 0x03,
-	LANG_CHINESE                     = 0x04,
-	LANG_CROATIAN                    = 0x1a,
-	LANG_CZECH                       = 0x05,
-	LANG_DANISH                      = 0x06,
-	LANG_DUTCH                       = 0x13,
-	LANG_ENGLISH                     = 0x09,
-	LANG_ESTONIAN                    = 0x25,
-	LANG_FAEROESE                    = 0x38,
-	LANG_FARSI                       = 0x29,
-	LANG_FINNISH                     = 0x0b,
-	LANG_FRENCH                      = 0x0c,
-	LANG_GERMAN                      = 0x07,
-	LANG_GREEK                       = 0x08,
-	LANG_HEBREW                      = 0x0d,
-	LANG_HUNGARIAN                   = 0x0e,
-	LANG_ICELANDIC                   = 0x0f,
-	LANG_INDONESIAN                  = 0x21,
-	LANG_ITALIAN                     = 0x10,
-	LANG_JAPANESE                    = 0x11,
-	LANG_KOREAN                      = 0x12,
-	LANG_LATVIAN                     = 0x26,
-	LANG_LITHUANIAN                  = 0x27,
-	LANG_NORWEGIAN                   = 0x14,
-	LANG_POLISH                      = 0x15,
-	LANG_PORTUGUESE                  = 0x16,
-	LANG_ROMANIAN                    = 0x18,
-	LANG_RUSSIAN                     = 0x19,
-	LANG_SERBIAN                     = 0x1a,
-	LANG_SLOVAK                      = 0x1b,
-	LANG_SLOVENIAN                   = 0x24,
-	LANG_SPANISH                     = 0x0a,
-	LANG_SWEDISH                     = 0x1d,
-	LANG_THAI                        = 0x1e,
-	LANG_TURKISH                     = 0x1f,
-	LANG_UKRAINIAN                   = 0x22,
-	LANG_VIETNAMESE                  = 0x2a,
-}
-//
-//  Sublanguage IDs.
-//
-//  The name immediately following SUBLANG_ dictates which primary
-//  language ID that sublanguage ID can be combined with to form a
-//  valid language ID.
-//
-enum
-{
-	SUBLANG_NEUTRAL =                  0x00,    // language neutral
-	SUBLANG_DEFAULT =                  0x01,    // user default
-	SUBLANG_SYS_DEFAULT =              0x02,    // system default
-
-	SUBLANG_ARABIC_SAUDI_ARABIA =      0x01,    // Arabic (Saudi Arabia)
-	SUBLANG_ARABIC_IRAQ =              0x02,    // Arabic (Iraq)
-	SUBLANG_ARABIC_EGYPT =             0x03,    // Arabic (Egypt)
-	SUBLANG_ARABIC_LIBYA =             0x04,    // Arabic (Libya)
-	SUBLANG_ARABIC_ALGERIA =           0x05,    // Arabic (Algeria)
-	SUBLANG_ARABIC_MOROCCO =           0x06,    // Arabic (Morocco)
-	SUBLANG_ARABIC_TUNISIA =           0x07,    // Arabic (Tunisia)
-	SUBLANG_ARABIC_OMAN =              0x08,    // Arabic (Oman)
-	SUBLANG_ARABIC_YEMEN =             0x09,    // Arabic (Yemen)
-	SUBLANG_ARABIC_SYRIA =             0x0a,    // Arabic (Syria)
-	SUBLANG_ARABIC_JORDAN =            0x0b,    // Arabic (Jordan)
-	SUBLANG_ARABIC_LEBANON =           0x0c,    // Arabic (Lebanon)
-	SUBLANG_ARABIC_KUWAIT =            0x0d,    // Arabic (Kuwait)
-	SUBLANG_ARABIC_UAE =               0x0e,    // Arabic (U.A.E)
-	SUBLANG_ARABIC_BAHRAIN =           0x0f,    // Arabic (Bahrain)
-	SUBLANG_ARABIC_QATAR =             0x10,    // Arabic (Qatar)
-	SUBLANG_CHINESE_TRADITIONAL =      0x01,    // Chinese (Taiwan)
-	SUBLANG_CHINESE_SIMPLIFIED =       0x02,    // Chinese (PR China)
-	SUBLANG_CHINESE_HONGKONG =         0x03,    // Chinese (Hong Kong)
-	SUBLANG_CHINESE_SINGAPORE =        0x04,    // Chinese (Singapore)
-	SUBLANG_DUTCH =                    0x01,    // Dutch
-	SUBLANG_DUTCH_BELGIAN =            0x02,    // Dutch (Belgian)
-	SUBLANG_ENGLISH_US =               0x01,    // English (USA)
-	SUBLANG_ENGLISH_UK =               0x02,    // English (UK)
-	SUBLANG_ENGLISH_AUS =              0x03,    // English (Australian)
-	SUBLANG_ENGLISH_CAN =              0x04,    // English (Canadian)
-	SUBLANG_ENGLISH_NZ =               0x05,    // English (New Zealand)
-	SUBLANG_ENGLISH_EIRE =             0x06,    // English (Irish)
-	SUBLANG_ENGLISH_SOUTH_AFRICA =     0x07,    // English (South Africa)
-	SUBLANG_ENGLISH_JAMAICA =          0x08,    // English (Jamaica)
-	SUBLANG_ENGLISH_CARIBBEAN =        0x09,    // English (Caribbean)
-	SUBLANG_ENGLISH_BELIZE =           0x0a,    // English (Belize)
-	SUBLANG_ENGLISH_TRINIDAD =         0x0b,    // English (Trinidad)
-	SUBLANG_FRENCH =                   0x01,    // French
-	SUBLANG_FRENCH_BELGIAN =           0x02,    // French (Belgian)
-	SUBLANG_FRENCH_CANADIAN =          0x03,    // French (Canadian)
-	SUBLANG_FRENCH_SWISS =             0x04,    // French (Swiss)
-	SUBLANG_FRENCH_LUXEMBOURG =        0x05,    // French (Luxembourg)
-	SUBLANG_GERMAN =                   0x01,    // German
-	SUBLANG_GERMAN_SWISS =             0x02,    // German (Swiss)
-	SUBLANG_GERMAN_AUSTRIAN =          0x03,    // German (Austrian)
-	SUBLANG_GERMAN_LUXEMBOURG =        0x04,    // German (Luxembourg)
-	SUBLANG_GERMAN_LIECHTENSTEIN =     0x05,    // German (Liechtenstein)
-	SUBLANG_ITALIAN =                  0x01,    // Italian
-	SUBLANG_ITALIAN_SWISS =            0x02,    // Italian (Swiss)
-	SUBLANG_KOREAN =                   0x01,    // Korean (Extended Wansung)
-	SUBLANG_KOREAN_JOHAB =             0x02,    // Korean (Johab)
-	SUBLANG_NORWEGIAN_BOKMAL =         0x01,    // Norwegian (Bokmal)
-	SUBLANG_NORWEGIAN_NYNORSK =        0x02,    // Norwegian (Nynorsk)
-	SUBLANG_PORTUGUESE =               0x02,    // Portuguese
-	SUBLANG_PORTUGUESE_BRAZILIAN =     0x01,    // Portuguese (Brazilian)
-	SUBLANG_SERBIAN_LATIN =            0x02,    // Serbian (Latin)
-	SUBLANG_SERBIAN_CYRILLIC =         0x03,    // Serbian (Cyrillic)
-	SUBLANG_SPANISH =                  0x01,    // Spanish (Castilian)
-	SUBLANG_SPANISH_MEXICAN =          0x02,    // Spanish (Mexican)
-	SUBLANG_SPANISH_MODERN =           0x03,    // Spanish (Modern)
-	SUBLANG_SPANISH_GUATEMALA =        0x04,    // Spanish (Guatemala)
-	SUBLANG_SPANISH_COSTA_RICA =       0x05,    // Spanish (Costa Rica)
-	SUBLANG_SPANISH_PANAMA =           0x06,    // Spanish (Panama)
-	SUBLANG_SPANISH_DOMINICAN_REPUBLIC = 0x07,  // Spanish (Dominican Republic)
-	SUBLANG_SPANISH_VENEZUELA =        0x08,    // Spanish (Venezuela)
-	SUBLANG_SPANISH_COLOMBIA =         0x09,    // Spanish (Colombia)
-	SUBLANG_SPANISH_PERU =             0x0a,    // Spanish (Peru)
-	SUBLANG_SPANISH_ARGENTINA =        0x0b,    // Spanish (Argentina)
-	SUBLANG_SPANISH_ECUADOR =          0x0c,    // Spanish (Ecuador)
-	SUBLANG_SPANISH_CHILE =            0x0d,    // Spanish (Chile)
-	SUBLANG_SPANISH_URUGUAY =          0x0e,    // Spanish (Uruguay)
-	SUBLANG_SPANISH_PARAGUAY =         0x0f,    // Spanish (Paraguay)
-	SUBLANG_SPANISH_BOLIVIA =          0x10,    // Spanish (Bolivia)
-	SUBLANG_SPANISH_EL_SALVADOR =      0x11,    // Spanish (El Salvador)
-	SUBLANG_SPANISH_HONDURAS =         0x12,    // Spanish (Honduras)
-	SUBLANG_SPANISH_NICARAGUA =        0x13,    // Spanish (Nicaragua)
-	SUBLANG_SPANISH_PUERTO_RICO =      0x14,    // Spanish (Puerto Rico)
-	SUBLANG_SWEDISH =                  0x01,    // Swedish
-	SUBLANG_SWEDISH_FINLAND =          0x02,    // Swedish (Finland)
-}
-//
-//  Sorting IDs.
-//
-
-enum
-{
-	SORT_DEFAULT                   = 0x0,    // sorting default
-
-	SORT_JAPANESE_XJIS             = 0x0,    // Japanese XJIS order
-	SORT_JAPANESE_UNICODE          = 0x1,    // Japanese Unicode order
-
-	SORT_CHINESE_BIG5              = 0x0,    // Chinese BIG5 order
-	SORT_CHINESE_PRCP              = 0x0,    // PRC Chinese Phonetic order
-	SORT_CHINESE_UNICODE           = 0x1,    // Chinese Unicode order
-	SORT_CHINESE_PRC               = 0x2,    // PRC Chinese Stroke Count order
-
-	SORT_KOREAN_KSC                = 0x0,    // Korean KSC order
-	SORT_KOREAN_UNICODE            = 0x1,    // Korean Unicode order
-
-	SORT_GERMAN_PHONE_BOOK         = 0x1,    // German Phone Book order
-}
-
-// end_r_winnt
-
-//
-//  A language ID is a 16 bit value which is the combination of a
-//  primary language ID and a secondary language ID.  The bits are
-//  allocated as follows:
-//
-//       +-----------------------+-------------------------+
-//       |     Sublanguage ID    |   Primary Language ID   |
-//       +-----------------------+-------------------------+
-//        15                   10 9                       0   bit
-//
-//
-//  Language ID creation/extraction macros:
-//
-//    MAKELANGID    - construct language id from a primary language id and
-//                    a sublanguage id.
-//    PRIMARYLANGID - extract primary language id from a language id.
-//    SUBLANGID     - extract sublanguage id from a language id.
-//
-
-int MAKELANGID(int p, int s) { return ((cast(WORD)s) << 10) | cast(WORD)p; }
-WORD PRIMARYLANGID(int lgid) { return cast(WORD)(lgid & 0x3ff); }
-WORD SUBLANGID(int lgid)     { return cast(WORD)(lgid >> 10); }
-
-
-struct FLOATING_SAVE_AREA {
-    DWORD   ControlWord;
-    DWORD   StatusWord;
-    DWORD   TagWord;
-    DWORD   ErrorOffset;
-    DWORD   ErrorSelector;
-    DWORD   DataOffset;
-    DWORD   DataSelector;
-    BYTE    RegisterArea[80 ];
-    DWORD   Cr0NpxState;
-}
-
-enum
-{
-	SIZE_OF_80387_REGISTERS =      80,
-//
-// The following flags control the contents of the CONTEXT structure.
-//
-	CONTEXT_i386 =    0x00010000,    // this assumes that i386 and
-	CONTEXT_i486 =    0x00010000,    // i486 have identical context records
-
-	CONTEXT_CONTROL =         (CONTEXT_i386 | 0x00000001), // SS:SP, CS:IP, FLAGS, BP
-	CONTEXT_INTEGER =         (CONTEXT_i386 | 0x00000002), // AX, BX, CX, DX, SI, DI
-	CONTEXT_SEGMENTS =        (CONTEXT_i386 | 0x00000004), // DS, ES, FS, GS
-	CONTEXT_FLOATING_POINT =  (CONTEXT_i386 | 0x00000008), // 387 state
-	CONTEXT_DEBUG_REGISTERS = (CONTEXT_i386 | 0x00000010), // DB 0-3,6,7
-
-	CONTEXT_FULL = (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS),
-}
-
-struct CONTEXT
-{
-
-    //
-    // The flags values within this flag control the contents of
-    // a CONTEXT record.
-    //
-    // If the context record is used as an input parameter, then
-    // for each portion of the context record controlled by a flag
-    // whose value is set, it is assumed that that portion of the
-    // context record contains valid context. If the context record
-    // is being used to modify a threads context, then only that
-    // portion of the threads context will be modified.
-    //
-    // If the context record is used as an IN OUT parameter to capture
-    // the context of a thread, then only those portions of the thread's
-    // context corresponding to set flags will be returned.
-    //
-    // The context record is never used as an OUT only parameter.
-    //
-
-    DWORD ContextFlags;
-
-    //
-    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
-    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
-    // included in CONTEXT_FULL.
-    //
-
-    DWORD   Dr0;
-    DWORD   Dr1;
-    DWORD   Dr2;
-    DWORD   Dr3;
-    DWORD   Dr6;
-    DWORD   Dr7;
-
-    //
-    // This section is specified/returned if the
-    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
-    //
-
-    FLOATING_SAVE_AREA FloatSave;
-
-    //
-    // This section is specified/returned if the
-    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
-    //
-
-    DWORD   SegGs;
-    DWORD   SegFs;
-    DWORD   SegEs;
-    DWORD   SegDs;
-
-    //
-    // This section is specified/returned if the
-    // ContextFlags word contians the flag CONTEXT_INTEGER.
-    //
-
-    DWORD   Edi;
-    DWORD   Esi;
-    DWORD   Ebx;
-    DWORD   Edx;
-    DWORD   Ecx;
-    DWORD   Eax;
-
-    //
-    // This section is specified/returned if the
-    // ContextFlags word contians the flag CONTEXT_CONTROL.
-    //
-
-    DWORD   Ebp;
-    DWORD   Eip;
-    DWORD   SegCs;              // MUST BE SANITIZED
-    DWORD   EFlags;             // MUST BE SANITIZED
-    DWORD   Esp;
-    DWORD   SegSs;
-}
-
-enum
-{
-	THREAD_BASE_PRIORITY_LOWRT =  15,  // value that gets a thread to LowRealtime-1
-	THREAD_BASE_PRIORITY_MAX =    2,   // maximum thread base priority boost
-	THREAD_BASE_PRIORITY_MIN =    -2,  // minimum thread base priority boost
-	THREAD_BASE_PRIORITY_IDLE =   -15, // value that gets a thread to idle
-
-	THREAD_PRIORITY_LOWEST =          THREAD_BASE_PRIORITY_MIN,
-	THREAD_PRIORITY_BELOW_NORMAL =    (THREAD_PRIORITY_LOWEST+1),
-	THREAD_PRIORITY_NORMAL =          0,
-	THREAD_PRIORITY_HIGHEST =         THREAD_BASE_PRIORITY_MAX,
-	THREAD_PRIORITY_ABOVE_NORMAL =    (THREAD_PRIORITY_HIGHEST-1),
-	THREAD_PRIORITY_ERROR_RETURN =    int.max,
-
-	THREAD_PRIORITY_TIME_CRITICAL =   THREAD_BASE_PRIORITY_LOWRT,
-	THREAD_PRIORITY_IDLE =            THREAD_BASE_PRIORITY_IDLE,
-}
-
-export HANDLE GetCurrentThread();
-export BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
-export HANDLE GetCurrentProcess();
-export DWORD GetCurrentProcessId();
-export BOOL DuplicateHandle (HANDLE sourceProcess, HANDLE sourceThread,
-        HANDLE targetProcessHandle, HANDLE *targetHandle, DWORD access, 
-        BOOL inheritHandle, DWORD options);
-export DWORD GetCurrentThreadId();
-export BOOL SetThreadPriority(HANDLE hThread, int nPriority);
-export BOOL SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost);
-export BOOL GetThreadPriorityBoost(HANDLE hThread, PBOOL pDisablePriorityBoost);
-export BOOL GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
-export int GetThreadPriority(HANDLE hThread);
-export BOOL GetThreadContext(HANDLE hThread, CONTEXT* lpContext);
-export BOOL SetThreadContext(HANDLE hThread, CONTEXT* lpContext);
-export DWORD SuspendThread(HANDLE hThread);
-export DWORD ResumeThread(HANDLE hThread);
-export DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
-export DWORD WaitForMultipleObjects(DWORD nCount, HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
-export void Sleep(DWORD dwMilliseconds);
-
-// Synchronization
-
-export
-{
-LONG  InterlockedIncrement(LPLONG lpAddend);
-LONG  InterlockedDecrement(LPLONG lpAddend);
-LONG  InterlockedExchange(LPLONG Target, LONG Value);
-LONG  InterlockedExchangeAdd(LPLONG Addend, LONG Value);
-PVOID InterlockedCompareExchange(PVOID *Destination, PVOID Exchange, PVOID Comperand);
-
-void InitializeCriticalSection(CRITICAL_SECTION * lpCriticalSection);
-void EnterCriticalSection(CRITICAL_SECTION * lpCriticalSection);
-BOOL TryEnterCriticalSection(CRITICAL_SECTION * lpCriticalSection);
-void LeaveCriticalSection(CRITICAL_SECTION * lpCriticalSection);
-void DeleteCriticalSection(CRITICAL_SECTION * lpCriticalSection);
-
-}
-
-
-
-export BOOL QueryPerformanceCounter(long* lpPerformanceCount);
-export BOOL QueryPerformanceFrequency(long* lpFrequency);
-
-enum
-{
-	WM_NOTIFY =                       0x004E,
-	WM_INPUTLANGCHANGEREQUEST =       0x0050,
-	WM_INPUTLANGCHANGE =              0x0051,
-	WM_TCARD =                        0x0052,
-	WM_HELP =                         0x0053,
-	WM_USERCHANGED =                  0x0054,
-	WM_NOTIFYFORMAT =                 0x0055,
-
-	NFR_ANSI =                             1,
-	NFR_UNICODE =                          2,
-	NF_QUERY =                             3,
-	NF_REQUERY =                           4,
-
-	WM_CONTEXTMENU =                  0x007B,
-	WM_STYLECHANGING =                0x007C,
-	WM_STYLECHANGED =                 0x007D,
-	WM_DISPLAYCHANGE =                0x007E,
-	WM_GETICON =                      0x007F,
-	WM_SETICON =                      0x0080,
-
-
-
-	WM_NCCREATE =                     0x0081,
-	WM_NCDESTROY =                    0x0082,
-	WM_NCCALCSIZE =                   0x0083,
-	WM_NCHITTEST =                    0x0084,
-	WM_NCPAINT =                      0x0085,
-	WM_NCACTIVATE =                   0x0086,
-	WM_GETDLGCODE =                   0x0087,
-
-	WM_NCMOUSEMOVE =                  0x00A0,
-	WM_NCLBUTTONDOWN =                0x00A1,
-	WM_NCLBUTTONUP =                  0x00A2,
-	WM_NCLBUTTONDBLCLK =              0x00A3,
-	WM_NCRBUTTONDOWN =                0x00A4,
-	WM_NCRBUTTONUP =                  0x00A5,
-	WM_NCRBUTTONDBLCLK =              0x00A6,
-	WM_NCMBUTTONDOWN =                0x00A7,
-	WM_NCMBUTTONUP =                  0x00A8,
-	WM_NCMBUTTONDBLCLK =              0x00A9,
-
-	WM_KEYFIRST =                     0x0100,
-	WM_KEYDOWN =                      0x0100,
-	WM_KEYUP =                        0x0101,
-	WM_CHAR =                         0x0102,
-	WM_DEADCHAR =                     0x0103,
-	WM_SYSKEYDOWN =                   0x0104,
-	WM_SYSKEYUP =                     0x0105,
-	WM_SYSCHAR =                      0x0106,
-	WM_SYSDEADCHAR =                  0x0107,
-	WM_KEYLAST =                      0x0108,
-
-
-	WM_IME_STARTCOMPOSITION =         0x010D,
-	WM_IME_ENDCOMPOSITION =           0x010E,
-	WM_IME_COMPOSITION =              0x010F,
-	WM_IME_KEYLAST =                  0x010F,
-
-
-	WM_INITDIALOG =                   0x0110,
-	WM_COMMAND =                      0x0111,
-	WM_SYSCOMMAND =                   0x0112,
-	WM_TIMER =                        0x0113,
-	WM_HSCROLL =                      0x0114,
-	WM_VSCROLL =                      0x0115,
-	WM_INITMENU =                     0x0116,
-	WM_INITMENUPOPUP =                0x0117,
-	WM_MENUSELECT =                   0x011F,
-	WM_MENUCHAR =                     0x0120,
-	WM_ENTERIDLE =                    0x0121,
-
-	WM_CTLCOLORMSGBOX =               0x0132,
-	WM_CTLCOLOREDIT =                 0x0133,
-	WM_CTLCOLORLISTBOX =              0x0134,
-	WM_CTLCOLORBTN =                  0x0135,
-	WM_CTLCOLORDLG =                  0x0136,
-	WM_CTLCOLORSCROLLBAR =            0x0137,
-	WM_CTLCOLORSTATIC =               0x0138,
-
-
-
-	WM_MOUSEFIRST =                   0x0200,
-	WM_MOUSEMOVE =                    0x0200,
-	WM_LBUTTONDOWN =                  0x0201,
-	WM_LBUTTONUP =                    0x0202,
-	WM_LBUTTONDBLCLK =                0x0203,
-	WM_RBUTTONDOWN =                  0x0204,
-	WM_RBUTTONUP =                    0x0205,
-	WM_RBUTTONDBLCLK =                0x0206,
-	WM_MBUTTONDOWN =                  0x0207,
-	WM_MBUTTONUP =                    0x0208,
-	WM_MBUTTONDBLCLK =                0x0209,
-
-
-
-	WM_MOUSELAST =                    0x0209,
-
-
-
-
-
-
-
-
-	WM_PARENTNOTIFY =                 0x0210,
-	MENULOOP_WINDOW =                 0,
-	MENULOOP_POPUP =                  1,
-	WM_ENTERMENULOOP =                0x0211,
-	WM_EXITMENULOOP =                 0x0212,
-
-
-	WM_NEXTMENU =                     0x0213,
-}
-
-enum
-{
-/*
- * Dialog Box Command IDs
- */
-	IDOK =                1,
-	IDCANCEL =            2,
-	IDABORT =             3,
-	IDRETRY =             4,
-	IDIGNORE =            5,
-	IDYES =               6,
-	IDNO =                7,
-
-	IDCLOSE =         8,
-	IDHELP =          9,
-
-
-// end_r_winuser
-
-
-
-/*
- * Control Manager Structures and Definitions
- */
-
-
-
-// begin_r_winuser
-
-/*
- * Edit Control Styles
- */
-	ES_LEFT =             0x0000,
-	ES_CENTER =           0x0001,
-	ES_RIGHT =            0x0002,
-	ES_MULTILINE =        0x0004,
-	ES_UPPERCASE =        0x0008,
-	ES_LOWERCASE =        0x0010,
-	ES_PASSWORD =         0x0020,
-	ES_AUTOVSCROLL =      0x0040,
-	ES_AUTOHSCROLL =      0x0080,
-	ES_NOHIDESEL =        0x0100,
-	ES_OEMCONVERT =       0x0400,
-	ES_READONLY =         0x0800,
-	ES_WANTRETURN =       0x1000,
-
-	ES_NUMBER =           0x2000,
-
-
-// end_r_winuser
-
-
-
-/*
- * Edit Control Notification Codes
- */
-	EN_SETFOCUS =         0x0100,
-	EN_KILLFOCUS =        0x0200,
-	EN_CHANGE =           0x0300,
-	EN_UPDATE =           0x0400,
-	EN_ERRSPACE =         0x0500,
-	EN_MAXTEXT =          0x0501,
-	EN_HSCROLL =          0x0601,
-	EN_VSCROLL =          0x0602,
-
-
-/* Edit control EM_SETMARGIN parameters */
-	EC_LEFTMARGIN =       0x0001,
-	EC_RIGHTMARGIN =      0x0002,
-	EC_USEFONTINFO =      0xffff,
-
-
-
-
-// begin_r_winuser
-
-/*
- * Edit Control Messages
- */
-	EM_GETSEL =               0x00B0,
-	EM_SETSEL =               0x00B1,
-	EM_GETRECT =              0x00B2,
-	EM_SETRECT =              0x00B3,
-	EM_SETRECTNP =            0x00B4,
-	EM_SCROLL =               0x00B5,
-	EM_LINESCROLL =           0x00B6,
-	EM_SCROLLCARET =          0x00B7,
-	EM_GETMODIFY =            0x00B8,
-	EM_SETMODIFY =            0x00B9,
-	EM_GETLINECOUNT =         0x00BA,
-	EM_LINEINDEX =            0x00BB,
-	EM_SETHANDLE =            0x00BC,
-	EM_GETHANDLE =            0x00BD,
-	EM_GETTHUMB =             0x00BE,
-	EM_LINELENGTH =           0x00C1,
-	EM_REPLACESEL =           0x00C2,
-	EM_GETLINE =              0x00C4,
-	EM_LIMITTEXT =            0x00C5,
-	EM_CANUNDO =              0x00C6,
-	EM_UNDO =                 0x00C7,
-	EM_FMTLINES =             0x00C8,
-	EM_LINEFROMCHAR =         0x00C9,
-	EM_SETTABSTOPS =          0x00CB,
-	EM_SETPASSWORDCHAR =      0x00CC,
-	EM_EMPTYUNDOBUFFER =      0x00CD,
-	EM_GETFIRSTVISIBLELINE =  0x00CE,
-	EM_SETREADONLY =          0x00CF,
-	EM_SETWORDBREAKPROC =     0x00D0,
-	EM_GETWORDBREAKPROC =     0x00D1,
-	EM_GETPASSWORDCHAR =      0x00D2,
-
-	EM_SETMARGINS =           0x00D3,
-	EM_GETMARGINS =           0x00D4,
-	EM_SETLIMITTEXT =         EM_LIMITTEXT, /* ;win40 Name change */
-	EM_GETLIMITTEXT =         0x00D5,
-	EM_POSFROMCHAR =          0x00D6,
-	EM_CHARFROMPOS =          0x00D7,
-
-
-
-// end_r_winuser
-
-
-/*
- * EDITWORDBREAKPROC code values
- */
-	WB_LEFT =            0,
-	WB_RIGHT =           1,
-	WB_ISDELIMITER =     2,
-
-// begin_r_winuser
-
-/*
- * Button Control Styles
- */
-	BS_PUSHBUTTON =       0x00000000,
-	BS_DEFPUSHBUTTON =    0x00000001,
-	BS_CHECKBOX =         0x00000002,
-	BS_AUTOCHECKBOX =     0x00000003,
-	BS_RADIOBUTTON =      0x00000004,
-	BS_3STATE =           0x00000005,
-	BS_AUTO3STATE =       0x00000006,
-	BS_GROUPBOX =         0x00000007,
-	BS_USERBUTTON =       0x00000008,
-	BS_AUTORADIOBUTTON =  0x00000009,
-	BS_OWNERDRAW =        0x0000000B,
-	BS_LEFTTEXT =         0x00000020,
-
-	BS_TEXT =             0x00000000,
-	BS_ICON =             0x00000040,
-	BS_BITMAP =           0x00000080,
-	BS_LEFT =             0x00000100,
-	BS_RIGHT =            0x00000200,
-	BS_CENTER =           0x00000300,
-	BS_TOP =              0x00000400,
-	BS_BOTTOM =           0x00000800,
-	BS_VCENTER =          0x00000C00,
-	BS_PUSHLIKE =         0x00001000,
-	BS_MULTILINE =        0x00002000,
-	BS_NOTIFY =           0x00004000,
-	BS_FLAT =             0x00008000,
-	BS_RIGHTBUTTON =      BS_LEFTTEXT,
-
-
-
-/*
- * User Button Notification Codes
- */
-	BN_CLICKED =          0,
-	BN_PAINT =            1,
-	BN_HILITE =           2,
-	BN_UNHILITE =         3,
-	BN_DISABLE =          4,
-	BN_DOUBLECLICKED =    5,
-
-	BN_PUSHED =           BN_HILITE,
-	BN_UNPUSHED =         BN_UNHILITE,
-	BN_DBLCLK =           BN_DOUBLECLICKED,
-	BN_SETFOCUS =         6,
-	BN_KILLFOCUS =        7,
-
-/*
- * Button Control Messages
- */
-	BM_GETCHECK =        0x00F0,
-	BM_SETCHECK =        0x00F1,
-	BM_GETSTATE =        0x00F2,
-	BM_SETSTATE =        0x00F3,
-	BM_SETSTYLE =        0x00F4,
-
-	BM_CLICK =           0x00F5,
-	BM_GETIMAGE =        0x00F6,
-	BM_SETIMAGE =        0x00F7,
-
-	BST_UNCHECKED =      0x0000,
-	BST_CHECKED =        0x0001,
-	BST_INDETERMINATE =  0x0002,
-	BST_PUSHED =         0x0004,
-	BST_FOCUS =          0x0008,
-
-
-/*
- * Static Control Constants
- */
-	SS_LEFT =             0x00000000,
-	SS_CENTER =           0x00000001,
-	SS_RIGHT =            0x00000002,
-	SS_ICON =             0x00000003,
-	SS_BLACKRECT =        0x00000004,
-	SS_GRAYRECT =         0x00000005,
-	SS_WHITERECT =        0x00000006,
-	SS_BLACKFRAME =       0x00000007,
-	SS_GRAYFRAME =        0x00000008,
-	SS_WHITEFRAME =       0x00000009,
-	SS_USERITEM =         0x0000000A,
-	SS_SIMPLE =           0x0000000B,
-	SS_LEFTNOWORDWRAP =   0x0000000C,
-
-	SS_OWNERDRAW =        0x0000000D,
-	SS_BITMAP =           0x0000000E,
-	SS_ENHMETAFILE =      0x0000000F,
-	SS_ETCHEDHORZ =       0x00000010,
-	SS_ETCHEDVERT =       0x00000011,
-	SS_ETCHEDFRAME =      0x00000012,
-	SS_TYPEMASK =         0x0000001F,
-
-	SS_NOPREFIX =         0x00000080, /* Don't do "&" character translation */
-
-	SS_NOTIFY =           0x00000100,
-	SS_CENTERIMAGE =      0x00000200,
-	SS_RIGHTJUST =        0x00000400,
-	SS_REALSIZEIMAGE =    0x00000800,
-	SS_SUNKEN =           0x00001000,
-	SS_ENDELLIPSIS =      0x00004000,
-	SS_PATHELLIPSIS =     0x00008000,
-	SS_WORDELLIPSIS =     0x0000C000,
-	SS_ELLIPSISMASK =     0x0000C000,
-
-
-// end_r_winuser
-
-
-/*
- * Static Control Mesages
- */
-	STM_SETICON =         0x0170,
-	STM_GETICON =         0x0171,
-
-	STM_SETIMAGE =        0x0172,
-	STM_GETIMAGE =        0x0173,
-	STN_CLICKED =         0,
-	STN_DBLCLK =          1,
-	STN_ENABLE =          2,
-	STN_DISABLE =         3,
-
-	STM_MSGMAX =          0x0174,
-}
-
-
-enum
-{
-/*
- * Window Messages
- */
-
-	WM_NULL =                         0x0000,
-	WM_CREATE =                       0x0001,
-	WM_DESTROY =                      0x0002,
-	WM_MOVE =                         0x0003,
-	WM_SIZE =                         0x0005,
-
-	WM_ACTIVATE =                     0x0006,
-/*
- * WM_ACTIVATE state values
- */
-	WA_INACTIVE =     0,
-	WA_ACTIVE =       1,
-	WA_CLICKACTIVE =  2,
-
-	WM_SETFOCUS =                     0x0007,
-	WM_KILLFOCUS =                    0x0008,
-	WM_ENABLE =                       0x000A,
-	WM_SETREDRAW =                    0x000B,
-	WM_SETTEXT =                      0x000C,
-	WM_GETTEXT =                      0x000D,
-	WM_GETTEXTLENGTH =                0x000E,
-	WM_PAINT =                        0x000F,
-	WM_CLOSE =                        0x0010,
-	WM_QUERYENDSESSION =              0x0011,
-	WM_QUIT =                         0x0012,
-	WM_QUERYOPEN =                    0x0013,
-	WM_ERASEBKGND =                   0x0014,
-	WM_SYSCOLORCHANGE =               0x0015,
-	WM_ENDSESSION =                   0x0016,
-	WM_SHOWWINDOW =                   0x0018,
-	WM_WININICHANGE =                 0x001A,
-
-	WM_SETTINGCHANGE =                WM_WININICHANGE,
-
-
-
-	WM_DEVMODECHANGE =                0x001B,
-	WM_ACTIVATEAPP =                  0x001C,
-	WM_FONTCHANGE =                   0x001D,
-	WM_TIMECHANGE =                   0x001E,
-	WM_CANCELMODE =                   0x001F,
-	WM_SETCURSOR =                    0x0020,
-	WM_MOUSEACTIVATE =                0x0021,
-	WM_CHILDACTIVATE =                0x0022,
-	WM_QUEUESYNC =                    0x0023,
-
-	WM_GETMINMAXINFO =                0x0024,
-}
-
-struct RECT
-{
-    LONG    left;
-    LONG    top;
-    LONG    right;
-    LONG    bottom;
-}
-alias RECT* PRECT, NPRECT, LPRECT;
-
-struct PAINTSTRUCT {
-    HDC         hdc;
-    BOOL        fErase;
-    RECT        rcPaint;
-    BOOL        fRestore;
-    BOOL        fIncUpdate;
-    BYTE        rgbReserved[32];
-}
-alias PAINTSTRUCT* PPAINTSTRUCT, NPPAINTSTRUCT, LPPAINTSTRUCT;
-
-// flags for GetDCEx()
-
-enum
-{
-	DCX_WINDOW =           0x00000001,
-	DCX_CACHE =            0x00000002,
-	DCX_NORESETATTRS =     0x00000004,
-	DCX_CLIPCHILDREN =     0x00000008,
-	DCX_CLIPSIBLINGS =     0x00000010,
-	DCX_PARENTCLIP =       0x00000020,
-	DCX_EXCLUDERGN =       0x00000040,
-	DCX_INTERSECTRGN =     0x00000080,
-	DCX_EXCLUDEUPDATE =    0x00000100,
-	DCX_INTERSECTUPDATE =  0x00000200,
-	DCX_LOCKWINDOWUPDATE = 0x00000400,
-	DCX_VALIDATE =         0x00200000,
-}
-
-export
-{
- BOOL UpdateWindow(HWND hWnd);
- HWND SetActiveWindow(HWND hWnd);
- HWND GetForegroundWindow();
- BOOL PaintDesktop(HDC hdc);
- BOOL SetForegroundWindow(HWND hWnd);
- HWND WindowFromDC(HDC hDC);
- HDC GetDC(HWND hWnd);
- HDC GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags);
- HDC GetWindowDC(HWND hWnd);
- int ReleaseDC(HWND hWnd, HDC hDC);
- HDC BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);
- BOOL EndPaint(HWND hWnd, PAINTSTRUCT *lpPaint);
- BOOL GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase);
- int GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase);
- int SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw);
- int GetWindowRgn(HWND hWnd, HRGN hRgn);
- int ExcludeUpdateRgn(HDC hDC, HWND hWnd);
- BOOL InvalidateRect(HWND hWnd, RECT *lpRect, BOOL bErase);
- BOOL ValidateRect(HWND hWnd, RECT *lpRect);
- BOOL InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase);
- BOOL ValidateRgn(HWND hWnd, HRGN hRgn);
- BOOL RedrawWindow(HWND hWnd, RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags);
-}
-
-// flags for RedrawWindow()
-enum
-{
-	RDW_INVALIDATE =          0x0001,
-	RDW_INTERNALPAINT =       0x0002,
-	RDW_ERASE =               0x0004,
-	RDW_VALIDATE =            0x0008,
-	RDW_NOINTERNALPAINT =     0x0010,
-	RDW_NOERASE =             0x0020,
-	RDW_NOCHILDREN =          0x0040,
-	RDW_ALLCHILDREN =         0x0080,
-	RDW_UPDATENOW =           0x0100,
-	RDW_ERASENOW =            0x0200,
-	RDW_FRAME =               0x0400,
-	RDW_NOFRAME =             0x0800,
-}
-
-export
-{
- BOOL GetClientRect(HWND hWnd, LPRECT lpRect);
- BOOL GetWindowRect(HWND hWnd, LPRECT lpRect);
- BOOL AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu);
- BOOL AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle);
- HFONT CreateFontA(int, int, int, int, int, DWORD,
-                             DWORD, DWORD, DWORD, DWORD, DWORD,
-                             DWORD, DWORD, LPCSTR);
- HFONT CreateFontW(int, int, int, int, int, DWORD,
-                             DWORD, DWORD, DWORD, DWORD, DWORD,
-                             DWORD, DWORD, LPCWSTR);
-}
-
-enum
-{
-	OUT_DEFAULT_PRECIS =          0,
-	OUT_STRING_PRECIS =           1,
-	OUT_CHARACTER_PRECIS =        2,
-	OUT_STROKE_PRECIS =           3,
-	OUT_TT_PRECIS =               4,
-	OUT_DEVICE_PRECIS =           5,
-	OUT_RASTER_PRECIS =           6,
-	OUT_TT_ONLY_PRECIS =          7,
-	OUT_OUTLINE_PRECIS =          8,
-	OUT_SCREEN_OUTLINE_PRECIS =   9,
-
-	CLIP_DEFAULT_PRECIS =     0,
-	CLIP_CHARACTER_PRECIS =   1,
-	CLIP_STROKE_PRECIS =      2,
-	CLIP_MASK =               0xf,
-	CLIP_LH_ANGLES =          (1<<4),
-	CLIP_TT_ALWAYS =          (2<<4),
-	CLIP_EMBEDDED =           (8<<4),
-
-	DEFAULT_QUALITY =         0,
-	DRAFT_QUALITY =           1,
-	PROOF_QUALITY =           2,
-
-	NONANTIALIASED_QUALITY =  3,
-	ANTIALIASED_QUALITY =     4,
-
-
-	DEFAULT_PITCH =           0,
-	FIXED_PITCH =             1,
-	VARIABLE_PITCH =          2,
-
-	MONO_FONT =               8,
-
-
-	ANSI_CHARSET =            0,
-	DEFAULT_CHARSET =         1,
-	SYMBOL_CHARSET =          2,
-	SHIFTJIS_CHARSET =        128,
-	HANGEUL_CHARSET =         129,
-	GB2312_CHARSET =          134,
-	CHINESEBIG5_CHARSET =     136,
-	OEM_CHARSET =             255,
-
-	JOHAB_CHARSET =           130,
-	HEBREW_CHARSET =          177,
-	ARABIC_CHARSET =          178,
-	GREEK_CHARSET =           161,
-	TURKISH_CHARSET =         162,
-	VIETNAMESE_CHARSET =      163,
-	THAI_CHARSET =            222,
-	EASTEUROPE_CHARSET =      238,
-	RUSSIAN_CHARSET =         204,
-
-	MAC_CHARSET =             77,
-	BALTIC_CHARSET =          186,
-
-	FS_LATIN1 =               0x00000001L,
-	FS_LATIN2 =               0x00000002L,
-	FS_CYRILLIC =             0x00000004L,
-	FS_GREEK =                0x00000008L,
-	FS_TURKISH =              0x00000010L,
-	FS_HEBREW =               0x00000020L,
-	FS_ARABIC =               0x00000040L,
-	FS_BALTIC =               0x00000080L,
-	FS_VIETNAMESE =           0x00000100L,
-	FS_THAI =                 0x00010000L,
-	FS_JISJAPAN =             0x00020000L,
-	FS_CHINESESIMP =          0x00040000L,
-	FS_WANSUNG =              0x00080000L,
-	FS_CHINESETRAD =          0x00100000L,
-	FS_JOHAB =                0x00200000L,
-	FS_SYMBOL =               cast(int)0x80000000L,
-
-
-/* Font Families */
-	FF_DONTCARE =         (0<<4), /* Don't care or don't know. */
-	FF_ROMAN =            (1<<4), /* Variable stroke width, serifed. */
-                                    /* Times Roman, Century Schoolbook, etc. */
-	FF_SWISS =            (2<<4), /* Variable stroke width, sans-serifed. */
-                                    /* Helvetica, Swiss, etc. */
-	FF_MODERN =           (3<<4), /* Constant stroke width, serifed or sans-serifed. */
-                                    /* Pica, Elite, Courier, etc. */
-	FF_SCRIPT =           (4<<4), /* Cursive, etc. */
-	FF_DECORATIVE =       (5<<4), /* Old English, etc. */
-
-/* Font Weights */
-	FW_DONTCARE =         0,
-	FW_THIN =             100,
-	FW_EXTRALIGHT =       200,
-	FW_LIGHT =            300,
-	FW_NORMAL =           400,
-	FW_MEDIUM =           500,
-	FW_SEMIBOLD =         600,
-	FW_BOLD =             700,
-	FW_EXTRABOLD =        800,
-	FW_HEAVY =            900,
-
-	FW_ULTRALIGHT =       FW_EXTRALIGHT,
-	FW_REGULAR =          FW_NORMAL,
-	FW_DEMIBOLD =         FW_SEMIBOLD,
-	FW_ULTRABOLD =        FW_EXTRABOLD,
-	FW_BLACK =            FW_HEAVY,
-
-	PANOSE_COUNT =               10,
-	PAN_FAMILYTYPE_INDEX =        0,
-	PAN_SERIFSTYLE_INDEX =        1,
-	PAN_WEIGHT_INDEX =            2,
-	PAN_PROPORTION_INDEX =        3,
-	PAN_CONTRAST_INDEX =          4,
-	PAN_STROKEVARIATION_INDEX =   5,
-	PAN_ARMSTYLE_INDEX =          6,
-	PAN_LETTERFORM_INDEX =        7,
-	PAN_MIDLINE_INDEX =           8,
-	PAN_XHEIGHT_INDEX =           9,
-
-	PAN_CULTURE_LATIN =           0,
-}
-
-struct RGBQUAD {
-        BYTE    rgbBlue;
-        BYTE    rgbGreen;
-        BYTE    rgbRed;
-        BYTE    rgbReserved;
-}
-alias RGBQUAD* LPRGBQUAD;
-
-struct BITMAPINFOHEADER
-{
-        DWORD      biSize;
-        LONG       biWidth;
-        LONG       biHeight;
-        WORD       biPlanes;
-        WORD       biBitCount;
-        DWORD      biCompression;
-        DWORD      biSizeImage;
-        LONG       biXPelsPerMeter;
-        LONG       biYPelsPerMeter;
-        DWORD      biClrUsed;
-        DWORD      biClrImportant;
-}
-alias BITMAPINFOHEADER* LPBITMAPINFOHEADER, PBITMAPINFOHEADER;
-
-struct BITMAPINFO {
-    BITMAPINFOHEADER    bmiHeader;
-    RGBQUAD             bmiColors[1];
-}
-alias BITMAPINFO* LPBITMAPINFO, PBITMAPINFO;
-
-struct PALETTEENTRY {
-    BYTE        peRed;
-    BYTE        peGreen;
-    BYTE        peBlue;
-    BYTE        peFlags;
-}
-alias PALETTEENTRY* PPALETTEENTRY, LPPALETTEENTRY;
-
-struct LOGPALETTE {
-    WORD        palVersion;
-    WORD        palNumEntries;
-    PALETTEENTRY        palPalEntry[1];
-}
-alias LOGPALETTE* PLOGPALETTE, NPLOGPALETTE, LPLOGPALETTE;
-
-/* Pixel format descriptor */
-struct PIXELFORMATDESCRIPTOR
-{
-    WORD  nSize;
-    WORD  nVersion;
-    DWORD dwFlags;
-    BYTE  iPixelType;
-    BYTE  cColorBits;
-    BYTE  cRedBits;
-    BYTE  cRedShift;
-    BYTE  cGreenBits;
-    BYTE  cGreenShift;
-    BYTE  cBlueBits;
-    BYTE  cBlueShift;
-    BYTE  cAlphaBits;
-    BYTE  cAlphaShift;
-    BYTE  cAccumBits;
-    BYTE  cAccumRedBits;
-    BYTE  cAccumGreenBits;
-    BYTE  cAccumBlueBits;
-    BYTE  cAccumAlphaBits;
-    BYTE  cDepthBits;
-    BYTE  cStencilBits;
-    BYTE  cAuxBuffers;
-    BYTE  iLayerType;
-    BYTE  bReserved;
-    DWORD dwLayerMask;
-    DWORD dwVisibleMask;
-    DWORD dwDamageMask;
-}
-alias PIXELFORMATDESCRIPTOR* PPIXELFORMATDESCRIPTOR, LPPIXELFORMATDESCRIPTOR;
-
-
-export
-{
- BOOL   RoundRect(HDC, int, int, int, int, int, int);
- BOOL   ResizePalette(HPALETTE, UINT);
- int    SaveDC(HDC);
- int    SelectClipRgn(HDC, HRGN);
- int    ExtSelectClipRgn(HDC, HRGN, int);
- int    SetMetaRgn(HDC);
- HGDIOBJ   SelectObject(HDC, HGDIOBJ);
- HPALETTE   SelectPalette(HDC, HPALETTE, BOOL);
- COLORREF   SetBkColor(HDC, COLORREF);
- int     SetBkMode(HDC, int);
- LONG    SetBitmapBits(HBITMAP, DWORD, void *);
- UINT    SetBoundsRect(HDC,   RECT *, UINT);
- int     SetDIBits(HDC, HBITMAP, UINT, UINT, void *, BITMAPINFO *, UINT);
- int     SetDIBitsToDevice(HDC, int, int, DWORD, DWORD, int,
-        int, UINT, UINT, void *, BITMAPINFO *, UINT);
- DWORD   SetMapperFlags(HDC, DWORD);
- int     SetGraphicsMode(HDC hdc, int iMode);
- int     SetMapMode(HDC, int);
- HMETAFILE     SetMetaFileBitsEx(UINT, BYTE *);
- UINT    SetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY *);
- COLORREF   SetPixel(HDC, int, int, COLORREF);
- BOOL     SetPixelV(HDC, int, int, COLORREF);
- BOOL    SetPixelFormat(HDC, int, PIXELFORMATDESCRIPTOR *);
- int     SetPolyFillMode(HDC, int);
- BOOL    StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
- BOOL    SetRectRgn(HRGN, int, int, int, int);
- int     StretchDIBits(HDC, int, int, int, int, int, int, int, int,
-         void *, BITMAPINFO *, UINT, DWORD);
- int     SetROP2(HDC, int);
- int     SetStretchBltMode(HDC, int);
- UINT    SetSystemPaletteUse(HDC, UINT);
- int     SetTextCharacterExtra(HDC, int);
- COLORREF   SetTextColor(HDC, COLORREF);
- UINT    SetTextAlign(HDC, UINT);
- BOOL    SetTextJustification(HDC, int, int);
- BOOL    UpdateColors(HDC);
-}
-
-/* Text Alignment Options */
-enum
-{
-	TA_NOUPDATECP =                0,
-	TA_UPDATECP =                  1,
-
-	TA_LEFT =                      0,
-	TA_RIGHT =                     2,
-	TA_CENTER =                    6,
-
-	TA_TOP =                       0,
-	TA_BOTTOM =                    8,
-	TA_BASELINE =                  24,
-
-	TA_RTLREADING =                256,
-	TA_MASK =       (TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING),
-}
-
-struct POINT
-{
-    LONG  x;
-    LONG  y;
-}
-alias POINT* PPOINT, NPPOINT, LPPOINT;
-
-
-export
-{
- BOOL    MoveToEx(HDC, int, int, LPPOINT);
- BOOL    TextOutA(HDC, int, int, LPCSTR, int);
- BOOL    TextOutW(HDC, int, int, LPCWSTR, int);
-}
-
-export void PostQuitMessage(int nExitCode);
-export LRESULT DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
-export HMODULE GetModuleHandleA(LPCSTR lpModuleName);
-
-alias LRESULT (* WNDPROC)(HWND, UINT, WPARAM, LPARAM);
-
-struct WNDCLASSEXA {
-    UINT        cbSize;
-    /* Win 3.x */
-    UINT        style;
-    WNDPROC     lpfnWndProc;
-    int         cbClsExtra;
-    int         cbWndExtra;
-    HINSTANCE   hInstance;
-    HICON       hIcon;
-    HCURSOR     hCursor;
-    HBRUSH      hbrBackground;
-    LPCSTR      lpszMenuName;
-    LPCSTR      lpszClassName;
-    /* Win 4.0 */
-    HICON       hIconSm;
-}
-alias WNDCLASSEXA* PWNDCLASSEXA, NPWNDCLASSEXA, LPWNDCLASSEXA;
-
-
-struct WNDCLASSA {
-    UINT        style;
-    WNDPROC     lpfnWndProc;
-    int         cbClsExtra;
-    int         cbWndExtra;
-    HINSTANCE   hInstance;
-    HICON       hIcon;
-    HCURSOR     hCursor;
-    HBRUSH      hbrBackground;
-    LPCSTR      lpszMenuName;
-    LPCSTR      lpszClassName;
-}
-alias WNDCLASSA* PWNDCLASSA, NPWNDCLASSA, LPWNDCLASSA;
-alias WNDCLASSA WNDCLASS;
-
-/*
- * Window Styles
- */
-enum : uint
-{
-	WS_OVERLAPPED =       0x00000000,
-	WS_POPUP =            0x80000000,
-	WS_CHILD =            0x40000000,
-	WS_MINIMIZE =         0x20000000,
-	WS_VISIBLE =          0x10000000,
-	WS_DISABLED =         0x08000000,
-	WS_CLIPSIBLINGS =     0x04000000,
-	WS_CLIPCHILDREN =     0x02000000,
-	WS_MAXIMIZE =         0x01000000,
-	WS_CAPTION =          0x00C00000,  /* WS_BORDER | WS_DLGFRAME  */
-	WS_BORDER =           0x00800000,
-	WS_DLGFRAME =         0x00400000,
-	WS_VSCROLL =          0x00200000,
-	WS_HSCROLL =          0x00100000,
-	WS_SYSMENU =          0x00080000,
-	WS_THICKFRAME =       0x00040000,
-	WS_GROUP =            0x00020000,
-	WS_TABSTOP =          0x00010000,
-
-	WS_MINIMIZEBOX =      0x00020000,
-	WS_MAXIMIZEBOX =      0x00010000,
-
-	WS_TILED =            WS_OVERLAPPED,
-	WS_ICONIC =           WS_MINIMIZE,
-	WS_SIZEBOX =          WS_THICKFRAME,
-
-/*
- * Common Window Styles
- */
-	WS_OVERLAPPEDWINDOW = (WS_OVERLAPPED |            WS_CAPTION |  WS_SYSMENU |  WS_THICKFRAME |            WS_MINIMIZEBOX |                 WS_MAXIMIZEBOX),
-	WS_TILEDWINDOW =      WS_OVERLAPPEDWINDOW,
-	WS_POPUPWINDOW =      (WS_POPUP |  WS_BORDER |  WS_SYSMENU),
-	WS_CHILDWINDOW =      (WS_CHILD),
-}
-
-/*
- * Class styles
- */
-enum
-{
-	CS_VREDRAW =          0x0001,
-	CS_HREDRAW =          0x0002,
-	CS_KEYCVTWINDOW =     0x0004,
-	CS_DBLCLKS =          0x0008,
-	CS_OWNDC =            0x0020,
-	CS_CLASSDC =          0x0040,
-	CS_PARENTDC =         0x0080,
-	CS_NOKEYCVT =         0x0100,
-	CS_NOCLOSE =          0x0200,
-	CS_SAVEBITS =         0x0800,
-	CS_BYTEALIGNCLIENT =  0x1000,
-	CS_BYTEALIGNWINDOW =  0x2000,
-	CS_GLOBALCLASS =      0x4000,
-
-
-	CS_IME =              0x00010000,
-}
-
-export
-{
- HICON LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName);
- HICON LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName);
- HCURSOR LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName);
- HCURSOR LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName);
-}
-
-enum : LPSTR
-{
-	IDI_APPLICATION =     cast(LPSTR)(32512),
-
-	IDC_ARROW =           cast(LPSTR)(32512),
-	IDC_CROSS =           cast(LPSTR)(32515),
-}
-
-/*
- * Color Types
- */
-enum
-{
-	CTLCOLOR_MSGBOX =         0,
-	CTLCOLOR_EDIT =           1,
-	CTLCOLOR_LISTBOX =        2,
-	CTLCOLOR_BTN =            3,
-	CTLCOLOR_DLG =            4,
-	CTLCOLOR_SCROLLBAR =      5,
-	CTLCOLOR_STATIC =         6,
-	CTLCOLOR_MAX =            7,
-
-	COLOR_SCROLLBAR =         0,
-	COLOR_BACKGROUND =        1,
-	COLOR_ACTIVECAPTION =     2,
-	COLOR_INACTIVECAPTION =   3,
-	COLOR_MENU =              4,
-	COLOR_WINDOW =            5,
-	COLOR_WINDOWFRAME =       6,
-	COLOR_MENUTEXT =          7,
-	COLOR_WINDOWTEXT =        8,
-	COLOR_CAPTIONTEXT =       9,
-	COLOR_ACTIVEBORDER =      10,
-	COLOR_INACTIVEBORDER =    11,
-	COLOR_APPWORKSPACE =      12,
-	COLOR_HIGHLIGHT =         13,
-	COLOR_HIGHLIGHTTEXT =     14,
-	COLOR_BTNFACE =           15,
-	COLOR_BTNSHADOW =         16,
-	COLOR_GRAYTEXT =          17,
-	COLOR_BTNTEXT =           18,
-	COLOR_INACTIVECAPTIONTEXT = 19,
-	COLOR_BTNHIGHLIGHT =      20,
-
-
-	COLOR_3DDKSHADOW =        21,
-	COLOR_3DLIGHT =           22,
-	COLOR_INFOTEXT =          23,
-	COLOR_INFOBK =            24,
-
-	COLOR_DESKTOP =           COLOR_BACKGROUND,
-	COLOR_3DFACE =            COLOR_BTNFACE,
-	COLOR_3DSHADOW =          COLOR_BTNSHADOW,
-	COLOR_3DHIGHLIGHT =       COLOR_BTNHIGHLIGHT,
-	COLOR_3DHILIGHT =         COLOR_BTNHIGHLIGHT,
-	COLOR_BTNHILIGHT =        COLOR_BTNHIGHLIGHT,
-}
-
-enum : int
-{
-	CW_USEDEFAULT = cast(int)0x80000000
-}
-
-/*
- * Special value for CreateWindow, et al.
- */
-enum : HWND
-{
-    HWND_DESKTOP = cast(HWND)0,
-}
-
-export ATOM RegisterClassA(WNDCLASSA *lpWndClass);
-
-export HWND CreateWindowExA(
-    DWORD dwExStyle,
-    LPCSTR lpClassName,
-    LPCSTR lpWindowName,
-    DWORD dwStyle,
-    int X,
-    int Y,
-    int nWidth,
-    int nHeight,
-    HWND hWndParent ,
-    HMENU hMenu,
-    HINSTANCE hInstance,
-    LPVOID lpParam);
-
-
-HWND CreateWindowA(
-    LPCSTR lpClassName,
-    LPCSTR lpWindowName,
-    DWORD dwStyle,
-    int X,
-    int Y,
-    int nWidth,
-    int nHeight,
-    HWND hWndParent ,
-    HMENU hMenu,
-    HINSTANCE hInstance,
-    LPVOID lpParam)
-{
-    return CreateWindowExA(0, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
-}
-
-/*
- * Message structure
- */
-struct MSG {
-    HWND        hwnd;
-    UINT        message;
-    WPARAM      wParam;
-    LPARAM      lParam;
-    DWORD       time;
-    POINT       pt;
-}
-alias MSG* PMSG, NPMSG, LPMSG;
-
-export
-{
- BOOL GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
- BOOL TranslateMessage(MSG *lpMsg);
- LONG DispatchMessageA(MSG *lpMsg);
- BOOL PeekMessageA(MSG *lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
- HWND GetFocus();
-}
-
-export DWORD ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize);
-
-export
-{
- BOOL IsValidCodePage(UINT CodePage);
- UINT GetACP();
- UINT GetOEMCP();
- //BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo);
- BOOL IsDBCSLeadByte(BYTE TestChar);
- BOOL IsDBCSLeadByteEx(UINT CodePage, BYTE TestChar);
- int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cchMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
- int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cchMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
-}
-
-export HANDLE CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
-export HANDLE CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
-
-export BOOL GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout);
-export BOOL SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout);
-export LPVOID MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, DWORD dwNumberOfBytesToMap);
-export LPVOID MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, DWORD dwNumberOfBytesToMap, LPVOID lpBaseAddress);
-export BOOL FlushViewOfFile(LPCVOID lpBaseAddress, DWORD dwNumberOfBytesToFlush);
-export BOOL UnmapViewOfFile(LPCVOID lpBaseAddress);
-
-export  HGDIOBJ   GetStockObject(int);
-export BOOL ShowWindow(HWND hWnd, int nCmdShow);
-
-/* Stock Logical Objects */
-enum
-{	WHITE_BRUSH =         0,
-	LTGRAY_BRUSH =        1,
-	GRAY_BRUSH =          2,
-	DKGRAY_BRUSH =        3,
-	BLACK_BRUSH =         4,
-	NULL_BRUSH =          5,
-	HOLLOW_BRUSH =        NULL_BRUSH,
-	WHITE_PEN =           6,
-	BLACK_PEN =           7,
-	NULL_PEN =            8,
-	OEM_FIXED_FONT =      10,
-	ANSI_FIXED_FONT =     11,
-	ANSI_VAR_FONT =       12,
-	SYSTEM_FONT =         13,
-	DEVICE_DEFAULT_FONT = 14,
-	DEFAULT_PALETTE =     15,
-	SYSTEM_FIXED_FONT =   16,
-	DEFAULT_GUI_FONT =    17,
-	STOCK_LAST =          17,
-}
-
-/*
- * ShowWindow() Commands
- */
-enum
-{	SW_HIDE =             0,
-	SW_SHOWNORMAL =       1,
-	SW_NORMAL =           1,
-	SW_SHOWMINIMIZED =    2,
-	SW_SHOWMAXIMIZED =    3,
-	SW_MAXIMIZE =         3,
-	SW_SHOWNOACTIVATE =   4,
-	SW_SHOW =             5,
-	SW_MINIMIZE =         6,
-	SW_SHOWMINNOACTIVE =  7,
-	SW_SHOWNA =           8,
-	SW_RESTORE =          9,
-	SW_SHOWDEFAULT =      10,
-	SW_MAX =              10,
-}
-
-struct TEXTMETRICA
-{
-    LONG        tmHeight;
-    LONG        tmAscent;
-    LONG        tmDescent;
-    LONG        tmInternalLeading;
-    LONG        tmExternalLeading;
-    LONG        tmAveCharWidth;
-    LONG        tmMaxCharWidth;
-    LONG        tmWeight;
-    LONG        tmOverhang;
-    LONG        tmDigitizedAspectX;
-    LONG        tmDigitizedAspectY;
-    BYTE        tmFirstChar;
-    BYTE        tmLastChar;
-    BYTE        tmDefaultChar;
-    BYTE        tmBreakChar;
-    BYTE        tmItalic;
-    BYTE        tmUnderlined;
-    BYTE        tmStruckOut;
-    BYTE        tmPitchAndFamily;
-    BYTE        tmCharSet;
-}
-
-export  BOOL   GetTextMetricsA(HDC, TEXTMETRICA*);
-
-/*
- * Scroll Bar Constants
- */
-enum
-{	SB_HORZ =             0,
-	SB_VERT =             1,
-	SB_CTL =              2,
-	SB_BOTH =             3,
-}
-
-/*
- * Scroll Bar Commands
- */
-enum
-{	SB_LINEUP =           0,
-	SB_LINELEFT =         0,
-	SB_LINEDOWN =         1,
-	SB_LINERIGHT =        1,
-	SB_PAGEUP =           2,
-	SB_PAGELEFT =         2,
-	SB_PAGEDOWN =         3,
-	SB_PAGERIGHT =        3,
-	SB_THUMBPOSITION =    4,
-	SB_THUMBTRACK =       5,
-	SB_TOP =              6,
-	SB_LEFT =             6,
-	SB_BOTTOM =           7,
-	SB_RIGHT =            7,
-	SB_ENDSCROLL =        8,
-}
-
-export int SetScrollPos(HWND hWnd, int nBar, int nPos, BOOL bRedraw);
-export int GetScrollPos(HWND hWnd, int nBar);
-export BOOL SetScrollRange(HWND hWnd, int nBar, int nMinPos, int nMaxPos, BOOL bRedraw);
-export BOOL GetScrollRange(HWND hWnd, int nBar, LPINT lpMinPos, LPINT lpMaxPos);
-export BOOL ShowScrollBar(HWND hWnd, int wBar, BOOL bShow);
-export BOOL EnableScrollBar(HWND hWnd, UINT wSBflags, UINT wArrows);
-
-/*
- * LockWindowUpdate API
- */
-
-export BOOL LockWindowUpdate(HWND hWndLock);
-export BOOL ScrollWindow(HWND hWnd, int XAmount, int YAmount, RECT* lpRect, RECT* lpClipRect);
-export BOOL ScrollDC(HDC hDC, int dx, int dy, RECT* lprcScroll, RECT* lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate);
-export int ScrollWindowEx(HWND hWnd, int dx, int dy, RECT* prcScroll, RECT* prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags);
-
-/*
- * Virtual Keys, Standard Set
- */
-enum
-{	VK_LBUTTON =        0x01,
-	VK_RBUTTON =        0x02,
-	VK_CANCEL =         0x03,
-	VK_MBUTTON =        0x04, /* NOT contiguous with L & RBUTTON */
-
-	VK_BACK =           0x08,
-	VK_TAB =            0x09,
-
-	VK_CLEAR =          0x0C,
-	VK_RETURN =         0x0D,
-
-	VK_SHIFT =          0x10,
-	VK_CONTROL =        0x11,
-	VK_MENU =           0x12,
-	VK_PAUSE =          0x13,
-	VK_CAPITAL =        0x14,
-
-
-	VK_ESCAPE =         0x1B,
-
-	VK_SPACE =          0x20,
-	VK_PRIOR =          0x21,
-	VK_NEXT =           0x22,
-	VK_END =            0x23,
-	VK_HOME =           0x24,
-	VK_LEFT =           0x25,
-	VK_UP =             0x26,
-	VK_RIGHT =          0x27,
-	VK_DOWN =           0x28,
-	VK_SELECT =         0x29,
-	VK_PRINT =          0x2A,
-	VK_EXECUTE =        0x2B,
-	VK_SNAPSHOT =       0x2C,
-	VK_INSERT =         0x2D,
-	VK_DELETE =         0x2E,
-	VK_HELP =           0x2F,
-
-/* VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) */
-/* VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) */
-
-	VK_LWIN =           0x5B,
-	VK_RWIN =           0x5C,
-	VK_APPS =           0x5D,
-
-	VK_NUMPAD0 =        0x60,
-	VK_NUMPAD1 =        0x61,
-	VK_NUMPAD2 =        0x62,
-	VK_NUMPAD3 =        0x63,
-	VK_NUMPAD4 =        0x64,
-	VK_NUMPAD5 =        0x65,
-	VK_NUMPAD6 =        0x66,
-	VK_NUMPAD7 =        0x67,
-	VK_NUMPAD8 =        0x68,
-	VK_NUMPAD9 =        0x69,
-	VK_MULTIPLY =       0x6A,
-	VK_ADD =            0x6B,
-	VK_SEPARATOR =      0x6C,
-	VK_SUBTRACT =       0x6D,
-	VK_DECIMAL =        0x6E,
-	VK_DIVIDE =         0x6F,
-	VK_F1 =             0x70,
-	VK_F2 =             0x71,
-	VK_F3 =             0x72,
-	VK_F4 =             0x73,
-	VK_F5 =             0x74,
-	VK_F6 =             0x75,
-	VK_F7 =             0x76,
-	VK_F8 =             0x77,
-	VK_F9 =             0x78,
-	VK_F10 =            0x79,
-	VK_F11 =            0x7A,
-	VK_F12 =            0x7B,
-	VK_F13 =            0x7C,
-	VK_F14 =            0x7D,
-	VK_F15 =            0x7E,
-	VK_F16 =            0x7F,
-	VK_F17 =            0x80,
-	VK_F18 =            0x81,
-	VK_F19 =            0x82,
-	VK_F20 =            0x83,
-	VK_F21 =            0x84,
-	VK_F22 =            0x85,
-	VK_F23 =            0x86,
-	VK_F24 =            0x87,
-
-	VK_NUMLOCK =        0x90,
-	VK_SCROLL =         0x91,
-
-/*
- * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
- * Used only as parameters to GetAsyncKeyState() and GetKeyState().
- * No other API or message will distinguish left and right keys in this way.
- */
-	VK_LSHIFT =         0xA0,
-	VK_RSHIFT =         0xA1,
-	VK_LCONTROL =       0xA2,
-	VK_RCONTROL =       0xA3,
-	VK_LMENU =          0xA4,
-	VK_RMENU =          0xA5,
-
-
-	VK_PROCESSKEY =     0xE5,
-
-
-	VK_ATTN =           0xF6,
-	VK_CRSEL =          0xF7,
-	VK_EXSEL =          0xF8,
-	VK_EREOF =          0xF9,
-	VK_PLAY =           0xFA,
-	VK_ZOOM =           0xFB,
-	VK_NONAME =         0xFC,
-	VK_PA1 =            0xFD,
-	VK_OEM_CLEAR =      0xFE,
-}
-
-export LRESULT SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
-
-alias UINT (*LPOFNHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
-
-struct OPENFILENAMEA {
-   DWORD        lStructSize;
-   HWND         hwndOwner;
-   HINSTANCE    hInstance;
-   LPCSTR       lpstrFilter;
-   LPSTR        lpstrCustomFilter;
-   DWORD        nMaxCustFilter;
-   DWORD        nFilterIndex;
-   LPSTR        lpstrFile;
-   DWORD        nMaxFile;
-   LPSTR        lpstrFileTitle;
-   DWORD        nMaxFileTitle;
-   LPCSTR       lpstrInitialDir;
-   LPCSTR       lpstrTitle;
-   DWORD        Flags;
-   WORD         nFileOffset;
-   WORD         nFileExtension;
-   LPCSTR       lpstrDefExt;
-   LPARAM       lCustData;
-   LPOFNHOOKPROC lpfnHook;
-   LPCSTR       lpTemplateName;
-}
-alias OPENFILENAMEA *LPOPENFILENAMEA;
-
-struct OPENFILENAMEW {
-   DWORD        lStructSize;
-   HWND         hwndOwner;
-   HINSTANCE    hInstance;
-   LPCWSTR      lpstrFilter;
-   LPWSTR       lpstrCustomFilter;
-   DWORD        nMaxCustFilter;
-   DWORD        nFilterIndex;
-   LPWSTR       lpstrFile;
-   DWORD        nMaxFile;
-   LPWSTR       lpstrFileTitle;
-   DWORD        nMaxFileTitle;
-   LPCWSTR      lpstrInitialDir;
-   LPCWSTR      lpstrTitle;
-   DWORD        Flags;
-   WORD         nFileOffset;
-   WORD         nFileExtension;
-   LPCWSTR      lpstrDefExt;
-   LPARAM       lCustData;
-   LPOFNHOOKPROC lpfnHook;
-   LPCWSTR      lpTemplateName;
-}
-alias OPENFILENAMEW *LPOPENFILENAMEW;
-
-BOOL          GetOpenFileNameA(LPOPENFILENAMEA);
-BOOL          GetOpenFileNameW(LPOPENFILENAMEW);
-
-BOOL          GetSaveFileNameA(LPOPENFILENAMEA);
-BOOL          GetSaveFileNameW(LPOPENFILENAMEW);
-
-short         GetFileTitleA(LPCSTR, LPSTR, WORD);
-short         GetFileTitleW(LPCWSTR, LPWSTR, WORD);
-
-enum
-{
-	PM_NOREMOVE =         0x0000,
-	PM_REMOVE =           0x0001,
-	PM_NOYIELD =          0x0002,
-}
-
-/* Bitmap Header Definition */
-struct BITMAP
-{
-    LONG        bmType;
-    LONG        bmWidth;
-    LONG        bmHeight;
-    LONG        bmWidthBytes;
-    WORD        bmPlanes;
-    WORD        bmBitsPixel;
-    LPVOID      bmBits;
-}
-alias BITMAP* PBITMAP, NPBITMAP, LPBITMAP;
-
-
-export  HDC       CreateCompatibleDC(HDC);
-
-export  int     GetObjectA(HGDIOBJ, int, LPVOID);
-export  int     GetObjectW(HGDIOBJ, int, LPVOID);
-export  BOOL   DeleteDC(HDC);
-
-struct LOGFONTA
-{
-    LONG      lfHeight;
-    LONG      lfWidth;
-    LONG      lfEscapement;
-    LONG      lfOrientation;
-    LONG      lfWeight;
-    BYTE      lfItalic;
-    BYTE      lfUnderline;
-    BYTE      lfStrikeOut;
-    BYTE      lfCharSet;
-    BYTE      lfOutPrecision;
-    BYTE      lfClipPrecision;
-    BYTE      lfQuality;
-    BYTE      lfPitchAndFamily;
-    CHAR      lfFaceName[32 ];
-}
-alias LOGFONTA* PLOGFONTA, NPLOGFONTA, LPLOGFONTA;
-
-export HMENU LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName);
-export HMENU LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName);
-
-export HMENU GetSubMenu(HMENU hMenu, int nPos);
-
-export HBITMAP LoadBitmapA(HINSTANCE hInstance, LPCSTR lpBitmapName);
-export HBITMAP LoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName);
-
-LPSTR MAKEINTRESOURCEA(int i) { return cast(LPSTR)(cast(DWORD)(cast(WORD)(i))); }
-
-export  HFONT     CreateFontIndirectA(LOGFONTA *);
-
-export BOOL MessageBeep(UINT uType);
-export int ShowCursor(BOOL bShow);
-export BOOL SetCursorPos(int X, int Y);
-export HCURSOR SetCursor(HCURSOR hCursor);
-export BOOL GetCursorPos(LPPOINT lpPoint);
-export BOOL ClipCursor( RECT *lpRect);
-export BOOL GetClipCursor(LPRECT lpRect);
-export HCURSOR GetCursor();
-export BOOL CreateCaret(HWND hWnd, HBITMAP hBitmap , int nWidth, int nHeight);
-export UINT GetCaretBlinkTime();
-export BOOL SetCaretBlinkTime(UINT uMSeconds);
-export BOOL DestroyCaret();
-export BOOL HideCaret(HWND hWnd);
-export BOOL ShowCaret(HWND hWnd);
-export BOOL SetCaretPos(int X, int Y);
-export BOOL GetCaretPos(LPPOINT lpPoint);
-export BOOL ClientToScreen(HWND hWnd, LPPOINT lpPoint);
-export BOOL ScreenToClient(HWND hWnd, LPPOINT lpPoint);
-export int MapWindowPoints(HWND hWndFrom, HWND hWndTo, LPPOINT lpPoints, UINT cPoints);
-export HWND WindowFromPoint(POINT Point);
-export HWND ChildWindowFromPoint(HWND hWndParent, POINT Point);
-
-
-export BOOL TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y,
-	int nReserved, HWND hWnd, RECT *prcRect);
-
-align (2) struct DLGTEMPLATE {
-    DWORD style;
-    DWORD dwExtendedStyle;
-    WORD cdit;
-    short x;
-    short y;
-    short cx;
-    short cy;
-}
-alias DLGTEMPLATE *LPDLGTEMPLATEA;
-alias DLGTEMPLATE *LPDLGTEMPLATEW;
-
-
-alias LPDLGTEMPLATEA LPDLGTEMPLATE;
-
-alias  DLGTEMPLATE *LPCDLGTEMPLATEA;
-alias  DLGTEMPLATE *LPCDLGTEMPLATEW;
-
-
-alias LPCDLGTEMPLATEA LPCDLGTEMPLATE;
-
-
-export int DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName,
-	HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
-export int DialogBoxIndirectParamA(HINSTANCE hInstance,
-	LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc,
-	LPARAM dwInitParam);
-
-enum : DWORD
-{
-	SRCCOPY =             cast(DWORD)0x00CC0020, /* dest = source                   */
-	SRCPAINT =            cast(DWORD)0x00EE0086, /* dest = source OR dest           */
-	SRCAND =              cast(DWORD)0x008800C6, /* dest = source AND dest          */
-	SRCINVERT =           cast(DWORD)0x00660046, /* dest = source XOR dest          */
-	SRCERASE =            cast(DWORD)0x00440328, /* dest = source AND (NOT dest)   */
-	NOTSRCCOPY =          cast(DWORD)0x00330008, /* dest = (NOT source)             */
-	NOTSRCERASE =         cast(DWORD)0x001100A6, /* dest = (NOT src) AND (NOT dest) */
-	MERGECOPY =           cast(DWORD)0x00C000CA, /* dest = (source AND pattern)     */
-	MERGEPAINT =          cast(DWORD)0x00BB0226, /* dest = (NOT source) OR dest     */
-	PATCOPY =             cast(DWORD)0x00F00021, /* dest = pattern                  */
-	PATPAINT =            cast(DWORD)0x00FB0A09, /* dest = DPSnoo                   */
-	PATINVERT =           cast(DWORD)0x005A0049, /* dest = pattern XOR dest         */
-	DSTINVERT =           cast(DWORD)0x00550009, /* dest = (NOT dest)               */
-	BLACKNESS =           cast(DWORD)0x00000042, /* dest = BLACK                    */
-	WHITENESS =           cast(DWORD)0x00FF0062, /* dest = WHITE                    */
-}
-
-enum
-{
-	SND_SYNC =            0x0000, /* play synchronously (default) */
-	SND_ASYNC =           0x0001, /* play asynchronously */
-	SND_NODEFAULT =       0x0002, /* silence (!default) if sound not found */
-	SND_MEMORY =          0x0004, /* pszSound points to a memory file */
-	SND_LOOP =            0x0008, /* loop the sound until next sndPlaySound */
-	SND_NOSTOP =          0x0010, /* don't stop any currently playing sound */
-
-	SND_NOWAIT =	0x00002000, /* don't wait if the driver is busy */
-	SND_ALIAS =       0x00010000, /* name is a registry alias */
-	SND_ALIAS_ID =	0x00110000, /* alias is a predefined ID */
-	SND_FILENAME =    0x00020000, /* name is file name */
-	SND_RESOURCE =    0x00040004, /* name is resource name or atom */
-
-	SND_PURGE =           0x0040, /* purge non-static events for task */
-	SND_APPLICATION =     0x0080, /* look for application specific association */
-
-
-	SND_ALIAS_START =	0,     /* alias base */
-}
-
-export  BOOL   PlaySoundA(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound);
-export  BOOL   PlaySoundW(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound);
-
-export  int     GetClipBox(HDC, LPRECT);
-export  int     GetClipRgn(HDC, HRGN);
-export  int     GetMetaRgn(HDC, HRGN);
-export  HGDIOBJ   GetCurrentObject(HDC, UINT);
-export  BOOL    GetCurrentPositionEx(HDC, LPPOINT);
-export  int     GetDeviceCaps(HDC, int);
-
-struct LOGPEN
-  {
-    UINT        lopnStyle;
-    POINT       lopnWidth;
-    COLORREF    lopnColor;
-}
-alias LOGPEN* PLOGPEN, NPLOGPEN, LPLOGPEN;
-
-enum
-{
-	PS_SOLID =            0,
-	PS_DASH =             1, /* -------  */
-	PS_DOT =              2, /* .......  */
-	PS_DASHDOT =          3, /* _._._._  */
-	PS_DASHDOTDOT =       4, /* _.._.._  */
-	PS_NULL =             5,
-	PS_INSIDEFRAME =      6,
-	PS_USERSTYLE =        7,
-	PS_ALTERNATE =        8,
-	PS_STYLE_MASK =       0x0000000F,
-
-	PS_ENDCAP_ROUND =     0x00000000,
-	PS_ENDCAP_SQUARE =    0x00000100,
-	PS_ENDCAP_FLAT =      0x00000200,
-	PS_ENDCAP_MASK =      0x00000F00,
-
-	PS_JOIN_ROUND =       0x00000000,
-	PS_JOIN_BEVEL =       0x00001000,
-	PS_JOIN_MITER =       0x00002000,
-	PS_JOIN_MASK =        0x0000F000,
-
-	PS_COSMETIC =         0x00000000,
-	PS_GEOMETRIC =        0x00010000,
-	PS_TYPE_MASK =        0x000F0000,
-}
-
-export  HPALETTE   CreatePalette(LOGPALETTE *);
-export  HPEN      CreatePen(int, int, COLORREF);
-export  HPEN      CreatePenIndirect(LOGPEN *);
-export  HRGN      CreatePolyPolygonRgn(POINT *, INT *, int, int);
-export  HBRUSH    CreatePatternBrush(HBITMAP);
-export  HRGN      CreateRectRgn(int, int, int, int);
-export  HRGN      CreateRectRgnIndirect(RECT *);
-export  HRGN      CreateRoundRectRgn(int, int, int, int, int, int);
-export  BOOL      CreateScalableFontResourceA(DWORD, LPCSTR, LPCSTR, LPCSTR);
-export  BOOL      CreateScalableFontResourceW(DWORD, LPCWSTR, LPCWSTR, LPCWSTR);
-
-COLORREF RGB(int r, int g, int b)
-{
-    return cast(COLORREF)
-	((cast(BYTE)r|(cast(WORD)(cast(BYTE)g)<<8))|((cast(DWORD)cast(BYTE)b)<<16));
-}
-
-export  BOOL   LineTo(HDC, int, int);
-export  BOOL   DeleteObject(HGDIOBJ);
-export int FillRect(HDC hDC,  RECT *lprc, HBRUSH hbr);
-
-
-export BOOL EndDialog(HWND hDlg, int nResult);
-export HWND GetDlgItem(HWND hDlg, int nIDDlgItem);
-
-export BOOL SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned);
-export UINT GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated,
-    BOOL bSigned);
-
-export BOOL SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString);
-export BOOL SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);
-
-export UINT GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int nMaxCount);
-export UINT GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int nMaxCount);
-
-export BOOL CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck);
-export BOOL CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton,
-    int nIDCheckButton);
-
-export UINT IsDlgButtonChecked(HWND hDlg, int nIDButton);
-
-export HWND SetFocus(HWND hWnd);
-
-export int wsprintfA(LPSTR, LPCSTR, ...);
-export int wsprintfW(LPWSTR, LPCWSTR, ...);
-
-enum : uint
-{
-	INFINITE = uint.max,
-	WAIT_OBJECT_0 = 0,
-}
-
-export HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCTSTR lpName);
-export HANDLE OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);
-export BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
-
-struct COORD {
-    SHORT X;
-    SHORT Y;
-}
-alias COORD *PCOORD;
-
-struct SMALL_RECT {
-    SHORT Left;
-    SHORT Top;
-    SHORT Right;
-    SHORT Bottom;
-}
-alias SMALL_RECT *PSMALL_RECT;
-
-struct KEY_EVENT_RECORD {
-    BOOL bKeyDown;
-    WORD wRepeatCount;
-    WORD wVirtualKeyCode;
-    WORD wVirtualScanCode;
-    union {
-        WCHAR UnicodeChar;
-        CHAR   AsciiChar;
-    }
-    DWORD dwControlKeyState;
-}
-alias KEY_EVENT_RECORD *PKEY_EVENT_RECORD;
-
-//
-// ControlKeyState flags
-//
-
-enum
-{
-	RIGHT_ALT_PRESSED =     0x0001, // the right alt key is pressed.
-	LEFT_ALT_PRESSED =      0x0002, // the left alt key is pressed.
-	RIGHT_CTRL_PRESSED =    0x0004, // the right ctrl key is pressed.
-	LEFT_CTRL_PRESSED =     0x0008, // the left ctrl key is pressed.
-	SHIFT_PRESSED =         0x0010, // the shift key is pressed.
-	NUMLOCK_ON =            0x0020, // the numlock light is on.
-	SCROLLLOCK_ON =         0x0040, // the scrolllock light is on.
-	CAPSLOCK_ON =           0x0080, // the capslock light is on.
-	ENHANCED_KEY =          0x0100, // the key is enhanced.
-}
-
-struct MOUSE_EVENT_RECORD {
-    COORD dwMousePosition;
-    DWORD dwButtonState;
-    DWORD dwControlKeyState;
-    DWORD dwEventFlags;
-}
-alias MOUSE_EVENT_RECORD *PMOUSE_EVENT_RECORD;
-
-//
-// ButtonState flags
-//
-enum
-{
-	FROM_LEFT_1ST_BUTTON_PRESSED =    0x0001,
-	RIGHTMOST_BUTTON_PRESSED =        0x0002,
-	FROM_LEFT_2ND_BUTTON_PRESSED =    0x0004,
-	FROM_LEFT_3RD_BUTTON_PRESSED =    0x0008,
-	FROM_LEFT_4TH_BUTTON_PRESSED =    0x0010,
-}
-
-//
-// EventFlags
-//
-
-enum
-{
-	MOUSE_MOVED =   0x0001,
-	DOUBLE_CLICK =  0x0002,
-}
-
-struct WINDOW_BUFFER_SIZE_RECORD {
-    COORD dwSize;
-}
-alias WINDOW_BUFFER_SIZE_RECORD *PWINDOW_BUFFER_SIZE_RECORD;
-
-struct MENU_EVENT_RECORD {
-    UINT dwCommandId;
-}
-alias MENU_EVENT_RECORD *PMENU_EVENT_RECORD;
-
-struct FOCUS_EVENT_RECORD {
-    BOOL bSetFocus;
-}
-alias FOCUS_EVENT_RECORD *PFOCUS_EVENT_RECORD;
-
-struct INPUT_RECORD {
-    WORD EventType;
-    union {
-        KEY_EVENT_RECORD KeyEvent;
-        MOUSE_EVENT_RECORD MouseEvent;
-        WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
-        MENU_EVENT_RECORD MenuEvent;
-        FOCUS_EVENT_RECORD FocusEvent;
-    }
-}
-alias INPUT_RECORD *PINPUT_RECORD;
-
-//
-//  EventType flags:
-//
-
-enum
-{
-	KEY_EVENT =         0x0001, // Event contains key event record
-	MOUSE_EVENT =       0x0002, // Event contains mouse event record
-	WINDOW_BUFFER_SIZE_EVENT = 0x0004, // Event contains window change event record
-	MENU_EVENT = 0x0008, // Event contains menu event record
-	FOCUS_EVENT = 0x0010, // event contains focus change
-}
-
-struct CHAR_INFO {
-    union {
-        WCHAR UnicodeChar;
-        CHAR   AsciiChar;
-    }
-    WORD Attributes;
-}
-alias CHAR_INFO *PCHAR_INFO;
-
-//
-// Attributes flags:
-//
-
-enum
-{
-	FOREGROUND_BLUE =      0x0001, // text color contains blue.
-	FOREGROUND_GREEN =     0x0002, // text color contains green.
-	FOREGROUND_RED =       0x0004, // text color contains red.
-	FOREGROUND_INTENSITY = 0x0008, // text color is intensified.
-	BACKGROUND_BLUE =      0x0010, // background color contains blue.
-	BACKGROUND_GREEN =     0x0020, // background color contains green.
-	BACKGROUND_RED =       0x0040, // background color contains red.
-	BACKGROUND_INTENSITY = 0x0080, // background color is intensified.
-}
-
-struct CONSOLE_SCREEN_BUFFER_INFO {
-    COORD dwSize;
-    COORD dwCursorPosition;
-    WORD  wAttributes;
-    SMALL_RECT srWindow;
-    COORD dwMaximumWindowSize;
-}
-alias CONSOLE_SCREEN_BUFFER_INFO *PCONSOLE_SCREEN_BUFFER_INFO;
-
-struct CONSOLE_CURSOR_INFO {
-    DWORD  dwSize;
-    BOOL   bVisible;
-}
-alias CONSOLE_CURSOR_INFO *PCONSOLE_CURSOR_INFO;
-
-enum
-{
-	ENABLE_PROCESSED_INPUT = 0x0001,
-	ENABLE_LINE_INPUT =      0x0002,
-	ENABLE_ECHO_INPUT =      0x0004,
-	ENABLE_WINDOW_INPUT =    0x0008,
-	ENABLE_MOUSE_INPUT =     0x0010,
-}
-
-enum
-{
-	ENABLE_PROCESSED_OUTPUT =    0x0001,
-	ENABLE_WRAP_AT_EOL_OUTPUT =  0x0002,
-}
-
-BOOL PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
-BOOL PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
-BOOL ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
-BOOL ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
-BOOL WriteConsoleInputA(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten);
-BOOL WriteConsoleInputW(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten);
-BOOL ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion);
-BOOL ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion);
-BOOL WriteConsoleOutputA(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion);
-BOOL WriteConsoleOutputW(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion);
-BOOL ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead);
-BOOL ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead);
-BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead);
-BOOL WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
-BOOL WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
-BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD *lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten);
-BOOL FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD  nLength, COORD  dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
-BOOL FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD  nLength, COORD  dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
-BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD   wAttribute, DWORD  nLength, COORD  dwWriteCoord, LPDWORD lpNumberOfAttrsWritten);
-BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
-BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents);
-BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);
-COORD GetLargestConsoleWindowSize( HANDLE hConsoleOutput);
-BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo);
-BOOL GetNumberOfConsoleMouseButtons( LPDWORD lpNumberOfMouseButtons);
-BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode);
-BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput);
-BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput);
-BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize);
-BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition);
-BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo);
-BOOL ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill);
-BOOL ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill);
-BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT *lpConsoleWindow);
-BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes);
-alias BOOL(*PHANDLER_ROUTINE)(DWORD CtrlType);
-BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add);
-BOOL GenerateConsoleCtrlEvent( DWORD dwCtrlEvent, DWORD dwProcessGroupId);
-BOOL AllocConsole();
-BOOL FreeConsole();
-DWORD GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize);
-DWORD GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize);
-BOOL SetConsoleTitleA(LPCSTR lpConsoleTitle);
-BOOL SetConsoleTitleW(LPCWSTR lpConsoleTitle);
-BOOL ReadConsoleA(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, LPVOID lpReserved);
-BOOL ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, LPVOID lpReserved);
-BOOL WriteConsoleA(HANDLE hConsoleOutput, const  void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
-BOOL WriteConsoleW(HANDLE hConsoleOutput, const  void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
-HANDLE CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData);
-UINT GetConsoleCP();
-BOOL SetConsoleCP( UINT wCodePageID);
-UINT GetConsoleOutputCP();
-BOOL SetConsoleOutputCP(UINT wCodePageID);
-
-enum CONSOLE_TEXTMODE_BUFFER = 1;
-
-enum
-{
-	SM_CXSCREEN =             0,
-	SM_CYSCREEN =             1,
-	SM_CXVSCROLL =            2,
-	SM_CYHSCROLL =            3,
-	SM_CYCAPTION =            4,
-	SM_CXBORDER =             5,
-	SM_CYBORDER =             6,
-	SM_CXDLGFRAME =           7,
-	SM_CYDLGFRAME =           8,
-	SM_CYVTHUMB =             9,
-	SM_CXHTHUMB =             10,
-	SM_CXICON =               11,
-	SM_CYICON =               12,
-	SM_CXCURSOR =             13,
-	SM_CYCURSOR =             14,
-	SM_CYMENU =               15,
-	SM_CXFULLSCREEN =         16,
-	SM_CYFULLSCREEN =         17,
-	SM_CYKANJIWINDOW =        18,
-	SM_MOUSEPRESENT =         19,
-	SM_CYVSCROLL =            20,
-	SM_CXHSCROLL =            21,
-	SM_DEBUG =                22,
-	SM_SWAPBUTTON =           23,
-	SM_RESERVED1 =            24,
-	SM_RESERVED2 =            25,
-	SM_RESERVED3 =            26,
-	SM_RESERVED4 =            27,
-	SM_CXMIN =                28,
-	SM_CYMIN =                29,
-	SM_CXSIZE =               30,
-	SM_CYSIZE =               31,
-	SM_CXFRAME =              32,
-	SM_CYFRAME =              33,
-	SM_CXMINTRACK =           34,
-	SM_CYMINTRACK =           35,
-	SM_CXDOUBLECLK =          36,
-	SM_CYDOUBLECLK =          37,
-	SM_CXICONSPACING =        38,
-	SM_CYICONSPACING =        39,
-	SM_MENUDROPALIGNMENT =    40,
-	SM_PENWINDOWS =           41,
-	SM_DBCSENABLED =          42,
-	SM_CMOUSEBUTTONS =        43,
-
-
-	SM_CXFIXEDFRAME =         SM_CXDLGFRAME,
-	SM_CYFIXEDFRAME =         SM_CYDLGFRAME,
-	SM_CXSIZEFRAME =          SM_CXFRAME,
-	SM_CYSIZEFRAME =          SM_CYFRAME,
-
-	SM_SECURE =               44,
-	SM_CXEDGE =               45,
-	SM_CYEDGE =               46,
-	SM_CXMINSPACING =         47,
-	SM_CYMINSPACING =         48,
-	SM_CXSMICON =             49,
-	SM_CYSMICON =             50,
-	SM_CYSMCAPTION =          51,
-	SM_CXSMSIZE =             52,
-	SM_CYSMSIZE =             53,
-	SM_CXMENUSIZE =           54,
-	SM_CYMENUSIZE =           55,
-	SM_ARRANGE =              56,
-	SM_CXMINIMIZED =          57,
-	SM_CYMINIMIZED =          58,
-	SM_CXMAXTRACK =           59,
-	SM_CYMAXTRACK =           60,
-	SM_CXMAXIMIZED =          61,
-	SM_CYMAXIMIZED =          62,
-	SM_NETWORK =              63,
-	SM_CLEANBOOT =            67,
-	SM_CXDRAG =               68,
-	SM_CYDRAG =               69,
-	SM_SHOWSOUNDS =           70,
-	SM_CXMENUCHECK =          71,
-	SM_CYMENUCHECK =          72,
-	SM_SLOWMACHINE =          73,
-	SM_MIDEASTENABLED =       74,
-	SM_CMETRICS =             75,
-}
-
-int GetSystemMetrics(int nIndex);
-
-}
diff -r f12bfe124807 d/phobos2/std/c/windows/winsock.d
--- a/d/phobos2/std/c/windows/winsock.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/c/windows/winsock.d	Thu Oct 14 14:12:53 2010 +0100
@@ -12,8 +12,8 @@
 
 extern(Windows):
 
-alias UINT SOCKET;
-alias int socklen_t;
+alias int  SOCKET;
+alias uint socklen_t;
 
 const SOCKET INVALID_SOCKET = cast(SOCKET)~0;
 const int SOCKET_ERROR = -1;
@@ -43,20 +43,20 @@
 int WSACleanup();
 SOCKET socket(int af, int type, int protocol);
 int ioctlsocket(SOCKET s, int cmd, uint* argp);
-int bind(SOCKET s, sockaddr* name, int namelen);
-int connect(SOCKET s, sockaddr* name, int namelen);
+int bind(SOCKET s, sockaddr* name, socklen_t namelen);
+int connect(SOCKET s, sockaddr* name, socklen_t namelen);
 int listen(SOCKET s, int backlog);
-SOCKET accept(SOCKET s, sockaddr* addr, int* addrlen);
+SOCKET accept(SOCKET s, sockaddr* addr, socklen_t* addrlen);
 int closesocket(SOCKET s);
 int shutdown(SOCKET s, int how);
-int getpeername(SOCKET s, sockaddr* name, int* namelen);
-int getsockname(SOCKET s, sockaddr* name, int* namelen);
+int getpeername(SOCKET s, sockaddr* name, socklen_t* namelen);
+int getsockname(SOCKET s, sockaddr* name, socklen_t* namelen);
 int send(SOCKET s, const(void)* buf, int len, int flags);
-int sendto(SOCKET s, const(void)* buf, int len, int flags, sockaddr* to, int tolen);
+int sendto(SOCKET s, const(void)* buf, int len, int flags, sockaddr* to, socklen_t tolen);
 int recv(SOCKET s, void* buf, int len, int flags);
-int recvfrom(SOCKET s, void* buf, int len, int flags, sockaddr* from, int* fromlen);
-int getsockopt(SOCKET s, int level, int optname, void* optval, int* optlen);
-int setsockopt(SOCKET s, int level, int optname, void* optval, int optlen);
+int recvfrom(SOCKET s, void* buf, int len, int flags, sockaddr* from, socklen_t* fromlen);
+int getsockopt(SOCKET s, int level, int optname, void* optval, socklen_t* optlen);
+int setsockopt(SOCKET s, int level, int optname, void* optval, socklen_t optlen);
 uint inet_addr(const char* cp);
 int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* errorfds, timeval* timeout);
 char* inet_ntoa(in_addr ina);
diff -r f12bfe124807 d/phobos2/std/complex.d
--- a/d/phobos2/std/complex.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/complex.d	Thu Oct 14 14:12:53 2010 +0100
@@ -11,8 +11,7 @@
 
 module std.complex;
 
-private import std.math;
-private import std.stdio;
+import std.conv, std.math, std.stdio;
 
 /**
 Representation choices for the $(D Complex) type. Cartesian
@@ -39,7 +38,7 @@
 struct Complex(Num, Representation rep = Representation.cartesian)
 {
     version(ddoc) {
-    Num getAngle();
+        Num getAngle();
     }
     static if (rep == Representation.cartesian)
     {
@@ -84,8 +83,10 @@
 
 unittest
 {
-    Complex!(double) c1 = { 1, 1 };
-    auto c2 = Complex!(double, Representation.polar)(sqrt(2.), PI / 4);
-    assert(approxEqual(c1.getRe, c2.getRe)
-           && approxEqual(c1.getIm, c2.getIm));
+    // Complex!(double, Representation.cartesian) c1 = { 1, 1 };
+    // auto c2 = Complex!(double, Representation.polar)(sqrt(2.0), PI / 4);
+    // writeln(c2.getRe);
+    // assert(approxEqual(c1.getRe, c2.getRe),
+    //         text(c1.getRe, " != ", c2.getRe));
+    // assert(approxEqual(c1.getIm, c2.getIm));
 }
diff -r f12bfe124807 d/phobos2/std/contracts.d
--- a/d/phobos2/std/contracts.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/contracts.d	Thu Oct 14 14:12:53 2010 +0100
@@ -26,27 +26,22 @@
  *     return assumeUnique(line);
  * }
  * ----
- * 
+ *
  * Author:
  *
  * $(WEB erdani.org, Andrei Alexandrescu)
- * 
+ *
  * Credits:
- * 
+ *
  * Brad Roberts came up with the name $(D_PARAM contracts).
  */
 
 module std.contracts;
-private import std.conv;
-private import std.algorithm;
-private import std.iterator;
-private import std.traits;
-private import std.string;
-private import std.c.stdlib;
-private import std.c.string;
+import std.array, std.c.string, std.conv, std.range, std.string, std.traits;
+import core.stdc.errno;
 version(unittest)
 {
-    private import std.stdio;
+    import std.stdio;
 }
 
 /*
@@ -83,13 +78,20 @@
  */
 
 T enforce(T, string file = __FILE__, int line = __LINE__)
-    (T value, lazy string msg = null)
+    (T value, lazy const(char)[] msg = null)
 {
     if (!value) bailOut(file, line, msg);
     return value;
 }
 
-private void bailOut(string file, int line, string msg)
+T enforce(T, string file = __FILE__, int line = __LINE__)
+(T value, scope void delegate() dg)
+{
+    if (!value) dg();
+    return value;
+}
+
+private void bailOut(string file, int line, in char[] msg)
 {
     throw new Exception(text(file, '(', line, "): ",
                     msg ? msg : "Enforcement failed"));
@@ -299,7 +301,7 @@
  * ----
  *
  * The call will duplicate the array appropriately.
- * 
+ *
  * Checking for uniqueness during compilation is possible in certain
  * cases (see the $(D_PARAM unique) and $(D_PARAM lent) keywords in
  * the $(WEB archjava.fluid.cs.cmu.edu/papers/oopsla02.pdf, ArchJava)
@@ -340,6 +342,39 @@
 }
 
 /**
+Passes the type system the information that $(D range) is already
+sorted by predicate $(D pred). No checking is performed; debug builds
+may insert checks randomly. To insert a check, see $(XREF algorithm,
+isSorted).
+ */
+struct AssumeSorted(Range, alias pred = "a < b")
+{
+    /// Alias for $(D Range).
+    alias Range AssumeSorted;
+    /// The passed-in range.
+    Range assumeSorted;
+    /// The sorting predicate.
+    alias pred assumeSortedBy;
+}
+
+/// Ditto
+AssumeSorted!(Range, pred) assumeSorted(alias pred = "a < b", Range)
+(Range r)
+{
+    AssumeSorted!(Range, pred) result;
+    result.assumeSorted = r;
+    return result;
+}
+
+unittest
+{
+    static assert(is(AssumeSorted!(int[]).AssumeSorted == int[]));
+    int[] a = [ 1, 2 ];
+    auto b = assumeSorted(a);
+    assert(b.assumeSorted == a);
+}
+
+/**
 Returns $(D true) if $(D source)'s representation embeds a pointer
 that points to $(D target)'s representation or somewhere inside
 it. Note that evaluating $(D pointsTo(x, x)) checks whether $(D x) has
@@ -357,7 +392,7 @@
         foreach (i, subobj; source.tupleof)
         {
             static if (!isStaticArray!(typeof(subobj)))
-                if (pointsTo(subobj, target)) return true;            
+                if (pointsTo(subobj, target)) return true;
         }
         return false;
     }
@@ -365,7 +400,7 @@
     {
         const void* p1 = source.ptr, p2 = p1 + source.length,
             b = &target, e = b + target.sizeof;
-        return overlap(range(p1, p2), range(b, e)).length != 0;
+        return overlap(p1[0 .. p2 - p1], b[0 .. e - b]).length != 0;
     }
     else
     {
@@ -408,17 +443,117 @@
     this(string msg, string file = null, uint line = 0)
     {
         errno = getErrno;
-	version (linux)
-	{
+        version (linux)
+        {
             char[1024] buf = void;
-	    auto s = std.c.string.strerror_r(errno, buf.ptr, buf.length);
-	}
-	else
-	{
-	    auto s = std.c.string.strerror(errno);
-	}
-	super((file ? file~'('~to!(string)(line)~"): " : "")
-                ~msg~" ("~std.string.toString(s)~")");
+            auto s = std.c.string.strerror_r(errno, buf.ptr, buf.length);
+        }
+        else
+        {
+            auto s = std.c.string.strerror(errno);
+        }
+        super((file ? file~'('~to!(string)(line)~"): " : "")
+                ~msg~" ("~to!string(s)~")");
     }
 }
 
+// structuralCast
+Target structuralCastImpl(Target, Source)(Source obj) if (is(Source : Object))
+{
+    alias BaseTypeTuple!(Target) TBases;
+    static if (is(TBases[0] == class))
+    {
+        // class-to-class structural cast
+        alias BaseTypeTuple!(Source) SBases;
+    }
+    else
+    {
+        static assert(false);
+    }
+    static assert(SBases.length >= TBases.length,
+            "Cannot structurally cast to a target with"
+            " fewer interfaces implemented");
+    static assert(
+        is(typeof(Target.tupleof) == typeof(Source.tupleof)),
+            "Cannot structurally cast to a target with more fields");
+    // Target bases must be a prefix of the source bases
+    foreach (i, B; TBases)
+    {
+        static assert(is(SBases[i] == B)
+                || is(SBases[i] == interface) && is(SBases[i] : B),
+                SBases[i].stringof ~ " does not inherit "
+                ~ B.stringof);
+    }
+    union Result
+    {
+        Source src;
+        Target tgt;
+    }
+    Result result = { obj };
+    return result.tgt;
+}
+
+template structurallyCompatible(S, T) if (!isArray!S || !isArray!T)
+{
+    enum structurallyCompatible =
+        FieldTypeTuple!S.length >= FieldTypeTuple!T.length
+        && is(FieldTypeTuple!S[0 .. FieldTypeTuple!T.length]
+                == FieldTypeTuple!T);
+}
+
+template structurallyCompatible(S, T) if (isArray!S && isArray!T)
+{
+    enum structurallyCompatible =
+        .structurallyCompatible!(ElementType!S, ElementType!T) &&
+        .structurallyCompatible!(ElementType!T, ElementType!S);
+}
+
+unittest
+{
+    struct X { uint a; }
+    static assert(structurallyCompatible!(uint[], X[]));
+    struct Y { uint a, b; }
+    static assert(!structurallyCompatible!(uint[], Y[]));
+    static assert(!structurallyCompatible!(Y[], uint[]));
+    static assert(!structurallyCompatible!(Y[], X[]));
+}
+
+/**
+Structural cast
+ */
+
+template structuralCast(Target)
+{
+    Target structuralCast(Source)(Source obj)
+    {
+        static if (is(Source : Object))
+        {
+            return .structuralCastImpl!(Target)(obj);
+        }
+        else
+        {
+            static if (structurallyCompatible!(Source, Target))
+                return *(cast(Target*) &obj);
+            else
+                static assert(false);
+        }
+    }
+}
+
+unittest
+{
+    interface I1 {}
+    interface I2 {}
+    class Base : I1 { int x; }
+    class A : I1 {}
+    class B : I1, I2 {}
+
+    auto b = new B;
+    auto a = structuralCast!(A)(b);
+    assert(a);
+
+    struct X { int a; }
+    int[] arr = [ 1 ];
+    auto x = structuralCast!(X[])(arr);
+    assert(x[0].a == 1);
+}
diff -r f12bfe124807 d/phobos2/std/conv.d
--- a/d/phobos2/std/conv.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/conv.d	Thu Oct 14 14:12:53 2010 +0100
@@ -27,7 +27,7 @@
 /***********
 A one-stop shop for converting values from one type to another.
 
-Authors: 
+Authors:
 
 $(WEB digitalmars.com, Walter Bright), $(WEB erdani.org, Andrei
 Alexandrescu)
@@ -35,13 +35,25 @@
 
 module std.conv;
 
+import core.memory;
+import std.string;  // for atof(), toString()
+//import std.c.stdlib;
+import core.stdc.stdlib;
+import std.math;  // for fabs(), isnan()
+import std.stdio; // for writefln() and printf()
+import std.typetuple; // for unittests
+import std.utf; // for string-to-string conversions
+import std.array;
+import std.range;
+import std.contracts;
 private import std.string;  // for atof(), toString()
-private import std.c.stdlib;
-private import std.math;  // for fabs(), isnan()
+private import core.stdc.errno;
+private import std.math;  // for fabs(), isNaN()
 private import std.stdio; // for writefln() and printf()
 private import std.typetuple; // for unittests
 private import std.utf; // for string-to-string conversions
 import std.traits;
+import std.typecons;
 import std.ctype;
 import std.c.string; // memcpy
 
@@ -56,8 +68,14 @@
 {
     this(string s)
     {
-	super("conversion " ~ s);
+        super(s);
     }
+    // static void raise(S, T)(S source)
+    // {
+    //     throw new ConvError(cast(string)
+    //             ("Can't convert value `"~to!(string)(source)~"' of type "
+    //                     ~S.stringof~" to type "~T.stringof));
+    // }
 }
 
 private void conv_error(S, T)(S source)
@@ -70,20 +88,282 @@
 /**
  * Thrown on conversion overflow errors.
  */
-class ConvOverflowError : Error
+class ConvOverflowError : ConvError
 {
     this(string s)
     {
-	super("Error: overflow " ~ s);
+        super("Error: overflow " ~ s);
+    }
+    static void raise(string s)
+    {
+        throw new ConvOverflowError(s);
     }
 }
 
-private void conv_overflow(string s)
+private template implicitlyConverts(S, T)
 {
-    throw new ConvOverflowError(s);
+    enum bool implicitlyConverts = T.sizeof >= S.sizeof
+        && is(typeof({S s; T t = s;}()));
 }
 
-/***************************************************************
+unittest
+{
+    assert(!implicitlyConverts!(const(char)[], string));
+    assert(implicitlyConverts!(string, const(char)[]));
+}
+
+/**
+String _to string conversion works for any two string types having
+($(D char), $(D wchar), $(D dchar)) character widths and any
+combination of qualifiers (mutable, $(D const), or $(D immutable)).
+
+Example:
+----
+char[] a = "abc";
+auto b = to!(immutable(dchar)[])(a);
+assert(b == "abc"w);
+----
+ */
+T to(T, S)(S s) if (!implicitlyConverts!(S, T) && isSomeString!(T)
+        && isSomeString!(S))
+{
+    // string-to-string conversion
+    static if (s[0].sizeof == T[0].sizeof) {
+        // same width, only qualifier conversion
+        enum tIsConst = is(T == const(char)[]) || is(T == const(wchar)[])
+            || is(T == const(dchar)[]);
+        enum tIsInvariant = is(T == invariant(char)[])
+            || is(T == invariant(wchar)[]) || is(T == invariant(dchar)[]);
+        static if (tIsConst) {
+            return s;
+        } else static if (tIsInvariant) {
+            // conversion (mutable|const) -> invariant
+            return s.idup;
+        } else {
+            // conversion (invariant|const) -> mutable
+            return s.dup;
+        }
+    } else {
+        // width conversion
+        // we can cast because toUTFX always produces a fresh string
+        static if (T[0].sizeof == 1) {
+            return cast(T) toUTF8(s);
+        } else static if (T[0].sizeof == 2) {
+            return cast(T) toUTF16(s);
+        } else {
+            static assert(T[0].sizeof == 4);
+            return cast(T) toUTF32(s);
+        }
+    }
+}
+
+unittest
+{
+    alias TypeTuple!(char, wchar, dchar) Chars;
+    foreach (LhsC; Chars)
+    {
+        alias TypeTuple!(LhsC[], const(LhsC)[], invariant(LhsC)[]) LhStrings;
+        foreach (Lhs; LhStrings)
+        {
+            foreach (RhsC; Chars)
+            {
+                alias TypeTuple!(RhsC[], const(RhsC)[], invariant(RhsC)[])
+                    RhStrings;
+                foreach (Rhs; RhStrings)
+                {
+                    Lhs s1 = to!(Lhs)("wyda");
+                    Rhs s2 = to!(Rhs)(s1);
+                    //writeln(Lhs.stringof, " -> ", Rhs.stringof);
+                    assert(s1 == to!(Lhs)(s2));
+                }
+            }
+        }
+    }
+}
+
+/**
+Converts array (other than strings) to string. The left bracket,
+separator, and right bracket are configurable. Each element is
+converted by calling $(D to!T).
+ */
+T to(T, S)(S s, in T leftBracket = "[", in T separator = ", ",
+    in T rightBracket = "]")
+if (isSomeString!(T) && !isSomeString!(S) && isArray!(S))
+{
+    alias Unqual!(ElementType!(T)) Char;
+    // array-to-string conversion
+    static if (is(S == void[])
+            || is(S == const(void)[]) || is(S == invariant(void)[])) {
+        auto raw = cast(const(ubyte)[]) s;
+        enforce(raw.length % Char.sizeof == 0, "Alignment mismatch"
+                " in converting a " ~ S.stringof ~ " to a " ~ T.stringof);
+        auto result = new Char[raw.length / Char.sizeof];
+        memcpy(result.ptr, s.ptr, s.length);
+        return cast(T) result;
+    } else {
+        Appender!(Char[]) result;
+        result.put(leftBracket);
+        foreach (i, e; s) {
+            if (i) result.put(separator);
+            result.put(to!(T)(e));
+        }
+        result.put(rightBracket);
+        return cast(T) result.data;
+    }
+}
+
+unittest
+{
+    double[2] a = [ 1.5, 2.5 ];
+    //writeln(to!string(a));
+    assert(to!string(a) == "[1.5, 2.5]");
+    short[] b = [ 1, 3, 5 ];
+    assert(to!string(b) == "[1, 3, 5]");
+}
+
+/**
+Associative array to string conversion. The left bracket, key-value
+separator, element separator, and right bracket are configurable.
+Each element is printed by calling $(D to!T).
+ */
+T to(T, S)(S s, in T leftBracket = "[", in T keyval = ":",
+        in T separator = ", ", in T rightBracket = "]")
+if (isAssociativeArray!(S) && isSomeString!(T))
+{
+    alias Unqual!(ElementType!(T)) Char;
+    Appender!(Char[]) result;
+    // hash-to-string conversion
+    result.put(leftBracket);
+    bool first = true;
+    foreach (k, v; s) {
+        if (!first) result.put(separator);
+        else first = false;
+        result.put(to!(T)(k));
+        result.put(keyval);
+        result.put(to!(T)(v));
+    }
+    result.put(rightBracket);
+    return cast(T) result.data;
+}
+
+/**
+Object to string conversion calls $(D toString) against the object or
+returns $(D nullstr) if the object is null.
+ */
+T to(T, S)(S s, in T nullstr = "null")
+if (is(S : Object) && isSomeString!(T))
+{
+    if (!s) return nullstr;
+    return to!(T)(s.toString);
+}
+
+unittest
+{
+    class A { override string toString() { return "an A"; } }
+    A a;
+    assert(to!string(a) == "null");
+    a = new A;
+    assert(to!string(a) == "an A");
+}
+
+/**
+Struct to string conversion calls $(D toString) against the struct if
+it is defined.
+ */
+T to(T, S)(S s)
+if (is(S == struct) && isSomeString!(T) && is(S.init.toString))
+{
+    return to!T(s.toString);
+}
+
+/**
+For structs that do not define $(D toString), the conversion to string
+produces the list of fields.
+ */
+T to(T, S)(S s, in T left = S.stringof~"(", in T separator = ", ",
+        in T right = ")")
+if (is(S == struct) && isSomeString!(T) && !is(S.init.toString))
+{
+    Tuple!(FieldTypeTuple!(S)) * t = void;
+    static if ((*t).sizeof == S.sizeof)
+    {
+        // ok, attempt to forge the tuple
+        t = cast(typeof(t)) &s;
+        alias Unqual!(ElementType!(T)) Char;
+        Appender!(Char[]) app;
+        app.put(left);
+        foreach (i, e; t.field)
+        {
+            if (i > 0) app.put(to!(T)(separator));
+            app.put(to!(T)(e));
+        }
+        app.put(right);
+        return cast(T) app.data;
+    }
+    else
+    {
+        // struct with weird alignment
+        return to!T(S.stringof);
+    }
+}
+
+unittest
+{
+    struct S { int a = 42; float b = 43.5; }
+    S s;
+    assert(to!string(s) == "S(42, 43.5)");
+}
+
+/**
+Enumerated types are printed as their base type (not the symbolic
+names).
+ */
+T to(T, S)(S s) if (is(S == enum) && isSomeString!(T)
+        && !implicitlyConverts!(S, T))
+{
+    static if (is(S E == enum)) return to!(T)(cast(E) (s));
+    else static assert(false);
+}
+
+unittest
+{
+    enum A : int { a = 123, b = 234 }
+    assert(to!string(A.a) == "123");
+    enum B : string { a = "123", b = "234" }
+    assert(to!string(B.a) == "123");
+    enum C : double { a = 123, b = 234 }
+    assert(to!string(C.a) == "123");
+}
+
+/**
+A $(D typedef Type Symbol) is printed as $(D Type(value)).
+ */
+T to(T, S)(S s, in T left = S.stringof~"(", in T right = ")")
+if (is(S == typedef) && isSomeString!(T))
+{
+    static if (is(S Original == typedef)) {
+        // typedef
+        return left ~ to!(T)(cast(Original) s) ~ right;
+    }
+}
+
+unittest
+{
+    typedef double Km;
+    Km km = 42;
+    assert(to!string(km) == "Km(42)");
+}
+
+unittest
+{
+    auto a = "abcx"w;
+    const(void)[] b = a;
+    assert(b.length == 8);
+    auto c = to!(wchar[])(b);
+    assert(c == "abcx");
+}
+
+/* **************************************************************
 
 The $(D_PARAM to) family of functions converts a value from type
 $(D_PARAM Source) to type $(D_PARAM Target). The source type is
@@ -197,140 +477,76 @@
 might fail the range check.
 
 Macros: WIKI=Phobos/StdConv
-*/
-
-template to(Target)
+ */
+
+/**
+If the source type is implicitly convertible to the target type, $(D
+to) simply performs the implicit conversion.
+ */
+Target to(Target, Source)(Source value) if (implicitlyConverts!(Source, Target))
 {
-    Target to(Source)(Source value)
+    return value;
+}
+
+unittest
+{
+    int a = 42;
+    auto b = to!long(a);
+    assert(a == b);
+}
+
+/**
+Boolean values are printed as $(D "true") or $(D "false").
+ */
+T to(T, S)(S b) if (is(Unqual!S == bool) && isSomeString!(T))
+{
+    return to!T(b ? "true" : "false");
+}
+
+unittest
+{
+    bool b;
+    assert(to!string(b) == "false");
+    b = true;
+    assert(to!string(b) == "true");
+}
+
+
+/**
+When the source is a wide string, it is first converted to a narrow
+string and then parsed.
+ */
+T to(T, S)(S value) if ((is(S : const(wchar)[]) || is(S : const(dchar)[]))
+        && !isSomeString!(T))
+{
+    // todo: improve performance
+    return parseString!(T)(toUTF8(value));
+}
+
+/**
+When the source is a narrow string, normal text parsing occurs.
+ */
+T to(T, S)(S value) if (is(S : const(char)[]) && !isSomeString!(T))
+{
+    return parseString!(T)(value);
+}
+
+unittest
+{
+    foreach (Char; TypeTuple!(char, wchar, dchar))
     {
-        return toImpl!(Source, Target)(value);
+        auto a = to!(Char[])("123");
+        assert(to!int(a) == 123);
+        assert(to!double(a) == 123);
     }
 }
 
-private T toSomeString(S, T)(S s)
+/**
+Object-to-object conversions throw exception when the source is
+non-null and the target is null.
+ */
+T to(T, S)(S value) if (is(S : Object) && is(T : Object))
 {
-    static const sIsString = is(S : const(char)[]) || is(S : const(wchar)[])
-        || is(S : const(dchar)[]);
-    static if (sIsString) {
-        // string-to-string conversion
-        static if (s[0].sizeof == T[0].sizeof) {
-            // same width, only qualifier conversion
-            enum tIsConst = is(T == const(char)[]) || is(T == const(wchar)[])
-                || is(T == const(dchar)[]);
-            enum tIsInvariant = is(T == invariant(char)[])
-                || is(T == invariant(wchar)[]) || is(T == invariant(dchar)[]);
-            static assert(!is(S == T)); // should have been handled earlier
-            static if (tIsConst) {
-                return s;
-            } else static if (tIsInvariant) {
-                // conversion (mutable|const) -> invariant
-                return s.idup;
-            } else {
-                // conversion (invariant|const) -> mutable
-                return s.dup;
-            }
-        } else {
-            // width conversion
-            // we can cast because toUTFX always produces a fresh string
-            static if (T[0].sizeof == 1) {
-                return cast(T) toUTF8(s);
-            } else static if (T[0].sizeof == 2) {
-                return cast(T) toUTF16(s);
-            } else {
-                static assert(T[0].sizeof == 4);
-                return cast(T) toUTF32(s);
-            }
-        }
-    } else {
-        static if (isArray!(S)) {
-            // array-to-string conversion
-            static if (is(S == void[])
-                    || is(S == const(void)[]) || is(S == invariant(void)[])) {
-                auto fake = cast(const(ubyte)[]) s;
-                static if (T[0].sizeof == 1)
-                    alias ubyte FakeT;
-                else static if (T[0].sizeof == 2)
-                         alias ushort FakeT;
-                    else static if (T[0].sizeof == 4)
-                         alias uint FakeT;
-                    else static assert(false, T.stringof);
-                auto result =
-                    new FakeT[(s.length + FakeT.sizeof - 1) / FakeT.sizeof];
-                assert(result.length * FakeT.sizeof >= s.length);
-                memcpy(result.ptr, s.ptr, s.length);
-                return cast(T) result;
-            } else {
-                T result = to!(T)("[");
-                foreach (i, e; s) {
-                    if (i) result ~= ',';
-                    result ~= to!(T)(e);
-                }
-                result ~= ']';
-                return result;
-            }
-        } else static if (isAssociativeArray!(S)) {
-            // hash-to-string conversion
-            T result = "[";
-            bool first = true;
-            foreach (k, v; s) {
-                if (!first) result ~= ',';
-                else first = false;
-                result ~= to!(T)(k);
-                result ~= ':';
-                result ~= to!(T)(v);
-            }
-            result ~= ']';
-            return result;
-        } else static if (is(S == enum)) {
-            // enumerated type
-            return to!(T)(to!(long)(s));
-        } else static if (is(S : Object)) {
-            // class
-            return s is null ? "null" : to!(T)(s.toString);
-        } else static if (is(typeof(s.toString))) {
-            // struct defining toString member
-            return to!(T)(s.toString);
-        } else static if (is(S Original == typedef)) {
-            // typedef
-            return to!(T)(to!(Original)(s));
-        } else {
-            // source is not a string
-            auto result = toString(s);
-            static if (is(typeof(result) == T)) return result;
-            else return to!(T)(result);
-        }
-    }
-}
-
-unittest
-{
-    auto a = "abcx"w;
-    const(void)[] b = a;
-    assert(b.length == 8);
-    auto c = to!(wchar[])(b);
-    assert(c == "abcx");
-}
-
-private T toImpl(S, T)(S value) {
-  static if (is(S == T)) {
-    // Identity conversion
-    return value;
-  } else static if (is(T : const(char)[]) || is(T : const(wchar)[])
-                    || is(T : const(dchar)[])) {
-    return toSomeString!(S, T)(value);
-  } else static if (is(S : const(char)[])) {
-    return parseString!(T)(value);
-  } else static if (is(S : const(wchar)[]) || is(S : const(dchar)[])) {
-    // todo: improve performance
-    return parseString!(T)(toUTF8(value));
-  } else static if (std.traits.isNumeric!(S) && std.traits.isNumeric!(T)) {
-    return numberToNumber!(S, T)(value);
-  } else static if (isAssociativeArray!(S) && isAssociativeArray!(T)) {
-    return hashToHash!(S, T)(value);
-  } else static if (isArray!(S) && isArray!(S)) {
-    return arrayToArray!(S, T)(value);
-  } else static if (is(S : Object) && is(T : Object)) {
-    // Object-to-Object conversion fails if source is null
     auto result = cast(T) value;
     if (!result && value)
     {
@@ -339,10 +555,6 @@
                 ~" to type "~T.classinfo.name);
     }
     return result;
-  } else {
-    // Attempt an implicit conversion
-    return value;
-  }
 }
 
 unittest
@@ -363,7 +575,13 @@
     }
 }
 
-private T numberToNumber(S, T)(S value)
+/**
+Narrowing numeric-numeric conversions throw when the value does not
+fit in the narrower type.
+ */
+T to(T, S)(S value)
+if (!implicitlyConverts!(S, T)
+        && std.traits.isNumeric!(S) && std.traits.isNumeric!(T))
 {
     enum sSmallest = mostNegative!(S);
     enum tSmallest = mostNegative!(T);
@@ -375,240 +593,255 @@
             static assert(tSmallest < 0);
             invariant good = value >= tSmallest;
         }
-        if (!good) conv_overflow("Conversion underflow");
+        if (!good) ConvOverflowError.raise("Conversion underflow");
     }
     static if (S.max > T.max) {
         // possible overflow
-        if (value > T.max) conv_overflow("Conversion overflow");
+        if (value > T.max) ConvOverflowError.raise("Conversion overflow");
     }
     return cast(T) value;
 }
 
 private T parseString(T)(const(char)[] v)
 {
-    scope(exit) 
+    scope(exit)
     {
-        if (v.length) 
+        if (v.length)
         {
-            conv_error!(const(char)[], T)(v); 
+            conv_error!(const(char)[], T)(v);
         }
     }
     return parse!(T)(v);
 }
 
-private T[] arrayToArray(S : S[], T : T[])(S[] src) {
-  T[] result;
-  foreach (e; src) {
-    result ~= to!(T)(e);
-  }
-  return result;
+/**
+Array-to-array conversion (except when target is a string type)
+converts each element in turn by using $(D to).
+ */
+T to(T, S)(S src) if (isArray!(S) && isArray!(T) && !isSomeString!(T)
+        && !implicitlyConverts!(S, T))
+{
+    alias typeof(T.init[0]) E;
+    auto result = new E[src.length];
+    foreach (i, e; src) {
+        result[i] = to!(E)(e);
+    }
+    return result;
 }
 
+unittest
+{
+    // array to array conversions
+    uint[] a = ([ 1u, 2, 3 ]).dup;
+    auto b = to!(float[])(a);
+    assert(b == [ 1.0f, 2, 3 ]);
+    auto c = to!(string[])(b);
+    assert(c[0] == "1" && c[1] == "2" && c[2] == "3");
+    invariant(int)[3] d = [ 1, 2, 3 ];
+    b = to!(float[])(d);
+    assert(b == [ 1.0f, 2, 3 ]);
+    uint[][] e = [ a, a ];
+    auto f = to!(float[][])(e);
+    assert(f[0] == b && f[1] == b);
+}
+
+/**
+Associative array to associative array conversion converts each key
+and each value in turn.
+ */
+T to(T : V2[K2], S : V1[K1], K1, V1, K2, V2)(S src)
+//if (isAssociativeArray!(S) && isAssociativeArray!(T))
+{
+    T result;
+    foreach (k1, v1; src)
+    {
+        result[to!(K2)(k1)] = to!(V2)(v1);
+    }
+    return result;
+}
+
 unittest {
-  // array to array conversions
-  uint[] a = ([ 1u, 2, 3 ]).dup;
-  auto b = to!(float[])(a);
-  assert(b == [ 1.0f, 2, 3 ]);
-  auto c = to!(string[])(b);
-  assert(c[0] == "1" && c[1] == "2" && c[2] == "3");
-  invariant(int)[3] d = [ 1, 2, 3 ];
-  b = to!(float[])(d);
-  assert(b == [ 1.0f, 2, 3 ]);
-  uint[][] e = [ a, a ];
-  auto f = to!(float[][])(e);
-  assert(f[0] == b && f[1] == b);
+    // hash to hash conversions
+    int[string] a;
+    a["0"] = 1;
+    a["1"] = 2;
+    auto b = to!(double[dstring])(a);
+    assert(b["0"d] == 1 && b["1"d] == 2);
+    // hash to string conversion
+    assert(to!(string)(a) == "[0:1, 1:2]");
 }
 
-private T hashToHash(S : V1[K1], T : V2[K2], K1, V1, K2, V2)(S src) {
-  T result;
-  foreach (k1, v1; src) {
-    result[to!(K2)(k1)] = to!(V2)(v1);
-  }
-  return result;
+unittest {
+    // string tests
+    alias TypeTuple!(char, wchar, dchar) AllChars;
+    foreach (T; AllChars) {
+        foreach (U; AllChars) {
+            T[] s1 = to!(T[])("Hello, world!");
+            auto s2 = to!(U[])(s1);
+            assert(s1 == to!(T[])(s2));
+            auto s3 = to!(const(U)[])(s1);
+            assert(s1 == to!(T[])(s3));
+            auto s4 = to!(invariant(U)[])(s1);
+            assert(s1 == to!(T[])(s4));
+        }
+    }
 }
 
-unittest {
-  // hash to hash conversions
-  int[string] a;
-  a["0"] = 1;
-  a["1"] = 2;
-  auto b = to!(double[dstring])(a);
-  assert(b["0"d] == 1 && b["1"d] == 2);
-  // hash to string conversion
-  assert(to!(string)(a) == "[0:1,1:2]");
+private bool convFails(Source, Target, E)(Source src) {
+    try {
+        auto t = to!(Target)(src);
+    } catch (E) {
+        return true;
+    }
+    return false;
 }
 
-unittest {
-  // string tests
-  alias TypeTuple!(char, wchar, dchar) AllChars;
-  foreach (T; AllChars) {
-    foreach (U; AllChars) {
-      T[] s1 = to!(T[])("Hello, world!");
-      auto s2 = to!(U[])(s1);
-      assert(s1 == to!(T[])(s2));
-      auto s3 = to!(const(U)[])(s1);
-      assert(s1 == to!(T[])(s3));
-      auto s4 = to!(invariant(U)[])(s1);
-      assert(s1 == to!(T[])(s4));
+private void testIntegralToFloating(Integral, Floating)() {
+    Integral a = 42;
+    auto b = to!(Floating)(a);
+    assert(a == b);
+    assert(a == to!(Integral)(b));
+}
+
+private void testFloatingToIntegral(Floating, Integral)() {
+    // convert some value
+    Floating a = 4.2e1;
+    auto b = to!(Integral)(a);
+    assert(is(typeof(b) == Integral) && b == 42);
+    // convert some negative value (if applicable)
+    a = -4.2e1;
+    static if (Integral.min < 0) {
+        b = to!(Integral)(a);
+        assert(is(typeof(b) == Integral) && b == -42);
+    } else {
+        // no go for unsigned types
+        assert(convFails!(Floating, Integral, ConvOverflowError)(a));
     }
-  }
-}
-
-private bool convFails(Source, Target, E)(Source src) {
-  try {
-    auto t = to!(Target)(src);
-  } catch (E) {
-    return true;
-  }
-  return false;
-}
-
-private void testIntegralToFloating(Integral, Floating)() {
-  Integral a = 42;
-  auto b = to!(Floating)(a);
-  assert(a == b);
-  assert(a == to!(Integral)(b));
-}
-
-private void testFloatingToIntegral(Floating, Integral)() {
-  // convert some value
-  Floating a = 4.2e1;
-  auto b = to!(Integral)(a);
-  assert(is(typeof(b) == Integral) && b == 42);
-  // convert some negative value (if applicable)
-  a = -4.2e1;
-  static if (Integral.min < 0) {
-    b = to!(Integral)(a);
-    assert(is(typeof(b) == Integral) && b == -42);
-  } else {
-    // no go for unsigned types
-    assert(convFails!(Floating, Integral, ConvOverflowError)(a));
-  }
-  // convert to the smallest integral value
-  a = 0.0 + Integral.min;
-  static if (Integral.min < 0) {
-    a = -a; // -Integral.min not representable as an Integral
+    // convert to the smallest integral value
+    a = 0.0 + Integral.min;
+    static if (Integral.min < 0) {
+        a = -a; // -Integral.min not representable as an Integral
+        assert(convFails!(Floating, Integral, ConvOverflowError)(a)
+                || Floating.sizeof <= Integral.sizeof);
+    }
+    a = 0.0 + Integral.min;
+    assert(to!(Integral)(a) == Integral.min);
+    --a; // no more representable as an Integral
     assert(convFails!(Floating, Integral, ConvOverflowError)(a)
-           || Floating.sizeof <= Integral.sizeof);
-  }
-  a = 0.0 + Integral.min;
-  assert(to!(Integral)(a) == Integral.min);
-  --a; // no more representable as an Integral
-  assert(convFails!(Floating, Integral, ConvOverflowError)(a)
-         || Floating.sizeof <= Integral.sizeof);
-  a = 0.0 + Integral.max;
+            || Floating.sizeof <= Integral.sizeof);
+    a = 0.0 + Integral.max;
 //   fwritefln(stderr, "%s a=%g, %s conv=%s", Floating.stringof, a,
 //             Integral.stringof, to!(Integral)(a));
-  assert(to!(Integral)(a) == Integral.max || Floating.sizeof <= Integral.sizeof);
-  ++a; // no more representable as an Integral
-  assert(convFails!(Floating, Integral, ConvOverflowError)(a)
-         || Floating.sizeof <= Integral.sizeof);
-  // convert a value with a fractional part
-  a = 3.14;
-  assert(to!(Integral)(a) == 3);
-  a = 3.99;
-  assert(to!(Integral)(a) == 3);
-  static if (Integral.min < 0) {
-    a = -3.14;
-    assert(to!(Integral)(a) == -3);
-    a = -3.99;
-    assert(to!(Integral)(a) == -3);
-  }
+    assert(to!(Integral)(a) == Integral.max || Floating.sizeof <= Integral.sizeof);
+    ++a; // no more representable as an Integral
+    assert(convFails!(Floating, Integral, ConvOverflowError)(a)
+            || Floating.sizeof <= Integral.sizeof);
+    // convert a value with a fractional part
+    a = 3.14;
+    assert(to!(Integral)(a) == 3);
+    a = 3.99;
+    assert(to!(Integral)(a) == 3);
+    static if (Integral.min < 0) {
+        a = -3.14;
+        assert(to!(Integral)(a) == -3);
+        a = -3.99;
+        assert(to!(Integral)(a) == -3);
+    }
 }
 
 unittest {
-  alias TypeTuple!(byte, ubyte, short, ushort, int, uint, long, ulong)
+    alias TypeTuple!(byte, ubyte, short, ushort, int, uint, long, ulong)
     AllInts;
-  alias TypeTuple!(float, double, real) AllFloats;
-  alias TypeTuple!(AllInts, AllFloats) AllNumerics;
-  // test with same type
-  {
-    foreach (T; AllNumerics) {
-      T a = 42;
-      auto b = to!(T)(a);
-      assert(is(typeof(a) == typeof(b)) && a == b);
+    alias TypeTuple!(float, double, real) AllFloats;
+    alias TypeTuple!(AllInts, AllFloats) AllNumerics;
+    // test with same type
+    {
+        foreach (T; AllNumerics) {
+            T a = 42;
+            auto b = to!(T)(a);
+            assert(is(typeof(a) == typeof(b)) && a == b);
+        }
     }
-  }
-  // test that floating-point numbers convert properly to largest ints
-  // see http://oregonstate.edu/~peterseb/mth351/docs/351s2001_fp80x87.html
-  // look for "largest fp integer with a predecessor"
-  {
-    // float
-    int a = 16_777_215; // 2^24 - 1
-    assert(to!(int)(to!(float)(a)) == a);
-    assert(to!(int)(to!(float)(-a)) == -a);
-    // double
-    long b = 9_007_199_254_740_991; // 2^53 - 1
-    assert(to!(long)(to!(double)(b)) == b);
-    assert(to!(long)(to!(double)(-b)) == -b);
-    // real
-    // @@@ BUG IN COMPILER @@@
+    // test that floating-point numbers convert properly to largest ints
+    // see http://oregonstate.edu/~peterseb/mth351/docs/351s2001_fp80x87.html
+    // look for "largest fp integer with a predecessor"
+    {
+        // float
+        int a = 16_777_215; // 2^24 - 1
+        assert(to!(int)(to!(float)(a)) == a);
+        assert(to!(int)(to!(float)(-a)) == -a);
+        // double
+        long b = 9_007_199_254_740_991; // 2^53 - 1
+        assert(to!(long)(to!(double)(b)) == b);
+        assert(to!(long)(to!(double)(-b)) == -b);
+        // real
+        // @@@ BUG IN COMPILER @@@
 //     ulong c = 18_446_744_073_709_551_615UL; // 2^64 - 1
 //     assert(to!(ulong)(to!(real)(c)) == c);
 //     assert(to!(ulong)(-to!(real)(c)) == c);
-  }
-  // test conversions floating => integral
-  {
-    // AllInts[0 .. $ - 1] should be AllInts
-    // @@@ BUG IN COMPILER @@@
-    foreach (Integral; AllInts[0 .. $ - 1]) {
-      foreach (Floating; AllFloats) {
-        testFloatingToIntegral!(Floating, Integral);
-      }
     }
-  }
-  // test conversion integral => floating
-  {
-    foreach (Integral; AllInts[0 .. $ - 1]) {
-      foreach (Floating; AllFloats) {
-        testIntegralToFloating!(Integral, Floating);
-      }
+    // test conversions floating => integral
+    {
+        // AllInts[0 .. $ - 1] should be AllInts
+        // @@@ BUG IN COMPILER @@@
+        foreach (Integral; AllInts[0 .. $ - 1]) {
+            foreach (Floating; AllFloats) {
+                testFloatingToIntegral!(Floating, Integral);
+            }
+        }
     }
-  }
-  // test parsing
-  {
-    foreach (T; AllNumerics) {
-      // from type invariant(char)[2]
-      auto a = to!(T)("42");
-      assert(a == 42);
-      // from type char[]
-      char[] s1 = "42".dup;
-      a = to!(T)(s1);
-      assert(a == 42);
-      // from type char[2]
-      char[2] s2;
-      s2[] = "42";
-      a = to!(T)(s2);
-      assert(a == 42);
-      // from type invariant(wchar)[2]
-      a = to!(T)("42"w);
-      assert(a == 42);
+    // test conversion integral => floating
+    {
+        foreach (Integral; AllInts[0 .. $ - 1]) {
+            foreach (Floating; AllFloats) {
+                testIntegralToFloating!(Integral, Floating);
+            }
+        }
     }
-  }
-  // test conversions to string
-  {
-    foreach (T; AllNumerics) {
-      T a = 42;
-      assert(to!(string)(a) == "42");
-      //assert(to!(wstring)(a) == "42"w);
-      //assert(to!(dstring)(a) == "42"d);
-      // array test
+    // test parsing
+    {
+        foreach (T; AllNumerics) {
+            // from type invariant(char)[2]
+            auto a = to!(T)("42");
+            assert(a == 42);
+            // from type char[]
+            char[] s1 = "42".dup;
+            a = to!(T)(s1);
+            assert(a == 42);
+            // from type char[2]
+            char[2] s2;
+            s2[] = "42";
+            a = to!(T)(s2);
+            assert(a == 42);
+            // from type invariant(wchar)[2]
+            a = to!(T)("42"w);
+            assert(a == 42);
+        }
+    }
+    // test conversions to string
+    {
+        foreach (T; AllNumerics) {
+            T a = 42;
+            assert(to!(string)(a) == "42");
+            //assert(to!(wstring)(a) == "42"w);
+            //assert(to!(dstring)(a) == "42"d);
+            // array test
 //       T[] b = new T[2];
 //       b[0] = 42;
 //       b[1] = 33;
 //       assert(to!(string)(b) == "[42,33]");
+        }
     }
-  }
-  // test array to string conversion
-  foreach (T ; AllNumerics) {
-    auto a = [to!(T)(1), 2, 3];
-    assert(to!(string)(a) == "[1,2,3]");
-  }
-  // test enum to int conversion
-  enum Testing { Test1, Test2 };
-  Testing t;
-  auto a = to!(string)(t);
-  assert(a == "0");
+    // test array to string conversion
+    foreach (T ; AllNumerics) {
+        auto a = [to!(T)(1), 2, 3];
+        assert(to!(string)(a) == "[1, 2, 3]");
+    }
+    // test enum to int conversion
+    // enum Testing { Test1, Test2 };
+    // Testing t;
+    // auto a = to!(string)(t);
+    // assert(a == "0");
 }
 
 /***************************************************************
@@ -629,15 +862,15 @@
  */
 
 template roundTo(Target) {
-  Target roundTo(Source)(Source value) {
-    static assert(is(Source == float) || is(Source == double)
-                  || is(Source == real));
-    static assert(is(Target == byte) || is(Target == ubyte)
-                  || is(Target == short) || is(Target == ushort)
-                  || is(Target == int) || is(Target == uint)
-                  || is(Target == long) || is(Target == ulong));
-    return to!(Target)(value + (value < 0 ? -0.5 : 0.5));
-  }
+    Target roundTo(Source)(Source value) {
+        static assert(is(Source == float) || is(Source == double)
+                || is(Source == real));
+        static assert(is(Target == byte) || is(Target == ubyte)
+                || is(Target == short) || is(Target == ushort)
+                || is(Target == int) || is(Target == uint)
+                || is(Target == long) || is(Target == ulong));
+        return to!(Target)(value + (value < 0 ? -0.5 : 0.5));
+    }
 }
 
 unittest {
@@ -674,85 +907,58 @@
 --------------
  */
 
-template parse(Target)
+Target parse(Target, Source)(ref Source s)
+if (isSomeString!Source && isIntegral!Target)
 {
-    Target parse(Source)(ref Source s)
-    {
-        //alias const(Char)[] Source;
-        static assert(is(Source : const(char)[]) || is(Source : const(wchar)[])
-                      || is(Source : const(dchar)[]),
-                      "parse requires a string upon input, not a "
-                      ~ Source.stringof);
-        static if (isIntegral!(Target))
-        {
-            return parseIntegral!(Source, Target)(s);
-        }
-        else static if (isFloatingPoint!(Target))
-        {
-            return parseFloating!(Source, Target)(s);
-        }
-        else
-        {
-            static assert(false, "Dunno how to parse a " ~ Target.stringof);
-        }
-    }
-}
-
-// Customizable integral parse
-
-private N parseIntegral(S, N)(ref S s)
-{
-    static if (N.sizeof < int.sizeof)
+    static if (Target.sizeof < int.sizeof)
     {
         // smaller types are handled like integers
-        static if (N.min < 0) // signed small integer
-            alias int N1;
-        else
-            alias uint N1;
-        auto v = parseIntegral!(S, N1)(s);
-        auto result = cast(N) v;
-        if (result != v) 
+        auto v = parse!(Select!(Target.min < 0, int, uint), Source)(s);
+        auto result = cast(Target) v;
+        if (result != v)
         {
-            conv_error!(S, N)(s); 
+            conv_error!(Source, Target)(s); 
         }
         return result;
     }
     else
     {
-        auto length = s.length;
+        // Larger than int types
+        immutable length = s.length;
         if (!length)
             goto Lerr;
 
-        static if (N.min < 0)
+        static if (Target.min < 0)
             int sign = 0;
         else
             static const int sign = 0;
-        N v = 0;
+        Target v = 0;
         size_t i = 0;
-        static const char maxLastDigit = N.min < 0 ? '7' : '5';
+        enum char maxLastDigit = Target.min < 0 ? '7' : '5';
         for (; i < length; i++)
         {
-            auto c = s[i];
+            immutable c = s[i];
             if (c >= '0' && c <= '9')
             {
-                if (v < N.max/10 || (v == N.max/10 && c + sign <= maxLastDigit))
-                    v = v * 10 + (c - '0');
-                else
+                if (v >= Target.max/10 &&
+                        (v != Target.max/10|| c + sign > maxLastDigit))
                     goto Loverflow;
+                v = cast(Target) (v * 10 + (c - '0'));
             }
-            else static if (N.min < 0)
+            else static if (Target.min < 0)
             {
                 if (c == '-' && i == 0)
                 {
-                    sign = -1;
                     if (length == 1)
                         goto Lerr;
+                    sign = -1;
                 }
                 else if (c == '+' && i == 0)
                 {
                     if (length == 1)
                         goto Lerr;
-                } else
+                }
+                else
                     break;
             }
             else
@@ -760,7 +966,7 @@
         }
         if (i == 0) goto Lerr;
         s = s[i .. $];
-        static if (N.min < 0)
+        static if (Target.min < 0)
         {
             if (sign == -1)
             {
@@ -768,53 +974,182 @@
             }
         }
         return v;
-    Loverflow:
-        conv_overflow(to!(string)(s));
-    Lerr:
-        conv_error!(S, N)(s);
+      Loverflow:
+        ConvOverflowError.raise("Overflow in integral conversion");
+      Lerr:
+        conv_error!(Source, Target)(s);
         return 0;
     }
 }
 
-/***************************************************************
- Convert character string to the return type. These functions will be
- deprecated because $(D_PARAM to!(T)) supersedes them.
- */
-
-int toInt(string s)
+Target parse(Target, Source)(ref Source s)
+if (isSomeString!Source && isFloatingPoint!Target)
 {
-    scope(exit) { if (s.length) conv_error!(string, int)(s); }
-    return parseIntegral!(string, int)(s);
+    //writefln("toFloat('%s')", s);
+    auto sz = toStringz(to!(const char[])(s));
+    if (std.ctype.isspace(*sz))
+	goto Lerr;
+
+    // issue 1589
+    version (Windows)
+    {
+        if (icmp(s, "nan") == 0)
+        {
+            s = s[3 .. $];
+            return Target.nan;
+        }
+    }
+
+    // BUG: should set __locale_decpoint to "." for DMC
+
+    setErrno(0);
+    char* endptr;
+    static if (is(Target == float))
+        auto f = strtof(sz, &endptr);
+    else static if (is(Target == double))
+        auto f = strtod(sz, &endptr);
+    else static if (is(Target == real))
+        auto f = strtold(sz, &endptr);
+    else
+        static assert(false);
+    if (getErrno() == ERANGE)
+        goto Lerr;
+    assert(endptr);
+    if (endptr == sz)
+    {
+        // no progress
+        goto Lerr;
+    }
+    s = s[endptr - sz .. $];
+    return f;
+  Lerr:
+    conv_error!(Source, Target)(s);
+    assert(0);
 }
 
+// Target parse(Target, Source)(ref Source s)
+// if (isSomeString!Source && isSomeString!Target)
+// {
+    
+// }
+
 unittest
 {
-    debug(conv) printf("conv.toInt.unittest\n");
+    string s = "123";
+    auto a = parse!int(s);
+}
+
+// Customizable integral parse
+
+// private N parseIntegral(S, N)(ref S s)
+// {
+//     static if (N.sizeof < int.sizeof)
+//     {
+//         // smaller types are handled like integers
+//         static if (N.min < 0) // signed small integer
+//             alias int N1;
+//         else
+//             alias uint N1;
+//         auto v = parseIntegral!(S, N1)(s);
+//         auto result = cast(N) v;
+//         if (result != v) 
+//         {
+//             ConvError.raise!(S, N)(s); 
+//         }
+//         return result;
+//     }
+//     else
+//     {
+//         // Larger than int types
+//         invariant length = s.length;
+//         if (!length)
+//             goto Lerr;
+
+//         static if (N.min < 0)
+//             int sign = 0;
+//         else
+//             enum sign = 0;
+//         N v = 0;
+//         size_t i = 0;
+//         enum char maxLastDigit = N.min < 0 ? '7' : '5';
+//         for (; i < length; i++)
+//         {
+//             auto c = s[i];
+//             if (c >= '0' && c <= '9')
+//             {
+//                 if (v < N.max/10 || (v == N.max/10 && c + sign <= maxLastDigit))
+//                     v = cast(N) (v * 10 + (c - '0'));
+//                 else
+//                     goto Loverflow;
+//             }
+//             else static if (N.min < 0)
+//             {
+//                 if (c == '-' && i == 0)
+//                 {
+//                     sign = -1;
+//                     if (length == 1)
+//                         goto Lerr;
+//                 }
+//                 else if (c == '+' && i == 0)
+//                 {
+//                     if (length == 1)
+//                         goto Lerr;
+//                 } else
+//                       break;
+//             }
+//             else
+//                 break;
+//         }
+//         if (i == 0) goto Lerr;
+//         s = s[i .. $];
+//         static if (N.min < 0)
+//         {
+//             if (sign == -1)
+//             {
+//                 v = -v;
+//             }
+//         }
+//         return v;
+//       Loverflow:
+//         assert(false);
+//         //ConvOverflowError.raise(to!string(s));
+//       Lerr:
+//         ConvError.raise!(S, N)(s);
+//         return 0;
+//     }
+// }
+
+/*
+ */
+
+unittest
+{
+    debug(conv) printf("conv.to!int.unittest\n");
 
     int i;
 
-    i = toInt("0");
+    i = to!int("0");
     assert(i == 0);
 
-    i = toInt("+0");
+    i = to!int("+0");
     assert(i == 0);
 
-    i = toInt("-0");
+    i = to!int("-0");
     assert(i == 0);
 
-    i = toInt("6");
+    i = to!int("6");
     assert(i == 6);
 
-    i = toInt("+23");
+    i = to!int("+23");
     assert(i == 23);
 
-    i = toInt("-468");
+    i = to!int("-468");
     assert(i == -468);
 
-    i = toInt("2147483647");
+    i = to!int("2147483647");
     assert(i == 0x7FFFFFFF);
 
-    i = toInt("-2147483648");
+    i = to!int("-2147483648");
     assert(i == 0x80000000);
 
     invariant string[] errors =
@@ -840,7 +1175,7 @@
 	i = 47;
 	try
 	{
-	    i = toInt(errors[j]);
+	    i = to!int(errors[j]);
 	    //printf("i = %d\n", i);
 	}
 	catch (Error e)
@@ -853,37 +1188,31 @@
 }
 
 
-/*******************************************************
- * ditto
+/*
+Tests for to!uint 
  */
-uint toUint(string s)
-{
-    scope(exit) if (s.length) conv_error!(string, uint)(s);
-    return parseIntegral!(string, uint)(s);
-}
-
 unittest
 {
-    debug(conv) printf("conv.toUint.unittest\n");
+    debug(conv) printf("conv.to!uint.unittest\n");
 
     uint i;
 
-    i = toUint("0");
+    i = to!uint("0");
     assert(i == 0);
 
-    i = toUint("6");
+    i = to!uint("6");
     assert(i == 6);
 
-    i = toUint("23");
+    i = to!uint("23");
     assert(i == 23);
 
-    i = toUint("468");
+    i = to!uint("468");
     assert(i == 468);
 
-    i = toUint("2147483647");
+    i = to!uint("2147483647");
     assert(i == 0x7FFFFFFF);
 
-    i = toUint("4294967295");
+    i = to!uint("4294967295");
     assert(i == 0xFFFFFFFF);
 
     static string[] errors =
@@ -909,7 +1238,7 @@
 	i = 47;
 	try
 	{
-	    i = toUint(errors[j]);
+	    i = to!uint(errors[j]);
 	    //printf("i = %d\n", i);
 	}
 	catch (Error e)
@@ -921,50 +1250,44 @@
     }
 }
 
-/*******************************************************
- * ditto
+/*
+Tests for to!long
  */
 
-long toLong(string s)
-{
-    scope(exit) if (s.length) conv_error!(string, long)(s);
-    return parseIntegral!(string, long)(s);
-}
-
 unittest
 {
-    debug(conv) printf("conv.toLong.unittest\n");
+    debug(conv) printf("conv.to!long.unittest\n");
 
     long i;
 
-    i = toLong("0");
+    i = to!long("0");
     assert(i == 0);
 
-    i = toLong("+0");
+    i = to!long("+0");
     assert(i == 0);
 
-    i = toLong("-0");
+    i = to!long("-0");
     assert(i == 0);
 
-    i = toLong("6");
+    i = to!long("6");
     assert(i == 6);
 
-    i = toLong("+23");
+    i = to!long("+23");
     assert(i == 23);
 
-    i = toLong("-468");
+    i = to!long("-468");
     assert(i == -468);
 
-    i = toLong("2147483647");
+    i = to!long("2147483647");
     assert(i == 0x7FFFFFFF);
 
-    i = toLong("-2147483648");
+    i = to!long("-2147483648");
     assert(i == -0x80000000L);
 
-    i = toLong("9223372036854775807");
+    i = to!long("9223372036854775807");
     assert(i == 0x7FFFFFFFFFFFFFFF);
 
-    i = toLong("-9223372036854775808");
+    i = to!long("-9223372036854775808");
     assert(i == 0x8000000000000000);
 
     static string[] errors =
@@ -989,7 +1312,7 @@
 	i = 47;
 	try
 	{
-	    i = toLong(errors[j]);
+	    i = to!long(errors[j]);
 	    //printf("l = %d\n", i);
 	}
 	catch (Error e)
@@ -1002,44 +1325,38 @@
 }
 
 
-/*******************************************************
- * ditto
+/*
+Tests for to!ulong
  */
 
-ulong toUlong(string s)
-{
-    scope(exit) if (s.length) conv_error!(string, ulong)(s);
-    return parseIntegral!(string, ulong)(s);
-}
-
 unittest
 {
-    debug(conv) printf("conv.toUlong.unittest\n");
+    debug(conv) printf("conv.to!ulong.unittest\n");
 
     ulong i;
 
-    i = toUlong("0");
+    i = to!ulong("0");
     assert(i == 0);
 
-    i = toUlong("6");
+    i = to!ulong("6");
     assert(i == 6);
 
-    i = toUlong("23");
+    i = to!ulong("23");
     assert(i == 23);
 
-    i = toUlong("468");
+    i = to!ulong("468");
     assert(i == 468);
 
-    i = toUlong("2147483647");
+    i = to!ulong("2147483647");
     assert(i == 0x7FFFFFFF);
 
-    i = toUlong("4294967295");
+    i = to!ulong("4294967295");
     assert(i == 0xFFFFFFFF);
 
-    i = toUlong("9223372036854775807");
+    i = to!ulong("9223372036854775807");
     assert(i == 0x7FFFFFFFFFFFFFFF);
 
-    i = toUlong("18446744073709551615");
+    i = to!ulong("18446744073709551615");
     assert(i == 0xFFFFFFFFFFFFFFFF);
 
 
@@ -1066,7 +1383,7 @@
 	i = 47;
 	try
 	{
-	    i = toUlong(errors[j]);
+	    i = to!ulong(errors[j]);
 	    //printf("i = %d\n", i);
 	}
 	catch (Error e)
@@ -1078,44 +1395,38 @@
     }
 }
 
-/*******************************************************
- * ditto
+/*
+Tests for toShort
  */
 
-short toShort(string s)
-{
-    scope(exit) if (s.length) conv_error!(string, short)(s);
-    return parseIntegral!(string, short)(s);
-}
-
 unittest
 {
-    debug(conv) printf("conv.toShort.unittest\n");
+    debug(conv) printf("conv.to!short.unittest\n");
 
     short i;
 
-    i = toShort("0");
+    i = to!short("0");
     assert(i == 0);
 
-    i = toShort("+0");
+    i = to!short("+0");
     assert(i == 0);
 
-    i = toShort("-0");
+    i = to!short("-0");
     assert(i == 0);
 
-    i = toShort("6");
+    i = to!short("6");
     assert(i == 6);
 
-    i = toShort("+23");
+    i = to!short("+23");
     assert(i == 23);
 
-    i = toShort("-468");
+    i = to!short("-468");
     assert(i == -468);
 
-    i = toShort("32767");
+    i = to!short("32767");
     assert(i == 0x7FFF);
 
-    i = toShort("-32768");
+    i = to!short("-32768");
     assert(i == cast(short)0x8000);
 
     static string[] errors =
@@ -1140,7 +1451,7 @@
 	i = 47;
 	try
 	{
-	    i = toShort(errors[j]);
+	    i = to!short(errors[j]);
 	    printf("i = %d\n", i);
 	}
 	catch (Error e)
@@ -1153,38 +1464,32 @@
 }
 
 
-/*******************************************************
- * ditto
+/*
+Tests for to!ushort
  */
 
-ushort toUshort(string s)
-{
-    scope(exit) if (s.length) conv_error!(string, ushort)(s);
-    return parseIntegral!(string, ushort)(s);
-}
-
 unittest
 {
-    debug(conv) printf("conv.toUshort.unittest\n");
+    debug(conv) printf("conv.to!ushort.unittest\n");
 
     ushort i;
 
-    i = toUshort("0");
+    i = to!ushort("0");
     assert(i == 0);
 
-    i = toUshort("6");
+    i = to!ushort("6");
     assert(i == 6);
 
-    i = toUshort("23");
+    i = to!ushort("23");
     assert(i == 23);
 
-    i = toUshort("468");
+    i = to!ushort("468");
     assert(i == 468);
 
-    i = toUshort("32767");
+    i = to!ushort("32767");
     assert(i == 0x7FFF);
 
-    i = toUshort("65535");
+    i = to!ushort("65535");
     assert(i == 0xFFFF);
 
     static string[] errors =
@@ -1210,7 +1515,7 @@
 	i = 47;
 	try
 	{
-	    i = toUshort(errors[j]);
+	    i = to!ushort(errors[j]);
 	    printf("i = %d\n", i);
 	}
 	catch (Error e)
@@ -1224,43 +1529,37 @@
 
 
 /*******************************************************
- * ditto
+Tests for to!byte
  */
 
-byte toByte(string s)
-{
-    scope(exit) if (s.length) conv_error!(string, byte)(s);
-    return parseIntegral!(string, byte)(s);
-}
-
 unittest
 {
-    debug(conv) printf("conv.toByte.unittest\n");
+    debug(conv) printf("conv.to!byte.unittest\n");
 
     byte i;
 
-    i = toByte("0");
+    i = to!byte("0");
     assert(i == 0);
 
-    i = toByte("+0");
+    i = to!byte("+0");
     assert(i == 0);
 
-    i = toByte("-0");
+    i = to!byte("-0");
     assert(i == 0);
 
-    i = toByte("6");
+    i = to!byte("6");
     assert(i == 6);
 
-    i = toByte("+23");
+    i = to!byte("+23");
     assert(i == 23);
 
-    i = toByte("-68");
+    i = to!byte("-68");
     assert(i == -68);
 
-    i = toByte("127");
+    i = to!byte("127");
     assert(i == 0x7F);
 
-    i = toByte("-128");
+    i = to!byte("-128");
     assert(i == cast(byte)0x80);
 
     static string[] errors =
@@ -1285,7 +1584,7 @@
 	i = 47;
 	try
 	{
-	    i = toByte(errors[j]);
+	    i = to!byte(errors[j]);
 	    printf("i = %d\n", i);
 	}
 	catch (Error e)
@@ -1298,38 +1597,32 @@
 }
 
 
-/*******************************************************
- * ditto
+/*
+Tests for to!ubyte
  */
 
-ubyte toUbyte(string s)
-{
-    scope(exit) if (s.length) conv_error!(string, ubyte)(s);
-    return parseIntegral!(string, ubyte)(s);
-}
-
 unittest
 {
-    debug(conv) printf("conv.toUbyte.unittest\n");
+    debug(conv) printf("conv.to!ubyte.unittest\n");
 
     ubyte i;
 
-    i = toUbyte("0");
+    i = to!ubyte("0");
     assert(i == 0);
 
-    i = toUbyte("6");
+    i = to!ubyte("6");
     assert(i == 6);
 
-    i = toUbyte("23");
+    i = to!ubyte("23");
     assert(i == 23);
 
-    i = toUbyte("68");
+    i = to!ubyte("68");
     assert(i == 68);
 
-    i = toUbyte("127");
+    i = to!ubyte("127");
     assert(i == 0x7F);
 
-    i = toUbyte("255");
+    i = to!ubyte("255");
     assert(i == 0xFF);
 
     static string[] errors =
@@ -1355,7 +1648,7 @@
 	i = 47;
 	try
 	{
-	    i = toUbyte(errors[j]);
+	    i = to!ubyte(errors[j]);
 	    printf("i = %d\n", i);
 	}
 	catch (Error e)
@@ -1367,116 +1660,91 @@
     }
 }
 
-version (skyos)
-{
-    float strtof(char * s, char ** ep) {
-	return strtod(s, ep);
-    }
-}
-
-static if (real.sizeof > double.sizeof)
-    private alias strtold _conv_strtold;
-else
-    private alias strtod _conv_strtold;
-
-/*******************************************************
- * ditto
- */
-
-float toFloat(Char)(Char[] s)
-{
-    scope(exit) if (s.length) conv_error!(Char[], float)(s);
-    return parseFloating!(Char[], float)(s);
-}
-
 // @@@ BUG IN COMPILER
 // lvalue of type invariant(T)[] should be implicitly convertible to
 // ref const(T)[].
-F parseFloating(S : S[], F)(ref S[] s)
-{
-    //writefln("toFloat('%s')", s);
-    version (aix)
-	s = toupper(s);
-    auto sz = toStringz(to!(const char[])(s));
-    if (std.ctype.isspace(*sz))
-	goto Lerr;
-
-    // issue 1589
-    version (Windows)
-    {
-        if (icmp(s, "nan") == 0)
-        {
-            s = s[3 .. $];
-            return F.nan;
-        }
-    }
-
-    // BUG: should set __locale_decpoint to "." for DMC
-
-    setErrno(0);
-    char* endptr;
-    static if (is(F == float))
-        auto f = strtof(sz, &endptr);
-    else static if (is(F == double))
-        auto f = strtod(sz, &endptr);
-    else static if (is(F == real))
-        auto f = _conv_strtold(sz, &endptr);
-    else
-        static assert(false);
-    if (getErrno() == ERANGE)
-	goto Lerr;
-    assert(endptr);
-    if (endptr == sz)
-    {
-        // no progress
-	goto Lerr;
-    }
-    s = s[endptr - sz .. $];
-    return f;
-        
-  Lerr:
-    conv_error!(S[], F)(s);
-    assert(0);
-}
- 
+// F parseFloating(S : S[], F)(ref S[] s)
+// {
+//     //writefln("toFloat('%s')", s);
+//     auto sz = toStringz(to!(const char[])(s));
+//     if (std.ctype.isspace(*sz))
+// 	goto Lerr;
+
+//     // issue 1589
+//     version (Windows)
+//     {
+//         if (icmp(s, "nan") == 0)
+//         {
+//             s = s[3 .. $];
+//             return F.nan;
+//         }
+//     }
+
+//     // BUG: should set __locale_decpoint to "." for DMC
+
+//     setErrno(0);
+//     char* endptr;
+//     static if (is(F == float))
+//         auto f = strtof(sz, &endptr);
+//     else static if (is(F == double))
+//         auto f = strtod(sz, &endptr);
+//     else static if (is(F == real))
+//         auto f = strtold(sz, &endptr);
+//     else
+//         static assert(false);
+//     if (getErrno() == ERANGE)
+//         goto Lerr;
+//     assert(endptr);
+//     if (endptr == sz)
+//     {
+//         // no progress
+//         goto Lerr;
+//     }
+//     s = s[endptr - sz .. $];
+//     return f;
+//   Lerr:
+//     ConvError.raise!(S[], F)(s);
+//     assert(0);
+// }
+
 unittest
 {
-    debug( conv ) writefln( "conv.toFloat.unittest" );
+    debug( conv ) writefln( "conv.to!float.unittest" );
     float f;
-    
-    f = toFloat( "nAn" );
+
+    f = to!float( "nAn" );
     assert(isnan(f));
-    f = toFloat( "123" );
+    f = to!float( "123" );
     assert( f == 123f );
-    f = toFloat( "+123" );
+    f = to!float( "+123" );
     assert( f == +123f );
-    f = toFloat( "-123" );
+    f = to!float( "-123" );
     assert( f == -123f );
-    f = toFloat( "123e+2" );
+    f = to!float( "123e+2" );
     assert( f == 123e+2f );
 
-    f = toFloat( "123e-2" );
+    f = to!float( "123e-2" );
     assert( f == 123e-2f );
-    f = toFloat( "123." );
+    f = to!float( "123." );
     assert( f == 123.f );
-    f = toFloat( ".456" );
+    f = to!float( ".456" );
     assert( f == .456f );
-    
+
     // min and max
-    f = toFloat("1.17549e-38");
+    f = to!float("1.17549e-38");
     assert(feq(cast(real)f, cast(real)1.17549e-38));
     assert(feq(cast(real)f, cast(real)float.min));
-    f = toFloat("3.40282e+38");
-    assert(toString(f) == toString(3.40282e+38));
+    f = to!float("3.40282e+38");
+    assert(to!string(f) == to!string(3.40282e+38));
 
     // nan
-    f = toFloat("nan");
-    assert(toString(f) == toString(float.nan));
+    f = to!float("nan");
+    assert(to!string(f) == to!string(float.nan));
 
     bool ok = false;
     try
     {
-	toFloat("\x00");
+	to!float("\x00");
     }
     catch (ConvError e)
     {
@@ -1485,55 +1753,49 @@
     assert(ok);
 }
 
-/*******************************************************
- * ditto
+/*
+Tests for to!double
  */
 
-double toDouble(Char)(Char[] s)
-{
-    scope(exit) if (s.length) conv_error!(Char[], double)(s);
-    return parseFloating!(Char[], double)(s);
-}
-
 unittest
 {
-    debug( conv ) writefln( "conv.toDouble.unittest" );
+    debug( conv ) writefln( "conv.to!double.unittest" );
     double d;
 
-    d = toDouble( "123" );
+    d = to!double( "123" );
     assert( d == 123 );
-    d = toDouble( "+123" );
+    d = to!double( "+123" );
     assert( d == +123 );
-    d = toDouble( "-123" );
+    d = to!double( "-123" );
     assert( d == -123 );
-    d = toDouble( "123e2" );
+    d = to!double( "123e2" );
     assert( d == 123e2);
-    d = toDouble( "123e-2" );
+    d = to!double( "123e-2" );
     assert( d == 123e-2 );
-    d = toDouble( "123." );
+    d = to!double( "123." );
     assert( d == 123. );
-    d = toDouble( ".456" );
+    d = to!double( ".456" );
     assert( d == .456 );
-    d = toDouble( "1.23456E+2" );
+    d = to!double( "1.23456E+2" );
     assert( d == 1.23456E+2 );
 
     // min and max
-    d = toDouble("2.22507e-308");
+    d = to!double("2.22507e-308");
     assert(feq(cast(real)d, cast(real)2.22508e-308));
     assert(feq(cast(real)d, cast(real)double.min));
-    d = toDouble("1.79769e+308");
-    assert(toString(d) == toString(1.79769e+308));
-    assert(toString(d) == toString(double.max));
+    d = to!double("1.79769e+308");
+    assert(to!string(d) == to!string(1.79769e+308));
+    assert(to!string(d) == to!string(double.max));
 
     // nan
-    d = toDouble("nan");
-    assert(toString(d) == toString(double.nan));
+    d = to!double("nan");
+    assert(to!string(d) == to!string(double.nan));
     //assert(cast(real)d == cast(real)double.nan);
 
     bool ok = false;
     try
     {
-	toDouble("\x00");
+	to!double("\x00");
     }
     catch (ConvError e)
     {
@@ -1542,59 +1804,53 @@
     assert(ok);
 }
 
-/*******************************************************
- * ditto
+/*
+Tests for to!real
  */
-real toReal(Char)(Char[] s)
-{
-    scope(exit) if (s.length) conv_error!(Char[], real)(s);
-    return parseFloating!(Char[], real)(s);
-}
-
 unittest
 {
-    debug(conv) writefln("conv.toReal.unittest");
+    debug(conv) writefln("conv.to!real.unittest");
     real r;
 
-    r = toReal("123");
+    r = to!real("123");
     assert(r == 123L);
-    r = toReal("+123");
+    r = to!real("+123");
     assert(r == 123L);
-    r = toReal("-123");
+    r = to!real("-123");
     assert(r == -123L);
-    r = toReal("123e2");
+    r = to!real("123e2");
     assert(feq(r, 123e2L));
-    r = toReal("123e-2");
+    r = to!real("123e-2");
     assert(feq(r, 1.23L));
-    r = toReal("123.");
+    r = to!real("123.");
     assert(r == 123L);
-    r = toReal(".456");
+    r = to!real(".456");
     assert(r == .456L);
 
-    r = toReal("1.23456e+2");
+    r = to!real("1.23456e+2");
     assert(feq(r,  1.23456e+2L));
-    r = toReal(toString(real.max / 2L));
-    assert(toString(r) == toString(real.max / 2L));
+    r = to!real(to!string(real.max / 2L));
+    assert(to!string(r) == to!string(real.max / 2L));
 
     // min and max
-    r = toReal(toString(real.min));
-    assert(toString(r) == toString(real.min));
-    r = toReal(toString(real.max));
-    assert(toString(r) == toString(real.max));
+    r = to!real(to!string(real.min));
+    assert(to!string(r) == to!string(real.min));
+    r = to!real(to!string(real.max));
+    assert(to!string(r) == to!string(real.max));
 
     // nan
-    r = toReal("nan");
-    assert(toString(r) == toString(real.nan));
+    r = to!real("nan");
+    assert(to!string(r) == to!string(real.nan));
     //assert(r == real.nan);
 
-    r = toReal(toString(real.nan));
-    assert(toString(r) == toString(real.nan));
+    r = to!real(to!string(real.nan));
+    assert(to!string(r) == to!string(real.nan));
     //assert(r == real.nan);
 
     bool ok = false;
     try
     {
-	toReal("\x00");
+	to!real("\x00");
     }
     catch (ConvError e)
     {
@@ -1608,370 +1864,370 @@
      * what to do about the 'i' suffix. Should it be there?
      * Should it not? What about 'nan', should it be 'nani'?
      * 'infinity' or 'infinityi'?
-     * Should it match what toString(ifloat) does with the 'i' suffix?
+     * Should it match what to!string(ifloat) does with the 'i' suffix?
      */
 
 /*******************************************************
  * ditto
  */
 
-ifloat toIfloat(in string s)
-{
-    return toFloat(s) * 1.0i;
-}
-
-unittest
-{
-    debug(conv) writefln("conv.toIfloat.unittest");
-    ifloat ift;
-    
-    ift = toIfloat(toString(123.45));
-    assert(toString(ift) == toString(123.45i));
-
-    ift = toIfloat(toString(456.77i));
-    assert(toString(ift) == toString(456.77i));
-
-    // min and max
-    ift = toIfloat(toString(ifloat.min));
-    assert(toString(ift) == toString(ifloat.min) );
-    assert(feq(cast(ireal)ift, cast(ireal)ifloat.min));
-
-    ift = toIfloat(toString(ifloat.max));
-    assert(toString(ift) == toString(ifloat.max));
-    assert(feq(cast(ireal)ift, cast(ireal)ifloat.max));
-   
-    // nan
-    ift = toIfloat("nani");
-    assert(cast(real)ift == cast(real)ifloat.nan);
-
-    ift = toIfloat(toString(ifloat.nan));
-    assert(toString(ift) == toString(ifloat.nan));
-    assert(feq(cast(ireal)ift, cast(ireal)ifloat.nan));
-}
+    ifloat toIfloat(in string s)
+    {
+        return toFloat(s) * 1.0i;
+    }
+
+    unittest
+    {
+        debug(conv) writefln("conv.toIfloat.unittest");
+        ifloat ift;
+
+        ift = toIfloat(to!string(123.45));
+        assert(to!string(ift) == to!string(123.45i));
+
+        ift = toIfloat(to!string(456.77i));
+        assert(to!string(ift) == to!string(456.77i));
+
+        // min and max
+        ift = toIfloat(to!string(ifloat.min));
+        assert(to!string(ift) == to!string(ifloat.min) );
+        assert(feq(cast(ireal)ift, cast(ireal)ifloat.min));
+
+        ift = toIfloat(to!string(ifloat.max));
+        assert(to!string(ift) == to!string(ifloat.max));
+        assert(feq(cast(ireal)ift, cast(ireal)ifloat.max));
+
+        // nan
+        ift = toIfloat("nani");
+        assert(cast(real)ift == cast(real)ifloat.nan);
+
+        ift = toIfloat(to!string(ifloat.nan));
+        assert(to!string(ift) == to!string(ifloat.nan));
+        assert(feq(cast(ireal)ift, cast(ireal)ifloat.nan));
+    }
 
 /*******************************************************
  * ditto
  */
 
-idouble toIdouble(in string s)
-{
-    return toDouble(s) * 1.0i;
-}
-
-unittest
-{
-    debug(conv) writefln("conv.toIdouble.unittest");
-    idouble id;
-
-    id = toIdouble(toString("123.45"));
-    assert(id == 123.45i);
-
-    id = toIdouble(toString("123.45e+302i"));
-    assert(id == 123.45e+302i);
-
-    // min and max
-    id = toIdouble(toString(idouble.min));
-    assert(toString( id ) == toString(idouble.min));
-    assert(feq(cast(ireal)id.re, cast(ireal)idouble.min.re));
-    assert(feq(cast(ireal)id.im, cast(ireal)idouble.min.im));
-    
-    id = toIdouble(toString(idouble.max));
-    assert(toString(id) == toString(idouble.max));
-    assert(feq(cast(ireal)id.re, cast(ireal)idouble.max.re));
-    assert(feq(cast(ireal)id.im, cast(ireal)idouble.max.im));
-    
-    // nan
-    id = toIdouble("nani");
-    assert(cast(real)id == cast(real)idouble.nan);
-
-    id = toIdouble(toString(idouble.nan));
-    assert(toString(id) == toString(idouble.nan));
-}
+    idouble toIdouble(in string s)
+    {
+        return toDouble(s) * 1.0i;
+    }
+
+    unittest
+    {
+        debug(conv) writefln("conv.toIdouble.unittest");
+        idouble id;
+
+        id = toIdouble(to!string("123.45"));
+        assert(id == 123.45i);
+
+        id = toIdouble(to!string("123.45e+302i"));
+        assert(id == 123.45e+302i);
+
+        // min and max
+        id = toIdouble(to!string(idouble.min));
+        assert(to!string( id ) == to!string(idouble.min));
+        assert(feq(cast(ireal)id.re, cast(ireal)idouble.min.re));
+        assert(feq(cast(ireal)id.im, cast(ireal)idouble.min.im));
+
+        id = toIdouble(to!string(idouble.max));
+        assert(to!string(id) == to!string(idouble.max));
+        assert(feq(cast(ireal)id.re, cast(ireal)idouble.max.re));
+        assert(feq(cast(ireal)id.im, cast(ireal)idouble.max.im));
+
+        // nan
+        id = toIdouble("nani");
+        assert(cast(real)id == cast(real)idouble.nan);
+
+        id = toIdouble(to!string(idouble.nan));
+        assert(to!string(id) == to!string(idouble.nan));
+    }
 
 /*******************************************************
  * ditto
  */
 
-ireal toIreal(in string s)
-{
-    return toReal(s) * 1.0i;
-}
-
-unittest
-{
-    debug(conv) writefln("conv.toIreal.unittest");
-    ireal ir;
-
-    ir = toIreal(toString("123.45"));
-    assert(feq(cast(real)ir.re, cast(real)123.45i)); 
-
-    ir = toIreal(toString("123.45e+82i"));
-    assert(toString(ir) == toString(123.45e+82i));
-    //assert(ir == 123.45e+82i);
-
-    // min and max
-    ir = toIreal(toString(ireal.min));
-    assert(toString(ir) == toString(ireal.min));
-    assert(feq(cast(real)ir.re, cast(real)ireal.min.re));
-    assert(feq(cast(real)ir.im, cast(real)ireal.min.im));
-
-    ir = toIreal(toString(ireal.max));
-    assert(toString(ir) == toString(ireal.max));
-    assert(feq(cast(real)ir.re, cast(real)ireal.max.re));
-    //assert(feq(cast(real)ir.im, cast(real)ireal.max.im));
-
-    // nan
-    ir = toIreal("nani");
-    assert(cast(real)ir == cast(real)ireal.nan);
-
-    ir = toIreal(toString(ireal.nan));
-    assert(toString(ir) == toString(ireal.nan));
-}
+    ireal toIreal(in string s)
+    {
+        return toReal(s) * 1.0i;
+    }
+
+    unittest
+    {
+        debug(conv) writefln("conv.toIreal.unittest");
+        ireal ir;
+
+        ir = toIreal(to!string("123.45"));
+        assert(feq(cast(real)ir.re, cast(real)123.45i)); 
+
+        ir = toIreal(to!string("123.45e+82i"));
+        assert(to!string(ir) == to!string(123.45e+82i));
+        //assert(ir == 123.45e+82i);
+
+        // min and max
+        ir = toIreal(to!string(ireal.min));
+        assert(to!string(ir) == to!string(ireal.min));
+        assert(feq(cast(real)ir.re, cast(real)ireal.min.re));
+        assert(feq(cast(real)ir.im, cast(real)ireal.min.im));
+
+        ir = toIreal(to!string(ireal.max));
+        assert(to!string(ir) == to!string(ireal.max));
+        assert(feq(cast(real)ir.re, cast(real)ireal.max.re));
+        //assert(feq(cast(real)ir.im, cast(real)ireal.max.im));
+
+        // nan
+        ir = toIreal("nani");
+        assert(cast(real)ir == cast(real)ireal.nan);
+
+        ir = toIreal(to!string(ireal.nan));
+        assert(to!string(ir) == to!string(ireal.nan));
+    }
 
 
 /*******************************************************
  * ditto
  */
-cfloat toCfloat(in string s)
-{
-    string s1;
-    string s2;
-    real   r1;
-    real   r2;
-    cfloat cf;
-    bool    b = 0;
-    char*  endptr;
-
-    if (!s.length)
-        goto Lerr;
-    
-    b = getComplexStrings(s, s1, s2);
-
-    if (!b)
-        goto Lerr;
-    
-    // atof(s1);
-    endptr = &s1[s1.length - 1];
-    r1 = _conv_strtold(s1, &endptr); 
-
-    // atof(s2);
-    endptr = &s2[s2.length - 1];
-    r2 = _conv_strtold(s2, &endptr); 
-
-    cf = cast(cfloat)(r1 + (r2 * 1.0i));
-
-    //writefln( "toCfloat() r1=%g, r2=%g, cf=%g, max=%g", 
-    //           r1, r2, cf, cfloat.max);
-    // Currently disabled due to a posted bug where a 
-    // complex float greater-than compare to .max compares 
-    // incorrectly.
-    //if (cf > cfloat.max)
-    //    goto Loverflow;
-
-    return cf;
-
-    Loverflow:
+    cfloat toCfloat(in string s)
+    {
+        string s1;
+        string s2;
+        real   r1;
+        real   r2;
+        cfloat cf;
+        bool    b = 0;
+        char*  endptr;
+
+        if (!s.length)
+            goto Lerr;
+
+        b = getComplexStrings(s, s1, s2);
+
+        if (!b)
+            goto Lerr;
+
+        // atof(s1);
+        endptr = &s1[s1.length - 1];
+        r1 = strtold(s1, &endptr); 
+
+        // atof(s2);
+        endptr = &s2[s2.length - 1];
+        r2 = strtold(s2, &endptr); 
+
+        cf = cast(cfloat)(r1 + (r2 * 1.0i));
+
+        //writefln( "toCfloat() r1=%g, r2=%g, cf=%g, max=%g", 
+        //           r1, r2, cf, cfloat.max);
+        // Currently disabled due to a posted bug where a 
+        // complex float greater-than compare to .max compares 
+        // incorrectly.
+        //if (cf > cfloat.max)
+        //    goto Loverflow;
+
+        return cf;
+
+      Loverflow:
         conv_overflow(s);
-        
-    Lerr:
+
+      Lerr:
         conv_error(s);
-        return cast(cfloat)0.0e-0+0i;   
-}
-
-unittest
-{
-    debug(conv) writefln("conv.toCfloat.unittest");
-    cfloat cf;
-
-    cf = toCfloat(toString("1.2345e-5+0i"));
-    assert(toString(cf) == toString(1.2345e-5+0i));
-    assert(feq(cf, 1.2345e-5+0i));
-
-    // min and max
-    cf = toCfloat(toString(cfloat.min));
-    assert(toString(cf) == toString(cfloat.min));
-
-    cf = toCfloat(toString(cfloat.max));
-    assert(toString(cf) == toString(cfloat.max));
-   
-    // nan ( nan+nani )
-    cf = toCfloat("nani");
-    //writefln("toCfloat() cf=%g, cf=\"%s\", nan=%s", 
-    //         cf, toString(cf), toString(cfloat.nan));
-    assert(toString(cf) == toString(cfloat.nan));
-
-    cf = toCdouble("nan+nani");
-    assert(toString(cf) == toString(cfloat.nan));
-
-    cf = toCfloat(toString(cfloat.nan));
-    assert(toString(cf) == toString(cfloat.nan));
-    assert(feq(cast(creal)cf, cast(creal)cfloat.nan));
-}
+        return cast(cfloat)0.0e-0+0i;
+    }
+
+    unittest
+    {
+        debug(conv) writefln("conv.toCfloat.unittest");
+        cfloat cf;
+
+        cf = toCfloat(to!string("1.2345e-5+0i"));
+        assert(to!string(cf) == to!string(1.2345e-5+0i));
+        assert(feq(cf, 1.2345e-5+0i));
+
+        // min and max
+        cf = toCfloat(to!string(cfloat.min));
+        assert(to!string(cf) == to!string(cfloat.min));
+
+        cf = toCfloat(to!string(cfloat.max));
+        assert(to!string(cf) == to!string(cfloat.max));
+
+        // nan ( nan+nani )
+        cf = toCfloat("nani");
+        //writefln("toCfloat() cf=%g, cf=\"%s\", nan=%s", 
+        //         cf, to!string(cf), to!string(cfloat.nan));
+        assert(to!string(cf) == to!string(cfloat.nan));
+
+        cf = toCdouble("nan+nani");
+        assert(to!string(cf) == to!string(cfloat.nan));
+
+        cf = toCfloat(to!string(cfloat.nan));
+        assert(to!string(cf) == to!string(cfloat.nan));
+        assert(feq(cast(creal)cf, cast(creal)cfloat.nan));
+    }
 
 /*******************************************************
  * ditto
  */
-cdouble toCdouble(in string s)
-{
-    string  s1;
-    string  s2;
-    real    r1;
-    real    r2;
-    cdouble cd;
-    bool     b = 0;
-    char*   endptr;
-
-    if (!s.length)
-        goto Lerr;
-    
-    b = getComplexStrings(s, s1, s2);
-
-    if (!b)
-        goto Lerr;
-
-    // atof(s1);
-    endptr = &s1[s1.length - 1];
-    r1 = _conv_strtold(s1, &endptr); 
-
-    // atof(s2);
-    endptr = &s2[s2.length - 1];
-    r2 = _conv_strtold(s2, &endptr); //atof(s2);
-
-    cd = cast(cdouble)(r1 + (r2 * 1.0i));
- 
-    //Disabled, waiting on a bug fix.
-    //if (cd > cdouble.max)  //same problem the toCfloat() having
-    //    goto Loverflow;
-
-    return cd;
-
-    Loverflow:
+    cdouble toCdouble(in string s)
+    {
+        string  s1;
+        string  s2;
+        real    r1;
+        real    r2;
+        cdouble cd;
+        bool     b = 0;
+        char*   endptr;
+
+        if (!s.length)
+            goto Lerr;
+
+        b = getComplexStrings(s, s1, s2);
+
+        if (!b)
+            goto Lerr;
+
+        // atof(s1);
+        endptr = &s1[s1.length - 1];
+        r1 = strtold(s1, &endptr); 
+
+        // atof(s2);
+        endptr = &s2[s2.length - 1];
+        r2 = strtold(s2, &endptr); //atof(s2);
+
+        cd = cast(cdouble)(r1 + (r2 * 1.0i));
+
+        //Disabled, waiting on a bug fix.
+        //if (cd > cdouble.max)  //same problem the toCfloat() having
+        //    goto Loverflow;
+
+        return cd;
+
+      Loverflow:
         conv_overflow(s);
-        
-    Lerr:
+
+      Lerr:
         conv_error(s);
-        return cast(cdouble)0.0e-0+0i; 
-}
-
-unittest
-{
-    debug(conv) writefln("conv.toCdouble.unittest");
-    cdouble cd;
-
-    cd = toCdouble(toString("1.2345e-5+0i"));
-    assert(toString( cd ) == toString(1.2345e-5+0i));
-    assert(feq(cd, 1.2345e-5+0i));
-
-    // min and max
-    cd = toCdouble(toString(cdouble.min));
-    assert(toString(cd) == toString(cdouble.min));
-    assert(feq(cast(creal)cd, cast(creal)cdouble.min));
-
-    cd = toCdouble(toString(cdouble.max));
-    assert(toString( cd ) == toString(cdouble.max));
-    assert(feq(cast(creal)cd, cast(creal)cdouble.max));
-
-    // nan ( nan+nani )
-    cd = toCdouble("nani");
-    assert(toString(cd) == toString(cdouble.nan));
-
-    cd = toCdouble("nan+nani");
-    assert(toString(cd) == toString(cdouble.nan));
-
-    cd = toCdouble(toString(cdouble.nan));
-    assert(toString(cd) == toString(cdouble.nan));
-    assert(feq(cast(creal)cd, cast(creal)cdouble.nan));
-}
+        return cast(cdouble)0.0e-0+0i;
+    }
+
+    unittest
+    {
+        debug(conv) writefln("conv.toCdouble.unittest");
+        cdouble cd;
+
+        cd = toCdouble(to!string("1.2345e-5+0i"));
+        assert(to!string( cd ) == to!string(1.2345e-5+0i));
+        assert(feq(cd, 1.2345e-5+0i));
+
+        // min and max
+        cd = toCdouble(to!string(cdouble.min));
+        assert(to!string(cd) == to!string(cdouble.min));
+        assert(feq(cast(creal)cd, cast(creal)cdouble.min));
+
+        cd = toCdouble(to!string(cdouble.max));
+        assert(to!string( cd ) == to!string(cdouble.max));
+        assert(feq(cast(creal)cd, cast(creal)cdouble.max));
+
+        // nan ( nan+nani )
+        cd = toCdouble("nani");
+        assert(to!string(cd) == to!string(cdouble.nan));
+
+        cd = toCdouble("nan+nani");
+        assert(to!string(cd) == to!string(cdouble.nan));
+
+        cd = toCdouble(to!string(cdouble.nan));
+        assert(to!string(cd) == to!string(cdouble.nan));
+        assert(feq(cast(creal)cd, cast(creal)cdouble.nan));
+    }
 
 /*******************************************************
  * ditto
  */
-creal toCreal(in string s)
-{
-    string s1;
-    string s2;
-    real   r1;
-    real   r2;
-    creal  cr;
-    bool    b = 0;
-    char*  endptr;
-
-    if (!s.length)
-        goto Lerr;
-
-    b = getComplexStrings(s, s1, s2);
-
-    if (!b)
-        goto Lerr;
- 
-    // atof(s1);
-    endptr = &s1[s1.length - 1];
-    r1 = _conv_strtold(s1, &endptr); 
-
-    // atof(s2);
-    endptr = &s2[s2.length - 1];
-    r2 = _conv_strtold(s2, &endptr); //atof(s2);
-
-    //writefln("toCreal() r1=%g, r2=%g, s1=\"%s\", s2=\"%s\", nan=%g", 
-    //          r1, r2, s1, s2, creal.nan);
-   
-    if (s1 =="nan" && s2 == "nani")
-        cr = creal.nan;
-    else if (r2 != 0.0)
-        cr = cast(creal)(r1 + (r2 * 1.0i));
-    else
-        cr = cast(creal)(r1 + 0.0i);    
+    creal toCreal(in string s)
+    {
+        string s1;
+        string s2;
+        real   r1;
+        real   r2;
+        creal  cr;
+        bool    b = 0;
+        char*  endptr;
+
+        if (!s.length)
+            goto Lerr;
+
+        b = getComplexStrings(s, s1, s2);
+
+        if (!b)
+            goto Lerr;
+
+        // atof(s1);
+        endptr = &s1[s1.length - 1];
+        r1 = strtold(s1, &endptr); 
+
+        // atof(s2);
+        endptr = &s2[s2.length - 1];
+        r2 = strtold(s2, &endptr); //atof(s2);
+
+        //writefln("toCreal() r1=%g, r2=%g, s1=\"%s\", s2=\"%s\", nan=%g", 
+        //          r1, r2, s1, s2, creal.nan);
+
+        if (s1 =="nan" && s2 == "nani")
+            cr = creal.nan;
+        else if (r2 != 0.0)
+            cr = cast(creal)(r1 + (r2 * 1.0i));
+        else
+            cr = cast(creal)(r1 + 0.0i);    
     
-    return cr;
-
-    Lerr:
+        return cr;
+
+      Lerr:
         conv_error(s);
-        return cast(creal)0.0e-0+0i;    
-}
-
-unittest
-{
-    debug(conv) writefln("conv.toCreal.unittest");
-    creal cr;
-
-    cr = toCreal(toString("1.2345e-5+0i"));
-    assert(toString(cr) == toString(1.2345e-5+0i));
-    assert(feq(cr, 1.2345e-5+0i));
-
-    cr = toCreal(toString("0.0e-0+0i"));
-    assert(toString(cr) == toString(0.0e-0+0i));
-    assert(cr == 0.0e-0+0i);
-    assert(feq(cr, 0.0e-0+0i));
-    
-    cr = toCreal("123");
-    assert(cr == 123);
-
-    cr = toCreal("+5");
-    assert(cr == 5);
- 
-    cr = toCreal("-78");
-    assert(cr == -78);
-
-    // min and max
-    cr = toCreal(toString(creal.min));
-    assert(toString(cr) == toString(creal.min));
-    assert(feq(cr, creal.min));
-    
-    cr = toCreal(toString(creal.max));
-    assert(toString(cr) == toString(creal.max));
-    assert(feq(cr, creal.max));
-
-    // nan ( nan+nani )
-    cr = toCreal("nani");
-    assert(toString(cr) == toString(creal.nan));
-
-    cr = toCreal("nan+nani");
-    assert(toString(cr) == toString(creal.nan));
-
-    cr = toCreal(toString(cdouble.nan));
-    assert(toString(cr) == toString(creal.nan));
-    assert(feq(cr, creal.nan));
-}
+        return cast(creal)0.0e-0+0i;
+    }
+
+    unittest
+    {
+        debug(conv) writefln("conv.toCreal.unittest");
+        creal cr;
+
+        cr = toCreal(to!string("1.2345e-5+0i"));
+        assert(to!string(cr) == to!string(1.2345e-5+0i));
+        assert(feq(cr, 1.2345e-5+0i));
+
+        cr = toCreal(to!string("0.0e-0+0i"));
+        assert(to!string(cr) == to!string(0.0e-0+0i));
+        assert(cr == 0.0e-0+0i);
+        assert(feq(cr, 0.0e-0+0i));
+
+        cr = toCreal("123");
+        assert(cr == 123);
+
+        cr = toCreal("+5");
+        assert(cr == 5);
+
+        cr = toCreal("-78");
+        assert(cr == -78);
+
+        // min and max
+        cr = toCreal(to!string(creal.min));
+        assert(to!string(cr) == to!string(creal.min));
+        assert(feq(cr, creal.min));
+
+        cr = toCreal(to!string(creal.max));
+        assert(to!string(cr) == to!string(creal.max));
+        assert(feq(cr, creal.max));
+
+        // nan ( nan+nani )
+        cr = toCreal("nani");
+        assert(to!string(cr) == to!string(creal.nan));
+
+        cr = toCreal("nan+nani");
+        assert(to!string(cr) == to!string(creal.nan));
+
+        cr = toCreal(to!string(cdouble.nan));
+        assert(to!string(cr) == to!string(creal.nan));
+        assert(feq(cr, creal.nan));
+    }
 
 }
 
@@ -1984,7 +2240,7 @@
 {
     int len = s.length;
 
-    if (!len) 
+    if (!len)
         goto Lerr;
 
     // When "nan" or "nani" just return them.
@@ -1994,7 +2250,7 @@
         s2 = "nani";
         return 1;
     }
-    
+
     // Split the original string out into two strings.
     for (int i = 1; i < len; i++)
         if ((s[i - 1] != 'e' && s[i - 1] != 'E') && s[i] == '+')
@@ -2003,29 +2259,29 @@
             s1 = s[0..i];
             if (i + 1 < len - 1)
                 s2 = s[i + 1..len - 1];
-            else 
+            else
                 s2 = "0e+0i";
-            
+
             break;
-        }   
-
-    // Handle the case when there's only a single value 
+        }
+
+    // Handle the case when there's only a single value
     // to work with, and set the other string to zero.
     if (!s1.length)
     {
         s1 = s;
         s2 = "0e+0i";
     }
- 
-    //writefln( "getComplexStrings() s=\"%s\", s1=\"%s\", s2=\"%s\", len=%d", 
+
+    //writefln( "getComplexStrings() s=\"%s\", s1=\"%s\", s2=\"%s\", len=%d",
     //           s, s1, s2, len );
-   
+
     return 1;
 
-    Lerr:
-        // Display the original string in the error message.
+  Lerr:
+    // Display the original string in the error message.
     throw new ConvError("getComplexStrings() \"" ~ s ~ "\"" ~ " s1=\""
-                             ~ s1 ~ "\"" ~ " s2=\"" ~ s2 ~ "\"");
+            ~ s1 ~ "\"" ~ " s2=\"" ~ s2 ~ "\"");
 }
 
 // feq() functions now used only in unittesting
@@ -2037,13 +2293,13 @@
 {
     if (rx == ry)
         return 1;
-    
+
     if (isnan(rx))
         return cast(bool)isnan(ry);
 
     if (isnan(ry))
         return 0;
-       
+
     return cast(bool)(fabs(rx - ry) <= precision);
 }
 
@@ -2059,16 +2315,16 @@
 {
     if (r1 == r2)
         return 1;
-    
+
     if (isnan(r1))
         return cast(bool)isnan(r2);
 
     if (isnan(r2))
         return 0;
-        
+
     return cast(bool)(feq(r1, r2, 0.000001L));
-} 
- 
+}
+
 /* ***************************************
  * compare ireals with given precision
  */
@@ -2079,15 +2335,15 @@
 
     if (rx == ry)
         return 1;
-    
-    if (isnan(rx)) 
+
+    if (isnan(rx))
         return cast(bool)isnan(ry);
 
     if (isnan(ry))
         return 0;
-    
+
     return feq(rx, ry, 0.000001L);
-} 
+}
 
 /* ***************************************
  * compare creals with given precision
@@ -2098,9 +2354,9 @@
     real r2b = fabs(cast(real)r1.im - cast(real)r2.im);
 
     if ((cast(real)r1.re == cast(real)r2.re) &&
-        (cast(real)r1.im == cast(real)r2.im))
+            (cast(real)r1.im == cast(real)r2.im))
         return 1;
-    
+
     if (isnan(r1a))
         return cast(bool)isnan(r2b);
 
@@ -2109,3 +2365,522 @@
 
     return feq(r1a, r2b, 0.000001L);
 }
+
+/// Small unsigned integers to strings.
+T to(T, S)(S value) if (isIntegral!S && S.min == 0
+        && S.sizeof < uint.sizeof && isSomeString!T)
+{
+    return to!T(cast(uint) value);
+}
+
+/// Small signed integers to strings.
+T to(T, S)(S value) if (isIntegral!S && S.min < 0
+        && S.sizeof < int.sizeof && isSomeString!T)
+{
+    return to!T(cast(int) value);
+}
+
+/// Unsigned integers (uint and ulong).
+T to(T, S)(S input)
+if (indexOf!(Unqual!S, uint, ulong) >= 0 && isSomeString!T)
+{
+    Unqual!S value = input;
+    alias Unqual!(ElementType!T) Char;
+    if (value < 10)
+    {
+        static invariant Char[10] digits = "0123456789";
+        // Avoid storage allocation for simple stuff
+        return digits[cast(size_t) value .. cast(size_t) value + 1];
+    }
+
+    static if (S.sizeof == uint.sizeof)
+        enum maxlength = S.sizeof * 3;
+    else
+        auto maxlength = (value > uint.max ? S.sizeof : uint.sizeof) * 3;
+    
+    auto result = cast(Char[])
+        GC.malloc(Char.sizeof * maxlength, GC.BlkAttr.NO_SCAN)
+        [0 .. maxlength];
+
+    uint ndigits = 0;
+    while (value)
+    {
+        const c = cast(Char) ((value % 10) + '0');
+        value /= 10;
+        ndigits++;
+        result[$ - ndigits] = c;
+    }
+    return cast(T) result[$ - ndigits .. $];
+}
+
+/// $(D char), $(D wchar), $(D dchar) to a string type.
+T to(T, S)(S c) if (indexOf!(Unqual!S, char, wchar, dchar) >= 0
+        && isSomeString!(T))
+{
+    static if (ElementType!T.sizeof >= S.sizeof)
+    {
+        return [ c ];
+    }
+    else
+    {
+        Unqual!(ElementType!T)[] result;
+        encode(result, cast(dchar) c);
+        return cast(T) result;
+    }
+}
+
+version(unittest) private alias TypeTuple!(
+    char, wchar, dchar,
+    const(char), const(wchar), const(dchar),
+    invariant(char), invariant(wchar), invariant(dchar))
+                      AllChars;
+
+unittest
+{
+    foreach (Char1; AllChars)
+    {
+        foreach (Char2; AllChars)
+        {
+            Char1 c = 'a';
+            assert(to!(Char2[])(c)[0] == c);
+        }
+    }
+}
+
+/// Signed values ($(D int) and $(D long)).
+T to(T, S)(S value) if (indexOf!(Unqual!S, int, long) >= 0 && isSomeString!T)
+{
+    if (value >= 0)
+        return to!T(cast(Unsigned!(S)) value);
+
+    alias Unqual!(ElementType!T) Char;
+    Char[1 + S.sizeof * 3] buffer;
+    Char[] result;
+
+    ulong u = cast(ulong)(-value);
+    int ndigits = 1;
+    while (u)
+    {
+        char c = cast(char)((u % 10) + '0');
+        u /= 10;
+        buffer[buffer.length - ndigits] = c;
+        ndigits++;
+    }
+    buffer[buffer.length - ndigits] = '-';
+    result = new Char[ndigits];
+    result[] = buffer[buffer.length - ndigits .. buffer.length];
+    return cast(T) result;
+}
+
+unittest
+{
+    string r;
+    int i;
+
+    r = to!string(0L);
+    i = cmp(r, "0");
+    assert(i == 0);
+
+    r = to!string(9L);
+    i = cmp(r, "9");
+    assert(i == 0);
+
+    r = to!string(123L);
+    i = cmp(r, "123");
+    assert(i == 0);
+
+    r = to!string(-0L);
+    i = cmp(r, "0");
+    assert(i == 0);
+
+    r = to!string(-9L);
+    i = cmp(r, "-9");
+    assert(i == 0);
+
+    r = to!string(-123L);
+    i = cmp(r, "-123");
+    assert(i == 0);
+}
+
+/// C-style strings
+T to(T, S)(S s) if (is(S : const(char)*) && isSomeString!(T))
+{
+    //if (s) writeln("cacat ", s[0 .. strlen(s)]);
+    return s ? cast(T) s[0 .. strlen(s)].dup : cast(string)null;
+}
+
+/// $(D float) to all string types.
+T to(T, S)(S f) if (is(Unqual!S == float) && isSomeString!(T))
+{
+    return to!T(cast(double) f);
+}
+
+/// $(D double) to all string types.
+T to(T, S)(S d) if (is(Unqual!S == double) && isSomeString!(T))
+{
+    //alias Unqual!(ElementType!T) Char;
+    char[20] buffer;
+    int len = sprintf(buffer.ptr, "%g", d);
+    return to!T(buffer[0 .. len].dup);
+}
+
+/// $(D real) to all string types.
+T to(T, S)(S r) if (is(Unqual!S == real) && isSomeString!(T))
+{
+    char[20] buffer;
+    int len = sprintf(buffer.ptr, "%Lg", r);
+    return to!T(buffer[0 .. len].dup);
+}
+
+/// $(D ifloat) to all string types.
+T to(T, S)(S f) if (is(Unqual!S == ifloat) && isSomeString!(T))
+{
+    return to!T(cast(idouble) f);
+}
+
+/// $(D idouble) to all string types.
+T to(T, S)(S d) if (is(Unqual!S == idouble) && isSomeString!(T))
+{
+    char[21] buffer;
+    int len = sprintf(buffer.ptr, "%gi", d);
+    return to!T(buffer[0 .. len].dup);
+}
+
+/// $(D ireal) to all string types.
+T to(T, S)(S r) if (is(Unqual!S == ireal) && isSomeString!(T))
+{
+    char[21] buffer;
+    int len = sprintf(buffer.ptr, "%Lgi", r);
+    //assert(len < buffer.length); // written bytes is len + 1
+    return to!T(buffer[0 .. len].dup);
+}
+
+/// $(D cfloat) to all string types.
+T to(T, S)(S f) if (is(Unqual!S == cfloat) && isSomeString!(T))
+{
+    return to!string(cast(cdouble) f);
+}
+
+/// $(D cdouble) to all string types.
+T to(T, S)(S d) if (is(Unqual!S == cdouble) && isSomeString!(T))
+{
+    char[20 + 1 + 20 + 1] buffer;
+
+    int len = sprintf(buffer.ptr, "%g+%gi", d.re, d.im);
+    return to!T(buffer[0 .. len]);
+}
+
+/// $(D creal) to all string types.
+T to(T, S)(S r) if (is(Unqual!S == creal) && isSomeString!(T))
+{
+    char[20 + 1 + 20 + 1] buffer;
+    int len = sprintf(buffer.ptr, "%Lg+%Lgi", r.re, r.im);
+    return to!T(buffer[0 .. len].dup);
+}
+
+/******************************************
+ * Convert value to string in _radix radix.
+ *
+ * radix must be a value from 2 to 36.
+ * value is treated as a signed value only if radix is 10.
+ * The characters A through Z are used to represent values 10 through 36.
+ */
+T to(T, S)(S value, uint radix)
+if (indexOf!(Unqual!S, int, long) >= 0 && isSomeString!(T))
+in
+{
+    assert(radix >= 2 && radix <= 36);
+}
+body
+{
+    if (radix == 10)
+        return to!string(value);     // handle signed cases only for radix 10
+    return to!string(cast(ulong) value, radix);
+}
+
+/// ditto
+T to(T, S)(S value, uint radix)
+if (is(Unqual!S == ulong) && isSomeString!(T))
+in
+{
+    assert(radix >= 2 && radix <= 36);
+}
+body
+{
+    char[value.sizeof * 8] buffer;
+    uint i = buffer.length;
+    
+    if (value < radix && value < hexdigits.length)
+        return hexdigits[cast(size_t)value .. cast(size_t)value + 1];
+    
+    do
+    {
+        ubyte c;
+        c = cast(ubyte)(value % radix);
+        value = value / radix;
+        i--;
+        buffer[i] = cast(char)((c < 10) ? c + '0' : c + 'A' - 10);
+    } while (value);
+    return to!T(buffer[i .. length].dup);
+}
+
+unittest
+{
+    debug(string) printf("string.toString(ulong, uint).unittest\n");
+
+    string r;
+    int i;
+
+    r = to!string(-10L, 10u);
+    assert(r == "-10");
+
+    r = to!string(15L, 2u);
+    //writefln("r = '%s'", r);
+    assert(r == "1111");
+
+    r = to!string(1L, 2u);
+    //writefln("r = '%s'", r);
+    assert(r == "1");
+
+    r = to!string(0x1234AFL, 16u);
+    //writefln("r = '%s'", r);
+    assert(r == "1234AF");
+}
+
+unittest
+{
+    debug(string) printf("string.toString(char).unittest\n");
+
+    string s = "foo";
+    string s2;
+    foreach (char c; s)
+    {
+        s2 ~= to!string(c);
+    }
+    //printf("%.*s", s2);
+    assert(s2 == "foo");
+}
+
+unittest
+{
+    debug(string) printf("string.toString(uint).unittest\n");
+
+    string r;
+    int i;
+
+    r = to!string(0u);
+    i = cmp(r, "0");
+    assert(i == 0);
+
+    r = to!string(9u);
+    i = cmp(r, "9");
+    assert(i == 0);
+
+    r = to!string(123u);
+    i = cmp(r, "123");
+    assert(i == 0);
+}
+
+unittest
+{
+    debug(string) printf("string.toString(ulong).unittest\n");
+
+    string r;
+    int i;
+
+    r = to!string(0uL);
+    i = cmp(r, "0");
+    assert(i == 0);
+
+    r = to!string(9uL);
+    i = cmp(r, "9");
+    assert(i == 0);
+
+    r = to!string(123uL);
+    i = cmp(r, "123");
+    assert(i == 0);
+}
+
+unittest
+{
+    debug(string) printf("string.toString(int).unittest\n");
+
+    string r;
+    int i;
+
+    r = to!string(0);
+    i = cmp(r, "0");
+    assert(i == 0);
+
+    r = to!string(9);
+    i = cmp(r, "9");
+    assert(i == 0);
+
+    r = to!string(123);
+    i = cmp(r, "123");
+    assert(i == 0);
+
+    r = to!string(-0);
+    i = cmp(r, "0");
+    assert(i == 0);
+
+    r = to!string(-9);
+    i = cmp(r, "-9");
+    assert(i == 0);
+
+    r = to!string(-123);
+    i = cmp(r, "-123");
+    assert(i == 0);
+}
+
+unittest
+{
+    debug(string) printf("string.toString(long).unittest\n");
+
+    string r;
+    int i;
+
+    r = to!string(0L);
+    i = cmp(r, "0");
+    assert(i == 0);
+
+    r = to!string(9L);
+    i = cmp(r, "9");
+    assert(i == 0);
+
+    r = to!string(123L);
+    i = cmp(r, "123");
+    assert(i == 0);
+
+    r = to!string(-0L);
+    i = cmp(r, "0");
+    assert(i == 0);
+
+    r = to!string(-9L);
+    i = cmp(r, "-9");
+    assert(i == 0);
+
+    r = to!string(-123L);
+    i = cmp(r, "-123");
+    assert(i == 0);
+}
+unittest
+{
+    debug(string) printf("string.to!string(ulong, uint).unittest\n");
+
+    string r;
+    int i;
+
+    r = to!string(-10L, 10u);
+    assert(r == "-10");
+
+    r = to!string(15L, 2u);
+    //writefln("r = '%s'", r);
+    assert(r == "1111");
+
+    r = to!string(1L, 2u);
+    //writefln("r = '%s'", r);
+    assert(r == "1");
+
+    r = to!string(0x1234AFL, 16u);
+    //writefln("r = '%s'", r);
+    assert(r == "1234AF");
+}
+
+unittest
+{
+    debug(string) printf("string.to!string(char*).unittest\n");
+
+    string r;
+    int i;
+
+    r = to!string(cast(char*) null);
+    i = cmp(r, "");
+    assert(i == 0);
+
+    r = to!string("foo\0".ptr);
+    i = cmp(r, "foo");
+    assert(i == 0);
+}
+
+unittest
+{
+    string s = "foo";
+    string s2;
+    foreach (char c; s)
+    {
+        s2 ~= to!string(c);
+    }
+    //printf("%.*s", s2);
+    assert(s2 == "foo");
+}
+
+unittest
+{
+    string r;
+    int i;
+
+    r = to!string(0uL);
+    i = cmp(r, "0");
+    assert(i == 0);
+
+    r = to!string(9uL);
+    i = cmp(r, "9");
+    assert(i == 0);
+
+    r = to!string(123uL);
+    i = cmp(r, "123");
+    assert(i == 0);
+}
+
+unittest
+{
+    string r;
+    int i;
+
+    r = to!string(0u);
+    i = cmp(r, "0");
+    assert(i == 0);
+
+    r = to!string(9u);
+    i = cmp(r, "9");
+    assert(i == 0);
+
+    r = to!string(123u);
+    i = cmp(r, "123");
+    assert(i == 0);
+}
+
+private S textImpl(S, U...)(U args)
+{
+    S result;
+    foreach (i, arg; args)
+    {
+        result ~= to!(S)(args[i]);
+    }
+    return result;
+}
+
+/**
+   Convenience functions for converting any number and types of arguments
+   into text (the three character widths).
+
+   Example:
+   ----
+   assert(text(42, ' ', 1.5, ": xyz") == "42 1.5: xyz");
+   assert(wtext(42, ' ', 1.5, ": xyz") == "42 1.5: xyz"w);
+   assert(dtext(42, ' ', 1.5, ": xyz") == "42 1.5: xyz"d);
+   ----
+*/
+string text(T...)(T args) { return textImpl!(string, T)(args); }
+///ditto
+// wstring wtext(T...)(T args) { return textImpl!(wstring, T)(args); }
+// ///ditto
+// dstring dtext(T...)(T args) { return textImpl!(dstring, T)(args); }
+
+unittest
+{
+    // assert(text(42, ' ', 1.5, ": xyz") == "42 1.5: xyz");
+    // assert(wtext(42, ' ', 1.5, ": xyz") == "42 1.5: xyz"w);
+    // assert(dtext(42, ' ', 1.5, ": xyz") == "42 1.5: xyz"d);
+}
diff -r f12bfe124807 d/phobos2/std/cpuid.d
--- a/d/phobos2/std/cpuid.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/cpuid.d	Thu Oct 14 14:12:53 2010 +0100
@@ -36,15 +36,10 @@
  *	COPYRIGHT = Public Domain
  */
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, November 2006
-*/
-
 module std.cpuid;
 
 import std.string;
+import std.conv;
 
 version(D_InlineAsm_X86)
 {
@@ -232,14 +227,12 @@
 	// puts the vendor string into dst
 	asm
 	{
-	    push EBX                    ;
 	    mov EAX, 0			;
 	    cpuid			;
 	    mov EAX, dst		;
 	    mov [EAX], EBX		;
 	    mov [EAX+4], EDX		;
 	    mov [EAX+8], ECX		;
-	    db 0x5b  /* pop EBX */      ;
 	}
     }
 
@@ -250,7 +243,6 @@
 	// puts the processor string into dst
 	asm
 	{
-	    push EBX                    ;
 	    mov EAX, 0x8000_0000	;
 	    cpuid			;
 	    cmp EAX, 0x8000_0004	;
@@ -277,14 +269,13 @@
 	    mov [EDI+44], EDX		;
 	    pop EDI			;
 	PSLabel:			;
-	    db 0x5b  /* pop EBX */      ;
 	}
 
 	if (buffer[0] == char.init) // no support
 	    return;
 
 	// seems many intel processors prepend whitespace
-	processorStr = std.string.strip(std.string.toString(dst)).idup;
+	processorStr = std.string.strip(to!string(dst)).idup;
     }
 
     private void getFeatureFlags()
@@ -292,7 +283,6 @@
 	uint f,m,e,a,s;
 	asm
 	{
-	    push EBX                    ;
 	    mov EAX, 0			;
 	    cpuid			;
 	    cmp EAX, 1			;
@@ -314,7 +304,6 @@
 	    mov e, EDX			;
 
 	FeatLabel2:
-	    db 0x5b  /* pop EBX */      ;
 	    ;
 	}
 	flags = f;
@@ -330,7 +319,6 @@
 	ubyte b = 0;
 	asm
 	{
-	    push EBX                    ;
 	    mov EAX, 0			;
 	    cpuid			;
 	    cmp EAX, 4			;
@@ -341,7 +329,6 @@
 	    mov n, EAX			;
 	    mov b, 1			;
 	IntelSingle:			;
-	    db 0x5b  /* pop EBX */      ;
 	}
 	if (b != 0)
 	{
@@ -360,7 +347,6 @@
 	ubyte b = 0;
 	asm
 	{
-	    push EBX                    ;
 	    mov EAX, 0x8000_0000	;
 	    cpuid			;
 	    cmp EAX, 0x8000_0008	;
@@ -370,7 +356,6 @@
 	    mov n, CL			;
 	    mov b, 1			;
 	AMDSingle:			;
-	    db 0x5b  /* pop EBX */      ;
 	}
 	if (b != 0)
 	{
diff -r f12bfe124807 d/phobos2/std/cstream.d
--- a/d/phobos2/std/cstream.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/cstream.d	Thu Oct 14 14:12:53 2010 +0100
@@ -13,6 +13,7 @@
 
 import std.stream;
 import std.c.stdio;
+version(unittest) import std.stdio;
 
 /**
  * A Stream wrapper for a C file of type FILE*.
@@ -145,9 +146,9 @@
     file.write(i);
     // string#1 + string#2 + int should give exacly that
     version (Win32)
-      assert(file.position() == 19 + 13 + 4);
+        assert(file.position() == 19 + 13 + 4);
     version (Posix)
-      assert(file.position() == 18 + 13 + 4);
+        assert(file.position() == 18 + 13 + 4);
     file.close();
     // no operations are allowed when file is closed
     assert(!file.readable && !file.writeable && !file.seekable);
diff -r f12bfe124807 d/phobos2/std/date.d
--- a/d/phobos2/std/date.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/date.d	Thu Oct 14 14:12:53 2010 +0100
@@ -1,15 +1,15 @@
-
 // Written in the D programming language.
 
 /**
- * Dates are represented in several formats. The date implementation revolves
- * around a central type, d_time, from which other formats are converted to and
- * from.
- * Dates are calculated using the Gregorian calendar.
- * References:
- *	$(LINK2 http://en.wikipedia.org/wiki/Gregorian_calendar, Gregorian calendar (Wikipedia))
- * Macros:
- *	WIKI = Phobos/StdDate
+ * Dates are represented in several formats. The date implementation
+ * revolves around a central type, $(D d_time), from which other
+ * formats are converted to and from.  Dates are calculated using the
+ * Gregorian calendar.
+ *
+ * References: $(WEB wikipedia.org/wiki/Gregorian_calendar, Gregorian
+ * calendar (Wikipedia))
+ *
+ * Macros: WIKI = Phobos/StdDate
  */
 
 // Copyright (c) 1999-2008 by Digital Mars
@@ -17,115 +17,117 @@
 // written by Walter Bright
 // http://www.digitalmars.com
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, May 2005
-*/
-
 module std.date;
 
 private import std.stdio;
 private import std.dateparse;
-import std.contracts;
+import std.c.stdlib, std.contracts, std.conv;
 
 /**
- * d_time is a signed arithmetic type giving the time elapsed since January 1,
- * 1970.
- * Negative values are for dates preceding 1970. The time unit used is Ticks.
- * Ticks are milliseconds or smaller intervals.
+ * $(D d_time) is a signed arithmetic type giving the time elapsed
+ * since January 1, 1970.  Negative values are for dates preceding
+ * 1970. The time unit used is Ticks.  Ticks are milliseconds or
+ * smaller intervals.
  *
  * The usual arithmetic operations can be performed on d_time, such as adding,
  * subtracting, etc. Elapsed time in Ticks can be computed by subtracting a
- * starting d_time from an ending d_time. 
+ * starting d_time from an ending d_time.
  */
 alias long d_time;
 
 /**
  * A value for d_time that does not represent a valid time.
  */
-const d_time d_time_nan = long.min;
+enum d_time d_time_nan = long.min;
 
 /**
  * Time broken down into its components.
  */
 struct Date
 {
-    int year = int.min;	/// use int.min as "nan" year value
-    int month;		/// 1..12
-    int day;		/// 1..31
-    int hour;		/// 0..23
-    int minute;		/// 0..59
-    int second;		/// 0..59
-    int ms;		/// 0..999
-    int weekday;	/// 0: not specified, 1..7: Sunday..Saturday
-    int tzcorrection = int.min;	/// -1200..1200 correction in hours
+    int year = int.min;        /// use int.min as "nan" year value
+    int month;                /// 1..12
+    int day;                /// 1..31
+    int hour;                /// 0..23
+    int minute;                /// 0..59
+    int second;                /// 0..59
+    int ms;                /// 0..999
+    int weekday;        /// 0: not specified, 1..7: Sunday..Saturday
+    int tzcorrection = int.min;        /// -1200..1200 correction in hours
 
     /// Parse date out of string s[] and store it in this Date instance.
     void parse(string s)
     {
-	DateParse dp;
-
-	dp.parse(s, this);
+        DateParse dp;
+        dp.parse(s, this);
     }
 }
 
 enum
 {
-    HoursPerDay    = 24,
-    MinutesPerHour = 60,
+    hoursPerDay    = 24,
+    minutesPerHour = 60,
     msPerMinute    = 60 * 1000,
     msPerHour      = 60 * msPerMinute,
     msPerDay       = 86_400_000,
-    TicksPerMs     = 1,
-    TicksPerSecond = 1000,			/// Will be at least 1000
-    TicksPerMinute = TicksPerSecond * 60,
-    TicksPerHour   = TicksPerMinute * 60,
-    TicksPerDay    = TicksPerHour   * 24,
+    ticksPerMs     = 1,
+    ticksPerSecond = 1000,                        /// Will be at least 1000
+    ticksPerMinute = ticksPerSecond * 60,
+    ticksPerHour   = ticksPerMinute * 60,
+    ticksPerDay    = ticksPerHour   * 24,
 }
 
-d_time LocalTZA = 0;
+deprecated alias ticksPerSecond TicksPerSecond;
+deprecated alias ticksPerMs TicksPerMs;
+deprecated alias ticksPerMinute TicksPerMinute;
+deprecated alias ticksPerHour TicksPerHour;
+deprecated alias ticksPerDay TicksPerDay;
 
-immutable char[] daystr = "SunMonTueWedThuFriSat";
-immutable char[] monstr = "JanFebMarAprMayJunJulAugSepOctNovDec";
+unittest
+{
+    assert(ticksPerSecond == TicksPerSecond);
+}
 
-const int[12] mdays = [ 0,31,59,90,120,151,181,212,243,273,304,334 ];
+d_time localTZA = 0;
+
+private immutable char[] daystr = "SunMonTueWedThuFriSat";
+private immutable char[] monstr = "JanFebMarAprMayJunJulAugSepOctNovDec";
+
+private immutable int[12] mdays =
+    [ 0,31,59,90,120,151,181,212,243,273,304,334 ];
 
 /********************************
  * Compute year and week [1..53] from t. The ISO 8601 week 1 is the first week
  * of the year that includes January 4. Monday is the first day of the week.
  * References:
- *	$(LINK2 http://en.wikipedia.org/wiki/ISO_8601, ISO 8601 (Wikipedia))
+ *        $(LINK2 http://en.wikipedia.org/wiki/ISO_8601, ISO 8601 (Wikipedia))
  */
 
 void toISO8601YearWeek(d_time t, out int year, out int week)
 {
-    year = YearFromTime(t);
+    year = yearFromTime(t);
 
-    int yday = Day(t) - DayFromYear(year);
-    int d;
-    int w;
-    int ydaybeg;
+    auto yday = day(t) - dayFromYear(year);
 
     /* Determine day of week Jan 4 falls on.
      * Weeks begin on a Monday.
      */
 
-    d = DayFromYear(year);
-    w = (d + 3/*Jan4*/ + 3) % 7;
+    auto d = dayFromYear(year);
+    auto w = (d + 3/*Jan4*/ + 3) % 7;
     if (w < 0)
         w += 7;
 
     /* Find yday of beginning of ISO 8601 year
      */
-    ydaybeg = 3/*Jan4*/ - w;
+    auto ydaybeg = 3/*Jan4*/ - w;
 
     /* Check if yday is actually the last week of the previous year
      */
     if (yday < ydaybeg)
     {
-	year -= 1;
-	week = 53;
+        year -= 1;
+        week = 53;
         return;
     }
 
@@ -135,7 +137,7 @@
     {   int d2;
         int ydaybeg2;
 
-        d2 = DayFromYear(year + 1);
+        d2 = dayFromYear(year + 1);
         w = (d2 + 3/*Jan4*/ + 3) % 7;
         if (w < 0)
             w += 7;
@@ -143,8 +145,8 @@
         ydaybeg2 = 3/*Jan4*/ - w;
         if (d + yday >= d2 + ydaybeg2)
         {
-	    year += 1;
-	    week = 1;
+            year += 1;
+            week = 1;
             return;
         }
     }
@@ -156,11 +158,9 @@
  * Divide time by divisor. Always round down, even if d is negative.
  */
 
-d_time floor(d_time d, int divisor)
+pure d_time floor(d_time d, int divisor)
 {
-    if (d < 0)
-	d -= divisor - 1;
-    return d / divisor;
+    return (d < 0 ? d - divisor - 1 : d) / divisor;
 }
 
 int dmod(d_time n, d_time d)
@@ -168,32 +168,32 @@
 
     r = n % d;
     if (r < 0)
-	r += d;
+        r += d;
     assert(cast(int)r == r);
     return cast(int)r;
 }
 
-int HourFromTime(d_time t)
+int hourFromTime(d_time t)
 {
-    return dmod(floor(t, msPerHour), HoursPerDay);
+    return dmod(floor(t, msPerHour), hoursPerDay);
 }
 
-int MinFromTime(d_time t)
+int minFromTime(d_time t)
 {
-    return dmod(floor(t, msPerMinute), MinutesPerHour);
+    return dmod(floor(t, msPerMinute), minutesPerHour);
 }
 
-int SecFromTime(d_time t)
+int secFromTime(d_time t)
 {
-    return dmod(floor(t, TicksPerSecond), 60);
+    return dmod(floor(t, ticksPerSecond), 60);
 }
 
 int msFromTime(d_time t)
 {
-    return dmod(t / (TicksPerSecond / 1000), 1000);
+    return dmod(t / (ticksPerSecond / 1000), 1000);
 }
 
-int TimeWithinDay(d_time t)
+int timeWithinDay(d_time t)
 {
     return dmod(t, msPerDay);
 }
@@ -203,62 +203,62 @@
     return n;
 }
 
-int Day(d_time t)
+int day(d_time t)
 {
     return cast(int)floor(t, msPerDay);
 }
 
-int LeapYear(int y)
+pure bool leapYear(int y)
 {
     return ((y & 3) == 0 &&
-	    (y % 100 || (y % 400) == 0));
+            (y % 100 || (y % 400) == 0));
 }
 
-int DaysInYear(int y)
+int daysInYear(int y)
 {
-    return 365 + LeapYear(y);
+    return 365 + leapYear(y);
 }
 
-int DayFromYear(int y)
+pure int dayFromYear(int y)
 {
     return cast(int) (365 * (y - 1970) +
-		floor((y - 1969), 4) -
-		floor((y - 1901), 100) +
-		floor((y - 1601), 400));
+                floor((y - 1969), 4) -
+                floor((y - 1901), 100) +
+                floor((y - 1601), 400));
 }
 
-d_time TimeFromYear(int y)
+pure d_time timeFromYear(int y)
 {
-    return cast(d_time)msPerDay * DayFromYear(y);
+    return cast(d_time)msPerDay * dayFromYear(y);
 }
 
 /*****************************
  * Calculates the year from the d_time t.
  */
 
-int YearFromTime(d_time t)
-{   int y;
+pure int yearFromTime(d_time t)
+{
 
     if (t == d_time_nan)
-	return 0;
+        return 0;
 
     // Hazard a guess
     //y = 1970 + cast(int) (t / (365.2425 * msPerDay));
     // Use integer only math
-    y = 1970 + cast(int) (t / (3652425 * (msPerDay / 10000)));
+    int y = 1970 + cast(int) (t / (3652425 * (msPerDay / 10000)));
 
-    if (TimeFromYear(y) <= t)
+    if (timeFromYear(y) <= t)
     {
-	while (TimeFromYear(y + 1) <= t)
-	    y++;
+        while (timeFromYear(y + 1) <= t)
+            y++;
     }
     else
     {
-	do
-	{
-	    y--;
-	}
-	while (TimeFromYear(y) > t);
+        do
+        {
+            y--;
+        }
+        while (timeFromYear(y) > t);
     }
     return y;
 }
@@ -272,72 +272,69 @@
  * Returns: !=0 if it is a leap year.
  *
  * References:
- *	$(LINK2 http://en.wikipedia.org/wiki/Leap_year, Wikipedia)
+ *        $(LINK2 http://en.wikipedia.org/wiki/Leap_year, Wikipedia)
  */
 
-int inLeapYear(d_time t)
+pure bool inLeapYear(d_time t)
 {
-    return LeapYear(YearFromTime(t));
+    return leapYear(yearFromTime(t));
 }
 
 /*****************************
  * Calculates the month from the d_time t.
  *
  * Returns: Integer in the range 0..11, where
- *	0 represents January and 11 represents December.
+ *        0 represents January and 11 represents December.
  */
 
-int MonthFromTime(d_time t)
+int monthFromTime(d_time t)
 {
-    int day;
+    auto year = yearFromTime(t);
+    auto day = day(t) - dayFromYear(year);
+
     int month;
-    int year;
-
-    year = YearFromTime(t);
-    day = Day(t) - DayFromYear(year);
-
     if (day < 59)
     {
-	if (day < 31)
-	{   assert(day >= 0);
-	    month = 0;
-	}
-	else
-	    month = 1;
+        if (day < 31)
+        {   assert(day >= 0);
+            month = 0;
+        }
+        else
+            month = 1;
     }
     else
     {
-	day -= LeapYear(year);
-	if (day < 212)
-	{
-	    if (day < 59)
-		month = 1;
-	    else if (day < 90)
-		month = 2;
-	    else if (day < 120)
-		month = 3;
-	    else if (day < 151)
-		month = 4;
-	    else if (day < 181)
-		month = 5;
-	    else
-		month = 6;
-	}
-	else
-	{
-	    if (day < 243)
-		month = 7;
-	    else if (day < 273)
-		month = 8;
-	    else if (day < 304)
-		month = 9;
-	    else if (day < 334)
-		month = 10;
-	    else if (day < 365)
-		month = 11;
-	    else
-		assert(0);
-	}
+        day -= leapYear(year);
+        if (day < 212)
+        {
+            if (day < 59)
+                month = 1;
+            else if (day < 90)
+                month = 2;
+            else if (day < 120)
+                month = 3;
+            else if (day < 151)
+                month = 4;
+            else if (day < 181)
+                month = 5;
+            else
+                month = 6;
+        }
+        else
+        {
+            if (day < 243)
+                month = 7;
+            else if (day < 273)
+                month = 8;
+            else if (day < 304)
+                month = 9;
+            else if (day < 334)
+                month = 10;
+            else if (day < 365)
+                month = 11;
+            else
+                assert(0);
+        }
     }
     return month;
 }
@@ -345,36 +342,31 @@
 /*******************************
  * Compute which day in a month a d_time t is.
  * Returns:
- *	Integer in the range 1..31
+ *        Integer in the range 1..31
  */
-int DateFromTime(d_time t)
+int dateFromTime(d_time t)
 {
-    int day;
-    int leap;
-    int month;
-    int year;
+    auto year = yearFromTime(t);
+    auto day = day(t) - dayFromYear(year);
+    auto leap = leapYear(year);
+    auto month = monthFromTime(t);
     int date;
-
-    year = YearFromTime(t);
-    day = Day(t) - DayFromYear(year);
-    leap = LeapYear(year);
-    month = MonthFromTime(t);
     switch (month)
     {
-	case 0:	 date = day +   1;		break;
-	case 1:	 date = day -  30;		break;
-	case 2:	 date = day -  58 - leap;	break;
-	case 3:	 date = day -  89 - leap;	break;
-	case 4:	 date = day - 119 - leap;	break;
-	case 5:	 date = day - 150 - leap;	break;
-	case 6:	 date = day - 180 - leap;	break;
-	case 7:	 date = day - 211 - leap;	break;
-	case 8:	 date = day - 242 - leap;	break;
-	case 9:	 date = day - 272 - leap;	break;
-	case 10: date = day - 303 - leap;	break;
-	case 11: date = day - 333 - leap;	break;
-	default:
-	    assert(0);
+        case 0:         date = day +   1;                break;
+        case 1:         date = day -  30;                break;
+        case 2:         date = day -  58 - leap;        break;
+        case 3:         date = day -  89 - leap;        break;
+        case 4:         date = day - 119 - leap;        break;
+        case 5:         date = day - 150 - leap;        break;
+        case 6:         date = day - 180 - leap;        break;
+        case 7:         date = day - 211 - leap;        break;
+        case 8:         date = day - 242 - leap;        break;
+        case 9:         date = day - 272 - leap;        break;
+        case 10: date = day - 303 - leap;        break;
+        case 11: date = day - 333 - leap;        break;
+        default:
+            assert(0);
     }
     return date;
 }
@@ -382,15 +374,14 @@
 /*******************************
  * Compute which day of the week a d_time t is.
  * Returns:
- *	Integer in the range 0..6, where 0 represents Sunday
- *	and 6 represents Saturday.
+ *        Integer in the range 0..6, where 0 represents Sunday
+ *        and 6 represents Saturday.
  */
-int WeekDay(d_time t)
-{   int w;
-
-    w = (cast(int)Day(t) + 4) % 7;
+int weekDay(d_time t)
+{
+    auto w = (cast(int)day(t) + 4) % 7;
     if (w < 0)
-	w += 7;
+        w += 7;
     return w;
 }
 
@@ -401,74 +392,70 @@
 d_time UTCtoLocalTime(d_time t)
 {
     return (t == d_time_nan)
-	? d_time_nan
-	: t + LocalTZA + DaylightSavingTA(t);
+        ? d_time_nan
+        : t + localTZA + daylightSavingTA(t);
 }
 
 /***********************************
  * Convert from local time to UTC.
  */
 
-d_time LocalTimetoUTC(d_time t)
+d_time localTimetoUTC(d_time t)
 {
     return (t == d_time_nan)
-	? d_time_nan
+        ? d_time_nan
 /* BUGZILLA 1752 says this line should be:
- *	: t - LocalTZA - DaylightSavingTA(t);
+ *        : t - localTZA - daylightSavingTA(t);
  */
-	: t - LocalTZA - DaylightSavingTA(t - LocalTZA);
+        : t - localTZA - daylightSavingTA(t - localTZA);
 }
 
 
-d_time MakeTime(d_time hour, d_time min, d_time sec, d_time ms)
+d_time makeTime(d_time hour, d_time min, d_time sec, d_time ms)
 {
-    return hour * TicksPerHour +
-	   min * TicksPerMinute +
-	   sec * TicksPerSecond +
-	   ms * TicksPerMs;
+    return hour * ticksPerHour +
+           min * ticksPerMinute +
+           sec * ticksPerSecond +
+           ms * ticksPerMs;
 }
 
 /* *****************************
  * Params:
- *	month = 0..11
- *	date = day of month, 1..31
+ *        month = 0..11
+ *        date = day of month, 1..31
  * Returns:
- *	number of days since start of epoch
+ *        number of days since start of epoch
  */
 
-d_time MakeDay(d_time year, d_time month, d_time date)
-{   d_time t;
-    int y;
-    int m;
-    int leap;
+d_time makeDay(d_time year, d_time month, d_time date)
+{
+    const y = cast(int)(year + floor(month, 12));
+    const m = dmod(month, 12);
 
-    y = cast(int)(year + floor(month, 12));
-    m = dmod(month, 12);
+    const leap = leapYear(y);
+    auto t = timeFromYear(y) + cast(d_time) mdays[m] * msPerDay;
+    if (leap && month >= 2)
+        t += msPerDay;
 
-    leap = LeapYear(y);
-    t = TimeFromYear(y) + cast(d_time)mdays[m] * msPerDay;
-    if (leap && month >= 2)
-	t += msPerDay;
-
-    if (YearFromTime(t) != y ||
-	MonthFromTime(t) != m ||
-	DateFromTime(t) != 1)
+    if (yearFromTime(t) != y ||
+        monthFromTime(t) != m ||
+        dateFromTime(t) != 1)
     {
-	return  d_time_nan;
+        return  d_time_nan;
     }
 
-    return Day(t) + date - 1;
+    return day(t) + date - 1;
 }
 
-d_time MakeDate(d_time day, d_time time)
+d_time makeDate(d_time day, d_time time)
 {
     if (day == d_time_nan || time == d_time_nan)
-	return d_time_nan;
+        return d_time_nan;
 
-    return day * TicksPerDay + time;
+    return day * ticksPerDay + time;
 }
 
-d_time TimeClip(d_time time)
+d_time timeClip(d_time time)
 {
     //printf("TimeClip(%g) = %g\n", time, toInteger(time));
 
@@ -479,16 +466,16 @@
  * Determine the date in the month, 1..31, of the nth
  * weekday.
  * Params:
- *	year = year
- *	month = month, 1..12
- *	weekday = day of week 0..6 representing Sunday..Saturday
- *	n = nth occurrence of that weekday in the month, 1..5, where
- *	    5 also means "the last occurrence in the month"
+ *        year = year
+ *        month = month, 1..12
+ *        weekday = day of week 0..6 representing Sunday..Saturday
+ *        n = nth occurrence of that weekday in the month, 1..5, where
+ *            5 also means "the last occurrence in the month"
  * Returns:
- *	the date in the month, 1..31, of the nth weekday
+ *        the date in the month, 1..31, of the nth weekday
  */
 
-int DateFromNthWeekdayOfMonth(int year, int month, int weekday, int n)
+int dateFromNthWeekdayOfMonth(int year, int month, int weekday, int n)
 in
 {
     assert(1 <= month && month <= 12);
@@ -498,24 +485,24 @@
 body
 {
     // Get day of the first of the month
-    auto x = MakeDay(year, month - 1, 1);
+    auto x = makeDay(year, month - 1, 1);
 
     // Get the week day 0..6 of the first of this month
-    auto wd = WeekDay(MakeDate(x, 0));
+    auto wd = weekDay(makeDate(x, 0));
 
     // Get monthday of first occurrence of weekday in this month
     auto mday = weekday - wd + 1;
     if (mday < 1)
-	mday += 7;
+        mday += 7;
 
     // Add in number of weeks
     mday += (n - 1) * 7;
 
     // If monthday is more than the number of days in the month,
     // back up to 'last' occurrence
-    if (mday > 28 && mday > DaysInMonth(year, month))
-    {	assert(n == 5);
-	mday -= 7;
+    if (mday > 28 && mday > daysInMonth(year, month))
+    {        assert(n == 5);
+        mday -= 7;
     }
 
     return mday;
@@ -523,46 +510,47 @@
 
 unittest
 {
-    assert(DateFromNthWeekdayOfMonth(2003,  3, 0, 5) == 30);
-    assert(DateFromNthWeekdayOfMonth(2003, 10, 0, 5) == 26);
-    assert(DateFromNthWeekdayOfMonth(2004,  3, 0, 5) == 28);
-    assert(DateFromNthWeekdayOfMonth(2004, 10, 0, 5) == 31);
+    assert(dateFromNthWeekdayOfMonth(2003,  3, 0, 5) == 30);
+    assert(dateFromNthWeekdayOfMonth(2003, 10, 0, 5) == 26);
+    assert(dateFromNthWeekdayOfMonth(2004,  3, 0, 5) == 28);
+    assert(dateFromNthWeekdayOfMonth(2004, 10, 0, 5) == 31);
 }
 
 /**************************************
  * Determine the number of days in a month, 1..31.
  * Params:
- *	month = 1..12
+ *        month = 1..12
  */
 
-int DaysInMonth(int year, int month)
+int daysInMonth(int year, int month)
 {
     switch (month)
     {
-	case 1:
-	case 3:
-	case 5:
-	case 7:
-	case 8:
-	case 10:
-	case 12:
-	    return 31;
-	case 2:
-	    return 28 + LeapYear(year);
-	case 4:
-	case 6:
-	case 9:
-	case 11:
-	    return 30;
-	default:
-	    assert(0);
+        case 1:
+        case 3:
+        case 5:
+        case 7:
+        case 8:
+        case 10:
+        case 12:
+            return 31;
+        case 2:
+            return 28 + leapYear(year);
+        case 4:
+        case 6:
+        case 9:
+        case 11:
+            return 30;
+    default:
+        break;
     }
+    return enforce(false, "Invalid month passed to daysInMonth");
 }
 
 unittest
 {
-    assert(DaysInMonth(2003, 2) == 28);
-    assert(DaysInMonth(2004, 2) == 29);
+    assert(daysInMonth(2003, 2) == 28);
+    assert(daysInMonth(2004, 2) == 29);
 }
 
 /*************************************
@@ -586,45 +574,38 @@
 
 string toString(d_time time)
 {
-    d_time t;
-    char sign;
-    int hr;
-    int mn;
-    int len;
-    d_time offset;
-    d_time dst;
-
     // Years are supposed to be -285616 .. 285616, or 7 digits
     // "Tue Apr 02 02:04:57 GMT-0800 1996"
-    char[] buffer = new char[29 + 7 + 1];
+    auto buffer = new char[29 + 7 + 1];
 
     if (time == d_time_nan)
-	return "Invalid Date";
+        return "Invalid Date";
 
-    dst = DaylightSavingTA(time);
-    offset = LocalTZA + dst;
-    t = time + offset;
-    sign = '+';
+    auto dst = daylightSavingTA(time);
+    auto offset = localTZA + dst;
+    auto t = time + offset;
+    auto sign = '+';
     if (offset < 0)
-    {	sign = '-';
-//	offset = -offset;
-	offset = -(LocalTZA + dst);
+    {        sign = '-';
+//        offset = -offset;
+        offset = -(localTZA + dst);
     }
 
-    mn = cast(int)(offset / msPerMinute);
-    hr = mn / 60;
+    auto mn = cast(int)(offset / msPerMinute);
+    auto hr = mn / 60;
     mn %= 60;
 
-    //printf("hr = %d, offset = %g, LocalTZA = %g, dst = %g, + = %g\n", hr, offset, LocalTZA, dst, LocalTZA + dst);
+    //printf("hr = %d, offset = %g, localTZA = %g, dst = %g, + = %g\n", hr, offset, localTZA, dst, localTZA + dst);
 
-    len = sprintf(buffer.ptr, "%.3s %.3s %02d %02d:%02d:%02d GMT%c%02d%02d %d",
-	&daystr[WeekDay(t) * 3],
-	&monstr[MonthFromTime(t) * 3],
-	DateFromTime(t),
-	HourFromTime(t), MinFromTime(t), SecFromTime(t),
-	sign, hr, mn,
-	/*cast(long)*/YearFromTime(t));
-
+    auto len = sprintf(buffer.ptr,
+            "%.3s %.3s %02d %02d:%02d:%02d GMT%c%02d%02d %d",
+            &daystr[weekDay(t) * 3],
+            &monstr[monthFromTime(t) * 3],
+            dateFromTime(t),
+            hourFromTime(t), minFromTime(t), secFromTime(t),
+            sign, hr, mn,
+            cast(long)yearFromTime(t));
+    
     // Ensure no buggy buffer overflows
     //printf("len = %d, buffer.length = %d\n", len, buffer.length);
     assert(len < buffer.length);
@@ -641,21 +622,20 @@
 {
     // Years are supposed to be -285616 .. 285616, or 7 digits
     // "Tue, 02 Apr 1996 02:04:57 GMT"
-    char[] buffer = new char[25 + 7 + 1];
-    int len;
+    auto buffer = new char[25 + 7 + 1];
 
     if (t == d_time_nan)
-	return "Invalid Date";
+        return "Invalid Date";
 
-    len = sprintf(buffer.ptr, "%.3s, %02d %.3s %d %02d:%02d:%02d UTC",
-	&daystr[WeekDay(t) * 3], DateFromTime(t),
-	&monstr[MonthFromTime(t) * 3],
-	YearFromTime(t),
-	HourFromTime(t), MinFromTime(t), SecFromTime(t));
-
+    auto len = sprintf(buffer.ptr, "%.3s, %02d %.3s %d %02d:%02d:%02d UTC",
+            &daystr[weekDay(t) * 3], dateFromTime(t),
+            &monstr[monthFromTime(t) * 3],
+            yearFromTime(t),
+            hourFromTime(t), minFromTime(t), secFromTime(t));
+    
     // Ensure no buggy buffer overflows
     assert(len < buffer.length);
-
+    
     return cast(string) buffer[0 .. len];
 }
 
@@ -667,27 +647,22 @@
 
 string toDateString(d_time time)
 {
-    d_time t;
-    d_time offset;
-    d_time dst;
-    int len;
-
     // Years are supposed to be -285616 .. 285616, or 7 digits
     // "Tue Apr 02 1996"
-    char[] buffer = new char[29 + 7 + 1];
+    auto buffer = new char[29 + 7 + 1];
 
     if (time == d_time_nan)
-	return "Invalid Date";
+        return "Invalid Date";
 
-    dst = DaylightSavingTA(time);
-    offset = LocalTZA + dst;
-    t = time + offset;
+    auto dst = daylightSavingTA(time);
+    auto offset = localTZA + dst;
+    auto t = time + offset;
 
-    len = sprintf(buffer.ptr, "%.3s %.3s %02d %d",
-	&daystr[WeekDay(t) * 3],
-	&monstr[MonthFromTime(t) * 3],
-	DateFromTime(t),
-	/*cast(long)*/YearFromTime(t));
+    auto len = sprintf(buffer.ptr, "%.3s %.3s %02d %d",
+        &daystr[weekDay(t) * 3],
+        &monstr[monthFromTime(t) * 3],
+        dateFromTime(t),
+        cast(long)yearFromTime(t));
 
     // Ensure no buggy buffer overflows
     assert(len < buffer.length);
@@ -704,39 +679,31 @@
 
 string toTimeString(d_time time)
 {
-    d_time t;
-    char sign;
-    int hr;
-    int mn;
-    int len;
-    d_time offset;
-    d_time dst;
-
     // "02:04:57 GMT-0800"
-    char[] buffer = new char[17 + 1];
+    auto buffer = new char[17 + 1];
 
     if (time == d_time_nan)
-	return "Invalid Date";
+        return "Invalid Date";
 
-    dst = DaylightSavingTA(time);
-    offset = LocalTZA + dst;
-    t = time + offset;
-    sign = '+';
+    auto dst = daylightSavingTA(time);
+    auto offset = localTZA + dst;
+    auto t = time + offset;
+    auto sign = '+';
     if (offset < 0)
-    {	sign = '-';
-//	offset = -offset;
-	offset = -(LocalTZA + dst);
+    {        sign = '-';
+//        offset = -offset;
+        offset = -(localTZA + dst);
     }
 
-    mn = cast(int)(offset / msPerMinute);
-    hr = mn / 60;
+    auto mn = cast(int)(offset / msPerMinute);
+    auto hr = mn / 60;
     mn %= 60;
 
-    //printf("hr = %d, offset = %g, LocalTZA = %g, dst = %g, + = %g\n", hr, offset, LocalTZA, dst, LocalTZA + dst);
+    //printf("hr = %d, offset = %g, localTZA = %g, dst = %g, + = %g\n", hr, offset, localTZA, dst, localTZA + dst);
 
-    len = sprintf(buffer.ptr, "%02d:%02d:%02d GMT%c%02d%02d",
-	HourFromTime(t), MinFromTime(t), SecFromTime(t),
-	sign, hr, mn);
+    auto len = sprintf(buffer.ptr, "%02d:%02d:%02d GMT%c%02d%02d",
+        hourFromTime(t), minFromTime(t), secFromTime(t),
+        sign, hr, mn);
 
     // Ensure no buggy buffer overflows
     assert(len < buffer.length);
@@ -747,53 +714,42 @@
 
 
 /******************************************
- * Parses s as a textual date string, and returns it as a d_time.
- * If the string is not a valid date, d_time_nan is returned.
+ * Parses s as a textual date string, and returns it as a d_time.  If
+ * the string is not a valid date, $(D d_time_nan) is returned.
  */
 
-/*d_time parse(string s)
+d_time parse(string s)
 {
-    Date dp;
-    d_time n;
-    d_time day;
-    d_time time;
-
     try
     {
-	dp.parse(s);
-
-	//writefln("year = %d, month = %d, day = %d", dp.year, dp.month, dp.day);
-	//writefln("%02d:%02d:%02d.%03d", dp.hour, dp.minute, dp.second, dp.ms);
-	//writefln("weekday = %d, ampm = %d, tzcorrection = %d", dp.weekday, 1, dp.tzcorrection);
-
-	time = MakeTime(dp.hour, dp.minute, dp.second, dp.ms);
-	if (dp.tzcorrection == int.min)
-	    time -= LocalTZA;
-	else
-	{
-	    time += cast(d_time)(dp.tzcorrection / 100) * msPerHour +
-		    cast(d_time)(dp.tzcorrection % 100) * msPerMinute;
-	}
-	day = MakeDay(dp.year, dp.month - 1, dp.day);
-	n = MakeDate(day,time);
-	n = TimeClip(n);
+        Date dp;
+        dp.parse(s);
+        auto time = makeTime(dp.hour, dp.minute, dp.second, dp.ms);
+        if (dp.tzcorrection == int.min)
+            time -= localTZA;
+        else
+        {
+            time += cast(d_time)(dp.tzcorrection / 100) * msPerHour +
+                    cast(d_time)(dp.tzcorrection % 100) * msPerMinute;
+        }
+        auto day = makeDay(dp.year, dp.month - 1, dp.day);
+        auto result = makeDate(day,time);
+        return timeClip(result);
     }
     catch
     {
-	n =  d_time_nan;		// erroneous date string
+        return d_time_nan;                // erroneous date string
     }
-    return n;
-}*/
+}
 
-static this()
+extern(C) void std_date_static_this()
 {
-    LocalTZA = getLocalTZA();
-    //printf("LocalTZA = %g, %g\n", LocalTZA, LocalTZA / msPerHour);
+    localTZA = getLocalTZA();
+    //printf("localTZA = %g, %g\n", localTZA, localTZA / msPerHour);
 }
 
 version (Win32)
 {
-
     private import std.c.windows.windows;
     //import c.time;
 
@@ -802,220 +758,250 @@
      */
     d_time getUTCtime()
     {
-	SYSTEMTIME st;
-	d_time n;
-
-	GetSystemTime(&st);		// get time in UTC
-	n = SYSTEMTIME2d_time(&st, 0);
-	return n;
-	//return c.time.time(null) * TicksPerSecond;
+        SYSTEMTIME st;
+        GetSystemTime(&st);                // get time in UTC
+        return SYSTEMTIME2d_time(&st, 0);
+        //return c.time.time(null) * ticksPerSecond;
     }
 
     static d_time FILETIME2d_time(const FILETIME *ft)
-    {   SYSTEMTIME st;
+    {
+        SYSTEMTIME st = void;
+        if (!FileTimeToSystemTime(ft, &st))
+            return d_time_nan;
+        return SYSTEMTIME2d_time(&st, 0);
+    }
 
-	if (!FileTimeToSystemTime(ft, &st))
-	    return d_time_nan;
-	return SYSTEMTIME2d_time(&st, 0);
+    FILETIME d_time2FILETIME(d_time dt)
+    {
+        static assert(10_000_000 >= ticksPerSecond);
+        static assert(10_000_000 % ticksPerSecond == 0);
+        enum ulong ticksFrom1601To1970 = 11_644_473_600UL * ticksPerSecond;
+        ulong t = (dt + ticksFrom1601To1970) * (10_000_000 / ticksPerSecond);
+        FILETIME result = void;
+        result.dwLowDateTime = cast(uint) (t & uint.max);
+        result.dwHighDateTime = cast(uint) (t >> 32);
+        return result;
+    }
+
+    unittest
+    {
+        auto dt = getUTCtime;
+        auto ft = d_time2FILETIME(dt);
+        auto dt1 = FILETIME2d_time(&ft);
+        assert(dt == dt1, text(dt, " != ", dt1));
     }
 
     static d_time SYSTEMTIME2d_time(const SYSTEMTIME *st, d_time t)
     {
-	/* More info: http://delphicikk.atw.hu/listaz.php?id=2667&oldal=52
-	 */
-	d_time n;
-	d_time day;
-	d_time time;
+        /* More info: http://delphicikk.atw.hu/listaz.php?id=2667&oldal=52
+         */
+        d_time day = void;
+        d_time time = void;
 
-	if (st.wYear)
-	{
-	    time = MakeTime(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
-	    day = MakeDay(st.wYear, st.wMonth - 1, st.wDay);
-	}
-	else
-	{   /* wYear being 0 is a flag to indicate relative time:
-	     * wMonth is the month 1..12
-	     * wDayOfWeek is weekday 0..6 corresponding to Sunday..Saturday
-	     * wDay is the nth time, 1..5, that wDayOfWeek occurs
-	     */
+        if (st.wYear)
+        {
+            time = makeTime(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
+            day = makeDay(st.wYear, st.wMonth - 1, st.wDay);
+        }
+        else
+        {   /* wYear being 0 is a flag to indicate relative time:
+             * wMonth is the month 1..12
+             * wDayOfWeek is weekday 0..6 corresponding to Sunday..Saturday
+             * wDay is the nth time, 1..5, that wDayOfWeek occurs
+             */
 
-	    auto year = YearFromTime(t);
-	    auto mday = DateFromNthWeekdayOfMonth(year, st.wMonth, st.wDay, st.wDayOfWeek);
-	    day = MakeDay(year, st.wMonth - 1, mday);
-	    time = MakeTime(st.wHour, st.wMinute, 0, 0);
-	}
-	n = MakeDate(day,time);
-	n = TimeClip(n);
-	return n;
+            auto year = yearFromTime(t);
+            auto mday = dateFromNthWeekdayOfMonth(year,
+                    st.wMonth, st.wDay, st.wDayOfWeek);
+            day = makeDay(year, st.wMonth - 1, mday);
+            time = makeTime(st.wHour, st.wMinute, 0, 0);
+        }
+        auto n = makeDate(day,time);
+        return timeClip(n);
     }
 
     d_time getLocalTZA()
     {
-	d_time t;
-	DWORD r;
-	TIME_ZONE_INFORMATION tzi;
+        TIME_ZONE_INFORMATION tzi = void;
 
-	/* http://msdn.microsoft.com/library/en-us/sysinfo/base/gettimezoneinformation.asp
-	 * http://msdn2.microsoft.com/en-us/library/ms725481.aspx
-	 */
-	r = GetTimeZoneInformation(&tzi);
-	//printf("bias = %d\n", tzi.Bias);
-	//printf("standardbias = %d\n", tzi.StandardBias);
-	//printf("daylightbias = %d\n", tzi.DaylightBias);
-	switch (r)
-	{
-	    case TIME_ZONE_ID_STANDARD:
-		t = -(tzi.Bias + tzi.StandardBias) * cast(d_time)(60 * TicksPerSecond);
-		break;
-	    case TIME_ZONE_ID_DAYLIGHT:
-		//t = -(tzi.Bias + tzi.DaylightBias) * cast(d_time)(60 * TicksPerSecond);
-		//break;
-	    case TIME_ZONE_ID_UNKNOWN:
-		t = -(tzi.Bias) * cast(d_time)(60 * TicksPerSecond);
-		break;
-
-	    default:
-		t = 0;
-		break;
-	}
-
-	return t;
+        /* http://msdn.microsoft.com/library/en-us/sysinfo/base/gettimezoneinformation.asp
+         * http://msdn2.microsoft.com/en-us/library/ms725481.aspx
+         */
+        auto r = GetTimeZoneInformation(&tzi);
+        //printf("bias = %d\n", tzi.Bias);
+        //printf("standardbias = %d\n", tzi.StandardBias);
+        //printf("daylightbias = %d\n", tzi.DaylightBias);
+        switch (r)
+        {
+            case TIME_ZONE_ID_STANDARD:
+                return -(tzi.Bias + tzi.StandardBias)
+                    * cast(d_time)(60 * ticksPerSecond);
+            case TIME_ZONE_ID_DAYLIGHT:
+                // falthrough
+                //t = -(tzi.Bias + tzi.DaylightBias) * cast(d_time)(60 * ticksPerSecond);
+                //break;
+            case TIME_ZONE_ID_UNKNOWN:
+                return -(tzi.Bias) * cast(d_time)(60 * ticksPerSecond);
+            default:
+                return 0;
+        }
     }
 
     /*
      * Get daylight savings time adjust for time dt.
      */
 
-    int DaylightSavingTA(d_time dt)
+    int daylightSavingTA(d_time dt)
     {
-	int t;
-	DWORD r;
-	TIME_ZONE_INFORMATION tzi;
-	d_time ts;
-	d_time td;
+        TIME_ZONE_INFORMATION tzi = void;
+        d_time ts;
+        d_time td;
 
-	/* http://msdn.microsoft.com/library/en-us/sysinfo/base/gettimezoneinformation.asp
-	 */
-	r = GetTimeZoneInformation(&tzi);
-	t = 0;
-	switch (r)
-	{
-	    case TIME_ZONE_ID_STANDARD:
-	    case TIME_ZONE_ID_DAYLIGHT:
-		if (tzi.StandardDate.wMonth == 0 ||
-		    tzi.DaylightDate.wMonth == 0)
-		    break;
+        /* http://msdn.microsoft.com/library/en-us/sysinfo/base/gettimezoneinformation.asp
+         */
+        auto r = GetTimeZoneInformation(&tzi);
+        auto t = 0;
+        switch (r)
+        {
+            case TIME_ZONE_ID_STANDARD:
+            case TIME_ZONE_ID_DAYLIGHT:
+                if (tzi.StandardDate.wMonth == 0 ||
+                    tzi.DaylightDate.wMonth == 0)
+                    break;
 
-		ts = SYSTEMTIME2d_time(&tzi.StandardDate, dt);
-		td = SYSTEMTIME2d_time(&tzi.DaylightDate, dt);
+                ts = SYSTEMTIME2d_time(&tzi.StandardDate, dt);
+                td = SYSTEMTIME2d_time(&tzi.DaylightDate, dt);
 
-		if (td <= dt && dt < ts)
-		{
-		    t = -tzi.DaylightBias * (60 * TicksPerSecond);
-		    //printf("DST is in effect, %d\n", t);
-		}
-		else
-		{
-		    //printf("no DST\n");
-		}
-		break;
+                if (td <= dt && dt < ts)
+                {
+                    t = -tzi.DaylightBias * (60 * ticksPerSecond);
+                    //printf("DST is in effect, %d\n", t);
+                }
+                else
+                {
+                    //printf("no DST\n");
+                }
+                break;
 
-	    case TIME_ZONE_ID_UNKNOWN:
-		// Daylight savings time not used in this time zone
-		break;
+            case TIME_ZONE_ID_UNKNOWN:
+                // Daylight savings time not used in this time zone
+                break;
 
-	    default:
-		assert(0);
-	}
-	return t;
+            default:
+                assert(0);
+        }
+        return t;
     }
 }
-else version (Posix)
+
+version (Posix)
 {
+    private import core.sys.posix.time;
+    private import core.sys.posix.sys.time;
 
-    private import std.c.unix.unix;
-
+    /******
+     * Get current UTC time.
+     */
     d_time getUTCtime()
     {   timeval tv;
 
-	//printf("getUTCtime()\n");
-	if (gettimeofday(&tv, null))
-	{   // Some error happened - try time() instead
-	    return time(null) * TicksPerSecond;
-	}
+        //printf("getUTCtime()\n");
+        if (gettimeofday(&tv, null))
+        {   // Some error happened - try time() instead
+            return time(null) * ticksPerSecond;
+        }
 
-	return tv.tv_sec * cast(d_time)TicksPerSecond +
-		(tv.tv_usec / (1000000 / cast(d_time)TicksPerSecond));
+        return tv.tv_sec * cast(d_time)ticksPerSecond +
+                (tv.tv_usec / (1000000 / cast(d_time)ticksPerSecond));
     }
 
-    private extern (C) time_t _d_gnu_cbridge_tza();
-
     d_time getLocalTZA()
     {
-	return _d_gnu_cbridge_tza() * TicksPerSecond;
+        time_t t;
+        
+        time(&t);
+        version (OSX)
+        {
+            tm result;
+            localtime_r(&t, &result);
+            return result.tm_gmtoff * ticksPerSecond;
+        }
+        else
+        {
+            localtime(&t);        // this will set timezone
+            return -(timezone * ticksPerSecond);
+        }
     }
 
     /*
      * Get daylight savings time adjust for time dt.
      */
 
-    int DaylightSavingTA(d_time dt)
+    int daylightSavingTA(d_time dt)
     {
-	tm *tmp;
-	time_t t;
-	int dst = 0;
+        tm *tmp;
+        time_t t;
+        int dst = 0;
 
-	if (dt != d_time_nan)
-	{
-	    d_time seconds = dt / TicksPerSecond;
-	    t = cast(time_t) seconds;
-	    if (t == seconds)	// if in range
-	    {
-		tmp = localtime(&t);
-		if (tmp.tm_isdst > 0)
-		    dst = TicksPerHour;	// BUG: Assume daylight savings time is plus one hour.
-	    }
-	    else	// out of range for system time, use our own calculation
-	    {	// Daylight savings time goes from 2 AM the first Sunday
-		// in April through 2 AM the last Sunday in October
+        if (dt != d_time_nan)
+        {
+            d_time seconds = dt / ticksPerSecond;
+            t = cast(time_t) seconds;
+            if (t == seconds)        // if in range
+            {
+                tmp = localtime(&t);
+                if (tmp.tm_isdst > 0)
+                    dst = ticksPerHour;        // BUG: Assume daylight savings time is plus one hour.
+            }
+            else // out of range for system time, use our own calculation
+            {
+                /* BUG: this works for the US, but not other timezones.
+                 */
 
-		dt -= LocalTZA;
+                dt -= localTZA;
 
-		int year = YearFromTime(dt);
-		int leap = LeapYear(dt);
-		//writefln("year = %s, leap = %s, month = %s", year, leap, MonthFromTime(dt));
+                int year = yearFromTime(dt);
 
-		d_time start = TimeFromYear(year);		// Jan 1
-		d_time end = start;
-		// Move fwd to Apr 1
-		start += cast(d_time)(mdays[3] + leap) * TicksPerDay;
-		// Advance a day at a time until we find Sunday (0)
-		while (WeekDay(start) != 0)
-		    start += TicksPerDay;
+                /* Compute time given year, month 1..12,
+                 * week in month, weekday, hour
+                 */
+                d_time dstt(int year, int month, int week, int weekday, int hour)
+                {
+                    auto mday = dateFromNthWeekdayOfMonth(year,  month, weekday, week);
+                    return timeClip(makeDate(
+                        makeDay(year, month - 1, mday),
+                        makeTime(hour, 0, 0, 0)));
+                }
 
-		// Move fwd to Oct 30
-		end += cast(d_time)(mdays[9] + leap + 30) * TicksPerDay;
-		// Back up a day at a time until we find Sunday (0)
-		while (WeekDay(end) != 0)		// 0 is Sunday
-		    end -= TicksPerDay;
+                d_time start;
+                d_time end;
+                if (year < 2007)
+                {   // Daylight savings time goes from 2 AM the first Sunday
+                    // in April through 2 AM the last Sunday in October
+                    start = dstt(year,  4, 1, 0, 2);
+                    end   = dstt(year, 10, 5, 0, 2);
+                }
+                else
+                {
+                    // the second Sunday of March to
+                    // the first Sunday in November
+                    start = dstt(year,  3, 2, 0, 2);
+                    end   = dstt(year, 11, 1, 0, 2);
+                }
 
-		dt -= 2 * TicksPerHour;			// 2 AM
-		if (dt >= start && dt <= end)
-		    dst = TicksPerHour;
-		//writefln("start = %s, dt = %s, end = %s, dst = %s", start, dt, end, dst);
-	    }
-	}
-	return dst;
+                if (start <= dt && dt < end)
+                    dst = ticksPerHour;
+                //writefln("start = %s, dt = %s, end = %s, dst = %s", start, dt, end, dst);
+            }
+        }
+        return dst;
     }
 
 }
-else version (NoSystem)
-{
-    d_time getLocalTZA() { return 0; }    
-    int DaylightSavingTA(d_time dt) { return 0; }
-}
 
-/+ ====================== DOS File Time =============================== +/
+
+/+ DOS File Time +/
 
 /***
  * Type representing the DOS file date/time format.
@@ -1031,28 +1017,28 @@
     uint dt = cast(uint)time;
 
     if (dt == 0)
-	return d_time_nan;
+        return d_time_nan;
 
     int year = ((dt >> 25) & 0x7F) + 1980;
-    int month = ((dt >> 21) & 0x0F) - 1;	// 0..12
-    int dayofmonth = ((dt >> 16) & 0x1F);	// 0..31
-    int hour = (dt >> 11) & 0x1F;		// 0..23
-    int minute = (dt >> 5) & 0x3F;		// 0..59
-    int second = (dt << 1) & 0x3E;		// 0..58 (in 2 second increments)
+    int month = ((dt >> 21) & 0x0F) - 1;        // 0..12
+    int dayofmonth = ((dt >> 16) & 0x1F);        // 0..31
+    int hour = (dt >> 11) & 0x1F;                // 0..23
+    int minute = (dt >> 5) & 0x3F;                // 0..59
+    int second = (dt << 1) & 0x3E;                // 0..58 (in 2 second increments)
 
     d_time t;
 
-    t = std.date.MakeDate(std.date.MakeDay(year, month, dayofmonth),
-	    std.date.MakeTime(hour, minute, second, 0));
+    t = std.date.makeDate(std.date.makeDay(year, month, dayofmonth),
+            std.date.makeTime(hour, minute, second, 0));
 
-    assert(YearFromTime(t) == year);
-    assert(MonthFromTime(t) == month);
-    assert(DateFromTime(t) == dayofmonth);
-    assert(HourFromTime(t) == hour);
-    assert(MinFromTime(t) == minute);
-    assert(SecFromTime(t) == second);
+    assert(yearFromTime(t) == year);
+    assert(monthFromTime(t) == month);
+    assert(dateFromTime(t) == dayofmonth);
+    assert(hourFromTime(t) == hour);
+    assert(minFromTime(t) == minute);
+    assert(secFromTime(t) == second);
 
-    t -= LocalTZA + DaylightSavingTA(t);
+    t -= localTZA + daylightSavingTA(t);
 
     return t;
 }
@@ -1065,16 +1051,16 @@
 {   uint dt;
 
     if (t == d_time_nan)
-	return cast(DosFileTime)0;
+        return cast(DosFileTime)0;
 
-    t += LocalTZA + DaylightSavingTA(t);
+    t += localTZA + daylightSavingTA(t);
 
-    uint year = YearFromTime(t);
-    uint month = MonthFromTime(t);
-    uint dayofmonth = DateFromTime(t);
-    uint hour = HourFromTime(t);
-    uint minute = MinFromTime(t);
-    uint second = SecFromTime(t);
+    uint year = yearFromTime(t);
+    uint month = monthFromTime(t);
+    uint dayofmonth = dateFromTime(t);
+    uint hour = hourFromTime(t);
+    uint minute = minFromTime(t);
+    uint second = secFromTime(t);
 
     dt = (year - 1980) << 25;
     dt |= ((month + 1) & 0x0F) << 21;
@@ -1085,3 +1071,64 @@
 
     return cast(DosFileTime)dt;
 }
+
+/**
+Benchmarks code for speed assessment and comparison.
+
+Params:
+
+fun = aliases of callable objects (e.g. function names). Each should
+take no arguments.
+
+times = The number of times each function is to be executed.
+
+result = The optional store for the return value. If $(D null) is
+passed in, new store is allocated appropriately.
+
+Returns:
+
+An array of $(D n) $(D uint)s. Element at slot $(D i) contains the
+number of milliseconds spent in calling the $(D i)th function $(D
+times) times.
+
+Example:
+----
+int a;
+void f0() { }
+void f1() { auto b = a; }
+void f2() { auto b = to!(string)(a); }
+auto r = benchmark!(f0, f1, f2)(10_000_000);
+----
+ */
+uint[] benchmark(fun...)(uint times, uint[] result = null)
+{
+    result.length = fun.length;
+    result.length = 0;
+    foreach (i, Unused; fun)
+    {
+        immutable t = getUTCtime;
+        foreach (j; 0 .. times)
+        {
+            fun[i]();
+        }
+        auto delta = getUTCtime - t;
+        result ~= delta;
+    }
+    foreach (ref e; result)
+    {
+        e *= 1000;
+        e /= ticksPerSecond;
+    }
+    return result;
+}
+
+unittest
+{
+    int a;
+    void f0() { }
+    //void f1() { auto b = to!(string)(a); }
+    void f2() { auto b = (a); }
+    auto r = benchmark!(f0, f2)(100);
+    //writeln(r);
+}
+
diff -r f12bfe124807 d/phobos2/std/dateparse.d
--- a/d/phobos2/std/dateparse.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/dateparse.d	Thu Oct 14 14:12:53 2010 +0100
@@ -1,28 +1,5 @@
 // Written in the D programming language
 
-/*
- *  Copyright (C) 1999-2004 by Digital Mars, http://www.digitalmars.com
- *  Written by Walter Bright
- *
- *  This software is provided 'as-is', without any express or implied
- *  warranty. In no event will the authors be held liable for any damages
- *  arising from the use of this software.
- *
- *  Permission is granted to anyone to use this software for any purpose,
- *  including commercial applications, and to alter it and redistribute it
- *  freely, subject to the following restrictions:
- *
- *  o  The origin of this software must not be misrepresented; you must not
- *     claim that you wrote the original software. If you use this software
- *     in a product, an acknowledgment in the product documentation would be
- *     appreciated but is not required.
- *  o  Altered source versions must be plainly marked as such, and must not
- *     be misrepresented as being the original software.
- *  o  This notice may not be removed or altered from any source
- *     distribution.
- */
-
-
 module std.dateparse;
 
 private
@@ -53,8 +30,7 @@
 	//else
 	    //buffer = new char[s.length];
 
-	debug(dateparse) printf("DateParse.parse('%.*s')\n",
-	    cast(int) s.length, s.ptr);
+	debug(dateparse) printf("DateParse.parse('%.*s')\n", s);
 	if (!parseString(s))
 	{
 	    goto Lerror;
@@ -424,113 +400,114 @@
 
     int parseString(string s)
     {
-	int n1;
-	int dp;
-	int sisave;
-	int result;
+        int n1;
+        int dp;
+        int sisave;
+        int result;
 
-	//message(DTEXT("DateParse::parseString('%ls')\n"), s);
-	this.s = s;
-	si = 0;
-	dp = nextToken();
-	for (;;)
-	{
-	    //message(DTEXT("\tdp = %d\n"), dp);
-	    switch (dp)
-	    {
-		case DP.end:
-		    result = 1;
-		Lret:
-		    return result;
+        //message(DTEXT("DateParse::parseString('%ls')\n"), s);
+        this.s = s;
+        si = 0;
+        dp = nextToken();
+        for (;;)
+        {
+            //message(DTEXT("\tdp = %d\n"), dp);
+            switch (dp)
+            {
+            case DP.end:
+                result = 1;
+            Lret:
+                return result;
 
-		case DP.err:
-		case_error:
-		    //message(DTEXT("\terror\n"));
-		default:
-		    result = 0;
-		    goto Lret;
+            case DP.err:
+            case_error:
+                //message(DTEXT("\terror\n"));
+            default:
+                result = 0;
+                goto Lret;
 
-		case DP.minus:
-		    break;			// ignore spurious '-'
+            case DP.minus:
+                break;			// ignore spurious '-'
 
-		case DP.weekday:
-		    weekday = number;
-		    break;
+            case DP.weekday:
+                weekday = number;
+                break;
 
-		case DP.month:		// month day, [year]
-		    month = number;
-		    dp = nextToken();
-		    if (dp == DP.number)
-		    {
-			day = number;
-			sisave = si;
-			dp = nextToken();
-			if (dp == DP.number)
-			{
-			    n1 = number;
-			    dp = nextToken();
-			    if (dp == DP.colon)
-			    {   // back up, not a year
-				si = sisave;
-			    }
-			    else
-			    {   year = n1;
-				continue;
-			    }
-			    break;
-			}
-		    }
-		    continue;
+            case DP.month:		// month day, [year]
+                month = number;
+                dp = nextToken();
+                if (dp == DP.number)
+                {
+                    day = number;
+                    sisave = si;
+                    dp = nextToken();
+                    if (dp == DP.number)
+                    {
+                        n1 = number;
+                        dp = nextToken();
+                        if (dp == DP.colon)
+                        {   // back up, not a year
+                            si = sisave;
+                        }
+                        else
+                        {   year = n1;
+                            continue;
+                        }
+                        break;
+                    }
+                }
+                continue;
 
-		case DP.number:
-		    n1 = number;
-		    dp = nextToken();
-		    switch (dp)
-		    {
-			case DP.end:
-			    year = n1;
-			    break;
+            case DP.number:
+                n1 = number;
+                dp = nextToken();
+                switch (dp)
+                {
+                case DP.end:
+                    year = n1;
+                    break;
 
-			case DP.minus:
-			case DP.slash:	// n1/ ? ? ?
-			    dp = parseCalendarDate(n1);
-			    if (dp == DP.err)
-				goto case_error;
-			    break;
+                case DP.minus:
+                case DP.slash:	// n1/ ? ? ?
+                    dp = parseCalendarDate(n1);
+                    if (dp == DP.err)
+                        goto case_error;
+                    break;
 
-		       case DP.colon:	// hh:mm [:ss] [am | pm]
-			    dp = parseTimeOfDay(n1);
-			    if (dp == DP.err)
-				goto case_error;
-			    break;
+                case DP.colon:	// hh:mm [:ss] [am | pm]
+                    dp = parseTimeOfDay(n1);
+                    if (dp == DP.err)
+                        goto case_error;
+                    break;
 
-		       case DP.ampm:
-			    hours = n1;
-			    minutes = 0;
-			    seconds = 0;
-			    ampm = number;
-			    break;
+                case DP.ampm:
+                    hours = n1;
+                    minutes = 0;
+                    seconds = 0;
+                    ampm = number;
+                    break;
 
-			case DP.month:
-			    day = n1;
-			    month = number;
-			    dp = nextToken();
-			    if (dp == DP.number)
-			    {   // day month year
-				year = number;
-				dp = nextToken();
-			    }
-			    break;
+                case DP.month:
+                    day = n1;
+                    month = number;
+                    dp = nextToken();
+                    if (dp == DP.number)
+                    {   // day month year
+                        year = number;
+                        dp = nextToken();
+                    }
+                    break;
 
-			default:
-			    year = n1;
-			    break;
-		    }
-		    continue;
-	    }
-	    dp = nextToken();
-	}
-	assert(0);
+                default:
+                    year = n1;
+                    break;
+                }
+                continue;
+            }
+            dp = nextToken();
+        }
+        // @@@ bug in the compiler: this is never reachable
+        assert(0);
     }
 
     int parseCalendarDate(int n1)
@@ -787,3 +764,24 @@
 	d.weekday, d.tzcorrection);
 }
 
+/*
+ *  Copyright (C) 1999-2004 by Digital Mars, http://www.digitalmars.com
+ *  Written by Walter Bright
+ *
+ *  This software is provided 'as-is', without any express or implied
+ *  warranty. In no event will the authors be held liable for any damages
+ *  arising from the use of this software.
+ *
+ *  Permission is granted to anyone to use this software for any purpose,
+ *  including commercial applications, and to alter it and redistribute it
+ *  freely, subject to the following restrictions:
+ *
+ *  o  The origin of this software must not be misrepresented; you must not
+ *     claim that you wrote the original software. If you use this software
+ *     in a product, an acknowledgment in the product documentation would be
+ *     appreciated but is not required.
+ *  o  Altered source versions must be plainly marked as such, and must not
+ *     be misrepresented as being the original software.
+ *  o  This notice may not be removed or altered from any source
+ *     distribution.
+ */
diff -r f12bfe124807 d/phobos2/std/demangle.d
--- a/d/phobos2/std/demangle.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/demangle.d	Thu Oct 14 14:12:53 2010 +0100
@@ -4,29 +4,25 @@
  * Placed into the Public Domain.
  */
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, November 2005
-*/
 /****
  * Demangle D mangled names.
  * Macros:
- *	WIKI = Phobos/StdDemangle
+ *        WIKI = Phobos/StdDemangle
  */
 
 /* Authors:
- *	Walter Bright, Digital Mars, www.digitalmars.com
- *	Thomas Kuehne
- *	Frits van Bommel
+ *        Walter Bright, Digital Mars, www.digitalmars.com
+ *        Thomas Kuehne
+ *        Frits van Bommel
  */
 
 module std.demangle;
 
-//debug=demangle;		// uncomment to turn on debugging printf's
+//debug=demangle;                // uncomment to turn on debugging printf's
 
 private import std.ctype;
 private import std.string;
+import std.conv;
 private import std.utf;
 import std.contracts;
 
@@ -36,7 +32,7 @@
 {
     this()
     {
-	super("MangleException");
+        super("MangleException");
     }
 }
 
@@ -45,8 +41,8 @@
  *
  * If it is not a D mangled name, it returns its argument name.
  * Example:
- *	This program reads standard in and writes it to standard out,
- *	pretty-printing any found D mangled names.
+ *        This program reads standard in and writes it to standard out,
+ *        pretty-printing any found D mangled names.
 -------------------
 import std.stdio;
 import std.ctype;
@@ -59,28 +55,28 @@
 
     while ((c = fgetc(stdin)) != EOF)
     {
-	if (inword)
-	{
-	    if (c == '_' || isalnum(c))
-		buffer ~= cast(char) c;
-	    else
-	    {
-		inword = false;
-		writef(demangle(buffer), cast(char) c);
-	    }
-	}
-	else
-	{   if (c == '_' || isalpha(c))
-	    {	inword = true;
-		buffer.length = 0;
-		buffer ~= cast(char) c;
-	    }
-	    else
-		writef(cast(char) c);
-	}
+        if (inword)
+        {
+            if (c == '_' || isalnum(c))
+                buffer ~= cast(char) c;
+            else
+            {
+                inword = false;
+                writef(demangle(buffer), cast(char) c);
+            }
+        }
+        else
+        {   if (c == '_' || isalpha(c))
+            {        inword = true;
+                buffer.length = 0;
+                buffer ~= cast(char) c;
+            }
+            else
+                writef(cast(char) c);
+        }
     }
     if (inword)
-	writef(demangle(buffer));
+        writef(demangle(buffer));
     return 0;
 }
 -------------------
@@ -93,389 +89,401 @@
 
     static void error()
     {
-	//writefln("error()");
-	throw new MangleException();
+        //writefln("error()");
+        throw new MangleException();
     }
 
     static ubyte ascii2hex(char c)
     {
-	if (!isxdigit(c))
-	    error();
-	return cast(ubyte)
-	      ( (c >= 'a') ? c - 'a' + 10 :
-		(c >= 'A') ? c - 'A' + 10 :
-			     c - '0'
-	      );
+        if (!isxdigit(c))
+            error();
+        return cast(ubyte)
+              ( (c >= 'a') ? c - 'a' + 10 :
+                (c >= 'A') ? c - 'A' + 10 :
+                             c - '0'
+              );
     }
 
     size_t parseNumber()
     {
-	//writefln("parseNumber() %d", ni);
-	size_t result;
+        //writefln("parseNumber() %d", ni);
+        size_t result;
 
-	while (ni < name.length && isdigit(name[ni]))
-	{   int i = name[ni] - '0';
-	    if (result > (size_t.max - i) / 10)
-		error();
-	    result = result * 10 + i;
-	    ni++;
-	}
-	return result;
+        while (ni < name.length && isdigit(name[ni]))
+        {   int i = name[ni] - '0';
+            if (result > (size_t.max - i) / 10)
+                error();
+            result = result * 10 + i;
+            ni++;
+        }
+        return result;
     }
 
     string parseSymbolName()
     {
-	//writefln("parseSymbolName() %d", ni);
-	size_t i = parseNumber();
-	if (ni + i > name.length)
-	    error();
-	string result;
-	if (i >= 5 &&
-	    name[ni] == '_' &&
-	    name[ni + 1] == '_' &&
-	    name[ni + 2] == 'T')
-	{
-	    size_t nisave = ni;
-	    bool err;
-	    ni += 3;
-	    try
-	    {
-		result = fparseTemplateInstanceName();
-		if (ni != nisave + i)
-		    err = true;
-	    }
-	    catch (MangleException me)
-	    {
-		err = true;
-	    }
-	    ni = nisave;
-	    if (err)
-		goto L1;
-	    goto L2;
-	}
+        //writefln("parseSymbolName() %d", ni);
+        size_t i = parseNumber();
+        if (ni + i > name.length)
+            error();
+        string result;
+        if (i >= 5 &&
+            name[ni] == '_' &&
+            name[ni + 1] == '_' &&
+            name[ni + 2] == 'T')
+        {
+            size_t nisave = ni;
+            bool err;
+            ni += 3;
+            try
+            {
+                result = fparseTemplateInstanceName();
+                if (ni != nisave + i)
+                    err = true;
+            }
+            catch (MangleException me)
+            {
+                err = true;
+            }
+            ni = nisave;
+            if (err)
+                goto L1;
+            goto L2;
+        }
       L1:
-	result = name[ni .. ni + i];
+        result = name[ni .. ni + i];
       L2:
-	ni += i;
-	return result;
+        ni += i;
+        return result;
     }
 
     string parseQualifiedName()
     {
-	//writefln("parseQualifiedName() %d", ni);
-	string result;
+        //writefln("parseQualifiedName() %d", ni);
+        string result;
 
-	while (ni < name.length && isdigit(name[ni]))
-	{
-	    if (result.length)
-		result ~= ".";
-	    result ~= parseSymbolName();
-	}
-	return result;
+        while (ni < name.length && isdigit(name[ni]))
+        {
+            if (result.length)
+                result ~= ".";
+            result ~= parseSymbolName();
+        }
+        return result;
     }
 
     string parseType(string identifier = null)
     {
-	//writefln("parseType() %d", ni);
-	int isdelegate = 0;
-	bool hasthisptr = false; /// For function/delegate types: expects a 'this' pointer as last argument
+        //writefln("parseType() %d", ni);
+        int isdelegate = 0;
+        bool hasthisptr = false; /// For function/delegate types: expects a 'this' pointer as last argument
       Lagain:
-	if (ni >= name.length)
-	    error();
-	string p;
-	switch (name[ni++])
-	{
-	    case 'v':	p = "void";	goto L1;
-	    case 'b':	p = "bool";	goto L1;
-	    case 'g':	p = "byte";	goto L1;
-	    case 'h':	p = "ubyte";	goto L1;
-	    case 's':	p = "short";	goto L1;
-	    case 't':	p = "ushort";	goto L1;
-	    case 'i':	p = "int";	goto L1;
-	    case 'k':	p = "uint";	goto L1;
-	    case 'l':	p = "long";	goto L1;
-	    case 'm':	p = "ulong";	goto L1;
-	    case 'f':	p = "float";	goto L1;
-	    case 'd':	p = "double";	goto L1;
-	    case 'e':	p = "real";	goto L1;
-	    case 'o':	p = "ifloat";	goto L1;
-	    case 'p':	p = "idouble";	goto L1;
-	    case 'j':	p = "ireal";	goto L1;
-	    case 'q':	p = "cfloat";	goto L1;
-	    case 'r':	p = "cdouble";	goto L1;
-	    case 'c':	p = "creal";	goto L1;
-	    case 'a':	p = "char";	goto L1;
-	    case 'u':	p = "wchar";	goto L1;
-	    case 'w':	p = "dchar";	goto L1;
+        if (ni >= name.length)
+            error();
+        string p;
+        switch (name[ni++])
+        {
+            case 'v':        p = "void";        goto L1;
+            case 'b':        p = "bool";        goto L1;
+            case 'g':        p = "byte";        goto L1;
+            case 'h':        p = "ubyte";        goto L1;
+            case 's':        p = "short";        goto L1;
+            case 't':        p = "ushort";        goto L1;
+            case 'i':        p = "int";        goto L1;
+            case 'k':        p = "uint";        goto L1;
+            case 'l':        p = "long";        goto L1;
+            case 'm':        p = "ulong";        goto L1;
+            case 'f':        p = "float";        goto L1;
+            case 'd':        p = "double";        goto L1;
+            case 'e':        p = "real";        goto L1;
+            case 'o':        p = "ifloat";        goto L1;
+            case 'p':        p = "idouble";        goto L1;
+            case 'j':        p = "ireal";        goto L1;
+            case 'q':        p = "cfloat";        goto L1;
+            case 'r':        p = "cdouble";        goto L1;
+            case 'c':        p = "creal";        goto L1;
+            case 'a':        p = "char";        goto L1;
+            case 'u':        p = "wchar";        goto L1;
+            case 'w':        p = "dchar";        goto L1;
 
-	    case 'A':				// dynamic array
-		p = parseType() ~ "[]";
-		goto L1;
+            case 'A':                                // dynamic array
+                p = parseType() ~ "[]";
+                goto L1;
 
-	    case 'P':				// pointer
-		p = parseType() ~ "*";
-		goto L1;
+            case 'P':                                // pointer
+                p = parseType() ~ "*";
+                goto L1;
 
-	    case 'G':				// static array
-	    {	size_t ns = ni;
-		parseNumber();
-		size_t ne = ni;
-		p = parseType() ~ "[" ~ name[ns .. ne] ~ "]";
-		goto L1;
-	    }
+            case 'G':                                // static array
+            {        size_t ns = ni;
+                parseNumber();
+                size_t ne = ni;
+                p = parseType() ~ "[" ~ name[ns .. ne] ~ "]";
+                goto L1;
+            }
 
-	    case 'H':				// associative array
-		p = parseType();
-		p = parseType() ~ "[" ~ p ~ "]";
-		goto L1;
+            case 'H':                                // associative array
+                p = parseType();
+                p = parseType() ~ "[" ~ p ~ "]";
+                goto L1;
 
-	    case 'D':				// delegate
-		isdelegate = 1;
-		goto Lagain;
+            case 'D':                                // delegate
+                isdelegate = 1;
+                goto Lagain;
 
-	    case 'M':
-		hasthisptr = true;
-		goto Lagain;
+            case 'M':
+                hasthisptr = true;
+                goto Lagain;
 
-	    case 'F':				// D function
-	    case 'U':				// C function
-	    case 'W':				// Windows function
-	    case 'V':				// Pascal function
-	    case 'R':				// C++ function
-	    {	char mc = name[ni - 1];
-		string args;
+            case 'y':
+                p = "immutable(" ~ parseType() ~ ")";
+                goto L1;
 
-		while (1)
-		{
-		    if (ni >= name.length)
-			error();
-		    char c = name[ni];
-		    if (c == 'Z')
-			break;
-		    if (c == 'X')
-		    {
-			if (!args.length) error();
-			args ~= " ...";
-			break;
-		    }
-		    if (args.length)
-			args ~= ", ";
-		    switch (c)
-		    {
-			case 'J':
-			    args ~= "out ";
-			    ni++;
-			    goto default;
+            case 'x':
+                p = "const(" ~ parseType() ~ ")";
+                goto L1;
 
-			case 'K':
-			    args ~= "inout ";
-			    ni++;
-			    goto default;
+            case 'O':
+                p = "shared(" ~ parseType() ~ ")";
+                goto L1;
 
-			case 'L':
-			    args ~= "lazy ";
-			    ni++;
-			    goto default;
+            case 'F':                                // D function
+            case 'U':                                // C function
+            case 'W':                                // Windows function
+            case 'V':                                // Pascal function
+            case 'R':                                // C++ function
+            {        char mc = name[ni - 1];
+                string args;
 
-			default:
-			    args ~= parseType();
-			    continue;
+                while (1)
+                {
+                    if (ni >= name.length)
+                        error();
+                    char c = name[ni];
+                    if (c == 'Z')
+                        break;
+                    if (c == 'X')
+                    {
+                        if (!args.length) error();
+                        args ~= " ...";
+                        break;
+                    }
+                    if (args.length)
+                        args ~= ", ";
+                    switch (c)
+                    {
+                        case 'J':
+                            args ~= "out ";
+                            ni++;
+                            goto default;
 
-			case 'Y':
-			    args ~= "...";
-			    break;
-		    }
-		    break;
-		}
-		ni++;
-		if (!isdelegate && identifier.length)
-		{
-		    switch (mc)
-		    {
-			case 'F': p = null;                break; // D function
-			case 'U': p = "extern (C) ";       break; // C function
-			case 'W': p = "extern (Windows) "; break; // Windows function
-			case 'V': p = "extern (Pascal) ";  break; // Pascal function
-			default:  assert(0);
-		    }
-		    p ~= parseType() ~ " " ~ identifier ~ "(" ~ args ~ ")";
-		    return p;
-		}
-		p = parseType() ~
-		    (isdelegate ? " delegate(" : " function(") ~
-		    args ~ ")";
-		isdelegate = 0;
-		goto L1;
-	    }
+                        case 'K':
+                            args ~= "inout ";
+                            ni++;
+                            goto default;
 
-	    case 'C':	p = "class ";	goto L2;
-	    case 'S':	p = "struct ";	goto L2;
-	    case 'E':	p = "enum ";	goto L2;
-	    case 'T':	p = "typedef ";	goto L2;
+                        case 'L':
+                            args ~= "lazy ";
+                            ni++;
+                            goto default;
 
-	    L2:	p ~= parseQualifiedName();
-		goto L1;
+                        default:
+                            args ~= parseType();
+                            continue;
 
-	    L1:
-		if (isdelegate)
-		    error();		// 'D' must be followed by function
-		if (identifier.length)
-		    p ~= " " ~ identifier;
-		return p;
+                        case 'Y':
+                            args ~= "...";
+                            break;
+                    }
+                    break;
+                }
+                ni++;
+                if (!isdelegate && identifier.length)
+                {
+                    switch (mc)
+                    {
+                        case 'F': p = null;                break; // D function
+                        case 'U': p = "extern (C) ";       break; // C function
+                        case 'W': p = "extern (Windows) "; break; // Windows function
+                        case 'V': p = "extern (Pascal) ";  break; // Pascal function
+                        default:  assert(0);
+                    }
+                    p ~= parseType() ~ " " ~ identifier ~ "(" ~ args ~ ")";
+                    return p;
+                }
+                p = parseType() ~
+                    (isdelegate ? " delegate(" : " function(") ~
+                    args ~ ")";
+                isdelegate = 0;
+                goto L1;
+            }
 
-	    default:
-		size_t i = ni - 1;
-		ni = name.length;
-		p = name[i .. length];
-		goto L1;
-	}
+            case 'C':        p = "class ";        goto L2;
+            case 'S':        p = "struct ";        goto L2;
+            case 'E':        p = "enum ";        goto L2;
+            case 'T':        p = "typedef ";        goto L2;
+
+            L2:        p ~= parseQualifiedName();
+                goto L1;
+
+            L1:
+                if (isdelegate)
+                    error();                // 'D' must be followed by function
+                if (identifier.length)
+                    p ~= " " ~ identifier;
+                return p;
+
+            default:
+                size_t i = ni - 1;
+                ni = name.length;
+                p = name[i .. length];
+                goto L1;
+        }
     }
 
     string parseTemplateInstanceName()
     {
-	auto result = parseSymbolName() ~ "!(";
-	int nargs;
+        auto result = parseSymbolName() ~ "!(";
+        int nargs;
 
-	while (1)
-	{   size_t i;
+        while (1)
+        {   size_t i;
 
-	    if (ni >= name.length)
-		error();
-	    if (nargs && name[ni] != 'Z')
-		result ~= ", ";
-	    nargs++;
-	    switch (name[ni++])
-	    {
-		case 'T':
-		    result ~= parseType();
-		    continue;
+            if (ni >= name.length)
+                error();
+            if (nargs && name[ni] != 'Z')
+                result ~= ", ";
+            nargs++;
+            switch (name[ni++])
+            {
+                case 'T':
+                    result ~= parseType();
+                    continue;
 
-		case 'V':
+                case 'V':
 
-		    void getReal()
-		    {   real r;
-			ubyte *p = cast(ubyte *)&r;
+                    void getReal()
+                    {   real r;
+                        ubyte *p = cast(ubyte *)&r;
 
-			if (ni + real.sizeof * 2 > name.length)
-			    error();
-			for (i = 0; i < real.sizeof; i++)
-			{   ubyte b;
+                        if (ni + 10 * 2 > name.length)
+                            error();
+                        for (i = 0; i < 10; i++)
+                        {   ubyte b;
 
-			    b = cast(ubyte)
-				(
-				 (ascii2hex(name[ni + i * 2]) << 4) +
-				  ascii2hex(name[ni + i * 2 + 1])
-				);
-			    p[i] = b;
-			}
-			result ~= format(r);
-			ni += 10 * 2;
-		    }
+                            b = cast(ubyte)
+                                (
+                                 (ascii2hex(name[ni + i * 2]) << 4) +
+                                  ascii2hex(name[ni + i * 2 + 1])
+                                );
+                            p[i] = b;
+                        }
+                        result ~= format(r);
+                        ni += 10 * 2;
+                    }
 
-		    result ~= parseType() ~ " ";
-		    if (ni >= name.length)
-			error();
-		    switch (name[ni++])
-		    {
-			case '0': case '1': case '2': case '3': case '4':
-			case '5': case '6': case '7': case '8': case '9':
-			    i = ni - 1;
-			    while (ni < name.length && isdigit(name[ni]))
-				ni++;
-			    result ~= name[i .. ni];
-			    break;
+                    result ~= parseType() ~ " ";
+                    if (ni >= name.length)
+                        error();
+                    switch (name[ni++])
+                    {
+                        case '0': case '1': case '2': case '3': case '4':
+                        case '5': case '6': case '7': case '8': case '9':
+                            i = ni - 1;
+                            while (ni < name.length && isdigit(name[ni]))
+                                ni++;
+                            result ~= name[i .. ni];
+                            break;
 
-			case 'N':
-			    i = ni;
-			    while (ni < name.length && isdigit(name[ni]))
-				ni++;
-			    if (i == ni)
-				error();
-			    result ~= "-" ~ name[i .. ni];
-			    break;
+                        case 'N':
+                            i = ni;
+                            while (ni < name.length && isdigit(name[ni]))
+                                ni++;
+                            if (i == ni)
+                                error();
+                            result ~= "-" ~ name[i .. ni];
+                            break;
 
-			case 'n':
-			    result ~= "null";
-			    break;
+                        case 'n':
+                            result ~= "null";
+                            break;
 
-			case 'e':
-			    getReal();
-			    break;
+                        case 'e':
+                            getReal();
+                            break;
 
-			case 'c':
-			    getReal();
-			    result ~= '+';
-			    getReal();
-			    result ~= 'i';
-			    break;
+                        case 'c':
+                            getReal();
+                            result ~= '+';
+                            getReal();
+                            result ~= 'i';
+                            break;
 
-			case 'a':
-			case 'w':
-			case 'd':
-			{   char m = name[ni - 1];
-			    if (m == 'a')
-				m = 'c';
-			    size_t n = parseNumber();
-			    if (ni >= name.length || name[ni++] != '_' ||
-				ni + n * 2 > name.length)
-				error();
-			    result ~= '"';
-			    for (i = 0; i < n; i++)
-			    {	char c;
+                        case 'a':
+                        case 'w':
+                        case 'd':
+                        {   char m = name[ni - 1];
+                            if (m == 'a')
+                                m = 'c';
+                            size_t n = parseNumber();
+                            if (ni >= name.length || name[ni++] != '_' ||
+                                ni + n * 2 > name.length)
+                                error();
+                            result ~= '"';
+                            for (i = 0; i < n; i++)
+                            {        char c;
 
-				c = (ascii2hex(name[ni + i * 2]) << 4) +
-				     ascii2hex(name[ni + i * 2 + 1]);
-				result ~= c;
-			    }
-			    ni += n * 2;
-			    result ~= '"';
-			    result ~= m;
-			    break;
-			}
+                                c = (ascii2hex(name[ni + i * 2]) << 4) +
+                                     ascii2hex(name[ni + i * 2 + 1]);
+                                result ~= c;
+                            }
+                            ni += n * 2;
+                            result ~= '"';
+                            result ~= m;
+                            break;
+                        }
 
-			default:
-			    error();
-			    break;
-		    }
-		    continue;
+                        default:
+                            error();
+                            break;
+                    }
+                    continue;
 
-		case 'S':
-		    result ~= parseSymbolName();
-		    continue;
+                case 'S':
+                    result ~= parseSymbolName();
+                    continue;
 
-		case 'Z':
-		    break;
+                case 'Z':
+                    break;
 
-		default:
-		    error();
-	    }
-	    break;
-	}
-	result ~= ")";
-	return assumeUnique(result);
+                default:
+                    error();
+            }
+            break;
+        }
+        result ~= ")";
+        return assumeUnique(result);
     }
 
     if (name.length < 3 ||
-	name[0] != '_' ||
-	name[1] != 'D' ||
-	!isdigit(name[2]))
+        name[0] != '_' ||
+        name[1] != 'D' ||
+        !isdigit(name[2]))
     {
-	goto Lnot;
+        goto Lnot;
     }
 
     fparseTemplateInstanceName = &parseTemplateInstanceName;
 
     try
     {
-	auto result = parseQualifiedName();
-	result = parseType(result);
-	while(ni < name.length){
-		result ~= " . " ~ parseType(parseQualifiedName());
-	}
+        auto result = parseQualifiedName();
+        result = parseType(result);
+        while(ni < name.length){
+                result ~= " . " ~ parseType(parseQualifiedName());
+        }
 
-	if (ni != name.length)
-	    goto Lnot;
-	return result;
+        if (ni != name.length)
+            goto Lnot;
+        return result;
     }
     catch (MangleException e)
     {
@@ -493,35 +501,31 @@
 
     static string[2][] table =
     [
-	[ "printf",	"printf" ],
-	[ "_foo",	"_foo" ],
-	[ "_D88",	"_D88" ],
-	[ "_D4test3fooAa", "char[] test.foo"],
-	[ "_D8demangle8demangleFAaZAa", "char[] demangle.demangle(char[])" ],
-	[ "_D6object6Object8opEqualsFC6ObjectZi", "int object.Object.opEquals(class Object)" ],
-	[ "_D4test2dgDFiYd", "double delegate(int, ...) test.dg" ],
-	[ "_D4test58__T9factorialVde67666666666666860140VG5aa5_68656c6c6fVPvnZ9factorialf", "float test.factorial!(double 4.2, char[5] \"hello\"c, void* null).factorial" ],
-	[ "_D4test101__T9factorialVde67666666666666860140Vrc9a999999999999d9014000000000000000c00040VG5aa5_68656c6c6fVPvnZ9factorialf", "float test.factorial!(double 4.2, cdouble 6.8+3i, char[5] \"hello\"c, void* null).factorial" ],
-	[ "_D4test34__T3barVG3uw3_616263VG3wd3_646566Z1xi", "int test.bar!(wchar[3] \"abc\"w, dchar[3] \"def\"d).x" ],
-	[ "_D8demangle4testFLC6ObjectLDFLiZiZi", "int demangle.test(lazy class Object, lazy int delegate(lazy int))"],
-	[ "_D8demangle4testFAiXi", "int demangle.test(int[] ...)"],
-	[ "_D8demangle4testFLAiXi", "int demangle.test(lazy int[] ...)"] 
+        [ "printf",        "printf" ],
+        [ "_foo",        "_foo" ],
+        [ "_D88",        "_D88" ],
+        [ "_D4test3fooAa", "char[] test.foo"],
+        [ "_D8demangle8demangleFAaZAa", "char[] demangle.demangle(char[])" ],
+        [ "_D6object6Object8opEqualsFC6ObjectZi", "int object.Object.opEquals(class Object)" ],
+        [ "_D4test2dgDFiYd", "double delegate(int, ...) test.dg" ],
+        [ "_D4test58__T9factorialVde67666666666666860140VG5aa5_68656c6c6fVPvnZ9factorialf", "float test.factorial!(double 4.2, char[5] \"hello\"c, void* null).factorial" ],
+        [ "_D4test101__T9factorialVde67666666666666860140Vrc9a999999999999d9014000000000000000c00040VG5aa5_68656c6c6fVPvnZ9factorialf", "float test.factorial!(double 4.2, cdouble 6.8+3i, char[5] \"hello\"c, void* null).factorial" ],
+        [ "_D4test34__T3barVG3uw3_616263VG3wd3_646566Z1xi", "int test.bar!(wchar[3] \"abc\"w, dchar[3] \"def\"d).x" ],
+        [ "_D8demangle4testFLC6ObjectLDFLiZiZi", "int demangle.test(lazy class Object, lazy int delegate(lazy int))"],
+        [ "_D8demangle4testFAiXi", "int demangle.test(int[] ...)"],
+        [ "_D8demangle4testFLAiXi", "int demangle.test(lazy int[] ...)"],
+        [ "_D6plugin8generateFiiZAya", "immutable(char)[] plugin.generate(int, int)"],
+        [ "_D6plugin8generateFiiZAxa", "const(char)[] plugin.generate(int, int)"],
+        [ "_D6plugin8generateFiiZAOa", "shared(char)[] plugin.generate(int, int)"]
     ];
 
-    foreach (int i, name; table)
+    foreach (i, name; table)
     {
-	// Bugzilla 1377 workaround
-	if (i == 6 || i == 10)
-	    continue;
-
-	static if (real.sizeof != 10) {
-	    if (i == 7 || i == 8)
-		continue;
-	}
-	string r = demangle(name[0]);
-	//writefln("%d, [ \"%s\", \"%s\" ],", i, name[0], r);
-	assert(r == name[1],
-	    "table entry #" ~ toString(i) ~ ": '" ~ name[0] ~ "' demangles as '" ~ r ~ "' but is expected to be '" ~ name[1] ~ "'");
+        string r = demangle(name[0]);
+        assert(r == name[1],
+                "table entry #" ~ to!string(i) ~ ": '" ~ name[0]
+                ~ "' demangles as '" ~ r ~ "' but is expected to be '"
+                ~ name[1] ~ "'");
 
     }
 }
diff -r f12bfe124807 d/phobos2/std/encoding.d
--- a/d/phobos2/std/encoding.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/encoding.d	Thu Oct 14 14:12:53 2010 +0100
@@ -9,28 +9,31 @@
 
 Encodings currently supported are UTF-8, UTF-16, UTF-32, ASCII, ISO-8859-1
 (also known as LATIN-1), and WINDOWS-1252.
-The type AsciiChar represents an ASCII character.
-The type AsciiString represents an ASCII character.
-The type Latin1Char represents an ISO-8859-1 character.
-The type Latin1String represents an ISO-8859-1 character.
-The type Windows1252Char represents a Windows-1252 character.
-The type Windows1252String represents a Windows-1252 character.
-
-For cases where the _encoding is not known at compile-time, but is known at
-run-time, we provide the abstract class EncodingScheme and its subclasses.
-To construct a run-time encoder/decoder, one does e.g.
+
+$(UL
+$(LI The type $(D AsciiChar) represents an ASCII character.)
+$(LI The type $(D AsciiString) represents an ASCII string.)
+$(LI The type $(D Latin1Char) represents an ISO-8859-1 character.)
+$(LI The type $(D Latin1String) represents an ISO-8859-1 string.)
+$(LI The type $(D Windows1252Char) represents a Windows-1252 character.)
+$(LI The type $(D Windows1252String) represents a Windows-1252 string.))
+
+For cases where the _encoding is not known at compile-time, but is
+known at run-time, we provide the abstract class $(D EncodingScheme)
+and its subclasses.  To construct a run-time encoder/decoder, one does
+e.g.
 
 ----------------------------------------------------
     auto e = EncodingScheme.create("utf-8");
 ----------------------------------------------------
 
-This library supplies EncodingScheme subclasses for ASCII, ISO-8859-1
-(also known as LATIN-1), WINDOWS-1252, UTF-8, and (on little-endian
-architectures) UTF-16LE and UTF-32LE; or (on big-endian architectures)
-UTF-16BE and UTF-32BE.
-
-This library provides a mechanism whereby other modules may add EncodingScheme
-subclasses for any other encoding.
+This library supplies $(D EncodingScheme) subclasses for ASCII,
+ISO-8859-1 (also known as LATIN-1), WINDOWS-1252, UTF-8, and (on
+little-endian architectures) UTF-16LE and UTF-32LE; or (on big-endian
+architectures) UTF-16BE and UTF-32BE.
+
+This library provides a mechanism whereby other modules may add $(D
+EncodingScheme) subclasses for any other _encoding.
 
 Authors: Janice Caron
 
@@ -38,7 +41,6 @@
 
 License: Public Domain
 
-
 Macros:
     WIKI=Phobos/StdEncoding
 */
@@ -46,6 +48,7 @@
 module std.encoding;
 import std.string;
 import std.traits;
+import std.range;
 
 unittest
 {
@@ -68,26 +71,32 @@
         [ 0xEF, 0xBF, 0xBF ],           // U+0000FFFF   three bytes
 
         // Other boundary conditions
-        [ 0xED, 0x9F, 0xBF ],           // U+0000D7FF   Last character before surrogates
-        [ 0xEE, 0x80, 0x80 ],           // U+0000E000   First character after surrogates
-        [ 0xEF, 0xBF, 0xBD ],           // U+0000FFFD   Unicode replacement character
-        [ 0xF4, 0x8F, 0xBF, 0xBF ],     // U+0010FFFF   Very last character
+        [ 0xED, 0x9F, 0xBF ],
+        // U+0000D7FF   Last character before surrogates
+        [ 0xEE, 0x80, 0x80 ],
+        // U+0000E000   First character after surrogates
+        [ 0xEF, 0xBF, 0xBD ],
+        // U+0000FFFD   Unicode replacement character
+        [ 0xF4, 0x8F, 0xBF, 0xBF ],
+        // U+0010FFFF   Very last character
 
         // Non-character code points
-        /*  NOTE: These are legal in UTF, and may be converted from one UTF to
-            another, however they do not represent Unicode characters. These
-            code points have been reserved by Unicode as non-character code
-            points. They are permissible for data exchange within an
-            application, but they are are not permitted to be used as
-            characters. Since this module deals with UTF, and not with Unicode
-            per se, we choose to accept them here. */
+        /*  NOTE: These are legal in UTF, and may be converted from
+            one UTF to another, however they do not represent Unicode
+            characters. These code points have been reserved by
+            Unicode as non-character code points. They are permissible
+            for data exchange within an application, but they are are
+            not permitted to be used as characters. Since this module
+            deals with UTF, and not with Unicode per se, we choose to
+            accept them here. */
         [ 0xDF, 0xBE ],                 // U+0000FFFE
         [ 0xDF, 0xBF ],                 // U+0000FFFF
     ];
 
     ubyte[][] invalidStrings =
     [
-        // First possible sequence of a certain length, but greater than U+10FFFF
+        // First possible sequence of a certain length, but greater
+        // than U+10FFFF
         [ 0xF8, 0x88, 0x80, 0x80, 0x80 ],           // U+00200000   five bytes
         [ 0xFC, 0x84, 0x80, 0x80, 0x80, 0x80 ],     // U+04000000   six bytes
 
@@ -97,8 +106,10 @@
         [ 0xFD, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF ],     // U+7FFFFFFF   six bytes
 
         // Other boundary conditions
-        [ 0xF4, 0x90, 0x80, 0x80 ],                 // U+00110000   First code
-                                                    // point after last character
+        [ 0xF4, 0x90, 0x80, 0x80 ],                 // U+00110000
+                                                    // First code
+                                                    // point after
+                                                    // last character
 
         // Unexpected continuation bytes
         [ 0x80 ],
@@ -239,7 +250,7 @@
 
     // Make sure all transcodings work in both directions, using both forward
     // and reverse iteration
-    foreach(a;validStrings)
+    foreach(a; validStrings)
     {
         string s = cast(string)a;
         string s2;
@@ -347,62 +358,8 @@
 
 //=============================================================================
 
-/* A simple growable buffer for fast appending */
-deprecated struct Buffer(E)
-{
-    alias Mutable!(E) T;
-
-    private
-    {
-        T[] buffer;
-        uint index;
-
-        void reserve(uint spaceNeeded)
-        {
-            uint bufferLength = buffer.length;
-            if (bufferLength < index + spaceNeeded)
-            {
-                if (bufferLength == 0) bufferLength = 16;
-                while (bufferLength < index + spaceNeeded) bufferLength <<= 2;
-                buffer.length = bufferLength;
-            }
-        }
-    }
-
-    void opCatAssign(E c) // Append a single character
-    {
-        reserve(1);
-        buffer[index++] = c;
-    }
-
-    void opCatAssign(const(E)[] a) // Append an array of characters
-    {
-        reserve(a.length);
-        buffer[index..index+a.length] = a[0..$];
-        index += a.length;
-    }
-
-    T[] toArray() // Return the buffer, and reset it
-    {
-        auto t = buffer[0..index];
-        buffer = null;
-        index = 0;
-        return t;
-    }
-
-    invariant(T)[] toIArray() // Return the buffer as an invariant array, and reset it
-    {
-        auto t = cast(invariant(T)[])(buffer[0..index]);
-        buffer = null;
-        index = 0;
-        return t;
-    }
-}
-
-//=============================================================================
-
-/** Special value returned by safeDecode */
-enum dchar INVALID_SEQUENCE = cast(dchar)0xFFFFFFFF;
+/** Special value returned by $(D safeDecode) */
+enum dchar INVALID_SEQUENCE = cast(dchar) 0xFFFFFFFF;
 
 template EncoderFunctions()
 {
@@ -546,12 +503,6 @@
     	e.encode(c);
     }
 
-    deprecated void encode(dchar c, ref Buffer!(E) buffer)
-    {
-        mixin EncodeToBuffer e;
-        e.encode(c);
-    }
-    
     void encode(dchar c, void delegate(E) dg)
     {
         mixin EncodeToDelegate e;
@@ -564,13 +515,13 @@
         e.skip();
     }
 
-    dchar decode(ref const(E)[] s)
+    dchar decode(S)(ref S s)
     {
         mixin DecodeFromString e;
         return e.decode();
     }
 
-    dchar safeDecode(ref const(E)[] s)
+    dchar safeDecode(S)(ref S s)
     {
         mixin SafeDecodeFromString e;
         return e.safeDecode();
@@ -706,11 +657,14 @@
 //          ASCII
 //=============================================================================
 
-typedef char AsciiChar; ///
-alias invariant(AsciiChar)[] AsciiString; ///
-
-template EncoderInstance(E:AsciiChar)
+/** Defines various character sets. */
+typedef ubyte AsciiChar;
+/// Ditto
+alias invariant(AsciiChar)[] AsciiString; 
+
+template EncoderInstance(CharType : AsciiChar)
 {
+    alias AsciiChar E;
     alias AsciiString EString;
 
     string encodingName()
@@ -735,7 +689,13 @@
     }
     body
     {
-		return 1;
+        return 1;
+    }
+
+    void encodeX(Range)(dchar c, Range r)
+    {
+        if (!canEncode(c)) c = '?';
+        r.write(cast(AsciiChar) c);
     }
 
     void encodeViaWrite()(dchar c)
@@ -777,11 +737,17 @@
 //          ISO-8859-1
 //=============================================================================
 
-typedef ubyte Latin1Char; ///
+/** Defines an Latin1-encoded character. */
+typedef ubyte Latin1Char;
+/**
+Defines an Latin1-encoded string (as an array of $(D
+invariant(Latin1Char))).
+ */
 alias invariant(Latin1Char)[] Latin1String; ///
 
-template EncoderInstance(E:Latin1Char)
+template EncoderInstance(CharType : Latin1Char)
 {
+    alias Latin1Char E;
     alias Latin1String EString;
 
     string encodingName()
@@ -847,11 +813,17 @@
 //          WINDOWS-1252
 //=============================================================================
 
-typedef ubyte Windows1252Char; ///
+/** Defines a Windows1252-encoded character. */
+typedef ubyte Windows1252Char;
+/**
+Defines an Windows1252-encoded string (as an array of $(D
+invariant(Windows1252Char))).
+ */
 alias invariant(Windows1252Char)[] Windows1252String; ///
 
-template EncoderInstance(E:Windows1252Char)
+template EncoderInstance(CharType : Windows1252Char)
 {
+    alias Windows1252Char E;
     alias Windows1252String EString;
 
     string encodingName()
@@ -859,7 +831,7 @@
         return "windows-1252";
     }
 
-    wstring charMap =
+    invariant wstring charMap =
         "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021"
         "\u02C6\u2030\u0160\u2039\u0152\uFFFD\u017D\uFFFD"
         "\uFFFD\u2018\u2019\u201C\u201D\u2022\u2103\u2014"
@@ -868,7 +840,7 @@
 
     bool canEncode(dchar c)
     {
-        if (c < 0x80 || (c >= 0xA0 && c <0x100)) return true;
+        if (c < 0x80 || (c >= 0xA0 && c < 0x100)) return true;
         if (c >= 0xFFFD) return false;
         foreach(wchar d;charMap) { if (c == d) return true; }
         return false;
@@ -887,12 +859,12 @@
     }
     body
     {
-		return 1;
+        return 1;
     }
 
     void encodeViaWrite()(dchar c)
     {
-        if (c < 0x80 || (c >= 0xA0 && c <0x100)) {}
+        if (c < 0x80 || (c >= 0xA0 && c < 0x100)) {}
         else if (c >= 0xFFFD) { c = '?'; }
         else
         {
@@ -946,8 +918,9 @@
 //          UTF-8
 //=============================================================================
 
-template EncoderInstance(E:char)
+template EncoderInstance(CharType : char)
 {
+    alias char E;
     alias invariant(char)[] EString;
 
     string encodingName()
@@ -965,7 +938,7 @@
         return (c < 0xC0 || (c >= 0xC2 && c < 0xF5));
     }
 
-    byte[128] tailTable =
+    immutable ubyte[128] tailTable =
     [
         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
@@ -994,10 +967,10 @@
     }
     body
     {
-		if (c < 0x80) return 1;
-		if (c < 0x800) return 2;
-		if (c < 0x10000) return 3;
-		return 4;
+        if (c < 0x80) return 1;
+        if (c < 0x800) return 2;
+        if (c < 0x10000) return 3;
+        return 4;
     }
 
     void encodeViaWrite()(dchar c)
@@ -1030,7 +1003,7 @@
     {
         auto c = read;
         if (c < 0xC0) return;
-        int n = tails(c);
+        int n = tails(cast(char) c);
         for (uint i=0; i<n; ++i)
         {
             read();
@@ -1041,7 +1014,7 @@
     {
         auto c = read;
         if (c < 0xC0) return c;
-        int n = tails(c);
+        int n = tails(cast(char) c);
         c &= (1 << (6 - n)) - 1;
         for (uint i=0; i<n; ++i)
         {
@@ -1091,7 +1064,7 @@
         {
             shift += 6;
             auto d = read;
-            uint n = tails(d);
+            uint n = tails(cast(char) d);
             uint mask = n == 0 ? 0x3F : (1 << (6 - n)) - 1;
             c += ((d & mask) << shift);
             if (n != 0) break;
@@ -1111,9 +1084,10 @@
 //          UTF-16
 //=============================================================================
 
-template EncoderInstance(E:wchar)
+template EncoderInstance(CharType : wchar)
 {
-    alias invariant(wchar)[] EString;
+    alias wchar E;
+    alias immutable(wchar)[] EString;
 
     string encodingName()
     {
@@ -1207,9 +1181,10 @@
 //          UTF-32
 //=============================================================================
 
-template EncoderInstance(E:dchar)
+template EncoderInstance(CharType : dchar)
 {
-    alias invariant(dchar)[] EString;
+    alias dchar E;
+    alias immutable(dchar)[] EString;
 
     string encodingName()
     {
@@ -1274,19 +1249,19 @@
 // Below are forwarding functions which expose the function to the user
 
 /**
- * Returns true if c is a valid code point
- *
- * Note that this includes the non-character code points U+FFFE and U+FFFF,
- * since these are valid code points (even though they are not valid
- * characters).
- *
- * Supercedes:
- * This function supercedes std.utf.startsValidDchar().
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    c = the code point to be tested
+Returns true if c is a valid code point
+
+ Note that this includes the non-character code points U+FFFE and U+FFFF,
+ since these are valid code points (even though they are not valid
+ characters).
+
+ Supercedes:
+ This function supercedes $(D std.utf.startsValidDchar()).
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    c = the code point to be tested
  */
 bool isValidCodePoint(dchar c)
 {
@@ -1294,18 +1269,17 @@
 }
 
 /**
- * Returns the name of an encoding.
- *
- * The type of encoding cannot be deduced. Therefore, it is necessary to
- * explicitly specify the encoding type.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Examples:
- * -----------------------------------
- * writefln(encodingName!(Latin1Char));
- *     // writes ISO-8859-1
- * -----------------------------------
+ Returns the name of an encoding.
+
+ The type of encoding cannot be deduced. Therefore, it is necessary to
+ explicitly specify the encoding type.
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Examples:
+ -----------------------------------
+ assert(encodingName!(Latin1Char) == "ISO-8859-1");
+ -----------------------------------
  */
 string encodingName(T)()
 {
@@ -1323,19 +1297,18 @@
 }
 
 /**
- * Returns true iff it is possible to represent the specifed codepoint
- * in the encoding.
- *
- * The type of encoding cannot be deduced. Therefore, it is necessary to
- * explicitly specify the encoding type.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Examples:
- * -----------------------------------
- * writefln(canEncode!(Latin1Char)('A'));
- *     // writes true
- * -----------------------------------
+ Returns true iff it is possible to represent the specifed codepoint
+ in the encoding.
+
+ The type of encoding cannot be deduced. Therefore, it is necessary to
+ explicitly specify the encoding type.
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Examples:
+ -----------------------------------
+ assert(canEncode!(Latin1Char)('A'));
+ -----------------------------------
  */
 bool canEncode(E)(dchar c)
 {
@@ -1353,14 +1326,14 @@
 }
 
 /**
- * Returns true if the code unit is legal. For example, the byte 0x80 would
- * not be legal in ASCII, because ASCII code units must always be in the range
- * 0x00 to 0x7F.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    c = the code unit to be tested
+ Returns true if the code unit is legal. For example, the byte 0x80 would
+ not be legal in ASCII, because ASCII code units must always be in the range
+ 0x00 to 0x7F.
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    c = the code unit to be tested
  */
 bool isValidCodeUnit(E)(E c)
 {
@@ -1379,27 +1352,21 @@
 }
 
 /**
- * Returns true if the string is encoded correctly
- *
- * Supercedes:
- * This function supercedes std.utf.validate(), however note that this
- * function returns a bool indicating whether the input was valid or not,
- * wheras the older funtion would throw an exception.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    s = the string to be tested
+ Returns true if the string is encoded correctly
+
+ Supercedes:
+ This function supercedes std.utf.validate(), however note that this
+ function returns a bool indicating whether the input was valid or not,
+ wheras the older funtion would throw an exception.
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    s = the string to be tested
  */
 bool isValid(E)(const(E)[] s)
 {
-    while (s.length != 0)
-    {
-        dchar d = EncoderInstance!(E).safeDecode(s);
-        if (d == INVALID_SEQUENCE)
-            return false;
-    }
-    return true;
+    return s.length == validLength(s);
 }
 
 unittest
@@ -1408,53 +1375,52 @@
 }
 
 /**
- * Returns the length of the longest possible substring, starting from
- * the first code unit, which is validly encoded.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    s = the string to be tested
+ Returns the length of the longest possible substring, starting from
+ the first code unit, which is validly encoded.
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    s = the string to be tested
  */
 uint validLength(E)(const(E)[] s)
 {
-    const(E)[] r = s;
-    const(E)[] t = s;
-    while (s.length != 0)
+    uint result, before = void;
+    while ((before = s.length) > 0)
     {
         if (EncoderInstance!(E).safeDecode(s) == INVALID_SEQUENCE)
             break;
-        t = s;
+        result += before - s.length;
     }
-    return r.length - t.length;
+    return result;
 }
 
 /**
- * Sanitizes a string by replacing malformed code unit sequences with valid
- * code unit sequences. The result is guaranteed to be valid for this encoding.
- *
- * If the input string is already valid, this function returns the original,
- * otherwise it constructs a new string by replacing all illegal code unit
- * sequences with the encoding's replacement character, Invalid sequences will
- * be replaced with the Unicode replacement character (U+FFFD) if the
- * character repertoire contains it, otherwise invalid sequences will be
- * replaced with '?'.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    s = the string to be sanitized
+ Sanitizes a string by replacing malformed code unit sequences with valid
+ code unit sequences. The result is guaranteed to be valid for this encoding.
+
+ If the input string is already valid, this function returns the original,
+ otherwise it constructs a new string by replacing all illegal code unit
+ sequences with the encoding's replacement character, Invalid sequences will
+ be replaced with the Unicode replacement character (U+FFFD) if the
+ character repertoire contains it, otherwise invalid sequences will be
+ replaced with '?'.
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    s = the string to be sanitized
  */
-invariant(E)[] sanitize(E)(invariant(E)[] s)
+immutable(E)[] sanitize(E)(immutable(E)[] s)
 {
     uint n = validLength(s);
     if (n == s.length) return s;
 
     auto repSeq = EncoderInstance!(E).replacementSequence;
 
-	// Count how long the string needs to be.
-	// Overestimating is not a problem
-	uint len = s.length;
+    // Count how long the string needs to be.
+    // Overestimating is not a problem
+    uint len = s.length;
     const(E)[] t = s[n..$];
     while (t.length != 0)
     {
@@ -1481,7 +1447,7 @@
         offset += n;
         t = t[n..$];
     }
-    return cast(invariant(E)[])array[0..offset];
+    return cast(immutable(E)[])array[0..offset];
 }
 
 unittest
@@ -1490,17 +1456,17 @@
 }
 
 /**
- * Returns the length of the first encoded sequence.
- *
- * The input to this function MUST be validly encoded.
- * This is enforced by the function's in-contract.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    s = the string to be sliced
+Returns the length of the first encoded sequence.
+
+The input to this function MUST be validly encoded.
+This is enforced by the function's in-contract.
+
+Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+Params:
+s = the string to be sliced
  */
-uint firstSequence(E)(const(E)[] s) /// ditto
+uint firstSequence(E)(const(E)[] s)
 in
 {
     assert(s.length != 0);
@@ -1509,9 +1475,9 @@
 }
 body
 {
-    const(E)[] t = s;
+    auto before = s.length;
     EncoderInstance!(E).skip(s);
-    return t.length - s.length;
+    return before - s.length;
 }
 
 unittest
@@ -1520,17 +1486,17 @@
 }
 
 /**
- * Returns the length the last encoded sequence.
- *
- * The input to this function MUST be validly encoded.
- * This is enforced by the function's in-contract.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    s = the string to be sliced
+ Returns the length the last encoded sequence.
+
+ The input to this function MUST be validly encoded.
+ This is enforced by the function's in-contract.
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    s = the string to be sliced
  */
-uint lastSequence(E)(const(E)[] s) /// ditto
+uint lastSequence(E)(const(E)[] s)
 in
 {
     assert(s.length != 0);
@@ -1549,18 +1515,17 @@
 }
 
 /**
- * Returns the total number of code points encoded in a string.
- *
- * The input to this function MUST be validly encoded.
- * This is enforced by the function's in-contract.
- *
- * Supercedes:
- * This function supercedes std.utf.toUCSindex().
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    s = the string to be counted
+Returns the total number of code points encoded in a string.
+
+The input to this function MUST be validly encoded.  This is enforced
+by the function's in-contract.
+
+Supercedes: This function supercedes $(D std.utf.toUCSindex()).
+
+Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+Params:
+s = the string to be counted
  */
 uint count(E)(const(E)[] s)
 in
@@ -1584,18 +1549,18 @@
 }
 
 /**
- * Returns the array index at which the (n+1)th code point begins.
- *
- * The input to this function MUST be validly encoded.
- * This is enforced by the function's in-contract.
- *
- * Supercedes:
- * This function supercedes std.utf.toUTFindex().
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    s = the string to be counted
+ Returns the array index at which the (n+1)th code point begins.
+
+ The input to this function MUST be validly encoded.
+ This is enforced by the function's in-contract.
+
+ Supercedes:
+ This function supercedes std.utf.toUTFindex().
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    s = the string to be counted
  */
 int index(E)(const(E)[] s,int n)
 in
@@ -1616,48 +1581,48 @@
 }
 
 /**
- * Decodes a single code point.
- *
- * This function removes one or more code units from the start of a string,
- * and returns the decoded code point which those code units represent.
- *
- * The input to this function MUST be validly encoded.
- * This is enforced by the function's in-contract.
- *
- * Supercedes:
- * This function supercedes std.utf.decode(), however, note that the
- * function codePoints() supercedes it more conveniently.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    s = the string whose first code point is to be decoded
+ Decodes a single code point.
+
+ This function removes one or more code units from the start of a string,
+ and returns the decoded code point which those code units represent.
+
+ The input to this function MUST be validly encoded.
+ This is enforced by the function's in-contract.
+
+ Supercedes:
+ This function supercedes std.utf.decode(), however, note that the
+ function codePoints() supercedes it more conveniently.
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    s = the string whose first code point is to be decoded
  */
-dchar decode(E)(ref const(E)[] s)
+dchar decode(S)(ref S s)
 in
 {
     assert(s.length != 0);
-    const(E)[] u = s;
+    auto u = s;
     assert(safeDecode(u) != INVALID_SEQUENCE);
 }
 body
 {
-    return EncoderInstance!(E).decode(s);
+    return EncoderInstance!(typeof(s[0])).decode(s);
 }
 
 /**
- * Decodes a single code point from the end of a string.
- *
- * This function removes one or more code units from the end of a string,
- * and returns the decoded code point which those code units represent.
- *
- * The input to this function MUST be validly encoded.
- * This is enforced by the function's in-contract.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    s = the string whose first code point is to be decoded
+ Decodes a single code point from the end of a string.
+
+ This function removes one or more code units from the end of a string,
+ and returns the decoded code point which those code units represent.
+
+ The input to this function MUST be validly encoded.
+ This is enforced by the function's in-contract.
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    s = the string whose first code point is to be decoded
  */
 dchar decodeReverse(E)(ref const(E)[] s)
 in
@@ -1671,43 +1636,43 @@
 }
 
 /**
- * Decodes a single code point. The input does not have to be valid.
- *
- * This function removes one or more code units from the start of a string,
- * and returns the decoded code point which those code units represent.
- *
- * This function will accept an invalidly encoded string as input.
- * If an invalid sequence is found at the start of the string, this
- * function will remove it, and return the value INVALID_SEQUENCE.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    s = the string whose first code point is to be decoded
+ Decodes a single code point. The input does not have to be valid.
+
+ This function removes one or more code units from the start of a string,
+ and returns the decoded code point which those code units represent.
+
+ This function will accept an invalidly encoded string as input.
+ If an invalid sequence is found at the start of the string, this
+ function will remove it, and return the value INVALID_SEQUENCE.
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    s = the string whose first code point is to be decoded
  */
-dchar safeDecode(E)(ref const(E)[] s)
+dchar safeDecode(S)(ref S s)
 in
 {
     assert(s.length != 0);
 }
 body
 {
-    return EncoderInstance!(E).safeDecode(s);
+    return EncoderInstance!(typeof(s[0])).safeDecode(s);
 }
 
 /**
- * Returns the number of code units required to encode a single code point.
- *
- * The input to this function MUST be a valid code point.
- * This is enforced by the function's in-contract.
- *
- * The type of the output cannot be deduced. Therefore, it is necessary to
- * explicitly specify the encoding as a template parameter.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    c = the code point to be encoded
+ Returns the number of code units required to encode a single code point.
+
+ The input to this function MUST be a valid code point.
+ This is enforced by the function's in-contract.
+
+ The type of the output cannot be deduced. Therefore, it is necessary to
+ explicitly specify the encoding as a template parameter.
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    c = the code point to be encoded
  */
 uint encodedLength(E)(dchar c)
 in
@@ -1720,25 +1685,25 @@
 }
 
 /**
- * Encodes a single code point.
- *
- * This function encodes a single code point into one or more code units.
- * It returns a string containing those code units.
- *
- * The input to this function MUST be a valid code point.
- * This is enforced by the function's in-contract.
- *
- * The type of the output cannot be deduced. Therefore, it is necessary to
- * explicitly specify the encoding as a template parameter.
- *
- * Supercedes:
- * This function supercedes std.utf.encode(), however, note that the
- * function codeUnits() supercedes it more conveniently.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    c = the code point to be encoded
+ Encodes a single code point.
+
+ This function encodes a single code point into one or more code units.
+ It returns a string containing those code units.
+
+ The input to this function MUST be a valid code point.
+ This is enforced by the function's in-contract.
+
+ The type of the output cannot be deduced. Therefore, it is necessary to
+ explicitly specify the encoding as a template parameter.
+
+ Supercedes:
+ This function supercedes std.utf.encode(), however, note that the
+ function codeUnits() supercedes it more conveniently.
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    c = the code point to be encoded
  */
 E[] encode(E)(dchar c)
 in
@@ -1751,29 +1716,29 @@
 }
 
 /**
- * Encodes a single code point into an array.
- *
- * This function encodes a single code point into one or more code units
- * The code units are stored in a user-supplied fixed-size array,
- * which must be passed by reference.
- *
- * The input to this function MUST be a valid code point.
- * This is enforced by the function's in-contract.
- *
- * The type of the output cannot be deduced. Therefore, it is necessary to
- * explicitly specify the encoding as a template parameter.
- *
- * Supercedes:
- * This function supercedes std.utf.encode(), however, note that the
- * function codeUnits() supercedes it more conveniently.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    c = the code point to be encoded
- *
- * Returns:
- *	  the number of code units written to the array
+ Encodes a single code point into an array.
+
+ This function encodes a single code point into one or more code units
+ The code units are stored in a user-supplied fixed-size array,
+ which must be passed by reference.
+
+ The input to this function MUST be a valid code point.
+ This is enforced by the function's in-contract.
+
+ The type of the output cannot be deduced. Therefore, it is necessary to
+ explicitly specify the encoding as a template parameter.
+
+ Supercedes:
+ This function supercedes std.utf.encode(), however, note that the
+ function codeUnits() supercedes it more conveniently.
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    c = the code point to be encoded
+
+ Returns:
+	  the number of code units written to the array
  */
 uint encode(E)(dchar c, E[] array)
 in
@@ -1787,57 +1752,119 @@
     return array.length - t.length;
 }
 
+// /**
+//  * Encodes a single code point into a Buffer.
+//  *
+//  * This function encodes a single code point into one or more code units
+//  * The code units are stored in a growable buffer.
+//  *
+//  * The input to this function MUST be a valid code point.
+//  * This is enforced by the function's in-contract.
+//  *
+//  * The type of the output cannot be deduced. Therefore, it is necessary to
+//  * explicitly specify the encoding as a template parameter.
+//  *
+//  * Supercedes:
+//  * This function supercedes std.utf.encode(), however, note that the
+//  * function codeUnits() supercedes it more conveniently.
+//  *
+//  * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+//  *
+//  * Params:
+//  *    c = the code point to be encoded
+//  */
+// deprecated void encode(E)(dchar c, ref Buffer!(E) buffer)
+// in
+// {
+//     assert(isValidCodePoint(c));
+// }
+// body
+// {
+//     EncoderInstance!(E).encode(c,buffer);
+// }
+
 /**
- * Encodes a single code point into a Buffer.
- *
- * This function encodes a single code point into one or more code units
- * The code units are stored in a growable buffer.
- *
- * The input to this function MUST be a valid code point.
- * This is enforced by the function's in-contract.
- *
- * The type of the output cannot be deduced. Therefore, it is necessary to
- * explicitly specify the encoding as a template parameter.
- *
- * Supercedes:
- * This function supercedes std.utf.encode(), however, note that the
- * function codeUnits() supercedes it more conveniently.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    c = the code point to be encoded
+Encodes $(D c) in units of type $(D E) and writes the result to the
+output range $(D R). Returns the number of $(D E)s written.
  */
-deprecated void encode(E)(dchar c, ref Buffer!(E) buffer)
-in
+
+uint encode(E, R)(dchar c, R range)
 {
-    assert(isValidCodePoint(c));
+    static if (is(E == char))
+    {
+        if (c <= 0x7F)
+        {
+            range.put(cast(char) c);
+            return 1;
+        }
+        if (c <= 0x7FF)
+        {
+            range.put(cast(char)(0xC0 | (c >> 6)));
+            range.put(cast(char)(0x80 | (c & 0x3F)));
+            return 2;
+        }
+        if (c <= 0xFFFF)
+        {
+            range.put(cast(char)(0xE0 | (c >> 12)));
+            range.put(cast(char)(0x80 | ((c >> 6) & 0x3F)));
+            range.put(cast(char)(0x80 | (c & 0x3F)));
+            return 3;
+        }
+        if (c <= 0x10FFFF)
+        {
+            range.put(cast(char)(0xF0 | (c >> 18)));
+            range.put(cast(char)(0x80 | ((c >> 12) & 0x3F)));
+            range.put(cast(char)(0x80 | ((c >> 6) & 0x3F)));
+            range.put(cast(char)(0x80 | (c & 0x3F)));
+            return 4;
+        }
+        else
+        {
+            assert(0);
+        }
+    }
+    else static if (is(E == wchar))
+    {
+        if (c <= 0xFFFF)
+        {
+            r.put(cast(wchar) c);
+            return 1;
+        }
+        r.put(cast(wchar) ((((c - 0x10000) >> 10) & 0x3FF) + 0xD800));
+        r.put(cast(wchar) (((c - 0x10000) & 0x3FF) + 0xDC00));
+        return 2;
+    }
+    else static if (is(E == dchar))
+    {
+        r.put(c);
+        return 1;
+    }
+    else
+    {
+        return 0;
+    }
 }
-body
-{
-    EncoderInstance!(E).encode(c,buffer);
-}
 
 /**
- * Encodes a single code point to a delegate.
- *
- * This function encodes a single code point into one or more code units.
- * The code units are passed one at a time to the supplied delegate.
- *
- * The input to this function MUST be a valid code point.
- * This is enforced by the function's in-contract.
- *
- * The type of the output cannot be deduced. Therefore, it is necessary to
- * explicitly specify the encoding as a template parameter.
- *
- * Supercedes:
- * This function supercedes std.utf.encode(), however, note that the
- * function codeUnits() supercedes it more conveniently.
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    c = the code point to be encoded
+ Encodes a single code point to a delegate.
+
+ This function encodes a single code point into one or more code units.
+ The code units are passed one at a time to the supplied delegate.
+
+ The input to this function MUST be a valid code point.
+ This is enforced by the function's in-contract.
+
+ The type of the output cannot be deduced. Therefore, it is necessary to
+ explicitly specify the encoding as a template parameter.
+
+ Supercedes:
+ This function supercedes std.utf.encode(), however, note that the
+ function codeUnits() supercedes it more conveniently.
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    c = the code point to be encoded
  */
 void encode(E)(dchar c, void delegate(E) dg)
 in
@@ -1850,38 +1877,38 @@
 }
 
 /**
- * Returns a foreachable struct which can bidirectionally iterate over all
- * code points in a string.
- *
- * The input to this function MUST be validly encoded.
- * This is enforced by the function's in-contract.
- *
- * You can foreach either
- * with or without an index. If an index is specified, it will be initialized
- * at each iteration with the offset into the string at which the code point
- * begins.
- *
- * Supercedes:
- * This function supercedes std.utf.decode().
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    s = the string to be decoded
- *
- * Examples:
- * --------------------------------------------------------
- * string s = "hello world";
- * foreach(c;codePoints(s))
- * {
- *     // do something with c (which will always be a dchar)
- * }
- * --------------------------------------------------------
- *
- * Note that, currently, foreach(c:codePoints(s)) is superior to foreach(c;s)
- * in that the latter will fall over on encountering U+FFFF.
+ Returns a foreachable struct which can bidirectionally iterate over all
+ code points in a string.
+
+ The input to this function MUST be validly encoded.
+ This is enforced by the function's in-contract.
+
+ You can foreach either
+ with or without an index. If an index is specified, it will be initialized
+ at each iteration with the offset into the string at which the code point
+ begins.
+
+ Supercedes:
+ This function supercedes std.utf.decode().
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    s = the string to be decoded
+
+ Examples:
+ --------------------------------------------------------
+ string s = "hello world";
+ foreach(c;codePoints(s))
+ {
+     // do something with c (which will always be a dchar)
+ }
+ --------------------------------------------------------
+
+ Note that, currently, foreach(c:codePoints(s)) is superior to foreach(c;s)
+ in that the latter will fall over on encountering U+FFFF.
  */
-CodePoints!(E) codePoints(E)(invariant(E)[] s)
+CodePoints!(E) codePoints(E)(immutable(E)[] s)
 in
 {
     assert(isValid(s));
@@ -1903,35 +1930,35 @@
 }
 
 /**
- * Returns a foreachable struct which can bidirectionally iterate over all
- * code units in a code point.
- *
- * The input to this function MUST be a valid code point.
- * This is enforced by the function's in-contract.
- *
- * The type of the output cannot be deduced. Therefore, it is necessary to
- * explicitly specify the encoding type in the template parameter.
- *
- * Supercedes:
- * This function supercedes std.utf.encode().
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    d = the code point to be encoded
- *
- * Examples:
- * --------------------------------------------------------
- * dchar d = '\u20AC';
- * foreach(c;codeUnits!(char)(d))
- * {
- *     writefln("%X",c)
- * }
- * // will print
- * // E2
- * // 82
- * // AC
- * --------------------------------------------------------
+ Returns a foreachable struct which can bidirectionally iterate over all
+ code units in a code point.
+
+ The input to this function MUST be a valid code point.
+ This is enforced by the function's in-contract.
+
+ The type of the output cannot be deduced. Therefore, it is necessary to
+ explicitly specify the encoding type in the template parameter.
+
+ Supercedes:
+ This function supercedes std.utf.encode().
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    d = the code point to be encoded
+
+ Examples:
+ --------------------------------------------------------
+ dchar d = '\u20AC';
+ foreach(c;codeUnits!(char)(d))
+ {
+     writefln("%X",c)
+ }
+ // will print
+ // E2
+ // 82
+ // AC
+ --------------------------------------------------------
  */
 CodeUnits!(E) codeUnits(E)(dchar c)
 in
@@ -1957,34 +1984,49 @@
 }
 
 /**
- * Convert a string from one encoding to another. (See also to!() below).
- *
- * The input to this function MUST be validly encoded.
- * This is enforced by the function's in-contract.
- *
- * Supercedes:
- * This function supercedes std.utf.toUTF8(), std.utf.toUTF16() and
- * std.utf.toUTF32()
- * (but note that to!() supercedes it more conveniently).
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    s = the source string
- *    r = the destination string
- *
- * Examples:
- * --------------------------------------------------------
- * wstring ws;
- * transcode("hello world",ws);
- *     // transcode from UTF-8 to UTF-16
- *
- * Latin1String ls;
- * transcode(ws, ls);
- *     // transcode from UTF-16 to ISO-8859-1
- * --------------------------------------------------------
+Encodes $(D c) in units of type $(D E) and writes the result to the
+output range $(D R). Returns the number of $(D E)s written.
  */
-void transcode(Src,Dst)(invariant(Src)[] s,out invariant(Dst)[] r)
+
+uint encode(Tgt, Src, R)(in Src[] s, R range)
+{
+    uint result;
+    foreach (c; s)
+    {
+        result += encode!(Tgt)(c, range);
+    }
+    return result;
+}
+
+/**
+ Convert a string from one encoding to another. (See also to!() below).
+
+ The input to this function MUST be validly encoded.
+ This is enforced by the function's in-contract.
+
+ Supercedes:
+ This function supercedes std.utf.toUTF8(), std.utf.toUTF16() and
+ std.utf.toUTF32()
+ (but note that to!() supercedes it more conveniently).
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    s = the source string
+    r = the destination string
+
+ Examples:
+ --------------------------------------------------------
+ wstring ws;
+ transcode("hello world",ws);
+     // transcode from UTF-8 to UTF-16
+
+ Latin1String ls;
+ transcode(ws, ls);
+     // transcode from UTF-16 to ISO-8859-1
+  --------------------------------------------------------
+ */
+void transcode(Src,Dst)(immutable(Src)[] s,out immutable(Dst)[] r)
 in
 {
     assert(isValid(s));
@@ -2010,29 +2052,29 @@
 }
 
 /*
- * Convert a string from one encoding to another. (See also transcode() above).
- *
- * The input to this function MUST be validly encoded.
- * This is enforced by the function's in-contract.
- *
- * Supercedes:
- * This function supercedes std.utf.toUTF8(), std.utf.toUTF16() and
- * std.utf.toUTF32().
- *
- * Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
- *
- * Params:
- *    Dst = the destination encoding type
- *    s = the source string
- *
- * Examples:
- * -----------------------------------------------------------------------------
- * auto ws = to!(wchar)("hello world");  // transcode from UTF-8 to UTF-16
- * auto ls = to!(Latin1Char)(ws);            // transcode from UTF-16 to ISO-8859-1
- * -----------------------------------------------------------------------------
+ Convert a string from one encoding to another. (See also transcode() above).
+
+ The input to this function MUST be validly encoded.
+ This is enforced by the function's in-contract.
+
+ Supercedes:
+ This function supercedes std.utf.toUTF8(), std.utf.toUTF16() and
+ std.utf.toUTF32().
+
+ Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252
+
+ Params:
+    Dst = the destination encoding type
+    s = the source string
+
+ Examples:
+ -----------------------------------------------------------------------------
+ auto ws = to!(wchar)("hello world");  // transcode from UTF-8 to UTF-16
+ auto ls = to!(Latin1Char)(ws);            // transcode from UTF-16 to ISO-8859-1
+ -----------------------------------------------------------------------------
  */
 // TODO: Commented out for no - to be moved to std.conv
-// Dst to(Dst,Src)(invariant(Src)[] s)
+// Dst to(Dst,Src)(immutable(Src)[] s)
 // in
 // {
 //  assert(isValid(s));
@@ -2192,7 +2234,7 @@
          * Normally this will be a representation of some substitution
          * character, such as U+FFFD or '?'.
          */
-        abstract invariant(ubyte)[] replacementSequence();
+        abstract immutable(ubyte)[] replacementSequence();
     }
 
     /**
@@ -2243,7 +2285,7 @@
      * Params:
      *    s = the string to be sanitized
      */
-    invariant(ubyte)[] sanitize(invariant(ubyte)[] s)
+    immutable(ubyte)[] sanitize(immutable(ubyte)[] s)
     {
 		uint n = validLength(s);
 		if (n == s.length) return s;
@@ -2279,7 +2321,7 @@
 			offset += n;
 			t = t[n..$];
 		}
-		return cast(invariant(ubyte)[])array[0..offset];
+		return cast(immutable(ubyte)[])array[0..offset];
     }
 
     /**
@@ -2356,20 +2398,20 @@
 }
 
 /**
- * EncodingScheme to handle ASCII
- *
- * This scheme recognises the following names:
- *                 "ANSI_X3.4-1968",
- *                 "ANSI_X3.4-1986",
- *                 "ASCII",
- *                 "IBM367",
- *                 "ISO646-US",
- *                 "ISO_646.irv:1991",
- *                 "US-ASCII",
- *                 "cp367",
- *                 "csASCII"
- *                 "iso-ir-6",
- *                 "us"
+ EncodingScheme to handle ASCII
+
+ This scheme recognises the following names:
+                 "ANSI_X3.4-1968",
+                 "ANSI_X3.4-1986",
+                 "ASCII",
+                 "IBM367",
+                 "ISO646-US",
+                 "ISO_646.irv:1991",
+                 "US-ASCII",
+                 "cp367",
+                 "csASCII"
+                 "iso-ir-6",
+                 "us"
  */
 class EncodingSchemeASCII : EncodingScheme
 {
@@ -2436,26 +2478,26 @@
             return c;
         }
 
-        override invariant(ubyte)[] replacementSequence()
+        override immutable(ubyte)[] replacementSequence()
         {
-            return cast(invariant(ubyte)[])"?";
+            return cast(immutable(ubyte)[])"?";
         }
     }
 }
 
 /**
- * EncodingScheme to handle Latin-1
- *
- * This scheme recognises the following names:
- *                 "CP819",
- *                 "IBM819",
- *                 "ISO-8859-1",
- *                 "ISO_8859-1",
- *                 "ISO_8859-1:1987",
- *                 "csISOLatin1",
- *                 "iso-ir-100",
- *                 "l1",
- *                 "latin1"
+ EncodingScheme to handle Latin-1
+
+ This scheme recognises the following names:
+                 "CP819",
+                 "IBM819",
+                 "ISO-8859-1",
+                 "ISO_8859-1",
+                 "ISO_8859-1:1987",
+                 "csISOLatin1",
+                 "iso-ir-100",
+                 "l1",
+                 "latin1"
  */
 class EncodingSchemeLatin1 : EncodingScheme
 {
@@ -2520,18 +2562,18 @@
             return c;
         }
 
-        override invariant(ubyte)[] replacementSequence()
+        override immutable(ubyte)[] replacementSequence()
         {
-            return cast(invariant(ubyte)[])"?";
+            return cast(immutable(ubyte)[])"?";
         }
     }
 }
 
 /**
- * EncodingScheme to handle Windows-1252
- *
- * This scheme recognises the following names:
- *                 "windows-1252"
+ EncodingScheme to handle Windows-1252
+
+ This scheme recognises the following names:
+                 "windows-1252"
  */
 class EncodingSchemeWindows1252 : EncodingScheme
 {
@@ -2588,18 +2630,18 @@
             return c;
         }
 
-        override invariant(ubyte)[] replacementSequence()
+        override immutable(ubyte)[] replacementSequence()
         {
-            return cast(invariant(ubyte)[])"?";
+            return cast(immutable(ubyte)[])"?";
         }
     }
 }
 
 /**
- * EncodingScheme to handle UTF-8
- *
- * This scheme recognises the following names:
- *                 "UTF-8"
+ EncodingScheme to handle UTF-8
+
+ This scheme recognises the following names:
+                 "UTF-8"
  */
 class EncodingSchemeUtf8 : EncodingScheme
 {
@@ -2656,19 +2698,19 @@
             return c;
         }
 
-        override invariant(ubyte)[] replacementSequence()
+        override immutable(ubyte)[] replacementSequence()
         {
-            return cast(invariant(ubyte)[])"\uFFFD";
+            return cast(immutable(ubyte)[])"\uFFFD";
         }
     }
 }
 
 /**
- * EncodingScheme to handle UTF-16 in native byte order
- *
- * This scheme recognises the following names:
- *                 "UTF-16LE" (little-endian architecture only)
- *                 "UTF-16BE" (big-endian architecture only)
+ EncodingScheme to handle UTF-16 in native byte order
+
+ This scheme recognises the following names:
+                 "UTF-16LE" (little-endian architecture only)
+                 "UTF-16BE" (big-endian architecture only)
  */
 class EncodingSchemeUtf16Native : EncodingScheme
 {
@@ -2699,12 +2741,12 @@
 
         override uint encodedLength(dchar c)
         {
-            return std.encoding.encodedLength!(wchar)(c);
+        	return std.encoding.encodedLength!(wchar)(c);
         }
 
         override uint encode(dchar c, ubyte[] buffer)
         {
-            auto r = cast(wchar[])cast(void[])buffer;
+        	auto r = cast(wchar[])buffer;
             return wchar.sizeof * std.encoding.encode(c,r);
         }
 
@@ -2715,7 +2757,7 @@
         }
         body
         {
-            auto t = cast(const(wchar)[]) cast(const(void)[]) s;
+            auto t = cast(const(wchar)[]) s;
             dchar c = std.encoding.decode(t);
             s = s[$-t.length..$];
             return c;
@@ -2728,25 +2770,25 @@
         }
         body
         {
-            auto t = cast(const(wchar)[]) cast(const(void)[]) s;
+            auto t = cast(const(wchar)[]) s;
             dchar c = std.encoding.safeDecode(t);
             s = s[$-t.length..$];
             return c;
         }
 
-        override invariant(ubyte)[] replacementSequence()
+        override immutable(ubyte)[] replacementSequence()
         {
-            return cast(invariant(ubyte)[])"\uFFFD"w;
+            return cast(immutable(ubyte)[])"\uFFFD"w;
         }
     }
 }
 
 /**
- * EncodingScheme to handle UTF-32 in native byte order
- *
- * This scheme recognises the following names:
- *                 "UTF-32LE" (little-endian architecture only)
- *                 "UTF-32BE" (big-endian architecture only)
+ EncodingScheme to handle UTF-32 in native byte order
+
+ This scheme recognises the following names:
+                 "UTF-32LE" (little-endian architecture only)
+                 "UTF-32BE" (big-endian architecture only)
  */
 class EncodingSchemeUtf32Native : EncodingScheme
 {
@@ -2777,12 +2819,12 @@
 
         override uint encodedLength(dchar c)
         {
-            return std.encoding.encodedLength!(dchar)(c);
+        	return std.encoding.encodedLength!(dchar)(c);
         }
 
         override uint encode(dchar c, ubyte[] buffer)
         {
-            auto r = cast(dchar[])buffer;
+        	auto r = cast(dchar[])buffer;
             return dchar.sizeof * std.encoding.encode(c,r);
         }
 
@@ -2812,9 +2854,9 @@
             return c;
         }
 
-        override invariant(ubyte)[] replacementSequence()
+        override immutable(ubyte)[] replacementSequence()
         {
-            return cast(invariant(ubyte)[])"\uFFFD"d;
+            return cast(immutable(ubyte)[])"\uFFFD"d;
         }
     }
 }
@@ -2825,7 +2867,7 @@
 // Helper functions
 version(unittest)
 {
-    void transcodeReverse(Src,Dst)(invariant(Src)[] s, out invariant(Dst)[] r)
+    void transcodeReverse(Src,Dst)(immutable(Src)[] s, out immutable(Dst)[] r)
     {
         static if(is(Src==Dst))
         {
@@ -2926,4 +2968,3 @@
         return "0123456789ABCDEF"[n & 0xF];
     }
 }
-
diff -r f12bfe124807 d/phobos2/std/file.d
--- a/d/phobos2/std/file.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/file.d	Thu Oct 14 14:12:53 2010 +0100
@@ -13,70 +13,64 @@
 WIKI = Phobos/StdFile
 */
 
-/*
- *  Copyright (C) 2001-2004 by Digital Mars, www.digitalmars.com
- * Written by Walter Bright, Christopher E. Miller, Andre Fornacon
- *
- *  This software is provided 'as-is', without any express or implied
- *  warranty. In no event will the authors be held liable for any damages
- *  arising from the use of this software.
- *
- *  Permission is granted to anyone to use this software for any purpose,
- *  including commercial applications, and to alter it and redistribute it
- *  freely, subject to the following restrictions:
- *
- *  o  The origin of this software must not be misrepresented; you must not
- *     claim that you wrote the original software. If you use this software
- *     in a product, an acknowledgment in the product documentation would be
- *     appreciated but is not required.
- *  o  Altered source versions must be plainly marked as such, and must not
- *     be misrepresented as being the original software.
- *  o  This notice may not be removed or altered from any source
- *     distribution.
- */
-
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, March 2006
-*/
-
 module std.file;
 
-private import core.memory;
-private import std.c.stdio;
-private import std.c.stdlib;
-private import std.c.string;
-private import std.path;
-private import std.string;
-private import std.regexp;
-private import std.c.string;
-private import std.traits;
-private import std.conv;
-private import std.contracts;
-private import std.utf;
-version (unittest) {
-    private import std.stdio; // for testing only
+import core.memory;
+import core.stdc.stdio, core.stdc.stdlib, core.stdc.string,
+    core.stdc.errno, std.algorithm, std.array, 
+    std.contracts, std.conv, std.date, std.format, std.path, std.range,
+    std.regexp, std.stdio, std.string, std.traits, std.typecons,
+    std.typetuple, std.utf;
+version (Win32)
+{
+    import core.sys.windows.windows, std.windows.charset,
+        std.windows.syserror, std.__fileinit;
+/*
+ * Since Win 9x does not support the "W" API's, first convert
+ * to wchar, then convert to multibyte using the current code
+ * page.
+ * (Thanks to yaneurao for this)
+ */
+    version(Windows) alias std.windows.charset.toMBSz toMBSz;
+    bool useWfuncs = true;        // initialized in std.__fileinit
+}
+version (Posix)
+{
+    import core.sys.posix.dirent, core.sys.posix.fcntl, core.sys.posix.sys.stat,
+        core.sys.posix.sys.time, core.sys.posix.unistd, core.sys.posix.utime;
 }
 
-/* =========================== Win32 ======================= */
+// @@@@ TEMPORARY - THIS SHOULD BE IN THE CORE @@@
+// {{{
+version (Posix)
+{
+    struct struct_stat64        // distinguish it from the stat() function
+    {
+        ulong st_dev;        /// device
+        uint __pad1;
+        uint st_ino;        /// file serial number
+        uint st_mode;        /// file mode
+        uint st_nlink;        /// link count
+        uint st_uid;        /// user ID of file's owner
+        uint st_gid;        /// user ID of group's owner
+        ulong st_rdev;        /// if device then device number
+        uint __pad2;
+        align(4) ulong st_size;
+        int st_blksize;        /// optimal I/O block size
+        ulong st_blocks;        /// number of allocated 512 byte blocks
+        int st_atime;
+        uint st_atimensec;
+        int st_mtime;
+        uint st_mtimensec;
+        int st_ctime;
+        uint st_ctimensec;
 
-version (Win32)
-{
-
-private import std.c.windows.windows;
-private import std.utf;
-private import std.windows.syserror;
-private import std.windows.charset;
-private import std.date;
-
-bool useWfuncs = true;
-
-static this()
-{
-    // Win 95, 98, ME do not implement the W functions
-    useWfuncs = (GetVersion() < 0x80000000);
+        ulong st_ino64;
+    }
+    extern(C) int fstat64(int, struct_stat64*);
+    extern(C) int stat64(in char*, struct_stat64*);
 }
+// }}}
 
 /***********************************
  * Exception thrown for file I/O errors.
@@ -84,423 +78,623 @@
 
 class FileException : Exception
 {
-    uint errno;			// operating system error code
-
-    this(string name)
+/**
+OS error code.
+ */ 
+    immutable uint errno;
+    
+/**
+Constructor taking the name of the file where error happened and the
+error number ($(LUCKY GetLastError) in Windows, $(D getErrno) in
+Posix).
+ */ 
+    this(in char[] name, in char[] message)
     {
-	this(name, "file I/O");
+        super(text(name, ": ", message));
+        errno = 0;
     }
 
-    this(string name, string message)
+/**
+Constructor taking the name of the file where error happened and the
+error number ($(LUCKY GetLastError) in Windows, $(D getErrno) in
+Posix).
+ */ 
+    version(Windows) this(string name, uint errno = GetLastError)
     {
-	super(name ~ ": " ~ message);
+        this(name, sysErrorString(errno));
+        this.errno = errno;
     }
 
-    this(string name, uint errno)
+    version(Posix) this(in char[] name, uint errno = .getErrno)
     {
-	this(name, sysErrorString(errno));
-	this.errno = errno;
+        auto s = strerror(errno);
+        this(name, to!string(s));
+        this.errno = errno;
     }
 }
 
+private T cenforce(T, string file = __FILE__, uint line = __LINE__)
+(T condition, lazy const(char)[] name)
+{
+    if (!condition)
+    {
+        throw new FileException(
+            text("In ", file, "(", line, "), data file ", name), .getErrno);
+    }
+    return condition;
+}
+
 /* **********************************
  * Basic File operations.
  */
 
 /********************************************
- * Read file $(D name), return array of bytes read.
- *
+Read entire contents of file $(D name).
+
+Returns: Untyped array of bytes _read.
+
+Throws: $(D FileException) on error.
+ */
+
+version(Windows) void[] read(in char[] name)
+{
+    alias TypeTuple!(GENERIC_READ,
+            FILE_SHARE_READ, (SECURITY_ATTRIBUTES*).init, OPEN_EXISTING,
+            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
+            HANDLE.init)
+        defaults;
+    auto h = useWfuncs
+        ? CreateFileW(std.utf.toUTF16z(name), defaults)
+        : CreateFileA(toMBSz(name), defaults);
+    
+    cenforce(h != INVALID_HANDLE_VALUE, name);
+    scope(exit) cenforce(CloseHandle(h), name);
+    const size = GetFileSize(h, null);
+    cenforce(size != INVALID_FILE_SIZE, name);
+    auto buf = GC.malloc(size, GC.BlkAttr.NO_SCAN)[0 .. size];
+    scope(failure) delete buf;
+    
+    DWORD numread;
+    cenforce(ReadFile(h,buf.ptr, size, &numread, null) == 1
+            && numread == size, name);
+    return buf[0 .. size];
+}
+
+version(Posix) void[] read(in char[] name, size_t upTo = size_t.max)
+{
+    // A few internal configuration parameters {
+    enum size_t
+        minInitialAlloc = 1024 * 4,
+        maxInitialAlloc = size_t.max / 2,
+        sizeIncrement = 1024 * 16,
+        maxSlackMemoryAllowed = 1024;
+    // }
+    
+    immutable fd = core.sys.posix.fcntl.open(toStringz(name),
+            core.sys.posix.fcntl.O_RDONLY);
+    cenforce(fd != -1, name);
+    scope(exit) core.sys.posix.unistd.close(fd);
+    
+    struct_stat64 statbuf = void;
+    cenforce(fstat64(fd, &statbuf) == 0, name);
+    //cenforce(core.sys.posix.sys.stat.fstat(fd, &statbuf) == 0, name);
+    
+    immutable initialAlloc = statbuf.st_size
+        ? min(statbuf.st_size + 1, maxInitialAlloc)
+        : minInitialAlloc;
+    auto result = GC.malloc(initialAlloc, GC.BlkAttr.NO_SCAN)
+        [0 .. initialAlloc];
+    scope(failure) delete result;
+    size_t size = 0;
+    
+    for (;;)
+    {
+        immutable actual = core.sys.posix.unistd.read(fd, result.ptr + size,
+                min(result.length, upTo) - size);
+        cenforce(actual != -1, name);
+        if (actual == 0) break;
+        size += actual;
+        if (size < result.length) continue;
+        immutable newAlloc = size + sizeIncrement;
+        result = GC.realloc(result.ptr, newAlloc, GC.BlkAttr.NO_SCAN)
+            [0 .. newAlloc];
+    }
+    
+    return result.length - size >= maxSlackMemoryAllowed
+        ? GC.realloc(result.ptr, size, GC.BlkAttr.NO_SCAN)[0 .. size]
+        : result[0 .. size];
+}
+
+version (linux) unittest
+{    
+    // A file with "zero" length that doesn't have 0 length at all
+    char[] s = cast(char[])std.file.read("/proc/sys/kernel/osrelease");
+    assert(s.length > 0);
+    //writefln("'%s'", s);
+}
+
+/********************************************
+Read and validates (using $(XREF utf, validate)) a text file. $(D S)
+can be a type of array of characters of any width and constancy. No
+width conversion is performed; if the width of the characters in file
+$(D name) is different from the width of elements of $(D S),
+validation will fail.
+
+Returns: Array of characters read.
+
+Throws: $(D FileException) on file error, $(D UtfException) on UTF
+decoding error.
+
+Example:
+
+----
+enforce(system("echo abc>deleteme") == 0);
+scope(exit) remove("deleteme");
+enforce(chomp(readText("deleteme")) == "abc");
+----
+ */
+
+S readText(S = string)(in char[] name)
+{
+    auto result = cast(S) read(name);
+    std.utf.validate(result);
+    return result;
+}
+
+unittest
+{
+    enforce(system("echo abc>deleteme") == 0);
+    scope(exit) remove("deleteme");
+    enforce(chomp(readText("deleteme")) == "abc");
+}
+
+/*********************************************
+ * Write $(D buffer) to file $(D name).
  * Throws: $(D FileException) on error.
  */
 
-void[] read(in string name)
+version(Windows) void write(in char[] name, const void[] buffer)
 {
-    DWORD numread;
-    HANDLE h;
+    alias TypeTuple!(GENERIC_WRITE, 0, null, CREATE_ALWAYS,
+            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
+            HANDLE.init)
+        defaults;
+    auto h = useWfuncs
+        ? CreateFileW(std.utf.toUTF16z(name), defaults)
+        : CreateFileA(toMBSz(name), defaults);
+   
+    cenforce(h != INVALID_HANDLE_VALUE, name);
+    scope(exit) cenforce(CloseHandle(h), name);
+    DWORD numwritten;
+    cenforce(WriteFile(h, buffer.ptr, buffer.length, &numwritten, null) == 1
+            && buffer.length == numwritten,
+            name);
+}
 
+version(Posix) void write(in char[] name, in void[] buffer)
+{
+    return writeImpl(name, buffer, O_CREAT | O_WRONLY | O_TRUNC);
+}
+
+/*********************************************
+ * Append $(D buffer) to file $(D name).
+ * Throws: $(D FileException) on error.
+ */
+
+version(Windows) void append(in char[] name, in void[] buffer)
+{
+    alias TypeTuple!(GENERIC_WRITE,0,null,OPEN_ALWAYS,
+            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,HANDLE.init)
+        defaults;
+    
+    auto h = useWfuncs
+        ? CreateFileW(std.utf.toUTF16z(name), defaults)
+        : CreateFileA(toMBSz(name), defaults);
+    
+    cenforce(h != INVALID_HANDLE_VALUE, name);
+    scope(exit) cenforce(CloseHandle(h), name);
+    DWORD numwritten;
+    cenforce(SetFilePointer(h, 0, null, FILE_END) != INVALID_SET_FILE_POINTER
+            && WriteFile(h,buffer.ptr,buffer.length,&numwritten,null) == 1
+            && buffer.length == numwritten,
+            name);
+}
+
+version(Posix) void append(in char[] name, in void[] buffer)
+{
+    return writeImpl(name, buffer, O_APPEND | O_WRONLY | O_CREAT);
+}
+
+// Posix implementation helper for write and append
+
+version(Posix) private void writeImpl(in char[] name,
+        in void[] buffer, in uint mode)
+{
+    invariant fd = core.sys.posix.fcntl.open(toStringz(name),
+            mode, 0660);
+    cenforce(fd != -1, name);
+    {
+        scope(failure) core.sys.posix.unistd.close(fd);
+        invariant size = buffer.length;
+        cenforce(
+            core.sys.posix.unistd.write(fd, buffer.ptr, size) == size,
+            name);
+    }
+    cenforce(core.sys.posix.unistd.close(fd) == 0, name);
+}
+
+/***************************************************
+ * Rename file $(D from) to $(D to).
+ * Throws: $(D FileException) on error.
+ */
+
+version(Windows) void rename(in char[] from, in char[] to)
+{
+    enforce(useWfuncs
+            ? MoveFileW(std.utf.toUTF16z(from), std.utf.toUTF16z(to))
+            : MoveFileA(toMBSz(from), toMBSz(to)),
+            new FileException(
+                text("Attempting to rename file ", from, " to ",
+                        to)));
+}
+
+version(Posix) void rename(in char[] from, in char[] to)
+{
+    cenforce(std.c.stdio.rename(toStringz(from), toStringz(to)) == 0, to);
+}
+
+/***************************************************
+Delete file $(D name).
+Throws: $(D FileException) on error.
+ */
+
+version(Windows) void remove(in char[] name)
+{
+    cenforce(useWfuncs
+            ? DeleteFileW(std.utf.toUTF16z(name))
+            : DeleteFileA(toMBSz(name)),
+            name);
+}
+
+version(Posix) void remove(in char[] name)
+{
+    cenforce(std.c.stdio.remove(toStringz(name)) == 0, name);
+}
+
+/***************************************************
+Get size of file $(D name).
+
+Throws: $(D FileException) on error (e.g., file not found).
+ */
+
+version(Windows) ulong getSize(in char[] name)
+{
+    HANDLE findhndl = void;
+    uint resulth = void;
+    uint resultl = void;
+    
     if (useWfuncs)
     {
-	const(wchar*) namez = std.utf.toUTF16z(name);
-	h = CreateFileW(namez,GENERIC_READ,FILE_SHARE_READ,null,OPEN_EXISTING,
-	    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,cast(HANDLE)null);
+        WIN32_FIND_DATAW filefindbuf;
+        
+        findhndl = FindFirstFileW(std.utf.toUTF16z(name), &filefindbuf);
+        resulth = filefindbuf.nFileSizeHigh;
+        resultl = filefindbuf.nFileSizeLow;
     }
     else
     {
-	const(char*) namez = toMBSz(name);
-	h = CreateFileA(namez,GENERIC_READ,FILE_SHARE_READ,null,OPEN_EXISTING,
-	    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,cast(HANDLE)null);
+        WIN32_FIND_DATA filefindbuf;
+        
+        findhndl = FindFirstFileA(toMBSz(name), &filefindbuf);
+        resulth = filefindbuf.nFileSizeHigh;
+        resultl = filefindbuf.nFileSizeLow;
     }
-
-    if (h == INVALID_HANDLE_VALUE)
-	goto err1;
-
-    auto size = GetFileSize(h, null);
-    if (size == INVALID_FILE_SIZE)
-	goto err2;
-
-    auto buf = GC.malloc(size, GC.BlkAttr.NO_SCAN)[0 .. size];
-
-    if (ReadFile(h,buf.ptr,size,&numread,null) != 1)
-	goto err2;
-
-    if (numread != size)
-	goto err2;
-
-    if (!CloseHandle(h))
-	goto err;
-
-    return buf[0 .. size];
-
-err2:
-    CloseHandle(h);
-err:
-    delete buf;
-err1:
-    throw new FileException(name, GetLastError());
+    
+    cenforce(findhndl != cast(HANDLE)-1 && FindClose(findhndl), name);
+    return (cast(ulong) resulth << 32) + resultl;
 }
 
-/*********************************************
- * Write buffer[] to file name[].
- * Throws: $(D FileException) on error.
- */
-
-void write(in string name, const void[] buffer)
+version(Posix) ulong getSize(in char[] name)
 {
-    HANDLE h;
-    DWORD numwritten;
-
-    if (useWfuncs)
-    {
-	const(wchar*) namez = std.utf.toUTF16z(name);
-	h = CreateFileW(namez,GENERIC_WRITE,0,null,CREATE_ALWAYS,
-	    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,cast(HANDLE)null);
-    }
-    else
-    {
-	const(char*) namez = toMBSz(name);
-	h = CreateFileA(namez,GENERIC_WRITE,0,null,CREATE_ALWAYS,
-	    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,cast(HANDLE)null);
-    }
-    if (h == INVALID_HANDLE_VALUE)
-	goto err;
-
-    if (WriteFile(h,buffer.ptr,buffer.length,&numwritten,null) != 1)
-	goto err2;
-
-    if (buffer.length != numwritten)
-	goto err2;
+    struct_stat64 statbuf = void;
+    cenforce(stat64(toStringz(name), &statbuf) == 0, name);
+    return statbuf.st_size;
+}
     
-    if (!CloseHandle(h))
-	goto err;
-    return;
-
-err2:
-    CloseHandle(h);
-err:
-    throw new FileException(name, GetLastError());
+version(Posix) unittest
+{
+    scope(exit) system("rm -f /tmp/deleteme");
+    // create a file of size 1
+    assert(system("echo > /tmp/deleteme") == 0);
+    assert(getSize("/tmp/deleteme") == 1, text(getSize("/tmp/deleteme")));
+    // create a file of size 3
+    assert(system("echo ab > /tmp/deleteme") == 0);
+    assert(getSize("/tmp/deleteme") == 3);
 }
-
-
-/*********************************************
- * Append buffer[] to file name[].
- * Throws: $(D FileException) on error.
- */
-
-void append(in string name, in void[] buffer)
-{
-    HANDLE h;
-    DWORD numwritten;
-
-    if (useWfuncs)
-    {
-	const(wchar*) namez = std.utf.toUTF16z(name);
-	h = CreateFileW(namez,GENERIC_WRITE,0,null,OPEN_ALWAYS,
-	    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,cast(HANDLE)null);
-    }
-    else
-    {
-	const(char*) namez = toMBSz(name);
-	h = CreateFileA(namez,GENERIC_WRITE,0,null,OPEN_ALWAYS,
-	    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,cast(HANDLE)null);
-    }
-    if (h == INVALID_HANDLE_VALUE)
-	goto err;
-
-    SetFilePointer(h, 0, null, FILE_END);
-
-    if (WriteFile(h,buffer.ptr,buffer.length,&numwritten,null) != 1)
-	goto err2;
-
-    if (buffer.length != numwritten)
-	goto err2;
     
-    if (!CloseHandle(h))
-	goto err;
-    return;
-
-err2:
-    CloseHandle(h);
-err:
-    throw new FileException(name, GetLastError());
-}
-
-
-/***************************************************
- * Rename file from[] to to[].
- * Throws: $(D FileException) on error.
- */
-
-void rename(in string from, in string to)
-{
-    BOOL result = void;
-
-    if (useWfuncs)
-	result = MoveFileW(std.utf.toUTF16z(from), std.utf.toUTF16z(to));
-    else
-	result = MoveFileA(toMBSz(from), toMBSz(to));
-    if (!result)
-	throw new FileException(to, GetLastError());
-}
-
-
-/***************************************************
- * Delete file name[].
- * Throws: $(D FileException) on error.
- */
-
-void remove(in string name)
-{
-    BOOL result = void;
-
-    if (useWfuncs)
-	result = DeleteFileW(std.utf.toUTF16z(name));
-    else
-	result = DeleteFileA(toMBSz(name));
-    if (!result)
-	throw new FileException(name, GetLastError());
-}
-
-
-/***************************************************
- * Get size of file name[].
- * Throws: $(D FileException) on error.
- */
-
-ulong getSize(in string name)
-{
-    HANDLE findhndl;
-    uint resulth;
-    uint resultl;
-
-    if (useWfuncs)
-    {
-	WIN32_FIND_DATAW filefindbuf;
-
-	findhndl = FindFirstFileW(std.utf.toUTF16z(name), &filefindbuf);
-	resulth = filefindbuf.nFileSizeHigh;
-	resultl = filefindbuf.nFileSizeLow;
-    }
-    else
-    {
-	WIN32_FIND_DATA filefindbuf;
-
-	findhndl = FindFirstFileA(toMBSz(name), &filefindbuf);
-	resulth = filefindbuf.nFileSizeHigh;
-	resultl = filefindbuf.nFileSizeLow;
-    }
-
-    if (findhndl == cast(HANDLE)-1)
-    {
-	throw new FileException(name, GetLastError());
-    }
-    FindClose(findhndl);
-    return (cast(ulong)resulth << 32) + resultl;
-}
-
 /*************************
  * Get creation/access/modified times of file $(D name).
  * Throws: $(D FileException) on error.
  */
 
-void getTimes(in string name, out d_time ftc, out d_time fta, out d_time ftm)
+version(Windows) void getTimes(in char[] name,
+        out d_time ftc, out d_time fta, out d_time ftm)
 {
-    HANDLE findhndl;
-
+    HANDLE findhndl = void;
+    
     if (useWfuncs)
     {
-	WIN32_FIND_DATAW filefindbuf;
-
-	findhndl = FindFirstFileW(std.utf.toUTF16z(name), &filefindbuf);
-	ftc = std.date.FILETIME2d_time(&filefindbuf.ftCreationTime);
-	fta = std.date.FILETIME2d_time(&filefindbuf.ftLastAccessTime);
-	ftm = std.date.FILETIME2d_time(&filefindbuf.ftLastWriteTime);
+        WIN32_FIND_DATAW filefindbuf;
+        
+        findhndl = FindFirstFileW(std.utf.toUTF16z(name), &filefindbuf);
+        ftc = std.date.FILETIME2d_time(&filefindbuf.ftCreationTime);
+        fta = std.date.FILETIME2d_time(&filefindbuf.ftLastAccessTime);
+        ftm = std.date.FILETIME2d_time(&filefindbuf.ftLastWriteTime);
     }
     else
     {
-	WIN32_FIND_DATA filefindbuf;
-
-	findhndl = FindFirstFileA(toMBSz(name), &filefindbuf);
-	ftc = std.date.FILETIME2d_time(&filefindbuf.ftCreationTime);
-	fta = std.date.FILETIME2d_time(&filefindbuf.ftLastAccessTime);
-	ftm = std.date.FILETIME2d_time(&filefindbuf.ftLastWriteTime);
+        WIN32_FIND_DATA filefindbuf;
+        
+        findhndl = FindFirstFileA(toMBSz(name), &filefindbuf);
+        ftc = std.date.FILETIME2d_time(&filefindbuf.ftCreationTime);
+        fta = std.date.FILETIME2d_time(&filefindbuf.ftLastAccessTime);
+        ftm = std.date.FILETIME2d_time(&filefindbuf.ftLastWriteTime);
     }
-
+    
     if (findhndl == cast(HANDLE)-1)
     {
-	throw new FileException(name, GetLastError());
+        throw new FileException(name.idup);
     }
     FindClose(findhndl);
 }
 
+version(Posix) void getTimes(in char[] name,
+        out d_time ftc, out d_time fta, out d_time ftm)
+{
+    struct_stat64 statbuf = void;
+    cenforce(stat64(toStringz(name), &statbuf) == 0, name);
+    ftc = cast(d_time) statbuf.st_ctime * std.date.ticksPerSecond;
+    fta = cast(d_time) statbuf.st_atime * std.date.ticksPerSecond;
+    ftm = cast(d_time) statbuf.st_mtime * std.date.ticksPerSecond;
+}
+
+/*
+Get creation/access/modified times of file $(D name) as a tuple.
+
+Throws: $(D FileException) on error.
+ */
+
+// Tuple!(d_time, "ftc", d_time, "fta", d_time, "ftm") getTimes(in char[] name)
+// {
+//     typeof(return) result = void;
+//     getTimes(name, result.ftc, result.fta, result.ftm);
+//     return result;
+// }
+
+// unittest
+// {
+//     auto t = getTimes(".").ftm;
+// }
+
+/**
+   Returns the time of the last modification of file $(D name). If the
+   file does not exist, throws a $(D FileException).
+*/
+
+version(Windows) d_time lastModified(in char[] name)
+{
+    d_time dummy = void, ftm = void;
+    getTimes(name, dummy, dummy, ftm);
+    return ftm;
+}
+
+version(Posix) d_time lastModified(in char[] name)
+{
+    struct_stat64 statbuf = void;
+    cenforce(stat64(toStringz(name), &statbuf) == 0, name);
+    return cast(d_time) statbuf.st_mtime * std.date.ticksPerSecond;
+}
+    
+/**
+Returns the time of the last modification of file $(D name). If the
+file does not exist, returns $(D returnIfMissing).
+   
+A frequent usage pattern occurs in build automation tools such as
+$(WEB gnu.org/software/make, make) or $(WEB
+en.wikipedia.org/wiki/Apache_Ant, ant). To check whether file $(D
+target) must be rebuilt from file $(D source) (i.e., $(D target) is
+older than $(D source) or does not exist), use the comparison
+below. The code throws a $(D FileException) if $(D source) does not
+exist (as it should). On the other hand, the $(D d_time.min) default
+makes a non-existing $(D target) seem infinitely old so the test
+correctly prompts building it.
+
+----
+if (lastModified(source) >= lastModified(target, d_time.min))
+{
+    // must (re)build
+}
+else
+{
+    // target is up-to-date
+}
+----
+*/
+
+version(Windows) d_time lastModified(in char[] name, d_time returnIfMissing)
+{
+    if (!exists(name)) return returnIfMissing;
+    d_time dummy = void, ftm = void;
+    getTimes(name, dummy, dummy, ftm);
+    return ftm;
+}
+
+version(Posix) d_time lastModified(in char[] name, d_time returnIfMissing)
+{
+    struct_stat64 statbuf = void;
+    return stat64(toStringz(name), &statbuf) != 0
+        ? returnIfMissing
+        : cast(d_time) statbuf.st_mtime * std.date.ticksPerSecond;
+}
+
+unittest
+{
+    system("echo a>deleteme") == 0 || assert(false);
+    scope(exit) remove("deleteme");
+    assert(lastModified("deleteme") >
+            lastModified("this file does not exist", d_time.min));
+    assert(lastModified("deleteme") > lastModified(__FILE__));
+}
 
 /***************************************************
- * Does file name[] (or directory) exist?
- * Return 1 if it does, 0 if not.
+ * Does file (or directory) $(D name) exist?
  */
 
-bool exists(in string name)
+version(Windows) bool exists(in char[] name)
 {
-    uint result;
-
-    if (useWfuncs)
-	// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/fileio/base/getfileattributes.asp
-	result = GetFileAttributesW(std.utf.toUTF16z(name));
-    else
-	result = GetFileAttributesA(toMBSz(name));
-
+    auto result = useWfuncs
+// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/
+// fileio/base/getfileattributes.asp
+        ? GetFileAttributesW(std.utf.toUTF16z(name))
+        : GetFileAttributesA(toMBSz(name));
     return result != 0xFFFFFFFF;
 }
 
+version(Posix) bool exists(in char[] name)
+{
+    return access(toStringz(name), 0) == 0;
+}
+    
+unittest
+{
+    assert(exists("."));
+    assert(!exists("this file does not exist"));
+    system("echo a > deleteme") == 0 || assert(false);
+    scope(exit) remove("deleteme");
+    assert(exists("deleteme"));
+}
+
 /***************************************************
- * Get file name[] attributes.
- * Throws: $(D FileException) on error.
+Get file $(D name) attributes.
+
+Throws: $(D FileException) on error.
  */
 
-uint getAttributes(string name)
+version(Windows) uint getAttributes(in char[] name)
 {
-    uint result;
-
-    if (useWfuncs)
-	result = GetFileAttributesW(std.utf.toUTF16z(name));
-    else
-	result = GetFileAttributesA(toMBSz(name));
-    if (result == 0xFFFFFFFF)
-    {
-	throw new FileException(name, GetLastError());
-    }
+    auto result = useWfuncs
+        ? GetFileAttributesW(std.utf.toUTF16z(name))
+        : GetFileAttributesA(toMBSz(name));
+    enforce(result != uint.max,
+            new FileException(name.idup));
     return result;
 }
 
-/****************************************************
- * Is name[] a file?
- * Throws: $(D FileException) if name[] doesn't exist.
- */
-
-bool isfile(in string name)
+version(Posix) uint getAttributes(in char[] name)
 {
-    return (getAttributes(name) & FILE_ATTRIBUTE_DIRECTORY) == 0;
+    struct_stat64 statbuf = void;
+    cenforce(stat64(toStringz(name), &statbuf) == 0, name);
+    return statbuf.st_mode;
 }
 
 /****************************************************
- * Is name[] a directory?
- * Throws: $(D FileException) if name[] doesn't exist.
+ * Is $(D name) a directory?
+ * Throws: $(D FileException) if $(D name) doesn't exist.
  */
 
-bool isdir(in string name)
+version(Windows) bool isdir(in char[] name)
 {
     return (getAttributes(name) & FILE_ATTRIBUTE_DIRECTORY) != 0;
 }
 
+version(Posix) bool isdir(in char[] name)
+{
+    return (getAttributes(name) & S_IFMT) == S_IFDIR;
+}
+
 /****************************************************
- * Change directory to pathname[].
+ * Is $(D name) a file?
+ * Throws: $(D FileException) if $(D name) doesn't exist.
+ */
+
+version(Windows) bool isfile(in char[] name)
+{
+    return !isdir(name);
+}
+
+version(Posix) bool isfile(in char[] name)
+{
+    return (getAttributes(name) & S_IFMT) == S_IFREG;        // regular file
+}
+    
+/****************************************************
+ * Change directory to $(D pathname).
  * Throws: $(D FileException) on error.
  */
 
-void chdir(in string pathname)
-{   BOOL result;
-
-    if (useWfuncs)
-	result = SetCurrentDirectoryW(std.utf.toUTF16z(pathname));
-    else
-	result = SetCurrentDirectoryA(toMBSz(pathname));
-
-    if (!result)
-    {
-	throw new FileException(pathname, GetLastError());
-    }
+version(Windows) void chdir(in char[] pathname)
+{
+    enforce(useWfuncs
+            ? SetCurrentDirectoryW(std.utf.toUTF16z(pathname))
+            : SetCurrentDirectoryA(toMBSz(pathname)),
+            new FileException(pathname.idup));
 }
 
+version(Posix) void chdir(in char[] pathname)
+{
+    cenforce(core.sys.posix.unistd.chdir(toStringz(pathname)) == 0,
+            pathname);
+}
+    
 /****************************************************
- * Make directory pathname[].
- * Throws: $(D FileException) on error.
+Make directory $(D pathname).
+
+Throws: $(D FileException) on error.
  */
 
-void mkdir(in string pathname)
-{   BOOL result = void;
+version(Windows) void mkdir(in char[] pathname)
+{
+    enforce(useWfuncs
+            ? CreateDirectoryW(std.utf.toUTF16z(pathname), null)
+            : CreateDirectoryA(toMBSz(pathname), null),
+            new FileException(pathname.idup));
+}
 
-    if (useWfuncs)
-	result = CreateDirectoryW(std.utf.toUTF16z(pathname), null);
-    else
-	result = CreateDirectoryA(toMBSz(pathname), null);
-
-    if (!result)
-    {
-	throw new FileException(pathname, GetLastError());
-    }
+version(Posix) void mkdir(in char[] pathname)
+{
+    cenforce(core.sys.posix.sys.stat.mkdir(toStringz(pathname), 0777) == 0,
+            pathname);
 }
 
 /****************************************************
  * Make directory and all parent directories as needed.
  */
 
-void mkdirRecurse(string pathname)
+void mkdirRecurse(in char[] pathname)
 {
-    invariant left = dirname(pathname);
+    const left = dirname(pathname);
     exists(left) || mkdirRecurse(left);
     mkdir(pathname);
 }
 
 /****************************************************
- * Remove directory pathname[].
- * Throws: $(D FileException) on error.
+Remove directory $(D pathname).
+
+Throws: $(D FileException) on error.
  */
 
-void rmdir(in string pathname)
-{   BOOL result = void;
-
-    if (useWfuncs)
-	result = RemoveDirectoryW(std.utf.toUTF16z(pathname));
-    else
-	result = RemoveDirectoryA(toMBSz(pathname));
-
-    if (!result)
-    {
-	throw new FileException(pathname, GetLastError());
-    }
+version(Windows) void rmdir(in char[] pathname)
+{
+    cenforce(useWfuncs
+            ? RemoveDirectoryW(std.utf.toUTF16z(pathname))
+            : RemoveDirectoryA(toMBSz(pathname)),
+            pathname);
 }
 
-/****************************************************
- * Remove directory and all of its content and subdirectories,
- * recursively.
- */
-
-void rmdirRecurse(string pathname)
+version(Posix) void rmdir(in char[] pathname)
 {
-    // all children, recursively depth-first
-    foreach (DirEntry e; dirEntries(pathname, SpanMode.depth))
-    {
-        e.isdir ? rmdir(e.name) : remove(e.name);
-    }
-    // the dir itself
-    rmdir(pathname);
-}
-
-unittest
-{
-    auto d = r"c:\deleteme\a\b\c\d\e\f\g";
-    mkdirRecurse(d);
-    rmdirRecurse(r"c:\deleteme");
-    enforce(!exists(r"c:\deleteme"));
+    cenforce(core.sys.posix.unistd.rmdir(toStringz(pathname)) == 0,
+            pathname);
 }
 
 /****************************************************
@@ -508,269 +702,177 @@
  * Throws: $(D FileException) on error.
  */
 
-string getcwd()
+version(Windows) string getcwd()
 {
+    // A bit odd API: calling GetCurrentDirectory(0, null) returns
+    // length including the \0, whereas calling with non-zero
+    // params returns length excluding the \0.
     if (useWfuncs)
     {
-	wchar c;
-
-	auto len = GetCurrentDirectoryW(0, &c);
-	if (!len)
-	    goto Lerr;
-	auto dir = new wchar[len];
-	len = GetCurrentDirectoryW(len, dir.ptr);
-	if (!len)
-	    goto Lerr;
-	return std.utf.toUTF8(dir[0 .. len]); // leave off terminating 0
+        auto dir =
+            new wchar[enforce(GetCurrentDirectoryW(0, null), "getcwd")];
+        dir = dir[0 .. GetCurrentDirectoryW(dir.length, dir.ptr)];
+        cenforce(dir.length, "getcwd");
+        return to!string(dir);
     }
     else
     {
-	char c;
+        auto dir =
+            new char[enforce(GetCurrentDirectoryA(0, null), "getcwd")];
+        dir = dir[0 .. GetCurrentDirectoryA(dir.length, dir.ptr)];
+        cenforce(dir.length, "getcwd");
+        return assumeUnique(dir);
+    }
+}
 
-	auto len = GetCurrentDirectoryA(0, &c);
-	if (!len)
-	    goto Lerr;
-	auto dir = new char[len];
-	len = GetCurrentDirectoryA(len, dir.ptr);
-	if (!len)
-	    goto Lerr;
-	return cast(string)dir[0 .. len];	// leave off terminating 0
-    }
+version(Posix) string getcwd()
+{
+    auto p = cenforce(core.sys.posix.unistd.getcwd(null, 0),
+            "cannot get cwd");
+    scope(exit) std.c.stdlib.free(p);
+    return p[0 .. std.c.string.strlen(p)].idup;
+}
 
-Lerr:
-    throw new FileException("getcwd", GetLastError());
+unittest
+{
+    auto s = getcwd();
+    assert(s.length);
 }
 
 /***************************************************
  * Directory Entry
  */
 
-struct DirEntry
+version(Windows) struct DirEntry
 {
-    string name;			/// file or directory name
-    ulong size = ~0UL;			/// size of file in bytes
-    d_time creationTime = d_time_nan;	/// time of file creation
-    d_time lastAccessTime = d_time_nan;	/// time file was last accessed
-    d_time lastWriteTime = d_time_nan;	/// time file was last written to
-    uint attributes;		// Windows file attributes OR'd together
-
-    void init(string path, in WIN32_FIND_DATA *fd)
+    string name;                        /// file or directory name
+    ulong size = ~0UL;                        /// size of file in bytes
+    d_time creationTime = d_time_nan;        /// time of file creation
+    d_time lastAccessTime = d_time_nan;        /// time file was last accessed
+    d_time lastWriteTime = d_time_nan;        /// time file was last written to
+    uint attributes;                // Windows file attributes OR'd together
+    
+    void init(in char[] path, in WIN32_FIND_DATA *fd)
     {
-	wchar[] wbuf;
-	size_t clength;
-	size_t wlength;
-	size_t n;
-
-	clength = std.c.string.strlen(fd.cFileName.ptr);
-
-	// Convert cFileName[] to unicode
-	wlength = MultiByteToWideChar(0,0,fd.cFileName.ptr,clength,null,0);
-	if (wlength > wbuf.length)
-	    wbuf.length = wlength;
-	n = MultiByteToWideChar(0,0,fd.cFileName.ptr,clength,cast(wchar*)wbuf,wlength);
-	assert(n == wlength);
-	// toUTF8() returns a new buffer
-	name = std.path.join(path, std.utf.toUTF8(wbuf[0 .. wlength]));
-
-	size = (cast(ulong)fd.nFileSizeHigh << 32) | fd.nFileSizeLow;
-	creationTime = std.date.FILETIME2d_time(&fd.ftCreationTime);
-	lastAccessTime = std.date.FILETIME2d_time(&fd.ftLastAccessTime);
-	lastWriteTime = std.date.FILETIME2d_time(&fd.ftLastWriteTime);
-	attributes = fd.dwFileAttributes;
+        auto clength = std.c.string.strlen(fd.cFileName.ptr);
+            
+        // Convert cFileName[] to unicode
+        const wlength = MultiByteToWideChar(0, 0, fd.cFileName.ptr,
+                clength, null,0);
+        auto wbuf = new wchar[wlength];
+        const n = MultiByteToWideChar(0, 0, fd.cFileName.ptr, clength,
+                wbuf.ptr, wlength);
+        assert(n == wlength);
+        // toUTF8() returns a new buffer
+        name = std.path.join(path, std.utf.toUTF8(wbuf[0 .. wlength]));
+            
+        size = (cast(ulong)fd.nFileSizeHigh << 32) | fd.nFileSizeLow;
+        creationTime = std.date.FILETIME2d_time(&fd.ftCreationTime);
+        lastAccessTime = std.date.FILETIME2d_time(&fd.ftLastAccessTime);
+        lastWriteTime = std.date.FILETIME2d_time(&fd.ftLastWriteTime);
+        attributes = fd.dwFileAttributes;
     }
-
-    void init(string path, in WIN32_FIND_DATAW *fd)
+        
+    void init(in char[] path, in WIN32_FIND_DATAW *fd)
     {
-	size_t clength = std.string.wcslen(fd.cFileName.ptr);
-	name = std.path.join(path, std.utf.toUTF8(fd.cFileName[0 .. clength]));
-	size = (cast(ulong)fd.nFileSizeHigh << 32) | fd.nFileSizeLow;
-	creationTime = std.date.FILETIME2d_time(&fd.ftCreationTime);
-	lastAccessTime = std.date.FILETIME2d_time(&fd.ftLastAccessTime);
-	lastWriteTime = std.date.FILETIME2d_time(&fd.ftLastWriteTime);
-	attributes = fd.dwFileAttributes;
+        size_t clength = std.string.wcslen(fd.cFileName.ptr);
+        name = std.path.join(path,
+                std.utf.toUTF8(fd.cFileName[0 .. clength]));
+        size = (cast(ulong)fd.nFileSizeHigh << 32) | fd.nFileSizeLow;
+        creationTime = std.date.FILETIME2d_time(&fd.ftCreationTime);
+        lastAccessTime = std.date.FILETIME2d_time(&fd.ftLastAccessTime);
+        lastWriteTime = std.date.FILETIME2d_time(&fd.ftLastWriteTime);
+        attributes = fd.dwFileAttributes;
     }
-
+        
     /****
-     * Return !=0 if DirEntry is a directory.
+     * Return $(D true) if DirEntry is a directory.
      */
-    uint isdir()
+    bool isdir() const
     {
-	return attributes & FILE_ATTRIBUTE_DIRECTORY;
+        return (attributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
     }
-
+        
     /****
      * Return !=0 if DirEntry is a file.
      */
-    uint isfile()
+    bool isfile() const
     {
-	return !(attributes & FILE_ATTRIBUTE_DIRECTORY);
+        return !isdir;
     }
 }
 
-
-/***************************************************
- * Return contents of directory pathname[].
- * The names in the contents do not include the pathname.
- * Throws: $(D FileException) on error
- * Example:
- *	This program lists all the files and subdirectories in its
- *	path argument.
- * ----
- * import std.stdio;
- * import std.file;
- *
- * void main(string[] args)
- * {
- *    auto dirs = std.file.listdir(args[1]);
- *
- *    foreach (d; dirs)
- *	writefln(d);
- * }
- * ----
- */
-
-string[] listdir(string pathname)
+version(Posix) struct DirEntry
 {
-    string[] result;
-    
-    bool listing(string filename)
+    string name;                        /// file or directory name
+    ulong _size = ~0UL;                        /// size of file in bytes
+    d_time _creationTime = d_time_nan;        /// time of file creation
+    d_time _lastAccessTime = d_time_nan; /// time file was last accessed
+    d_time _lastWriteTime = d_time_nan;        /// time file was last written to
+    ubyte d_type;
+    struct_stat64 statbuf;
+    bool didstat;                        // done lazy evaluation of stat()
+        
+    void init(in char[] path, core.sys.posix.dirent.dirent *fd)
     {
-	result ~= filename;
-	return true; // continue
+        invariant len = std.c.string.strlen(fd.d_name.ptr);
+        name = std.path.join(path, fd.d_name[0 .. len].idup);
+        d_type = fd.d_type;
+        didstat = false;
     }
-    
-    listdir(pathname, &listing);
-    return result;
-}
-
-
-/*****************************************************
- * Return all the files in the directory and its subdirectories
- * that match pattern or regular expression r.
- * Params:
- *	pathname = Directory name
- *	pattern = String with wildcards, such as $(RED "*.d"). The supported
- *		wildcard strings are described under fnmatch() in
- *		$(LINK2 std_path.html, std.path).
- *	r = Regular expression, for more powerful _pattern matching.
- * Example:
- *	This program lists all the files with a "d" extension in
- *	the path passed as the first argument.
- * ----
- * import std.stdio;
- * import std.file;
- *
- * void main(string[] args)
- * {
- *    auto d_source_files = std.file.listdir(args[1], "*.d");
- *
- *    foreach (d; d_source_files)
- *	writefln(d);
- * }
- * ----
- * A regular expression version that searches for all files with "d" or
- * "obj" extensions:
- * ----
- * import std.stdio;
- * import std.file;
- * import std.regexp;
- *
- * void main(string[] args)
- * {
- *    auto d_source_files = std.file.listdir(args[1], RegExp(r"\.(d|obj)$"));
- *
- *    foreach (d; d_source_files)
- *	writefln(d);
- * }
- * ----
- */
-
-string[] listdir(string pathname, string pattern)
-{   string[] result;
-    
-    bool callback(DirEntry* de)
+        
+    bool isdir() const
     {
-	if (de.isdir)
-	    listdir(de.name, &callback);
-	else
-	{   if (std.path.fnmatch(de.name, pattern))
-		result ~= de.name;
-	}
-	return true; // continue
+        return (d_type & DT_DIR) != 0;
     }
-    
-    listdir(pathname, &callback);
-    return result;
-}
-
-/** Ditto */
-
-string[] listdir(string pathname, RegExp r)
-{   string[] result;
-    
-    bool callback(DirEntry* de)
+        
+    bool isfile() const
     {
-	if (de.isdir)
-	    listdir(de.name, &callback);
-	else
-	{   if (r.test(de.name))
-		result ~= de.name;
-	}
-	return true; // continue
+        return (d_type & DT_REG) != 0;
     }
-    
-    listdir(pathname, &callback);
-    return result;
-}
-
-/******************************************************
- * For each file and directory name in pathname[],
- * pass it to the callback delegate.
- *
- * Note:
- *
- * This function is being phased out. New code should use $(D_PARAM
- * dirEntries) (see below).
- * 
- * Params:
- *	callback =	Delegate that processes each
- *			filename in turn. Returns true to
- *			continue, false to stop.
- * Example:
- *	This program lists all the files in its
- *	path argument, including the path.
- * ----
- * import std.stdio;
- * import std.path;
- * import std.file;
- *
- * void main(string[] args)
- * {
- *    auto pathname = args[1];
- *    string[] result;
- *
- *    bool listing(string filename)
- *    {
- *      result ~= std.path.join(pathname, filename);
- *      return true; // continue
- *    }
- *
- *    listdir(pathname, &listing);
- *
- *    foreach (name; result)
- *      writefln("%s", name);
- * }
- * ----
- */
-
-void listdir(in string pathname, bool delegate(string filename) callback)
-{
-    bool listing(DirEntry* de)
+        
+    ulong size()
     {
-	return callback(std.path.getBaseName(de.name));
+        ensureStatDone;
+        return _size;
     }
-
-    listdir(pathname, &listing);
+        
+    d_time creationTime()
+    {
+        ensureStatDone;
+        return _creationTime;
+    }
+        
+    d_time lastAccessTime()
+    {
+        ensureStatDone;
+        return _lastAccessTime;
+    }
+        
+    d_time lastWriteTime()
+    {
+        ensureStatDone;
+        return _lastWriteTime;
+    }
+        
+    /* This is to support lazy evaluation, because doing stat's is
+     * expensive and not always needed.
+     */
+        
+    void ensureStatDone()
+    {
+        if (didstat) return;
+        enforce(stat64(toStringz(name), &statbuf) == 0,
+                "Failed to stat file `"~name~"'");
+        _size = statbuf.st_size;
+        _creationTime = cast(d_time)statbuf.st_ctime
+            * std.date.ticksPerSecond;
+        _lastAccessTime = cast(d_time)statbuf.st_atime
+            * std.date.ticksPerSecond;
+        _lastWriteTime = cast(d_time)statbuf.st_mtime
+            * std.date.ticksPerSecond;
+        didstat = true;
+    }
 }
 
 /******************************************************
@@ -781,14 +883,14 @@
  *
  * This function is being phased out. New code should use $(D_PARAM
  * dirEntries) (see below).
- * 
+ *
  * Params:
- *	callback =	Delegate that processes each
- *			DirEntry in turn. Returns true to
- *			continue, false to stop.
+ *        callback =        Delegate that processes each
+ *                        DirEntry in turn. Returns true to
+ *                        continue, false to stop.
  * Example:
- *	This program lists all the files in its
- *	path argument and all subdirectories thereof.
+ *        This program lists all the files in its
+ *        path argument and all subdirectories thereof.
  * ----
  * import std.stdio;
  * import std.file;
@@ -809,326 +911,130 @@
  * ----
  */
 
-void listdir(in string pathname, bool delegate(DirEntry* de) callback)
+version(Windows) void listdir(in char[] pathname,
+        bool delegate(DirEntry* de) callback)
 {
-    string c;
-    HANDLE h;
     DirEntry de;
-
-    c = std.path.join(pathname, "*.*");
+    auto c = std.path.join(pathname, "*.*");
     if (useWfuncs)
     {
-	WIN32_FIND_DATAW fileinfo;
-
-	h = FindFirstFileW(std.utf.toUTF16z(c), &fileinfo);
-	if (h != INVALID_HANDLE_VALUE)
-	{
-	    try
-	    {
-		do
-		{
-		    // Skip "." and ".."
-		    if (std.string.wcscmp(fileinfo.cFileName.ptr, ".") == 0 ||
-			std.string.wcscmp(fileinfo.cFileName.ptr, "..") == 0)
-			continue;
-
-		    de.init(pathname, &fileinfo);
-		    if (!callback(&de))
-			break;
-		} while (FindNextFileW(h,&fileinfo) != FALSE);
-	    }
-	    finally
-	    {
-		FindClose(h);
-	    }
-	}
+        WIN32_FIND_DATAW fileinfo;
+        
+        auto h = FindFirstFileW(std.utf.toUTF16z(c), &fileinfo);
+        if (h == INVALID_HANDLE_VALUE)
+            return;
+        scope(exit) FindClose(h);
+        do
+        {
+            // Skip "." and ".."
+            if (std.string.wcscmp(fileinfo.cFileName.ptr, ".") == 0 ||
+                    std.string.wcscmp(fileinfo.cFileName.ptr, "..") == 0)
+                continue;
+            
+            de.init(pathname, &fileinfo);
+            if (!callback(&de))
+                break;
+        } while (FindNextFileW(h, &fileinfo) != FALSE);
     }
     else
     {
-	WIN32_FIND_DATA fileinfo;
-
-	h = FindFirstFileA(toMBSz(c), &fileinfo);
-	if (h != INVALID_HANDLE_VALUE)	// should we throw exception if invalid?
-	{
-	    try
-	    {
-		do
-		{
-		    // Skip "." and ".."
-		    if (std.c.string.strcmp(fileinfo.cFileName.ptr, ".") == 0 ||
-			std.c.string.strcmp(fileinfo.cFileName.ptr, "..") == 0)
-			continue;
-
-		    de.init(pathname, &fileinfo);
-		    if (!callback(&de))
-			break;
-		} while (FindNextFileA(h,&fileinfo) != FALSE);
-	    }
-	    finally
-	    {
-		FindClose(h);
-	    }
-	}
+        WIN32_FIND_DATA fileinfo;
+        
+        auto h = FindFirstFileA(toMBSz(c), &fileinfo);
+        if (h == INVALID_HANDLE_VALUE)
+            return;
+        
+        scope(exit) FindClose(h);
+        do
+        {
+            // Skip "." and ".."
+            if (std.c.string.strcmp(fileinfo.cFileName.ptr, ".") == 0 ||
+                    std.c.string.strcmp(fileinfo.cFileName.ptr, "..") == 0)
+                continue;
+            
+            de.init(pathname, &fileinfo);
+            if (!callback(&de))
+                break;
+        } while (FindNextFileA(h,&fileinfo) != FALSE);
     }
 }
 
-/******************************************
- * Since Win 9x does not support the "W" API's, first convert
- * to wchar, then convert to multibyte using the current code
- * page.
- * (Thanks to yaneurao for this)
- * Deprecated: use std.windows.charset.toMBSz instead.
- */
-
-const(char)* toMBSz(in string s)
+version(Posix) void listdir(in char[] pathname,
+        bool delegate(DirEntry* de) callback)
 {
-    return std.windows.charset.toMBSz(s);
-}
-
-
-/***************************************************
- * Copy a file from[] to[].
- */
-
-void copy(in string from, in string to)
-{
-    invariant result = useWfuncs
-	? CopyFileW(std.utf.toUTF16z(from), std.utf.toUTF16z(to), false)
-        : CopyFileA(toMBSz(from), toMBSz(to), false);
-    if (!result)
-         throw new FileException(to, GetLastError);
-}
-
-
-}
-
-/* =========================== Posix ======================= */
-
-else version (Posix)
-{
-
-private import std.c.unix.unix;
-private import std.date;
-
-alias std.c.unix.unix unix;
-
-/***********************************
- */
-
-class FileException : Exception
-{
-    uint errno;			// operating system error code
-
-    this(string name)
+    auto h = cenforce(opendir(toStringz(pathname)), pathname);
+    scope(exit) closedir(h);
+    DirEntry de;
+    for (dirent* fdata; (fdata = readdir(h)) != null; )
     {
-	this(name, "file I/O");
-    }
-
-    this(string name, string message)
-    {
-	super(name ~ ": " ~ message);
-    }
-
-    this(string name, uint errno)
-    {
-        char[1024] buf = void;
-	auto s = _d_gnu_cbridge_strerror(errno, buf.ptr, buf.length);
-	this(name, std.string.toString(s));
-	this.errno = errno;
+        // Skip "." and ".."
+        if (!std.c.string.strcmp(fdata.d_name.ptr, ".") ||
+                !std.c.string.strcmp(fdata.d_name.ptr, ".."))
+            continue;
+        de.init(pathname, fdata);
+        if (!callback(&de))
+            break;
     }
 }
 
-private T cenforce(T)(T condition, lazy const(char)[] name)
+/***************************************************
+Copy file $(D from) to file $(D to). File timestamps are preserved.
+ */
+
+version(Windows) void copy(in char[] from, in char[] to)
 {
-    if (!condition) throw new FileException(name.idup, getErrno());
-    return condition;
+    invariant result = useWfuncs
+        ? CopyFileW(std.utf.toUTF16z(from), std.utf.toUTF16z(to), false)
+        : CopyFileA(toMBSz(from), toMBSz(to), false);
+    if (!result)
+        throw new FileException(to.idup);
 }
 
-
-/********************************************
- * Read a file.
- * Returns:
- *	array of bytes read
- */
-
-void[] read(string name)
+version(Posix) void copy(in char[] from, in char[] to)
 {
-    invariant fd = unix.open(toStringz(name), O_RDONLY);
-    cenforce(fd != -1, name);
-    scope(exit) unix.close(fd);
-
-    struct_stat statbuf = void;
-    cenforce(unix.fstat(fd, &statbuf) == 0, name);
-
-    void[] buf;
-    auto size = statbuf.st_size;
-    if (size == 0)
-    {	/* The size could be 0 if the file is a device or a procFS file,
-	 * so we just have to try reading it.
-	 */
-	int readsize = 1024;
-	while (1)
-	{
-	    buf = GC.realloc(buf.ptr, size + readsize, GC.BlkAttr.NO_SCAN)[0 .. cast(int)size + readsize];
-	    enforce(buf, "Out of memory");
-	    scope(failure) delete buf;
-
-	    auto toread = readsize;
-	    while (toread)
-	    {
-		auto numread = unix.read(fd, buf.ptr + size, toread);
-		cenforce(numread != -1, name);
-		size += numread;
-		if (numread == 0)
-		{   if (size == 0)			// it really was 0 size
-			delete buf;			// don't need the buffer
-		    return buf[0 .. size];		// end of file
-		}
-		toread -= numread;
-	    }
-	}
+    invariant fd = core.sys.posix.fcntl.open(toStringz(from), O_RDONLY);
+    cenforce(fd != -1, from);
+    scope(exit) core.sys.posix.unistd.close(fd);
+        
+    struct_stat64 statbuf = void;
+    cenforce(fstat64(fd, &statbuf) == 0, from);
+    //cenforce(core.sys.posix.sys.stat.fstat(fd, &statbuf) == 0, from);
+        
+    auto toz = toStringz(to);
+    invariant fdw = core.sys.posix.fcntl.open(toz,
+            O_CREAT | O_WRONLY | O_TRUNC, 0660);
+    cenforce(fdw != -1, from);
+    scope(failure) std.c.stdio.remove(toz);
+    {
+        scope(failure) core.sys.posix.unistd.close(fdw);
+        auto BUFSIZ = 4096u * 16;
+        auto buf = std.c.stdlib.malloc(BUFSIZ);
+        if (!buf)
+        {
+            BUFSIZ = 4096;
+            buf = enforce(std.c.stdlib.malloc(BUFSIZ), "Out of memory");
+        }
+        scope(exit) std.c.stdlib.free(buf);
+            
+        for (auto size = statbuf.st_size; size; )
+        {
+            invariant toxfer = (size > BUFSIZ) ? BUFSIZ : cast(size_t) size;
+            cenforce(
+                core.sys.posix.unistd.read(fd, buf, toxfer) == toxfer
+                && core.sys.posix.unistd.write(fdw, buf, toxfer) == toxfer,
+                from);
+            assert(size >= toxfer);
+            size -= toxfer;
+        }
     }
-    else
-    {
-	buf = GC.malloc(size, GC.BlkAttr.NO_SCAN)[0 .. size];
-	enforce(buf, "Out of memory");
-	scope(failure) delete buf;
-
-	cenforce(unix.read(fd, buf.ptr, size) == size, name);
-
-	return buf[0 .. size];
-    }
-}
-
-unittest
-{
-    version (linux)
-    {	// A file with "zero" length that doesn't have 0 length at all
-	char[] s = cast(char[])std.file.read("/proc/sys/kernel/osrelease");
-	assert(s.length > 0);
-	//writefln("'%s'", s);
-    }
-}
-
-/********************************************
- * Read and validates (using $(XREF utf, validate)) a text file. $(D
- * S) can be a type of array of characters of any width and constancy.
- *
- * Returns: array of characters read
- *
- * Throws: $(D FileException) on file error, $(D UtfException) on UTF
- * decoding error.
- *      
- */
-
-S readText(S = string)(in string name)
-{
-    auto result = cast(S) read(name);
-    std.utf.validate(result);
-    return result;
-}
-
-// Implementation helper for write and append
-
-private void writeImpl(in string name, in void[] buffer, in uint mode)
-{
-    invariant fd = unix.open(toStringz(name),
-            mode, 0660);
-    cenforce(fd != -1, name);
-    {
-        scope(failure) unix.close(fd);
-        invariant size = buffer.length;
-        cenforce(unix.write(fd, buffer.ptr, size) == size, name);
-    }
-    cenforce(unix.close(fd) == 0, name);
-}
-
-
-/*********************************************
- * Write a file.
- */
-
-void write(in string name, in void[] buffer)
-{
-    return writeImpl(name, buffer, O_CREAT | O_WRONLY | O_TRUNC);
-}
-
-
-/*********************************************
- * Append to a file.
- */
-
-void append(in string name, in void[] buffer)
-{
-    return writeImpl(name, buffer, O_APPEND | O_WRONLY | O_CREAT);
-}
-
-
-/***************************************************
- * Rename a file.
- */
-
-void rename(in string from, in string to)
-{
-    cenforce(std.c.stdio.rename(toStringz(from), toStringz(to)) == 0, to);
-}
-
-
-/***************************************************
- * Delete a file.
- */
-
-void remove(in string name)
-{
-    cenforce(std.c.stdio.remove(toStringz(name)) == 0, name);
-}
-
-
-/***************************************************
- * Get file size.
- */
-
-ulong getSize(in string name)
-{
-    struct_stat statbuf = void;
-    cenforce(unix.stat(toStringz(name), &statbuf) == 0, name);
-    return statbuf.st_size;
-}
-
-unittest
-{
-    scope(exit) system("rm -f /tmp/deleteme");
-    // create a file of size 1
-    assert(system("echo > /tmp/deleteme") == 0);
-    assert(getSize("/tmp/deleteme") == 1);
-    // create a file of size 3
-    assert(system("echo ab > /tmp/deleteme") == 0);
-    assert(getSize("/tmp/deleteme") == 3);
-}
-
-/***************************************************
- * Get file attributes.
- */
-
-uint getAttributes(in string name)
-{
-    struct_stat statbuf = void;
-    cenforce(unix.stat(toStringz(name), &statbuf) == 0, name);
-    return statbuf.st_mode;
-}
-
-/*************************
- * Get creation/access/modified times of file $(D name).
- * Throws: $(D FileException) on error.
- */
-
-void getTimes(in string name, out d_time ftc, out d_time fta, out d_time ftm)
-{
-    struct_stat statbuf = void;
-    cenforce(unix.stat(toStringz(name), &statbuf) == 0, name);
-    ftc = cast(d_time) statbuf.st_ctime * std.date.TicksPerSecond;
-    fta = cast(d_time) statbuf.st_atime * std.date.TicksPerSecond;
-    ftm = cast(d_time) statbuf.st_mtime * std.date.TicksPerSecond;
+        
+    cenforce(core.sys.posix.unistd.close(fdw) != -1, from);
+        
+    utimbuf utim = void;
+    utim.actime = cast(time_t)statbuf.st_atime;
+    utim.modtime = cast(time_t)statbuf.st_mtime;
+        
+    cenforce(utime(toz, &utim) != -1, from);
 }
 
 /*************************
@@ -1136,198 +1042,76 @@
  * Throws: $(D FileException) on error.
  */
 
-void setTimes(in string name, d_time fta, d_time ftm)
+version(Windows) void setTimes(in char[] name, d_time fta, d_time ftm)
 {
-    version (all)
-    {
-version (none) // does not compile
-{
-        // utimbuf times = {
-        //     cast(__time_t) (fta / std.date.TicksPerSecond),
-        //     cast(__time_t) (ftm / std.date.TicksPerSecond) };
-        // enforce(utime(toStringz(name), &times) == 0);
-        timeval[2] t = void;
-        t[0].tv_sec = fta / std.date.TicksPerSecond;
-        t[0].tv_usec = cast(long) ((cast(double) fta / std.date.TicksPerSecond)
-                * 1_000_000) % 1_000_000;
-        t[1].tv_sec = ftm / std.date.TicksPerSecond;
-        t[1].tv_usec = cast(long) ((cast(double) ftm / std.date.TicksPerSecond)
-                * 1_000_000) % 1_000_000;
-        enforce(utime(toStringz(name), t.ptr) == 0);
-}
-else
-{
-	assert(0);
-}
-    }
-    else
-    {
-        if (true) enforce(false, "Not implemented");
-    }
+    const ta = d_time2FILETIME(fta);
+    const tm = d_time2FILETIME(ftm);
+    alias TypeTuple!(GENERIC_WRITE, 0, null, OPEN_EXISTING,
+            FILE_ATTRIBUTE_NORMAL, HANDLE.init)
+        defaults;
+    auto h = useWfuncs
+        ? CreateFileW(std.utf.toUTF16z(name), defaults)
+        : CreateFileA(toMBSz(name), defaults);
+    cenforce(h != INVALID_HANDLE_VALUE, name);
+    scope(exit) cenforce(CloseHandle(h), name);
+
+    cenforce(SetFileTime(h, null, &ta, &tm), name);
 }
 
+version(Posix) void setTimes(in char[] name, d_time fta, d_time ftm)
+{
+    timeval[2] t = void;
+    t[0].tv_sec = to!int(fta / std.date.ticksPerSecond);
+    t[0].tv_usec = cast(int)
+        (cast(long) ((cast(double) fta / std.date.ticksPerSecond)
+                * 1_000_000) % 1_000_000);
+    t[1].tv_sec = to!int(ftm / std.date.ticksPerSecond);
+    t[1].tv_usec = cast(int)
+        (cast(long) ((cast(double) ftm / std.date.ticksPerSecond)
+                * 1_000_000) % 1_000_000);
+    enforce(utimes(toStringz(name), t) == 0);
+}
+/+
 unittest
 {
-    system("touch deleteme") == 0 || assert(false);
+    system("echo a>deleteme") == 0 || assert(false);
     scope(exit) remove("deleteme");
     d_time ftc1, fta1, ftm1;
     getTimes("deleteme", ftc1, fta1, ftm1);
+    enforce(collectException(setTimes("nonexistent", fta1, ftm1)));
     setTimes("deleteme", fta1 + 1000, ftm1 + 1000);
     d_time ftc2, fta2, ftm2;
     getTimes("deleteme", ftc2, fta2, ftm2);
-    assert(fta1 + 1000 == fta2);
+    assert(fta1 + 1000 == fta2, text(fta1 + 1000, "!=", fta2));
     assert(ftm1 + 1000 == ftm2);
 }
-
-/**
-   Returns the time of the last modification of file $(D name). If the
-   file does not exist, throws a $(D FileException).
-*/
-
-d_time lastModified(in string name)
-{
-    struct_stat statbuf = void;
-    cenforce(unix.stat(toStringz(name), &statbuf) == 0, name);
-    return cast(d_time) statbuf.st_mtime * std.date.TicksPerSecond;
-}
-
-/**
-Returns the time of the last modification of file $(D name). If the
-file does not exist, returns $(D returnIfMissing).
-
-A frequent usage pattern occurs in build automation tools such as
-$(WEB www.gnu.org/software/make, make) or $(WEB
-en.wikipedia.org/wiki/Apache_Ant, ant). To check whether file $(D
-target) must be rebuilt from file $(D source) (i.e., $(D target) is
-older than $(D source) or does not exist), use the comparison below.
-
-----------------------------
-if (lastModified(source) >= lastModified(target, d_time.min))
-{
-    ... must (re)build ...
-}
-else
-{
-    ... target's up-to-date ...
-}
-----------------------------
-
-The code above throws a $(D FileException) if $(D source) does not
-exist (as it should). On the other hand, the $(D d_time.min) default
-makes a non-existing $(D target) seem infinitely old so the test
-correctly prompts building it.
-
-*/
-
-d_time lastModified(string name, d_time returnIfMissing)
-{
-    struct_stat statbuf = void;
-    return unix.stat(toStringz(name), &statbuf) != 0
-        ? returnIfMissing
-        : cast(d_time) statbuf.st_mtime * std.date.TicksPerSecond;
-}
-
-unittest
-{
-    system("touch deleteme") == 0 || assert(false);
-    scope(exit) remove("deleteme");
-    assert(lastModified("deleteme") > 
-        lastModified("this file does not exist", d_time.min));
-    assert(lastModified("deleteme") > lastModified(__FILE__));
-}
-
-/****************************************************
- * Does file/directory exist?
- */
-
-bool exists(in char[] name)
-{
-    return access(toStringz(name), 0) == 0;
-}
-
-unittest
-{
-    assert(exists("."));
-    assert(!exists("this file does not exist"));
-    system("touch deleteme") == 0 || assert(false);
-    scope(exit) remove("deleteme");
-    assert(exists("deleteme"));
-}
-
-/****************************************************
- * Is name a file?
- */
-
-bool isfile(in string name)
-{
-    return (getAttributes(name) & S_IFMT) == S_IFREG;	// regular file
-}
-
-/****************************************************
- * Is name a directory?
- */
-
-bool isdir(in string name)
-{
-    return (getAttributes(name) & S_IFMT) == S_IFDIR;
-}
-
-/****************************************************
- * Change directory.
- */
-
-void chdir(string pathname)
-{
-    cenforce(unix.chdir(toStringz(pathname)) == 0, pathname);
-}
-
-/****************************************************
- * Make directory.
- */
-
-void mkdir(in char[] pathname)
-{
-    cenforce(unix.mkdir(toStringz(pathname), 0777) == 0, pathname);
-}
-
-/****************************************************
- * Make directory and all parent directories as needed.
- */
-
-void mkdirRecurse(in char[] pathname)
-{
-    auto left = dirname(pathname);
-    exists(left) || mkdirRecurse(left);
-    mkdir(pathname);
-}
-
-/****************************************************
- * Remove directory.
- */
-
-void rmdir(string pathname)
-{
-    cenforce(unix.rmdir(toStringz(pathname)) == 0, pathname);
-}
-
++/
+    
 /****************************************************
 Remove directory and all of its content and subdirectories,
 recursively.
  */
 
-void rmdirRecurse(string pathname)
+void rmdirRecurse(in char[] pathname)
 {
     // all children, recursively depth-first
-    foreach (DirEntry e; dirEntries(pathname, SpanMode.depth))
+    foreach (DirEntry e; dirEntries(pathname.idup, SpanMode.depth))
     {
-        throw new FileException(pathname, getErrno());
         e.isdir ? rmdir(e.name) : remove(e.name);
     }
     // the dir itself
     rmdir(pathname);
 }
 
-unittest
+version(Windows) unittest
+{
+    auto d = r"c:\deleteme\a\b\c\d\e\f\g";
+    mkdirRecurse(d);
+    rmdirRecurse(r"c:\deleteme");
+    enforce(!exists(r"c:\deleteme"));
+}
+
+version(Posix) unittest
 {
     auto d = "/tmp/deleteme/a/b/c/d/e/f/g";
     enforce(collectException(mkdir(d)));
@@ -1336,288 +1120,13 @@
     enforce(!exists("/tmp/deleteme"));
 }
 
-/****************************************************
- * Get current directory.
- */
-
-string getcwd()
-{
-    version(all)
-    {
-	char buf[PATH_MAX] = void;
-	cenforce(unix.getcwd(buf.ptr, buf.length),
-            "cannot get cwd");
-	return buf[0 .. std.c.string.strlen(buf.ptr)].idup;
-    }
-    else
-    {
-    auto p = cenforce(std.c.linux.linux.getcwd(null, 0),
-            "cannot get cwd");
-    scope(exit) std.c.stdlib.free(p);
-    return p[0 .. std.c.string.strlen(p)].idup;
-    }
-}
-
-/***************************************************
- * Directory Entry
- */
-
-struct DirEntry
-{
-    string name;			/// file or directory name
-    ulong _size = ~0UL;			// size of file in bytes
-    d_time _creationTime = d_time_nan;	// time of file creation
-    d_time _lastAccessTime = d_time_nan; // time file was last accessed
-    d_time _lastWriteTime = d_time_nan;	// time file was last written to
-    version (GNU)
-	{ }
-    else
-	ubyte d_type;
-    struct_stat statbuf;
-    bool didstat;			// done lazy evaluation of stat()
-
-    void init(string path, dirent *fd)
-    {
-        invariant len = std.c.string.strlen(fd.d_name.ptr);
-	name = std.path.join(path, fd.d_name[0 .. len].idup);
-	version(GNU)
-	    { }
-	else
-	    d_type = fd.d_type;
-	didstat = false;
-    }
-
-    bool isdir()
-    {
-	version(GNU)
-	{
-	    ensureStatDone;
-	    return (statbuf.st_mode & S_IFMT) == S_IFDIR;
-	}
-	else
-	    return (d_type & DT_DIR) != 0;
-    }
-
-    bool isfile()
-    {
-	version(GNU)
-	{
-	    ensureStatDone;
-	    return (statbuf.st_mode & S_IFMT) == S_IFREG;
-	}
-	else
-	    return (d_type & DT_REG) != 0;
-    }
-
-    ulong size()
-    {
-	ensureStatDone;
-	return _size;
-    }
-
-    d_time creationTime()
-    {
-	ensureStatDone;
-	return _creationTime;
-    }
-
-    d_time lastAccessTime()
-    {
-	ensureStatDone;
-	return _lastAccessTime;
-    }
-
-    d_time lastWriteTime()
-    {
-	ensureStatDone;
-	return _lastWriteTime;
-    }
-
-    /* This is to support lazy evaluation, because doing stat's is
-     * expensive and not always needed.
-     */
-
-    void ensureStatDone()
-    {
-        if (didstat) return;
-	enforce(unix.stat(toStringz(name), &statbuf) == 0,
-                "Failed to stat file `"~name~"'");
-	_size = cast(ulong)statbuf.st_size;
-	version (linux)
-	{
-	    _creationTime = cast(d_time)statbuf.st_ctime * std.date.TicksPerSecond;
-	    _lastAccessTime = cast(d_time)statbuf.st_atime * std.date.TicksPerSecond;
-	    _lastWriteTime = cast(d_time)statbuf.st_mtime * std.date.TicksPerSecond;
-	}
-	else version (OSX)
-	{
-	    _creationTime =   cast(d_time)statbuf.st_ctimespec.tv_sec * std.date.TicksPerSecond;
-	    _lastAccessTime = cast(d_time)statbuf.st_atimespec.tv_sec * std.date.TicksPerSecond;
-	    _lastWriteTime =  cast(d_time)statbuf.st_mtimespec.tv_sec * std.date.TicksPerSecond;
-	}
-	else
-	{
-	    static assert(0);
-	}
-
-	didstat = true;
-    }
-}
-
-
-/***************************************************
- * Return contents of directory.
- */
-
-string[] listdir(string pathname)
-{
-    string[] result;
-    
-    bool listing(string filename)
-    {
-	result ~= filename;
-	return true; // continue
-    }
-    
-    listdir(pathname, &listing);
-    return result;
-}
-
-string[] listdir(string pathname, string pattern)
-{   string[] result;
-    
-    bool callback(DirEntry* de)
-    {
-	if (de.isdir)
-	    listdir(de.name, &callback);
-	else
-	{   if (std.path.fnmatch(de.name, pattern))
-		result ~= de.name;
-	}
-	return true; // continue
-    }
-    
-    listdir(pathname, &callback);
-    return result;
-}
-
-string[] listdir(string pathname, RegExp r)
-{   string[] result;
-    
-    bool callback(DirEntry* de)
-    {
-	if (de.isdir)
-	    listdir(de.name, &callback);
-	else
-	{   if (r.test(de.name))
-		result ~= de.name;
-	}
-	return true; // continue
-    }
-    
-    listdir(pathname, &callback);
-    return result;
-}
-
-void listdir(string pathname, bool delegate(string filename) callback)
-{
-    bool listing(DirEntry* de)
-    {
-	return callback(std.path.getBaseName(de.name));
-    }
-
-    listdir(pathname, &listing);
-}
-
-void listdir(string pathname, bool delegate(DirEntry* de) callback)
-{
-    auto h = cenforce(opendir(toStringz(pathname)), pathname);
-    scope(exit) closedir(h);
-    /*DirEntry de;
-    for (dirent* fdata; (fdata = readdir(h)) != null; )
-    {
-        // Skip "." and ".."
-        if (!std.c.string.strcmp(fdata.d_name.ptr, ".") ||
-                !std.c.string.strcmp(fdata.d_name.ptr, ".."))
-            continue;
-        de.init(pathname, fdata);
-        if (!callback(&de))	    
-            break;
-    }*/
-}
-
-
-
-/***************************************************
- * Copy a file. File timestamps are preserved.
- */
-
-void copy(in string from, in string to)
-{
-    version (all)
-    {
-        invariant fd = unix.open(toStringz(from), O_RDONLY);
-        cenforce(fd != -1, from);
-        scope(exit) unix.close(fd);
-
-        struct_stat statbuf = void;
-        cenforce(unix.fstat(fd, &statbuf) == 0, from);
-
-        auto toz = toStringz(to);
-        invariant fdw = unix.open(toz,
-                O_CREAT | O_WRONLY | O_TRUNC, 0660);
-        cenforce(fdw != -1, from);
-        scope(failure) std.c.stdio.remove(toz);
-        {
-            scope(failure) unix.close(fdw);
-            auto BUFSIZ = 4096u * 16;
-            auto buf = std.c.stdlib.malloc(BUFSIZ);
-            if (!buf)
-            {
-                BUFSIZ = 4096;
-                buf = enforce(std.c.stdlib.malloc(BUFSIZ), "Out of memory");
-            }
-            scope(exit) std.c.stdlib.free(buf);
-            
-            for (auto size = statbuf.st_size; size; )
-            {
-                invariant toxfer = (size > BUFSIZ) ? BUFSIZ : size;
-                cenforce(unix.read(fd, buf, toxfer) == toxfer
-                        && unix.write(fdw, buf, toxfer) == toxfer,
-                        from);
-                assert(size >= toxfer);
-                size -= toxfer;
-            }
-        }
-        
-        cenforce(unix.close(fdw) != -1, from);
-        
-        utimbuf utim = void;
-        utim.actime = cast(typeof(utim.actime)) statbuf.st_atime;
-        utim.modtime = cast(typeof(utim.actime)) statbuf.st_mtime;
-        cenforce(utime(toz, &utim) != -1, from);
-    }
-    else
-    {
-        void[] buffer;
-        
-        buffer = read(from);
-        write(to, buffer);
-        delete buffer;
-    }
-}
-
-
-
-}
-
 unittest
 {
-    //printf("std.file.unittest\n");
     void[] buf;
 
     buf = new void[10];
     (cast(byte[])buf)[] = 3;
+    if (exists("unittest_write.tmp")) remove("unittest_write.tmp");
     write("unittest_write.tmp", buf);
     void buf2[] = read("unittest_write.tmp");
     assert(buf == buf2);
@@ -1627,28 +1136,26 @@
     assert(buf == buf2);
 
     remove("unittest_write.tmp");
-    if (exists("unittest_write.tmp"))
-	assert(0);
+    assert(!exists("unittest_write.tmp"));
     remove("unittest_write2.tmp");
-    if (exists("unittest_write2.tmp"))
-	assert(0);
+    assert(!exists("unittest_write2.tmp"));
 }
 
 unittest
 {
     listdir (".", delegate bool (DirEntry * de)
     {
-	auto s = std.string.format("%s : c %s, w %s, a %s", de.name,
-		toUTCString (de.creationTime),
-		toUTCString (de.lastWriteTime),
-		toUTCString (de.lastAccessTime));
-	return true;
+        auto s = std.string.format("%s : c %s, w %s, a %s", de.name,
+                toUTCString (de.creationTime),
+                toUTCString (de.lastWriteTime),
+                toUTCString (de.lastAccessTime));
+        return true;
     }
     );
 }
 
 /**
- * Dictates directory spanning policy for $(D_PARAM dirEntries) (see below). 
+ * Dictates directory spanning policy for $(D_PARAM dirEntries) (see below).
  */
 
 enum SpanMode
@@ -1672,7 +1179,7 @@
     private int doIt(D)(D dg, DirEntry * de)
     {
         alias ParameterTypeTuple!(D) Parms;
-        static if (is(Parms[0] : string))
+        static if (is(Parms[0] : const(char)[]))
         {
             return dg(de.name);
         }
@@ -1686,11 +1193,12 @@
                           " against type " ~ Parms[0].stringof);
         }
     }
-    
+
     int opApply(D)(D dg)
     {
         int result = 0;
-        string[] worklist = [ pathname ]; // used only in breadth-first traversal
+        // worklist used only in breadth-first traversal
+        string[] worklist = [ pathname ]; 
 
         bool callback(DirEntry* de)
         {
@@ -1718,7 +1226,7 @@
                 }
                 break;
             }
-            return result == 0; 
+            return result == 0;
         }
         // consume the worklist
         while (worklist.length)
@@ -1769,27 +1277,264 @@
 
 unittest
 {
-  version (Posix)
-  {
-    assert(system("mkdir -p dmd-testing") == 0);
-    scope(exit) system("rm -rf dmd-testing");
-    assert(system("mkdir -p dmd-testing/somedir") == 0);
-    assert(system("touch dmd-testing/somefile") == 0);
-    assert(system("touch dmd-testing/somedir/somedeepfile") == 0);
-    foreach (string name; dirEntries("dmd-testing", SpanMode.shallow))
+    version (linux)
     {
+        assert(system("mkdir --parents dmd-testing") == 0);
+        scope(exit) system("rm -rf dmd-testing");
+        assert(system("mkdir --parents dmd-testing/somedir") == 0);
+        assert(system("touch dmd-testing/somefile") == 0);
+        assert(system("touch dmd-testing/somedir/somedeepfile") == 0);
+        foreach (string name; dirEntries("dmd-testing", SpanMode.shallow))
+        {
+        }
+        foreach (string name; dirEntries("dmd-testing", SpanMode.depth))
+        {
+            //writeln(name);
+        }
+        foreach (string name; dirEntries("dmd-testing", SpanMode.breadth))
+        {
+            //writeln(name);
+        }
+        foreach (DirEntry e; dirEntries("dmd-testing", SpanMode.breadth))
+        {
+            //writeln(e.name);
+        }
     }
-    foreach (string name; dirEntries("dmd-testing", SpanMode.depth))
+}
+
+/**
+Reads an entire file into an array.
+
+Example:
+----
+// Load file; each line is an int followed by comma, whitespace and a
+// double.
+auto a = slurp!(int, double)("filename", "%s, %s");
+----
+ */
+Select!(Types.length == 1, Types[0][], Tuple!(Types)[])
+slurp(Types...)(string filename, in char[] format)
+{
+    typeof(return) result;
+    auto app = appender(&result);
+    ElementType!(typeof(return)) toAdd;
+    auto f = File(filename);
+    scope(exit) f.close;
+    foreach (line; f.byLine())
     {
-        //writeln(name);
+        line = formattedRead(line, format, &toAdd);
+        enforce(line.empty,
+                text("Trailing characters at the end of line: `", line,
+                        "'"));
+        app.put(toAdd);
     }
-    foreach (string name; dirEntries("dmd-testing", SpanMode.breadth))
+    return result;
+}
+
+unittest
+{
+    // Tuple!(int, double)[] x;
+    // auto app = appender(&x);
+    write("deleteme", "12 12.25\n345 1.125");
+    scope(exit) remove("deleteme");
+    auto a = slurp!(int, double)("deleteme", "%s %s");
+    assert(a.length == 2);
+    assert(a[0] == tuple(12, 12.25));
+    assert(a[1] == tuple(345, 1.125));
+}
+
+/***************************************************
+ * Return contents of directory pathname[].
+ * The names in the contents do not include the pathname.
+ * Throws: $(D FileException) on error
+ * Example:
+ *        This program lists all the files and subdirectories in its
+ *        path argument.
+ * ----
+ * import std.stdio;
+ * import std.file;
+ *
+ * void main(string[] args)
+ * {
+ *    auto dirs = std.file.listdir(args[1]);
+ *
+ *    foreach (d; dirs)
+ *        writefln(d);
+ * }
+ * ----
+ */
+
+string[] listdir(in char[] pathname)
+{
+    Appender!(string[]) result;
+    
+    bool listing(string filename)
     {
-        //writeln(name);
+        result.put(filename);
+        return true; // continue
     }
-    foreach (DirEntry e; dirEntries("dmd-testing", SpanMode.breadth))
+    
+    listdir(pathname, &listing);
+    return result.data;
+}
+
+unittest
+{
+    assert(listdir(".").length > 0);
+}
+
+/*****************************************************
+ * Return all the files in the directory and its subdirectories
+ * that match pattern or regular expression r.
+ * Params:
+ *        pathname = Directory name
+ *        pattern = String with wildcards, such as $(RED "*.d"). The supported
+ *                wildcard strings are described under fnmatch() in
+ *                $(LINK2 std_path.html, std.path).
+ *        r = Regular expression, for more powerful _pattern matching.
+ * Example:
+ *        This program lists all the files with a "d" extension in
+ *        the path passed as the first argument.
+ * ----
+ * import std.stdio;
+ * import std.file;
+ *
+ * void main(string[] args)
+ * {
+ *    auto d_source_files = std.file.listdir(args[1], "*.d");
+ *
+ *    foreach (d; d_source_files)
+ *        writefln(d);
+ * }
+ * ----
+ * A regular expression version that searches for all files with "d" or
+ * "obj" extensions:
+ * ----
+ * import std.stdio;
+ * import std.file;
+ * import std.regexp;
+ *
+ * void main(string[] args)
+ * {
+ *    auto d_source_files = std.file.listdir(args[1], RegExp(r"\.(d|obj)$"));
+ *
+ *    foreach (d; d_source_files)
+ *        writefln(d);
+ * }
+ * ----
+ */
+
+string[] listdir(in char[] pathname, in char[] pattern)
+{
+    Appender!(string[]) result;
+    
+    bool callback(DirEntry* de)
     {
-        //writeln(e.name);
+        if (de.isdir)
+            listdir(de.name, &callback);
+        else
+        {
+            if (std.path.fnmatch(de.name, pattern))
+                result.put(de.name);
+        }
+        return true; // continue
     }
-  }
+    
+    listdir(pathname, &callback);
+    return result.data;
 }
+    
+/** Ditto */
+    
+string[] listdir(in char[] pathname, RegExp r)
+{
+    Appender!(string[]) result;
+    
+    bool callback(DirEntry* de)
+    {
+        if (de.isdir)
+            listdir(de.name, &callback);
+        else
+        {
+            if (r.test(de.name))
+                result.put(de.name);
+        }
+        return true; // continue
+    }
+    
+    listdir(pathname, &callback);
+    return result.data;
+}
+    
+/******************************************************
+ * For each file and directory name in pathname[],
+ * pass it to the callback delegate.
+ *
+ * Note:
+ *
+ * This function is being phased out. New code should use $(D_PARAM
+ * dirEntries) (see below).
+ *
+ * Params:
+ *        callback =        Delegate that processes each
+ *                        filename in turn. Returns true to
+ *                        continue, false to stop.
+ * Example:
+ *        This program lists all the files in its
+ *        path argument, including the path.
+ * ----
+ * import std.stdio;
+ * import std.path;
+ * import std.file;
+ *
+ * void main(string[] args)
+ * {
+ *    auto pathname = args[1];
+ *    string[] result;
+ *
+ *    bool listing(string filename)
+ *    {
+ *      result ~= std.path.join(pathname, filename);
+ *      return true; // continue
+ *    }
+ *
+ *    listdir(pathname, &listing);
+ *
+ *    foreach (name; result)
+ *      writefln("%s", name);
+ * }
+ * ----
+ */
+
+void listdir(in char[] pathname, bool delegate(string filename) callback)
+{
+    bool listing(DirEntry* de)
+    {
+        return callback(std.path.getBaseName(de.name));
+    }
+    
+    listdir(pathname, &listing);
+}
+
+/*
+ *  Copyright (C) 2001-2004 by Digital Mars, www.digitalmars.com
+ * Written by Walter Bright, Christopher E. Miller, Andre Fornacon
+ *
+ *  This software is provided 'as-is', without any express or implied
+ *  warranty. In no event will the authors be held liable for any damages
+ *  arising from the use of this software.
+ *
+ *  Permission is granted to anyone to use this software for any purpose,
+ *  including commercial applications, and to alter it and redistribute it
+ *  freely, subject to the following restrictions:
+ *
+ *  o  The origin of this software must not be misrepresented; you must not
+ *     claim that you wrote the original software. If you use this software
+ *     in a product, an acknowledgment in the product documentation would be
+ *     appreciated but is not required.
+ *  o  Altered source versions must be plainly marked as such, and must not
+ *     be misrepresented as being the original software.
+ *  o  This notice may not be removed or altered from any source
+ *     distribution.
+ */
+
diff -r f12bfe124807 d/phobos2/std/format.d
--- a/d/phobos2/std/format.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/format.d	Thu Oct 14 14:12:53 2010 +0100
@@ -1,4 +1,3 @@
-
 // Written in the D programming language.
 
 /**
@@ -9,57 +8,37 @@
  *	WIKI = Phobos/StdFormat
  */
 
-/*
- *  Copyright (C) 2004-2006 by Digital Mars, www.digitalmars.com
- *  Written by Walter Bright and Andrei Alexandrescu
- *
- *  This software is provided 'as-is', without any express or implied
- *  warranty. In no event will the authors be held liable for any damages
- *  arising from the use of this software.
- *
- *  Permission is granted to anyone to use this software for any purpose,
- *  including commercial applications, and to alter it and redistribute it
- *  freely, subject to the following restrictions:
- *
- *  o  The origin of this software must not be misrepresented; you must not
- *     claim that you wrote the original software. If you use this software
- *     in a product, an acknowledgment in the product documentation would be
- *     appreciated but is not required.
- *  o  Altered source versions must be plainly marked as such, and must not
- *     be misrepresented as being the original software.
- *  o  This notice may not be removed or altered from any source
- *     distribution.
+/* NOTE: This file has been patched from the original DMD distribution to
+   work with the GDC compiler.
  */
 
 module std.format;
 
 //debug=format;		// uncomment to turn on debugging printf's
 
+import std.algorithm;
 import std.stdarg;	// caller will need va_list
-
-private import std.utf;
-private import std.c.stdio;
-private import std.c.stdlib;
-private import std.c.string;
-private import std.string;
+import std.array;
+import std.utf;
+import std.c.stdio;
+import std.c.stdlib;
+import std.c.string;
+import std.string;
 import std.ctype;
 import std.conv;
+import std.functional;
 import std.traits;
 import std.typetuple;
-import std.stdio; // for debugging only
 import std.contracts;
 import std.system;
+import std.range;
+version(unittest) {
+    import std.stdio, std.typecons;
+}
 
-version (Windows)
+version (Windows) version (DigitalMars)
 {
-    version (DigitalMars)
-    {
-	version = DigitalMarsC;
-    }
-    version (GNU)
-    {
-	version = GNU_MinGW_MSVCRT;
-    }
+    version = DigitalMarsC;
 }
 
 version (DigitalMarsC)
@@ -67,15 +46,16 @@
     // This is DMC's internal floating point formatting function
     extern (C)
     {
-	extern char* function(int c, int flags, int precision, real* pdval,
-	    char* buf, int* psl, int width) __pfloatfmt;
+	extern char* function(int c, int flags, int precision,
+                in real* pdval,
+                char* buf, size_t* psl, int width) __pfloatfmt;
     }
     alias std.c.stdio._snprintf snprintf;
 }
 else
 {
     // Use C99 snprintf
-    extern (C) int snprintf(char* s, size_t n, const char* format, ...);
+    extern (C) int snprintf(char* s, size_t n, in char* format, ...);
 }
 
 /**********************************************************************
@@ -138,90 +118,68 @@
     Tinvariant = 'y',
 }
 
-// return the TypeInfo for a primitive type and null otherwise.
-// This is required since for arrays of ints we only have the mangled
-// char to work from. If arrays always subclassed TypeInfo_Array this
+// return the TypeInfo for a primitive type and null otherwise.  This
+// is required since for arrays of ints we only have the mangled char
+// to work from. If arrays always subclassed TypeInfo_Array this
 // routine could go away.
 private TypeInfo primitiveTypeInfo(Mangle m) 
 {
-  TypeInfo ti;
-
-  switch (m)
-    {
-    case Mangle.Tvoid:
-      ti = typeid(void);break;
-    case Mangle.Tbool:
-      ti = typeid(bool);break;
-    case Mangle.Tbyte:
-      ti = typeid(byte);break;
-    case Mangle.Tubyte:
-      ti = typeid(ubyte);break;
-    case Mangle.Tshort:
-      ti = typeid(short);break;
-    case Mangle.Tushort:
-      ti = typeid(ushort);break;
-    case Mangle.Tint:
-      ti = typeid(int);break;
-    case Mangle.Tuint:
-      ti = typeid(uint);break;
-    case Mangle.Tlong:
-      ti = typeid(long);break;
-    case Mangle.Tulong:
-      ti = typeid(ulong);break;
-    case Mangle.Tfloat:
-      ti = typeid(float);break;
-    case Mangle.Tdouble:
-      ti = typeid(double);break;
-    case Mangle.Treal:
-      ti = typeid(real);break;
-    case Mangle.Tifloat:
-      ti = typeid(ifloat);break;
-    case Mangle.Tidouble:
-      ti = typeid(idouble);break;
-    case Mangle.Tireal:
-      ti = typeid(ireal);break;
-    case Mangle.Tcfloat:
-      ti = typeid(cfloat);break;
-    case Mangle.Tcdouble:
-      ti = typeid(cdouble);break;
-    case Mangle.Tcreal:
-      ti = typeid(creal);break;
-    case Mangle.Tchar:
-      ti = typeid(char);break;
-    case Mangle.Twchar:
-      ti = typeid(wchar);break;
-    case Mangle.Tdchar:
-      ti = typeid(dchar);
-    default:
-      ti = null;
+    static TypeInfo[Mangle] dic;
+    if (!dic.length) {
+        dic = [
+            Mangle.Tvoid : typeid(void),
+            Mangle.Tbool : typeid(bool),
+            Mangle.Tbyte : typeid(byte),
+            Mangle.Tubyte : typeid(ubyte),
+            Mangle.Tshort : typeid(short),
+            Mangle.Tushort : typeid(ushort),
+            Mangle.Tint : typeid(int),
+            Mangle.Tuint : typeid(uint),
+            Mangle.Tlong : typeid(long),
+            Mangle.Tulong : typeid(ulong),
+            Mangle.Tfloat : typeid(float),
+            Mangle.Tdouble : typeid(double),
+            Mangle.Treal : typeid(real),
+            Mangle.Tifloat : typeid(ifloat),
+            Mangle.Tidouble : typeid(idouble),
+            Mangle.Tireal : typeid(ireal),
+            Mangle.Tcfloat : typeid(cfloat),
+            Mangle.Tcdouble : typeid(cdouble),
+            Mangle.Tcreal : typeid(creal),
+            Mangle.Tchar : typeid(char),
+            Mangle.Twchar : typeid(wchar),
+            Mangle.Tdchar : typeid(dchar)
+            ];
     }
-  return ti;
+    auto p = m in dic;
+    return p ? *p : null;
 }
 
 /************************************
- * Interprets variadic argument list pointed to by argptr whose types are given
- * by arguments[], formats them according to embedded format strings in the
- * variadic argument list, and sends the resulting characters to putc.
+ * Interprets variadic argument list pointed to by argptr whose types
+ * are given by arguments[], formats them according to embedded format
+ * strings in the variadic argument list, and sends the resulting
+ * characters to putc.
  *
- * The variadic arguments are consumed in order.
- * Each is formatted into a sequence of chars, using the default format
- * specification for its type, and the
- * characters are sequentially passed to putc.
- * If a char[], wchar[], or dchar[]
- * argument is encountered, it is interpreted as a format string. As many
- * arguments as specified in the format string are consumed and formatted
- * according to the format specifications in that string and passed to putc. If
- * there are too few remaining arguments, a FormatError is thrown. If there are
- * more remaining arguments than needed by the format specification, the default
- * processing of arguments resumes until they are all consumed.
+ * The variadic arguments are consumed in order.  Each is formatted
+ * into a sequence of chars, using the default format specification
+ * for its type, and the characters are sequentially passed to putc.
+ * If a $(D char[]), $(D wchar[]), or $(D dchar[]) argument is
+ * encountered, it is interpreted as a format string. As many
+ * arguments as specified in the format string are consumed and
+ * formatted according to the format specifications in that string and
+ * passed to putc. If there are too few remaining arguments, a
+ * FormatError is thrown. If there are more remaining arguments than
+ * needed by the format specification, the default processing of
+ * arguments resumes until they are all consumed.
  *
  * Params:
  *	putc =	Output is sent do this delegate, character by character.
- *	arguments = Array of TypeInfo's, one for each argument to be formatted.
+ *	arguments = Array of $(D TypeInfo)s, one for each argument to be formatted.
  *	argptr = Points to variadic argument list.
  *
  * Throws:
- *	Mismatched arguments and formats result in a FormatError being thrown.
+ *	Mismatched arguments and formats result in a $(D FormatError) being thrown.
  *
  * Format_String:
  *	<a name="format-string">$(I Format strings)</a>
@@ -461,8 +419,7 @@
     doFormatPtr(putc, arguments, argptr, null);
 }
 
-void doFormatPtr(void delegate(dchar) putc, TypeInfo[] arguments, va_list argptr,
-	      void * p_args)
+void doFormatPtr(void delegate(dchar) putc, TypeInfo[] arguments, va_list argptr, void* p_args)
 {   int j;
     TypeInfo ti;
     Mangle m;
@@ -483,18 +440,18 @@
 
     static TypeInfo skipCI(TypeInfo valti)
     {
-      while (1)
-      {
-	if (valti.classinfo.name.length == 18 &&
-	    valti.classinfo.name[9..18] == "Invariant")
-	    valti =	(cast(TypeInfo_Invariant)valti).next;
-	else if (valti.classinfo.name.length == 14 &&
-	    valti.classinfo.name[9..14] == "Const")
-	    valti =	(cast(TypeInfo_Const)valti).next;
-	else
-	    break;
-      }
-      return valti;
+        for (;;)
+        {
+            if (valti.classinfo.name.length == 18 &&
+                    valti.classinfo.name[9..18] == "Invariant")
+                valti =	(cast(TypeInfo_Invariant)valti).next;
+            else if (valti.classinfo.name.length == 14 &&
+                    valti.classinfo.name[9..14] == "Const")
+                valti =	(cast(TypeInfo_Const)valti).next;
+            else
+                break;
+        }
+        return valti;
     }
 
     void formatArg(char fc)
@@ -553,7 +510,7 @@
 	void putreal(real v)
 	{
 	    //printf("putreal %Lg\n", vreal);
-
+        
 	    switch (fc)
 	    {
 		case 's':
@@ -570,76 +527,68 @@
 	    }
 	    version (DigitalMarsC)
 	    {
-		int sl;
-		char[] fbuf = tmpbuf;
-		if (!(flags & FLprecision))
-		    precision = 6;
-		while (1)
-		{
-		    sl = fbuf.length;
-		    prefix = (*__pfloatfmt)(fc, flags | FLlngdbl,
-			    precision, &v, cast(char*)fbuf, &sl, field_width);
+            uint sl;
+            char[] fbuf = tmpbuf;
+            if (!(flags & FLprecision))
+                precision = 6;
+            while (1)
+            {
+                sl = fbuf.length;
+                prefix = (*__pfloatfmt)(fc, flags | FLlngdbl,
+                        precision, &v, cast(char*)fbuf, &sl, field_width);
 		    if (sl != -1)
-			break;
+                break;
 		    sl = fbuf.length * 2;
 		    fbuf = (cast(char*)alloca(sl * char.sizeof))[0 .. sl];
-		}
-		putstr(fbuf[0 .. sl]);
+            }
+            putstr(fbuf[0 .. sl]);
 	    }
 	    else
 	    {
-		int sl;
-		char[] fbuf = tmpbuf;
-		char[12] format;
-		format[0] = '%';
-		int i = 1;
-		if (flags & FLdash)
-		    format[i++] = '-';
-		if (flags & FLplus)
-		    format[i++] = '+';
-		if (flags & FLspace)
-		    format[i++] = ' ';
-		if (flags & FLhash)
-		    format[i++] = '#';
-		if (flags & FL0pad)
-		    format[i++] = '0';
-		format[i + 0] = '*';
-		format[i + 1] = '.';
-		format[i + 2] = '*';
-		i += 3;
-		version (GNU_MinGW_MSVCRT)
-		    { /* nothing: no support for long double */ }
-		else
-		    static if (real.sizeof > double.sizeof)
-			format[i++] = 'L';
-		format[i++] = fc;
-		format[i] = 0;
-		if (!(flags & FLprecision))
-		    precision = -1;
-		while (1)
-		{   int n;
-
-		    sl = fbuf.length;
-		    version (GNU_MinGW_MSVCRT)
-			n = snprintf(fbuf.ptr, sl, format.ptr, field_width, precision, cast(double) v);
-		    else
-			n = snprintf(fbuf.ptr, sl, format.ptr, field_width, precision, v);
-		    //printf("format = '%s', n = %d\n", cast(char*)format, n);
-		    if (n >= 0 && n < sl)
-		    {	sl = n;
-			break;
-		    }
-		    if (n < 0)
-			sl = sl * 2;
-		    else
-			sl = n + 1;
-		    fbuf = (cast(char*)alloca(sl * char.sizeof))[0 .. sl];
-		}
-		putstr(fbuf[0 .. sl]);
+            int sl;
+            char[] fbuf = tmpbuf;
+            char[12] format;
+            format[0] = '%';
+            int i = 1;
+            if (flags & FLdash)
+                format[i++] = '-';
+            if (flags & FLplus)
+                format[i++] = '+';
+            if (flags & FLspace)
+                format[i++] = ' ';
+            if (flags & FLhash)
+                format[i++] = '#';
+            if (flags & FL0pad)
+                format[i++] = '0';
+            format[i + 0] = '*';
+            format[i + 1] = '.';
+            format[i + 2] = '*';
+            format[i + 3] = 'L';
+            format[i + 4] = fc;
+            format[i + 5] = 0;
+            if (!(flags & FLprecision))
+                precision = -1;
+            while (1)
+            {   int n;
+                
+                sl = fbuf.length;
+                n = snprintf(fbuf.ptr, sl, format.ptr, field_width, precision, v);
+                //printf("format = '%s', n = %d\n", cast(char*)format, n);
+                if (n >= 0 && n < sl)
+                {	sl = n;
+                    break;
+                }
+                if (n < 0)
+                    sl = sl * 2;
+                else
+                    sl = n + 1;
+                fbuf = (cast(char*)alloca(sl * char.sizeof))[0 .. sl];
+            }
+            putstr(fbuf[0 .. sl]);
 	    }
 	    return;
 	}
-
+    
 	static Mangle getMan(TypeInfo ti)
 	{
 	  auto m = cast(Mangle)ti.classinfo.name[9];
@@ -678,14 +627,6 @@
 
 	void putAArray(ubyte[long] vaa, TypeInfo valti, TypeInfo keyti)
 	{
-	    // Copied from aaA.d
-	    size_t aligntsize(size_t tsize)
-	    {
-		// Is pointer alignment on the x64 4 bytes or 8?
-		return (tsize + size_t.sizeof - 1) & ~(size_t.sizeof - 1);
-	    }
-
-	    
 	  putc('[');
 	  bool comma=false;
 	  auto argptrSave = p_args;
@@ -707,7 +648,9 @@
 	    formatArg('s');
 
 	    putc(':');
-	    ubyte* value = key + aligntsize(keyti.tsize);
+	    auto keysize = keyti.tsize;
+	    keysize = (keysize + 3) & ~3;
+	    ubyte* value = key + keysize;
 	    //doFormat(putc, (&valti)[0..1], value);
 	    p_args = value;
 	    ti = valti;
@@ -815,7 +758,7 @@
 		goto Lputstr;
 
 	    case Mangle.Tpointer:
-		vnumber = cast(size_t)va_arg!(void*)(argptr);
+		vnumber = cast(ulong)va_arg!(void*)(argptr);
 		uc = 1;
 		flags |= FL0pad;
 		if (!(flags & FLprecision))
@@ -829,22 +772,14 @@
 	    case Mangle.Tfloat:
 	    case Mangle.Tifloat:
 		if (fc == 'x' || fc == 'X')
-		{
-		    float f = va_arg!(float)(argptr);
-		    vnumber = *cast(uint*)&f;
-		    goto Lnumber;
-		}
+		    goto Luint;
 		vreal = va_arg!(float)(argptr);
 		goto Lreal;
 
 	    case Mangle.Tdouble:
 	    case Mangle.Tidouble:
 		if (fc == 'x' || fc == 'X')
-		{
-		    double f = va_arg!(double)(argptr);
-		    vnumber = *cast(ulong*)&f;
-		    goto Lnumber;
-		}
+		    goto Lulong;
 		vreal = va_arg!(double)(argptr);
 		goto Lreal;
 
@@ -961,24 +896,17 @@
 	    {	TypeInfo_Struct tis = cast(TypeInfo_Struct)ti;
 		if (tis.xtoString is null)
 		    throw new FormatError("Can't convert " ~ tis.toString() ~ " to string: \"string toString()\" not defined");
-		static if
-		    (
-		     is( typeof(argptr): void[] ) ||
-		     is( typeof(argptr) == struct ))
+		static if (is(typeof(argptr): void[]) || is(typeof(argptr) == struct))
 		{
 		    version(PPC)
 		    {
 			// Structs are pass-by-reference in V4 ABI
 			s = tis.xtoString(va_arg!(void*)(argptr));
 		    }
-		    else version(X86_64)
+		    else
 		    {
 			throw new FormatError("cannot portably format a struct on this target");
 		    }
-		    else
-		    {
-			static assert(0, "unimplemented");
-		    }
 		}
 		else
 		{
@@ -1003,25 +931,25 @@
 		    }
 		    putstr(vbit ? "true" : "false");
 		    return;
-    
-    
+
+
 		case Mangle.Tchar:
 		    vchar = *cast(char*)(p_args); p_args += char.sizeof;
 		    if (fc != 's')
 		    {   vnumber = vchar;
 			goto Lnumber;
 		    }
-		PL2: // there is goto L2 outside of thise switch; it's okay to do that
+	    PL2:
 		    putstr((&vchar)[0 .. 1]);
 		    return;
-    
+
 		case Mangle.Twchar:
 		    vdchar = *cast(wchar*)(p_args); p_args += wchar.sizeof;
 		    goto PL1;
-    
+
 		case Mangle.Tdchar:
 		    vdchar = *cast(dchar*)(p_args); p_args += dchar.sizeof;
-		PL1:
+	    PL1:
 		    if (fc != 's')
 		    {   vnumber = vdchar;
 			goto Lnumber;
@@ -1032,59 +960,61 @@
 		    }
 		    else
 		    {   if (!isValidDchar(vdchar))
-			    throw new UtfException("invalid dchar in format", 0);
+			throw new UtfException("invalid dchar in format", 0);
 			char[4] vbuf;
 			putstr(toUTF8(vbuf, vdchar));
 		    }
 		    return;
-    
-    
+
+
 		case Mangle.Tbyte:
 		    signed = 1;
 		    vnumber = *cast(byte*)p_args; p_args += byte.sizeof;
 		    goto Lnumber;
-    
+
 		case Mangle.Tubyte:
 		    vnumber = *cast(ubyte*)p_args; p_args += ubyte.sizeof;
 		    goto Lnumber;
-    
+
 		case Mangle.Tshort:
 		    signed = 1;
 		    vnumber = *cast(short*)p_args; p_args += short.sizeof;
 		    goto Lnumber;
-    
+
 		case Mangle.Tushort:
 		    vnumber = *cast(ushort*)p_args; p_args += ushort.sizeof;
 		    goto Lnumber;
-    
+
 		case Mangle.Tint:
 		    signed = 1;
 		    vnumber = *cast(int*)p_args; p_args += int.sizeof;
 		    goto Lnumber;
-    
+
 		case Mangle.Tuint:
-		PLuint:
+	    PLuint:
 		    vnumber = *cast(uint*)p_args; p_args += uint.sizeof;
 		    goto Lnumber;
-    
+
 		case Mangle.Tlong:
 		    signed = 1;
 		    vnumber = cast(ulong)*cast(long*)p_args; p_args += long.sizeof;
 		    goto Lnumber;
-    
+
 		case Mangle.Tulong:
-		PLulong:
+	    PLulong:
 		    vnumber = *cast(ulong*)p_args; p_args += ulong.sizeof;
 		    goto Lnumber;
-    
+
 		case Mangle.Tclass:
 		    vobject = *cast(Object*)p_args; p_args += Object.sizeof;
-		    s = vobject.toString();
+		    if (vobject is null)
+			s = "null";
+		    else
+			s = vobject.toString();
 		    goto Lputstr;
-    
+
 		case Mangle.Tpointer:
-		    alias void * void_ponter_t;
-		    vnumber = cast(size_t)*cast(void**)p_args; p_args += void_ponter_t.sizeof;
+		    vnumber = cast(size_t)*cast(void**)p_args; p_args += (void*).sizeof;
 		    uc = 1;
 		    flags |= FL0pad;
 		    if (!(flags & FLprecision))
@@ -1093,40 +1023,40 @@
 		    }
 		    base = 16;
 		    goto Lnumber;
-    
-    
+
+
 		case Mangle.Tfloat:
 		case Mangle.Tifloat:
 		    if (fc == 'x' || fc == 'X')
 			goto PLuint;
 		    vreal = *cast(float*)p_args; p_args += float.sizeof;
 		    goto Lreal;
-    
+
 		case Mangle.Tdouble:
 		case Mangle.Tidouble:
 		    if (fc == 'x' || fc == 'X')
 			goto PLulong;
 		    vreal = *cast(double*)p_args; p_args += double.sizeof;
 		    goto Lreal;
-    
+
 		case Mangle.Treal:
 		case Mangle.Tireal:
 		    vreal = *cast(real*)p_args; p_args += real.sizeof;
 		    goto Lreal;
-    
-    
+
+
 		case Mangle.Tcfloat:
 		    vcreal = *cast(cfloat*)p_args; p_args += cfloat.sizeof;
 		    goto Lcomplex;
-    
+
 		case Mangle.Tcdouble:
 		    vcreal = *cast(cdouble*)p_args; p_args += cdouble.sizeof;
 		    goto Lcomplex;
-    
+
 		case Mangle.Tcreal:
 		    vcreal = *cast(creal*)p_args; p_args += creal.sizeof;
 		    goto Lcomplex;
-    
+
 		case Mangle.Tsarray:
 		    putArray(p_args, (cast(TypeInfo_StaticArray)ti).len, (cast(TypeInfo_StaticArray)ti).next);
 		    p_args += ti.tsize();
@@ -1134,55 +1064,54 @@
 
 		case Mangle.Tarray:
 		    int mi = 10;
-		    alias void[] array_t;
 		    if (ti.classinfo.name.length == 14 &&
-			ti.classinfo.name[9..14] == "Array") 
+			    ti.classinfo.name[9..14] == "Array") 
 		    { // array of non-primitive types
-		      TypeInfo tn = (cast(TypeInfo_Array)ti).next;
-		      tn = skipCI(tn);
-		      switch (cast(Mangle)tn.classinfo.name[9])
-		      {
-			case Mangle.Tchar:  goto LarrayChar_p;
-			case Mangle.Twchar: goto LarrayWchar_p;
-			case Mangle.Tdchar: goto LarrayDchar_p;
-			default:
-			    break;
-		      }
-		      void[] va = *cast(void[]*)p_args; p_args += array_t.sizeof;
-		      putArray(va.ptr, va.length, tn);
-		      return;
+			TypeInfo tn = (cast(TypeInfo_Array)ti).next;
+			tn = skipCI(tn);
+			switch (cast(Mangle)tn.classinfo.name[9])
+			{
+			    case Mangle.Tchar:  goto LarrayChar;
+			    case Mangle.Twchar: goto LarrayWchar;
+			    case Mangle.Tdchar: goto LarrayDchar;
+			    default:
+				    		break;
+			}
+			void[] va = *cast(void[]*)p_args; p_args += (void[]).sizeof;
+			putArray(va.ptr, va.length, tn);
+			return;
 		    }
 		    if (ti.classinfo.name.length == 25 &&
-			ti.classinfo.name[9..25] == "AssociativeArray") 
+			    ti.classinfo.name[9..25] == "AssociativeArray") 
 		    { // associative array
-		      ubyte[long] vaa = *cast(ubyte[long]*)p_args; p_args += vaa.sizeof;
-		      putAArray(vaa,
-			    (cast(TypeInfo_AssociativeArray)ti).next,
-			    (cast(TypeInfo_AssociativeArray)ti).key);
-		      return;
+			ubyte[long] vaa = *cast(ubyte[long]*)p_args; p_args += (ubyte[long]).sizeof;
+			putAArray(vaa,
+				(cast(TypeInfo_AssociativeArray)ti).next,
+				(cast(TypeInfo_AssociativeArray)ti).key);
+			return;
 		    }
-		    
+
 		    while (1)
 		    {
-			m2 = cast(Mangle)ti.classinfo.name[10];
+			m2 = cast(Mangle)ti.classinfo.name[mi];
 			switch (m2)
 			{
 			    case Mangle.Tchar:
-				LarrayChar_p:
-				s = *cast(string*)p_args; p_args += array_t.sizeof;
+		    PLarrayChar:
+				s = *cast(string*)p_args; p_args += (string).sizeof;
 				goto PLputstr;
 
 			    case Mangle.Twchar:
-				LarrayWchar_p:
-				wchar[] sw = *cast(wchar[]*)p_args; p_args += array_t.sizeof;
+		    PLarrayWchar:
+				wchar[] sw = *cast(wchar[]*)p_args; p_args += (wchar[]).sizeof;
 				s = toUTF8(sw);
 				goto PLputstr;
 
 			    case Mangle.Tdchar:
-				LarrayDchar_p:
-				dchar[] sd = *cast(dchar[]*)p_args; p_args += array_t.sizeof;
+		    PLarrayDchar:
+				auto sd = *cast(dchar[]*)p_args; p_args += (dchar[]).sizeof;
 				s = toUTF8(sd);
-			    PLputstr:
+		    PLputstr:
 				if (fc != 's')
 				    throw new FormatError("string");
 				if (flags & FLprecision && precision < s.length)
@@ -1198,25 +1127,25 @@
 			    default:
 				TypeInfo ti2 = primitiveTypeInfo(m2);
 				if (!ti2)
-				  goto Lerror;
-				void[] va = *cast(void[]*)p_args; p_args += array_t.sizeof;
+				    goto Lerror;
+				void[] va = *cast(void[]*)p_args; p_args += (void[]).sizeof;
 				putArray(va.ptr, va.length, ti2);
 			}
 			return;
 		    }
-    
+
 		case Mangle.Ttypedef:
 		    ti = (cast(TypeInfo_Typedef)ti).base;
 		    m = cast(Mangle)ti.classinfo.name[9];
 		    formatArg(fc);
 		    return;
-    
+
 		case Mangle.Tenum:
 		    ti = (cast(TypeInfo_Enum)ti).base;
 		    m = cast(Mangle)ti.classinfo.name[9];
 		    formatArg(fc);
 		    return;
-		    
+
 		case Mangle.Tstruct:
 		{   TypeInfo_Struct tis = cast(TypeInfo_Struct)ti;
 		    if (tis.xtoString is null)
@@ -1359,259 +1288,220 @@
 
 
     for (j = 0; j < arguments.length; )
-    {	ti = arguments[j++];
-	//printf("test1: '%.*s' %d\n", ti.classinfo.name, ti.classinfo.name.length);
-	//ti.print();
-
-	flags = 0;
-	precision = 0;
-	field_width = 0;
-
-	ti = skipCI(ti);
-	int mi = 9;
-	do
-	{
-	    if (ti.classinfo.name.length <= mi)
-		goto Lerror;
-	    m = cast(Mangle)ti.classinfo.name[mi++];
-	} while (m == Mangle.Tconst || m == Mangle.Tinvariant);
-
-	if (m == Mangle.Tarray)
-	{
-	    if (ti.classinfo.name.length == 14 &&
-		ti.classinfo.name[9..14] == "Array") 
-	    {
-	      TypeInfo tn = (cast(TypeInfo_Array)ti).next;
-	      tn = skipCI(tn);
-	      switch (cast(Mangle)tn.classinfo.name[9])
-	      {
-		case Mangle.Tchar:
-		case Mangle.Twchar:
-		case Mangle.Tdchar:
-		    ti = tn;
-		    mi = 9;
-		    break;
-		default:
-		    break;
-	      }
-	    }
-	L1:
-	    Mangle m2 = cast(Mangle)ti.classinfo.name[mi];
-	    string  fmt;			// format string
-	    wstring wfmt;
-	    dstring dfmt;
-
-	    /* For performance reasons, this code takes advantage of the
-	     * fact that most format strings will be ASCII, and that the
-	     * format specifiers are always ASCII. This means we only need
-	     * to deal with UTF in a couple of isolated spots.
-	     */
-
-	    if (! p_args)
-	    switch (m2)
-	    {
-		case Mangle.Tchar:
-		    fmt = va_arg!(string)(argptr);
-		    break;
-
-		case Mangle.Twchar:
-		    wfmt = va_arg!(wstring)(argptr);
-		    fmt = toUTF8(wfmt);
-		    break;
-
-		case Mangle.Tdchar:
-		    dfmt = va_arg!(dstring)(argptr);
-		    fmt = toUTF8(dfmt);
-		    break;
-
-		case Mangle.Tconst:
-		case Mangle.Tinvariant:
-		    mi++;
-		    goto L1;
-
-		default:
-		    formatArg('s');
-		    continue;
-	    }
-	    else
-	    {
-		alias void[] array_t;
-		switch (m2)
-		{
-		    case Mangle.Tchar:
-			fmt = *cast(string*)p_args; p_args += array_t.sizeof;
-			break;
-
-		    case Mangle.Twchar:
-			wfmt = *cast(wstring*)p_args; p_args += array_t.sizeof;
-			fmt = toUTF8(wfmt);
-			break;
-
-		    case Mangle.Tdchar:
-			dfmt = *cast(dstring*)p_args; p_args += array_t.sizeof;
-			fmt = toUTF8(dfmt);
-			break;
-
-		    case Mangle.Tconst:
-		    case Mangle.Tinvariant:
-			mi++;
-			goto L1;
-
-		    default:
-			formatArg('s');
-			continue;
-		}
-	    }
-
-	    for (size_t i = 0; i < fmt.length; )
-	    {	dchar c = fmt[i++];
-
-		dchar getFmtChar()
-		{   // Valid format specifier characters will never be UTF
-		    if (i == fmt.length)
-			throw new FormatError("invalid specifier");
-		    return fmt[i++];
-		}
-
-		int getFmtInt()
-		{   int n;
-
-		    while (1)
-		    {
-			n = n * 10 + (c - '0');
-			if (n < 0)	// overflow
-			    throw new FormatError("int overflow");
-			c = getFmtChar();
-			if (c < '0' || c > '9')
-			    break;
-		    }
-		    return n;
-		}
-
-		int getFmtStar()
-		{   Mangle m;
-		    TypeInfo ti;
-
-		    if (j == arguments.length)
-			throw new FormatError("too few arguments");
-		    ti = arguments[j++];
-		    m = cast(Mangle)ti.classinfo.name[9];
-		    if (m != Mangle.Tint)
-			throw new FormatError("int argument expected");
-		    if (! p_args)
-		    return va_arg!(int)(argptr);
-		    else
-		    {
-			int result = *cast(int*)(p_args); p_args += int.sizeof;
-			return result;
-		    }
-		}
-
-		if (c != '%')
-		{
-		    if (c > 0x7F)	// if UTF sequence
-		    {
-			i--;		// back up and decode UTF sequence
-			c = std.utf.decode(fmt, i);
-		    }
-		Lputc:
-		    putc(c);
-		    continue;
-		}
-
-		// Get flags {-+ #}
-		flags = 0;
-		while (1)
-		{
-		    c = getFmtChar();
-		    switch (c)
-		    {
-			case '-':	flags |= FLdash;	continue;
-			case '+':	flags |= FLplus;	continue;
-			case ' ':	flags |= FLspace;	continue;
-			case '#':	flags |= FLhash;	continue;
-			case '0':	flags |= FL0pad;	continue;
-
-			case '%':	if (flags == 0)
-					    goto Lputc;
-			default:	break;
-		    }
-		    break;
-		}
-
-		// Get field width
-		field_width = 0;
-		if (c == '*')
-		{
-		    field_width = getFmtStar();
-		    if (field_width < 0)
-		    {   flags |= FLdash;
-			field_width = -field_width;
-		    }
-
-		    c = getFmtChar();
-		}
-		else if (c >= '0' && c <= '9')
-		    field_width = getFmtInt();
-
-		if (flags & FLplus)
-		    flags &= ~FLspace;
-		if (flags & FLdash)
-		    flags &= ~FL0pad;
-
-		// Get precision
-		precision = 0;
-		if (c == '.')
-		{   flags |= FLprecision;
-		    //flags &= ~FL0pad;
-
-		    c = getFmtChar();
-		    if (c == '*')
-		    {
-			precision = getFmtStar();
-			if (precision < 0)
-			{   precision = 0;
-			    flags &= ~FLprecision;
-			}
-
-			c = getFmtChar();
-		    }
-		    else if (c >= '0' && c <= '9')
-			precision = getFmtInt();
-		}
-
-		if (j == arguments.length)
-		    goto Lerror;
-		ti = arguments[j++];
-		ti = skipCI(ti);
-		mi = 9;
-		do
-		{
-		    m = cast(Mangle)ti.classinfo.name[mi++];
-		} while (m == Mangle.Tconst || m == Mangle.Tinvariant);
-
-		if (c > 0x7F)		// if UTF sequence
-		    goto Lerror;	// format specifiers can't be UTF
-		formatArg(cast(char)c);
-	    }
-	}
-	else
-	{
-	    formatArg('s');
-	}
+    {
+        ti = arguments[j++];
+        //printf("test1: '%.*s' %d\n", ti.classinfo.name,
+        //ti.classinfo.name.length); ti.print();
+        
+        flags = 0;
+        precision = 0;
+        field_width = 0;
+        
+        ti = skipCI(ti);
+        int mi = 9;
+        do
+        {
+            if (ti.classinfo.name.length <= mi)
+                goto Lerror;
+            m = cast(Mangle)ti.classinfo.name[mi++];
+        } while (m == Mangle.Tconst || m == Mangle.Tinvariant);
+        
+        if (m == Mangle.Tarray)
+        {
+            if (ti.classinfo.name.length == 14 &&
+                    ti.classinfo.name[9..14] == "Array") 
+            {
+                TypeInfo tn = (cast(TypeInfo_Array)ti).next;
+                tn = skipCI(tn);
+                switch (cast(Mangle)tn.classinfo.name[9])
+                {
+                case Mangle.Tchar:
+                case Mangle.Twchar:
+                case Mangle.Tdchar:
+                    ti = tn;
+                    mi = 9;
+                    break;
+                default:
+                    break;
+                }
+            }
+          L1:
+            Mangle m2 = cast(Mangle)ti.classinfo.name[mi];
+            string  fmt;			// format string
+            wstring wfmt;
+            dstring dfmt;
+            
+            /* For performance reasons, this code takes advantage of the
+             * fact that most format strings will be ASCII, and that the
+             * format specifiers are always ASCII. This means we only need
+             * to deal with UTF in a couple of isolated spots.
+             */
+            
+            switch (m2)
+            {
+            case Mangle.Tchar:
+                fmt = va_arg!(string)(argptr);
+                break;
+                
+            case Mangle.Twchar:
+                wfmt = va_arg!(wstring)(argptr);
+                fmt = toUTF8(wfmt);
+                break;
+                
+            case Mangle.Tdchar:
+                dfmt = va_arg!(dstring)(argptr);
+                fmt = toUTF8(dfmt);
+                break;
+                
+            case Mangle.Tconst:
+            case Mangle.Tinvariant:
+                mi++;
+                goto L1;
+                
+            default:
+                formatArg('s');
+                continue;
+            }
+            
+            for (size_t i = 0; i < fmt.length; )
+            {	dchar c = fmt[i++];
+                
+                dchar getFmtChar()
+                {   // Valid format specifier characters will never be UTF
+                    if (i == fmt.length)
+                        throw new FormatError("invalid specifier");
+                    return fmt[i++];
+                }
+                
+                int getFmtInt()
+                {   int n;
+                    
+                    while (1)
+                    {
+                        n = n * 10 + (c - '0');
+                        if (n < 0)	// overflow
+                            throw new FormatError("int overflow");
+                        c = getFmtChar();
+                        if (c < '0' || c > '9')
+                            break;
+                    }
+                    return n;
+                }
+                
+                int getFmtStar()
+                {   Mangle m;
+                    TypeInfo ti;
+                    
+                    if (j == arguments.length)
+                        throw new FormatError("too few arguments");
+                    ti = arguments[j++];
+                    m = cast(Mangle)ti.classinfo.name[9];
+                    if (m != Mangle.Tint)
+                        throw new FormatError("int argument expected");
+                    return va_arg!(int)(argptr);
+                }
+                
+                if (c != '%')
+                {
+                    if (c > 0x7F)	// if UTF sequence
+                    {
+                        i--;		// back up and decode UTF sequence
+                        c = std.utf.decode(fmt, i);
+                    }
+                  Lputc:
+                    putc(c);
+                    continue;
+                }
+                
+                // Get flags {-+ #}
+                flags = 0;
+                while (1)
+                {
+                    c = getFmtChar();
+                    switch (c)
+                    {
+                    case '-':	flags |= FLdash;	continue;
+                    case '+':	flags |= FLplus;	continue;
+                    case ' ':	flags |= FLspace;	continue;
+                    case '#':	flags |= FLhash;	continue;
+                    case '0':	flags |= FL0pad;	continue;
+                        
+                    case '%':	if (flags == 0)
+                            goto Lputc;
+                    default:	break;
+                    }
+                    break;
+                }
+                
+                // Get field width
+                field_width = 0;
+                if (c == '*')
+                {
+                    field_width = getFmtStar();
+                    if (field_width < 0)
+                    {   flags |= FLdash;
+                        field_width = -field_width;
+                    }
+                    
+                    c = getFmtChar();
+                }
+                else if (c >= '0' && c <= '9')
+                    field_width = getFmtInt();
+                
+                if (flags & FLplus)
+                    flags &= ~FLspace;
+                if (flags & FLdash)
+                    flags &= ~FL0pad;
+                
+                // Get precision
+                precision = 0;
+                if (c == '.')
+                {   flags |= FLprecision;
+                    //flags &= ~FL0pad;
+                    
+                    c = getFmtChar();
+                    if (c == '*')
+                    {
+                        precision = getFmtStar();
+                        if (precision < 0)
+                        {   precision = 0;
+                            flags &= ~FLprecision;
+                        }
+                        
+                        c = getFmtChar();
+                    }
+                    else if (c >= '0' && c <= '9')
+                        precision = getFmtInt();
+                }
+                
+                if (j == arguments.length)
+                    goto Lerror;
+                ti = arguments[j++];
+                ti = skipCI(ti);
+                mi = 9;
+                do
+                {
+                    m = cast(Mangle)ti.classinfo.name[mi++];
+                } while (m == Mangle.Tconst || m == Mangle.Tinvariant);
+                
+                if (c > 0x7F)		// if UTF sequence
+                    goto Lerror;	// format specifiers can't be UTF
+                formatArg(cast(char)c);
+            }
+        }
+        else
+        {
+            formatArg('s');
+        }
     }
     return;
-
-Lerror:
+    
+  Lerror:
     throw new FormatError();
 }
 
 /* ======================== Unit Tests ====================================== */
 
-version (skyos)
-    version = no_hexfloat;
-
-import std.stdio;//xx
 unittest
 {
     int i;
@@ -1627,16 +1517,10 @@
      * C99 doesn't specify what the hex digit before the decimal point
      * is for %A.
      */
-    /*
-    printf("%.*s\n", s);
-    printf("d:   %A\n",  -1.28);
-    printf("r:   %LA\n", -1.28L);
-    */
-    version (no_hexfloat)
-	{ /*nothing*/ }
+    version (linux)
+	assert(s == "1.67 -0XA.3D70A3D70A3D8P-3 nan");
     else
-	assert(s == "1.67 -0XA.3D70A3D70A3D8P-3 nan" ||
-	       s == "1.67 -0X1.47AE147AE147BP+0 nan");
+	assert(s == "1.67 -0X1.47AE147AE147BP+0 nan");
 
     s = std.string.format("%x %X", 0x1234AF, 0xAFAFAFAF);
     assert(s == "1234af AFAFAFAF");
@@ -1889,10 +1773,8 @@
 
     invariant(char[5])[int] aa = ([3:"hello", 4:"betty"]);
     r = std.string.format("%s", aa.values);
-    writefln(aa);
     assert(r == "[[h,e,l,l,o],[b,e,t,t,y]]");
     r = std.string.format("%s", aa);
-    writefln(aa);
     assert(r == "[3:[h,e,l,l,o],4:[b,e,t,t,y]]");
 
     static const dchar[] ds = ['a','b'];
@@ -1913,43 +1795,7 @@
 }
 
 // Andrei
-//-------------------------------------------------------------------------------
-/**
- * Implements the static Writer interface for a string. Instantiate it
- * with the character type, e.g. StringWriter!(char),
- * StringWriter!(wchar), or StringWriter!(dchar). Regardless of
- * instantiation, StringWriter supports all character widths; it only
- * is the most efficient at accepting the character type it was
- * instantiated with.
- */
-struct StringWriter(Char)
-{
-    alias Char NativeChar;
-    Char[] backend;
-    void write(C)(in C[] s)
-    {
-        static if (C.sizeof == NativeChar.sizeof)
-        {
-            backend ~= s;
-        }
-        else
-        {
-            backend ~= to!(const(NativeChar)[])(s);
-        }
-    }
-    void putchar(C)(in C c)
-    {
-        static if (C.sizeof == NativeChar.sizeof)
-        {
-            backend ~= c;
-        }
-        else
-        {
-            backend ~= to!(const(NativeChar)[])(c);
-        }
-    }
-}
-
+//------------------------------------------------------------------------------
 import std.bitmanip;
 
 /*
@@ -1958,126 +1804,175 @@
  * assigning any semantics to the fields. */
 struct FormatInfo
 {
-    /** minimum width, default 0. If width == width.max, then width
-     was specified as '*' in the format string.
-    */
-    short width = 0; 
-    /** precision, default ushort.max - 1. If precision ==
-     precision.max, then precision was specified as '*' in the format string.
-    */
-    short precision = short.max - 1; // by convention max-1 == "no precision"
+    /** Special values for width and precision, DYNAMIC width or
+     * precision means that they were specified with '*' in the format
+     * string. */
+    enum short DYNAMIC = short.max;
+    /** Special value for precision */
+    enum short UNSPECIFIED = DYNAMIC - 1;
+    /** minimum width, default 0.  */
+    short width = 0;
+    /** precision. */
+    short precision = UNSPECIFIED; 
     /** The actual format specifier, 's' by default. */
     char spec = 's';
-    /** Index of the argument, 1 .. ubyte.max. (0 means not used)*/
+    /** Index of the argument for positional parameters, from 1 to
+     * ubyte.max. (0 means not used) */
     ubyte index;
     /* Flags: flDash for '-', flZero for '0', flSpace for ' ', flPlus
      *  for '+', flHash for '#'. */
     mixin(bitfields!(
-              bool, "flDash", 1,
-              bool, "flZero", 1,
-              bool, "flSpace", 1,
-              bool, "flPlus", 1,
-              bool, "flHash", 1,
-              ubyte, "", 3));
-}
+                bool, "flDash", 1,
+                bool, "flZero", 1,
+                bool, "flSpace", 1,
+                bool, "flPlus", 1,
+                bool, "flHash", 1,
+                ubyte, "", 3));
+    /* For arrays only: the trailing spec after the  */    
+    const(char)[] innerTrailing;
 
 /*
  * Given a string format specification fmt, parses a format
  * specifier. The string is assumed to start with the character
  * immediately following the '%'. The string is advanced to right
  * after the end of the format specifier. */
-FormatInfo parseFormatSpec(S)(ref S fmt)
-{
-    FormatInfo result;
-    if (!fmt.length) return result;
-    size_t i = 0;
-    for (;;)
-        switch (fmt[i])
-        {
-        case '-': result.flDash = true; ++i; break;
-        case '+': result.flPlus = true; ++i; break;
-        case '#': result.flHash = true; ++i; break;
-        case '0': result.flZero = true; ++i; break;
-        case ' ': result.flSpace = true; ++i; break;
-        case '*':
-            if (isdigit(fmt[++i]))
+    static FormatInfo parse(S)(ref S fmt)
+    {
+        FormatInfo result;
+        if (!fmt.length) return result;
+        size_t i = 0;
+        for (;;)
+            switch (fmt[i])
             {
-                // a '*' followed by digits and '$' is a positional format
-                fmt = fmt[1 .. $];
-                result.width = -parse!(typeof(result.width))(fmt);
-                i = 0;
-                if (fmt[i++] != '$') throw new FormatError("$ expected");
+            case '(':
+            {
+                // embedded format specifier
+                auto j = i + 1;
+                void check(bool condition)
+                {
+                    enforce(
+                        condition,
+                        text("Incorrect format specifier: %", fmt[i .. $]));
+                }
+                for (int innerParens;; ++j)
+                {
+                    check(j < fmt.length);
+                    if (fmt[j] == '(') ++innerParens;
+                    else if (fmt[j] == ')')
+                    {
+                        if (innerParens-- == 0) break;
+                    }
+                    else if (fmt[j] == '%')
+                    {
+                        // skip the '%' and the character following
+                        // it, whatever it is
+                        ++j;
+                    }
+                }
+                auto innerFmtSpec = fmt[i + 1 .. j];
+                result = parse(innerFmtSpec);
+                result.innerTrailing = to!(typeof(innerTrailing))(innerFmtSpec);
+                // We practically found the format specifier
+                i = j + 1;
+                //result.raw = to!(const(char)[])(fmt[0 .. i]);
+                fmt = fmt[i .. $];
+                return result;
             }
-            else 
-            {
-                // read result
-                result.width = result.width.max;
-            }
-            break;
-        case '1': case '2': case '3': case '4':
-        case '5': case '6': case '7': case '8': case '9':
-            fmt = fmt[i .. $];
-            auto widthOrArgIndex = parse!(int)(fmt);
-            i = 0;
-            if (fmt[0] == '$')
-            {
-                // index!
-                result.index = to!(ubyte)(widthOrArgIndex);
-                ++i;
-            }
-            else
-            {
-                // width
-                result.width = cast(short)widthOrArgIndex;
-            }
-            break;
-        case '.':
-            if (fmt[++i] == '*')
-            {
+            case '-': result.flDash = true; ++i; break;
+            case '+': result.flPlus = true; ++i; break;
+            case '#': result.flHash = true; ++i; break;
+            case '0': result.flZero = true; ++i; break;
+            case ' ': result.flSpace = true; ++i; break;
+            case '*':
                 if (isdigit(fmt[++i]))
                 {
-                    // a '.*' followed by digits and '$' is a positional format
-                    fmt = fmt[i .. $];
+                    // a '*' followed by digits and '$' is a positional format
+                    fmt = fmt[1 .. $];
+                    result.width = -.parse!(typeof(result.width))(fmt);
                     i = 0;
-                    result.precision = cast(short)(-parse!(int)(fmt));
                     if (fmt[i++] != '$') throw new FormatError("$ expected");
                 }
+                else 
+                {
+                    // read result
+                    result.width = DYNAMIC;
+                }
+                break;
+            case '1': case '2': case '3': case '4':
+            case '5': case '6': case '7': case '8': case '9':
+                auto tmp = fmt[i .. $];
+                const widthOrArgIndex = .parse!(ushort)(tmp);
+                assert(tmp.length,
+                        text("Incorrect format specifier %", fmt[i .. $]));
+                i = tmp.ptr - fmt.ptr;
+                if (tmp.length && tmp[0] == '$')
+                {
+                    // index!
+                    result.index = to!(ubyte)(widthOrArgIndex);
+                    ++i;
+                }
                 else
                 {
-                    // read result
-                    result.precision = result.precision.max;
+                    // width
+                    result.width = cast(short) widthOrArgIndex;
                 }
-            }
-            else if (fmt[i] == '-')
-            {
-                // negative precision, as good as 0
-                result.precision = 0;
+                break;
+            case '.':
+                if (fmt[++i] == '*')
+                {
+                    if (isdigit(fmt[++i]))
+                    {
+                        // a '.*' followed by digits and '$' is a
+                        // positional precision
+                        fmt = fmt[i .. $];
+                        i = 0;
+                        result.precision = cast(short) -.parse!(int)(fmt);
+                        if (fmt[i++] != '$')
+                        {
+                            throw new FormatError("$ expected");
+                        }
+                    }
+                    else
+                    {
+                        // read result
+                        result.precision = DYNAMIC;
+                    }
+                }
+                else if (fmt[i] == '-')
+                {
+                    // negative precision, as good as 0
+                    result.precision = 0;
+                    auto tmp = fmt[i .. $];
+                    .parse!(int)(tmp); // skip digits
+                    i = tmp.ptr - fmt.ptr;
+                }
+                else if (isdigit(fmt[i]))
+                {
+                    auto tmp = fmt[i .. $];
+                    result.precision = .parse!(short)(tmp);
+                    i = tmp.ptr - fmt.ptr;
+                }
+                else
+                {
+                    // "." was specified, but nothing after it
+                    result.precision = 0;
+                }
+                break;
+            default:
+                // this is the format char
+                result.spec = fmt[i++];
+                //result.raw = to!(const(char)[])(fmt[0 .. i]);
                 fmt = fmt[i .. $];
-                i = 0;
-                parse!(int)(fmt); // skip digits
-            }
-            else
-            {
-                fmt = fmt[i .. $];
-                i = 0;
-                result.precision =
-                    cast(short)(isdigit(fmt[0]) ? parse!(int)(fmt) : 0);
-            }
-            break;
-        default:
-            // this is the format char
-            result.spec = fmt[i];
-            fmt = fmt[i + 1 .. $];
-            return result;
-        }
-    //assert(false);
+                return result;
+            } // end switch and for
+    }
 }
 
-//-------------------------------------------------------------------------------
-// Writes characters in the format strings up to the first format specifier
-// and updates the format specifier to remove the written portion
-// The updated format fmt does not include the '%'
-private void writeUpToFormatSpec(Writer, S)(ref Writer w, ref S fmt)
+//------------------------------------------------------------------------------
+// Writes characters in the format strings up to the first format
+// specifier and updates the format specifier to remove the written
+// portion The updated format fmt does not include the '%'
+private void writeUpToFormatSpec(OutRange, S)(ref OutRange w, ref S fmt)
 {
     for (size_t i = 0; i < fmt.length; ++i)
     {
@@ -2085,44 +1980,46 @@
         if (fmt[++i] != '%')
         {
             // spec found, print and bailout
-            w.write(fmt[0 .. i - 1]);
+            w.put(fmt[0 .. i - 1]);
             fmt = fmt[i .. $];
             return;
         }
-        // doubled! Now print whatever we had, then update the string and move on
-        w.write(fmt[0 .. i]);
+        // doubled! Now print whatever we had, then update the string
+        // and move on
+        w.put(fmt[0 .. i]);
         fmt = fmt[i + 1 .. $];
         i = 0;
     }
     // no format spec found
-    w.write(fmt);
+    w.put(fmt);
     fmt = null;
 }
 
 unittest
 {
-    StringWriter!(char) w;
+    Appender!(char[]) w;
     string fmt = "abc%sdef%sghi";
     writeUpToFormatSpec(w, fmt);
-    assert(w.backend == "abc" && fmt == "sdef%sghi");
+    assert(w.data == "abc" && fmt == "sdef%sghi");
     writeUpToFormatSpec(w, fmt);
-    assert(w.backend == "abcsdef" && fmt == "sghi");
+    assert(w.data == "abcsdef" && fmt == "sghi");
     // test with embedded %%s
     fmt = "ab%%cd%%ef%sg%%h%sij";
-    w.backend = null;
+    w.clear;
     writeUpToFormatSpec(w, fmt);
-    assert(w.backend == "ab%cd%ef" && fmt == "sg%%h%sij");
+    assert(w.data == "ab%cd%ef" && fmt == "sg%%h%sij");
     writeUpToFormatSpec(w, fmt);
-    assert(w.backend == "ab%cd%efsg%h" && fmt == "sij");
+    assert(w.data == "ab%cd%efsg%h" && fmt == "sij");
 }
 
 /*
  * Formats an integral number 'arg' according to 'f' and writes it to
  * 'w'.
  */ 
-private void formatIntegral(Writer, D)(ref Writer w, D argx, FormatInfo f)
+private void formatImplInt(Writer, D)(ref Writer w, D argx, FormatInfo f)
+//if (isIntegral!(D))
 {
-    Mutable!(D) arg = argx;
+    Unqual!(D) arg = argx;
     if (f.spec == 'r')
     {
         // raw write, skip all else and write the thing
@@ -2132,16 +2029,16 @@
         {
             // must swap bytes
             foreach_reverse (i; 0 .. arg.sizeof)
-                w.putchar(begin[i]);
+                w.put(begin[i]);
         }
         else
         {
             foreach (i; 0 .. arg.sizeof)
-                w.putchar(begin[i]);
+                w.put(begin[i]);
         }
         return;
     }
-    if (f.precision == f.precision.max - 1)
+    if (f.precision == FormatInfo.UNSPECIFIED)
     {
         // default precision for integrals is 1
         f.precision = 1;
@@ -2187,11 +2084,11 @@
     {
         char buffer[64]; // 64 bits in base 2 at most
         uint i = buffer.length;
-        auto n = cast(unsigned!(Mutable!(D))) arg;
+        auto n = cast(Unsigned!(Unqual!(D))) arg;
         do
         {
             --i;
-            buffer[i] = cast(char)(n % base);
+            buffer[i] = cast(char) (n % base);
             n /= base;
             if (buffer[i] < 10) buffer[i] += '0';
             else buffer[i] += (f.spec == 'x' ? 'a' : 'A') - 10;
@@ -2225,33 +2122,34 @@
                 cast(typeof(f.precision)) (spacesToPrint + digits.length);
                 //to!(typeof(f.precision))(spacesToPrint + digits.length);
         }
-        else if (leftPad) foreach (i ; 0 .. spacesToPrint) w.putchar(' ');
+        else if (leftPad) foreach (i ; 0 .. spacesToPrint) w.put(' ');
     }
     // write sign
-    if (forcedPrefix) w.putchar(forcedPrefix);
+    if (forcedPrefix) w.put(forcedPrefix);
     // write 0x or 0X
     if (base == 16 && f.flHash() && arg) {
         // @@@ overcome bug in dmd;
         //w.write(f.spec == 'x' ? "0x" : "0X"); //crashes the compiler
-        w.putchar('0');
-        w.putchar(f.spec == 'x' ? 'x' : 'X'); // x or X
+        w.put('0');
+        w.put(f.spec == 'x' ? 'x' : 'X'); // x or X
     }
     // write the digits
     if (arg || f.precision)
     {
         int zerosToPrint = f.precision - digits.length;
-        foreach (i ; 0 .. zerosToPrint) w.putchar('0');
-        w.write(digits);
+        foreach (i ; 0 .. zerosToPrint) w.put('0');
+        w.put(digits);
     }
     // write the spaces to the right if left-align
-    if (!leftPad) foreach (i ; 0 .. spacesToPrint) w.putchar(' ');
+    if (!leftPad) foreach (i ; 0 .. spacesToPrint) w.put(' ');
 }
 
 /*
  * Formats a floating point number 'arg' according to 'f' and writes
  * it to 'w'.
  */ 
-private void formatFloat(Writer, D)(ref Writer w, D obj, FormatInfo f)
+private void formatImplFloat(Writer, D)(ref Writer w, D obj, FormatInfo f)
+//if (isFloatingPoint!(D))
 {
     if (f.spec == 'r')
     {
@@ -2262,12 +2160,12 @@
         {
             // must swap bytes
             foreach_reverse (i; 0 .. obj.sizeof)
-                w.putchar(begin[i]);
+                w.put(begin[i]);
         }
         else
         {
             foreach (i; 0 .. obj.sizeof)
-                w.putchar(begin[i]);
+                w.put(begin[i]);
         }
         return;
     }
@@ -2292,13 +2190,13 @@
     //printf("format: '%s'; geeba: %g\n", sprintfSpec.ptr, obj);
     char[512] buf;
     invariant n = snprintf(buf.ptr, buf.length,
-                       sprintfSpec.ptr,
-                       f.width,
-                       // negative precision is same as no precision specified
-                       f.precision == f.precision.max - 1 ? -1 : f.precision,
-                       obj);
+            sprintfSpec.ptr,
+            f.width,
+            // negative precision is same as no precision specified
+            f.precision == FormatInfo.UNSPECIFIED ? -1 : f.precision,
+            obj);
     if (n < 0) throw new FormatError("floating point formatting failure");
-    w.write(buf[0 .. strlen(buf.ptr)]);
+    w.put(buf[0 .. strlen(buf.ptr)]);
 }
 
 /*
@@ -2312,46 +2210,49 @@
     auto obj = *cast(D*) arg;
     static if (is(const(D) == const(void[]))) {
         auto s = cast(const char[]) obj;
-        w.write(s);
+        w.put(s);
+    } else static if (is(D Original == enum)) {
+        formatGeneric!(Writer, Original)(w, arg, f);
     } else static if (is(D Original == typedef)) {
         formatGeneric!(Writer, Original)(w, arg, f);
-    } else static if (is(D Original == enum)) {
-        formatGeneric!(Writer, Original)(w, arg, f);
-    } else static if (is(const D == const(float))
-                      || is(const(D) == const(double))
-                      || is(const(D) == const(real))) {
-        formatFloat(w, obj, f);
+    } else static if (isFloatingPoint!(D)) {
+        formatImplFloat(w, obj, f);
     } else static if (is(const(D) == const ifloat)) {
-        formatFloat(w, *cast(float*) &obj, f);
+        formatImplFloat(w, *cast(float*) &obj, f);
     } else static if (is(const(D) == const idouble)) {
-        formatFloat(w, *cast(double*) &obj, f);
+        formatImplFloat(w, *cast(double*) &obj, f);
     } else static if (is(const(D) == const ireal)) {
-        formatFloat(w, *cast(real*) &obj, f);
+        formatImplFloat(w, *cast(real*) &obj, f);
     } else static if (is(const(D) == const cfloat)
                       || is(const(D) == const cdouble)
                       || is(const(D) == const creal)) {
-        formatFloat(w, obj.re, f);
-        w.write("+");
-        formatFloat(w, obj.im, f);
-        w.write("i");
-    } else static if (is(const(D) : const long) || is(const(D) : const ulong)) {
-        static if (is(const(D) == const bool)) {
-            if (f.spec == 's') {
-                w.write(obj ? "true" : "false");
-            } else {
-                formatIntegral(w, cast(int) obj, f);
-            }
-        } else static if (is(const(D) == const char)
-                          || is(const(D) == const wchar)
-                          || is(const(D) == const dchar)) {
-            if (f.spec == 's') {
-                w.putchar(obj);
-            } else {
-                formatIntegral(w, cast(uint) obj, f);
-            }
+        formatImplFloat(w, obj.re, f);
+        // @@@BUG 2367@@@
+        //w.write("+");
+        w.put('+');
+        formatImplFloat(w, obj.im, f);
+        // @@@BUG 2367@@@
+        //w.put("i");
+        w.put('i');
+    } else static if (is(const D == const bool)) {
+        if (f.spec == 's') {
+            //@@@BUG 2606
+            //w.put(obj ? "true" : "false");
+            auto s = obj ? "true" : "false";
+            w.put(s);
         } else {
-            formatIntegral(w, obj, f);
+            formatImplInt(w, cast(int) obj, f);
         }
+    } else static if (is(const(D) == const char)
+            || is(const(D) == const wchar)
+            || is(const(D) == const dchar)) {
+        if (f.spec == 's') {
+            w.put(obj);
+        } else {
+            formatImplInt(w, cast(uint) obj, f);
+        }
+    } else static if (isIntegral!(D)) {
+        formatImplInt(w, obj, f);
     } else static if (is(D : const(char)[]) || is(D : const(wchar)[])
                       || is(D : const(dchar)[])) {
         auto s = obj[0 .. f.precision < $ ? f.precision : $];
@@ -2359,46 +2260,93 @@
         {
             // right align
             if (f.width > s.length)
-                foreach (i ; 0 .. f.width - s.length) w.putchar(' ');
-            w.write(s);
+                foreach (i ; 0 .. f.width - s.length) w.put(' ');
+            w.put(s);
         }
         else
         {
             // left align
-            w.write(s);
+            w.put(s);
             if (f.width > s.length)
-                foreach (i ; 0 .. f.width - s.length) w.putchar(' ');
+                foreach (i ; 0 .. f.width - s.length) w.put(' ');
         }
     } else static if (is(D == void[0])) {
-        w.putchar('[');
-        w.putchar(']');
+        w.put('[');
+        w.put(']');
     } else static if (isArray!(D)) {
-        if (f.spec != 'r') w.putchar('['); // only write the brackets if not raw
-	foreach (i, e; obj)
-	{
-	    if (f.spec != 'r' && i > 0) w.putchar(' ');
-	    formatGeneric!(Writer, typeof(e))(w, &e, f);
-	}
-        if (f.spec != 'r') w.putchar(']'); // only write the brackets if not raw
+        if (f.spec == 'r')
+        {
+            // raw writes
+            foreach (i, e; obj) formatGeneric!(Writer, typeof(e))(w, &e, f);
+        }
+        else
+        {
+            if (obj.length == 0) return;
+            // formatted writes
+            formatGeneric!(Writer, typeof(obj[0]))(w, &obj[0], f);
+            if (!f.innerTrailing)
+            {
+                foreach (i, e; obj[1 .. $])
+                {
+                    w.put(' ');
+                    formatGeneric!(Writer, typeof(e))(w, &e, f);
+                }
+            }
+            else
+            {
+                const hasEscapes = 
+                    std.algorithm.find(f.innerTrailing, '%').length > 0;
+                foreach (i, e; obj[1 .. $])
+                {
+                    if (hasEscapes)
+                    {
+                        foreach (dchar c; f.innerTrailing)
+                        {
+                            if (c == '%') continue;
+                            w.put(c);
+                        }
+                    }
+                    else w.put(f.innerTrailing);
+                    formatGeneric!(Writer, typeof(e))(w, &e, f);
+                }
+            }
+        }
     } else static if (is(const(D) : const void*)) {
         f.spec = 'X';
-        ulong fake = cast(ulong) obj;
+        const fake = cast(ulong) obj;
         formatGeneric!(Writer, ulong)(w, &fake, f);
     } else static if (is(const(D) : const Object)) {
-        if (obj is null) w.write("null");
-        else w.write(obj.toString);
+        // @@@BUG 2367@@@
+        //if (obj is null) w.write("null");
+        if (obj is null) w.put("null"[]);
+        else w.put(obj.toString);
     } else static if (isAssociativeArray!(D)) {
         // somebody rid me of this hack
-        w.write(std.string.format("%s", obj));
+        w.put(std.string.format("%s", obj));
+    } else static if (is(D : const(char))) {
+        // somebody rid me of this hack
+        w.put(obj);
+    } else static if (is(typeof(obj.toString))) {
+        auto s = obj.toString;
+        w.put(s);                                        
     } else {
-        // last resort: look for toString
-        auto s = obj.toString;
-        w.write(s);                                        
-        //static assert(false, "Cannot format type " ~ D.stringof);
+        // last resort: just print type name
+        w.put(D.stringof);
     }
 }
 
-//-------------------------------------------------------------------------------
+unittest
+{
+    Appender!(char[]) w;
+    int[] a = [ 1, 3, 2 ];
+    formattedWrite(w, "testing %(s, ) embedded", a);
+    assert(w.data == "testing 1, 3, 2 embedded", w.data);
+    w.clear;
+    formattedWrite(w, "testing (%(s%) %()) embedded", a);
+    assert(w.data == "testing (1) (3) (2) embedded", w.data);
+}
+
+//------------------------------------------------------------------------------
 // Fix for issue 1591
 private int getNthInt(A...)(uint index, A args)
 {
@@ -2424,12 +2372,11 @@
 }
 
 /*
-  (Not public yet.)  Formats arguments 'args' according to the format
-  string 'fmt' and writes the result to 'w'. 'F' must be char, wchar,
-  or dchar.
+(Not public yet.)  Formats arguments $(D args) according to the format
+string $(D fmt) and writes the result to $(D w). $(D F) must be $(D
+char), $(D wchar), or $(D dchar).
 
-  Example:
-  
+Example:
 -------------------------
 import std.c.stdio;
 import std.format;
@@ -2437,17 +2384,16 @@
 string myFormat(A...)(A args)
 {
     StringWriter!(char) writer;
-    std.format.formattedWrite(writer, "%s et %s numeris romanis non sunt", args);
+    std.format.formattedWrite(writer,
+        "%s et %s numeris romanis non sunt", args);
     return writer.backend;
 }
-
 ...
-
 int x = 42;
 assert(myFormat(x, 0) == "42 et 0 numeris romanis non sunt");
 ------------------------
  
-formattedWrite supports positional parameter syntax in $(WEB
+$(D formattedWrite) supports positional parameter syntax in $(WEB
 opengroup.org/onlinepubs/009695399/functions/printf.html, POSIX)
 style.  Example:
 
@@ -2463,30 +2409,32 @@
 the largest positional parameter already used.
 
 Warning:
-
 This is the function internally used by writef* but it's still
 undergoing active development. Do not rely on it.
-*/
+ */
 
 void formattedWrite(Writer, F, A...)(ref Writer w, const(F)[] fmt, A args)
 {
-    invariant len = args.length;
+    enum len = args.length;
     void function(ref Writer, const(void)*, FormatInfo) funs[len] = void;
     const(void)* argsAddresses[len] = void;
     foreach (i, arg; args)
     {
         funs[i] = &formatGeneric!(Writer, typeof(arg));
-	alias typeof(arg) T;
-        size_t sz = T.sizeof;
-	void* p = (new void[sz]).ptr;
-	p[0..sz] = (cast(void*) & arg)[0..sz];
-        argsAddresses[i] = p;
+        argsAddresses[i] = &arg;
     }
+    // Are we already done with formats? Then just dump each parameter in turn
     uint currentArg = 0;
     for (;;)
     {
         writeUpToFormatSpec(w, fmt);
-        auto spec = parseFormatSpec(fmt);
+        if (fmt.length == 0) 
+        {
+            // New behavior: break if there are too few specifiers AND
+            // at least one specifier did exist
+            break;
+        }
+        auto spec = FormatInfo.parse(fmt);
         if (currentArg == funs.length && !spec.index)
         {
             // leftover spec?
@@ -2497,7 +2445,7 @@
             }
             break;
         }
-        if (spec.width == spec.width.max)
+        if (spec.width == FormatInfo.DYNAMIC)
         {
             auto width = to!(typeof(spec.width))(getNthInt(currentArg, args));
             if (width < 0)
@@ -2521,13 +2469,13 @@
             }
             spec.width = width;
         }
-        if (spec.precision == spec.precision.max)
+        if (spec.precision == FormatInfo.DYNAMIC)
         {
             auto precision = to!(typeof(spec.precision))(
                 getNthInt(currentArg, args));
             if (precision >= 0) spec.precision = precision;
             // else negative precision is same as no precision
-            else spec.precision = spec.precision.max - 1;
+            else spec.precision = FormatInfo.UNSPECIFIED;
             ++currentArg;
         }
         else if (spec.precision < 0)
@@ -2539,7 +2487,7 @@
             if (currentArg < index) currentArg = index;
             if (precision >= 0) spec.precision = precision;
             // else negative precision is same as no precision
-            else spec.precision = spec.precision.max - 1;
+            else spec.precision = FormatInfo.UNSPECIFIED;
         }
         // Format!
         if (spec.index > 0)
@@ -2560,363 +2508,369 @@
 
 unittest
 {
-    StringWriter!(char) stream;
+    Appender!(char[]) stream;
     formattedWrite(stream, "%s", 1.1);
-    assert(stream.backend == "1.1", stream.backend);
+    assert(stream.data == "1.1", stream.data);
 }
 
 unittest
 {
     // testing raw writes
-    StringWriter!(char) w;
-    w.backend = null;
+    Appender!(char[]) w;
     uint a = 0x02030405;
     formattedWrite(w, "%+r", a);
-    assert(w.backend.length == 4 && w.backend[0] == 2 && w.backend[1] == 3
-        && w.backend[2] == 4 && w.backend[3] == 5);
-    w.backend = null;
+    assert(w.data.length == 4 && w.data[0] == 2 && w.data[1] == 3
+        && w.data[2] == 4 && w.data[3] == 5);
+    w.clear;
     formattedWrite(w, "%-r", a);
-    assert(w.backend.length == 4 && w.backend[0] == 5 && w.backend[1] == 4
-        && w.backend[2] == 3 && w.backend[3] == 2);
+    assert(w.data.length == 4 && w.data[0] == 5 && w.data[1] == 4
+        && w.data[2] == 3 && w.data[3] == 2);
 }
 
 unittest
 {
     // testing positional parameters
-    StringWriter!(char) w;
-    w.backend = null;
-    formattedWrite(w, "Numbers %2$s and %1$s are reversed and %1$s%2$s repeated",
-        42, 0);
-    assert(w.backend == "Numbers 0 and 42 are reversed and 420 repeated",
-        w.backend);
+    Appender!(char[]) w;
+    formattedWrite(w,
+            "Numbers %2$s and %1$s are reversed and %1$s%2$s repeated",
+            42, 0);
+    assert(w.data == "Numbers 0 and 42 are reversed and 420 repeated",
+            w.data);
+    w.clear;
+    formattedWrite(w, "asd%s", 23);
+    assert(w.data == "asd23", w.data);
+    w.clear;
+    formattedWrite(w, "%s%s", 23, 45);
+    assert(w.data == "2345", w.data);
 }
 
 unittest
 {
-  debug(format) printf("std.format.format.unittest\n");
+    debug(format) printf("std.format.format.unittest\n");
     
-  StringWriter!(char) stream;
-  //goto here;
-  
-  formattedWrite(stream, "hello world! %s %s ", true, 57, 1_000_000_000, 'x', " foo");
-  assert(stream.backend == "hello world! true 57 1000000000x foo");
-
-  stream.backend = null;
-  formattedWrite(stream, "%g %A ", 1.67, -1.28, float.nan);
-  //std.c.stdio.fwrite(stream.backend.ptr, stream.backend.length, 1, stderr);
+    Appender!(char[]) stream;
+    //goto here;
+    
+    formattedWrite(stream,
+            "hello world! %s %s ", true, 57, 1_000_000_000, 'x', " foo");
+    assert(stream.data == "hello world! true 57 ",
+        stream.data);
+    
+    stream.clear;
+    formattedWrite(stream, "%g %A %s", 1.67, -1.28, float.nan);
+  //std.c.stdio.fwrite(stream.data.ptr, stream.data.length, 1, stderr);
   /* The host C library is used to format floats.
    * C99 doesn't specify what the hex digit before the decimal point
    * is for %A.
    */
   version (linux)
-      assert(stream.backend == "1.67 -0X1.47AE147AE147BP+0 nan", stream.backend);
+      assert(stream.data == "1.67 -0X1.47AE147AE147BP+0 nan", stream.data);
   else
-      assert(stream.backend == "1.67 -0X1.47AE147AE147BP+0 nan");
-  stream.backend = null;
+      assert(stream.data == "1.67 -0X1.47AE147AE147BP+0 nan");
+  stream.clear;
 
   formattedWrite(stream, "%x %X", 0x1234AF, 0xAFAFAFAF);
-  assert(stream.backend == "1234af AFAFAFAF");
-  stream.backend = null;
+  assert(stream.data == "1234af AFAFAFAF");
+  stream.clear;
 
   formattedWrite(stream, "%b %o", 0x1234AF, 0xAFAFAFAF);
-  assert(stream.backend == "100100011010010101111 25753727657");
-  stream.backend = null;
+  assert(stream.data == "100100011010010101111 25753727657");
+  stream.clear;
 
   formattedWrite(stream, "%d %s", 0x1234AF, 0xAFAFAFAF);
-  assert(stream.backend == "1193135 2947526575");
-  stream.backend = null;
+  assert(stream.data == "1193135 2947526575");
+  stream.clear;
   
   formattedWrite(stream, "%s", 1.2 + 3.4i);
-  assert(stream.backend == "1.2+3.4i");
-  stream.backend = null;
+  assert(stream.data == "1.2+3.4i");
+  stream.clear;
   
   formattedWrite(stream, "%a %A", 1.32, 6.78f);
   //formattedWrite(stream, "%x %X", 1.32);
-  assert(stream.backend == "0x1.51eb851eb851fp+0 0X1.B1EB86P+2");
-  stream.backend = null;
+  assert(stream.data == "0x1.51eb851eb851fp+0 0X1.B1EB86P+2");
+  stream.clear;
 
   formattedWrite(stream, "%#06.*f",2,12.345);
-  assert(stream.backend == "012.35");
-  stream.backend = null;
+  assert(stream.data == "012.35");
+  stream.clear;
 
   formattedWrite(stream, "%#0*.*f",6,2,12.345);
-  assert(stream.backend == "012.35");
-  stream.backend = null;
+  assert(stream.data == "012.35");
+  stream.clear;
 
   const real constreal = 1;
   formattedWrite(stream, "%g",constreal);
-  assert(stream.backend == "1");
-  stream.backend = null;
+  assert(stream.data == "1");
+  stream.clear;
 
   formattedWrite(stream, "%7.4g:", 12.678);
-  assert(stream.backend == "  12.68:");
-  stream.backend = null;
+  assert(stream.data == "  12.68:");
+  stream.clear;
   
   formattedWrite(stream, "%7.4g:", 12.678L);
-  assert(stream.backend == "  12.68:");
-  stream.backend = null;
+  assert(stream.data == "  12.68:");
+  stream.clear;
   
   formattedWrite(stream, "%04f|%05d|%#05x|%#5x",-4.,-10,1,1);
-  assert(stream.backend == "-4.000000|-0010|0x001|  0x1",
-      stream.backend);
-  stream.backend = null;
+  assert(stream.data == "-4.000000|-0010|0x001|  0x1",
+      stream.data);
+  stream.clear;
   
   int i;
   string s;
   
   i = -10;
   formattedWrite(stream, "%d|%3d|%03d|%1d|%01.4f",i,i,i,i,cast(double) i);
-  assert(stream.backend == "-10|-10|-10|-10|-10.0000");
-  stream.backend = null;
+  assert(stream.data == "-10|-10|-10|-10|-10.0000");
+  stream.clear;
 
   i = -5;
   formattedWrite(stream, "%d|%3d|%03d|%1d|%01.4f",i,i,i,i,cast(double) i);
-  assert(stream.backend == "-5| -5|-05|-5|-5.0000");
-  stream.backend = null;
+  assert(stream.data == "-5| -5|-05|-5|-5.0000");
+  stream.clear;
 
   i = 0;
   formattedWrite(stream, "%d|%3d|%03d|%1d|%01.4f",i,i,i,i,cast(double) i);
-  assert(stream.backend == "0|  0|000|0|0.0000");
-  stream.backend = null;
+  assert(stream.data == "0|  0|000|0|0.0000");
+  stream.clear;
 
   i = 5;
   formattedWrite(stream, "%d|%3d|%03d|%1d|%01.4f",i,i,i,i,cast(double) i);
-  assert(stream.backend == "5|  5|005|5|5.0000");
-  stream.backend = null;
+  assert(stream.data == "5|  5|005|5|5.0000");
+  stream.clear;
 
   i = 10;
   formattedWrite(stream, "%d|%3d|%03d|%1d|%01.4f",i,i,i,i,cast(double) i);
-  assert(stream.backend == "10| 10|010|10|10.0000");
-  stream.backend = null;
+  assert(stream.data == "10| 10|010|10|10.0000");
+  stream.clear;
 
   formattedWrite(stream, "%.0d", 0);
-  assert(stream.backend == "");
-  stream.backend = null;
+  assert(stream.data == "");
+  stream.clear;
 
   formattedWrite(stream, "%.g", .34);
-  assert(stream.backend == "0.3");
-  stream.backend = null;
+  assert(stream.data == "0.3");
+  stream.clear;
   
-  stream.backend = null; formattedWrite(stream, "%.0g", .34);
-  assert(stream.backend == "0.3");
+  stream.clear; formattedWrite(stream, "%.0g", .34);
+  assert(stream.data == "0.3");
   
-  stream.backend = null; formattedWrite(stream, "%.2g", .34);
-  assert(stream.backend == "0.34");
+  stream.clear; formattedWrite(stream, "%.2g", .34);
+  assert(stream.data == "0.34");
   
-  stream.backend = null; formattedWrite(stream, "%0.0008f", 1e-08);
-  assert(stream.backend == "0.00000001");
+  stream.clear; formattedWrite(stream, "%0.0008f", 1e-08);
+  assert(stream.data == "0.00000001");
   
-  stream.backend = null; formattedWrite(stream, "%0.0008f", 1e-05);
-  assert(stream.backend == "0.00001000");
+  stream.clear; formattedWrite(stream, "%0.0008f", 1e-05);
+  assert(stream.data == "0.00001000");
   
   //return;
-  //std.c.stdio.fwrite(stream.backend.ptr, stream.backend.length, 1, stderr);
+  //std.c.stdio.fwrite(stream.data.ptr, stream.data.length, 1, stderr);
   
   s = "helloworld";
   string r;
-  stream.backend = null; formattedWrite(stream, "%.2s", s[0..5]);
-  assert(stream.backend == "he");
-  stream.backend = null; formattedWrite(stream, "%.20s", s[0..5]);
-  assert(stream.backend == "hello");
-  stream.backend = null; formattedWrite(stream, "%8s", s[0..5]);
-  assert(stream.backend == "   hello");
+  stream.clear; formattedWrite(stream, "%.2s", s[0..5]);
+  assert(stream.data == "he");
+  stream.clear; formattedWrite(stream, "%.20s", s[0..5]);
+  assert(stream.data == "hello");
+  stream.clear; formattedWrite(stream, "%8s", s[0..5]);
+  assert(stream.data == "   hello");
 
-  byte[] arrbyte = new byte[4];
-  arrbyte[0] = 100;
-  arrbyte[1] = -99;
-  arrbyte[3] = 0;
-  stream.backend = null; formattedWrite(stream, "", arrbyte);
-  assert(stream.backend == "[100 -99 0 0]");
+    byte[] arrbyte = new byte[4];
+    arrbyte[0] = 100;
+    arrbyte[1] = -99;
+    arrbyte[3] = 0;
+    stream.clear; formattedWrite(stream, "%s", arrbyte);
+    assert(stream.data == "100 -99 0 0", stream.data);
 
   ubyte[] arrubyte = new ubyte[4];
   arrubyte[0] = 100;
   arrubyte[1] = 200;
   arrubyte[3] = 0;
-  stream.backend = null; formattedWrite(stream, "", arrubyte);
-  assert(stream.backend == "[100 200 0 0]");
+  stream.clear; formattedWrite(stream, "%s", arrubyte);
+    assert(stream.data == "100 200 0 0");
 
   short[] arrshort = new short[4];
   arrshort[0] = 100;
   arrshort[1] = -999;
   arrshort[3] = 0;
-  stream.backend = null; formattedWrite(stream, "", arrshort);
-  assert(stream.backend == "[100 -999 0 0]");
-  stream.backend = null; formattedWrite(stream, "%s",arrshort);
-  assert(stream.backend == "[100 -999 0 0]");
+  stream.clear; formattedWrite(stream, "%s", arrshort);
+  assert(stream.data == "100 -999 0 0");
+  stream.clear; formattedWrite(stream, "%s",arrshort);
+  assert(stream.data == "100 -999 0 0");
 
   ushort[] arrushort = new ushort[4];
   arrushort[0] = 100;
   arrushort[1] = 20_000;
   arrushort[3] = 0;
-  stream.backend = null; formattedWrite(stream, "", arrushort);
-  assert(stream.backend == "[100 20000 0 0]");
+  stream.clear; formattedWrite(stream, "%s", arrushort);
+    assert(stream.data == "100 20000 0 0");
 
   int[] arrint = new int[4];
   arrint[0] = 100;
   arrint[1] = -999;
   arrint[3] = 0;
-  stream.backend = null; formattedWrite(stream, "", arrint);
-  assert(stream.backend == "[100 -999 0 0]");
-  stream.backend = null; formattedWrite(stream, "%s",arrint);
-  assert(stream.backend == "[100 -999 0 0]");
+  stream.clear; formattedWrite(stream, "%s", arrint);
+    assert(stream.data == "100 -999 0 0");
+  stream.clear; formattedWrite(stream, "%s",arrint);
+  assert(stream.data == "100 -999 0 0");
 
   long[] arrlong = new long[4];
   arrlong[0] = 100;
   arrlong[1] = -999;
   arrlong[3] = 0;
-  stream.backend = null; formattedWrite(stream, "", arrlong);
-  assert(stream.backend == "[100 -999 0 0]");
-  stream.backend = null; formattedWrite(stream, "%s",arrlong);
-  assert(stream.backend == "[100 -999 0 0]");
+  stream.clear; formattedWrite(stream, "%s", arrlong);
+  assert(stream.data == "100 -999 0 0");
+  stream.clear; formattedWrite(stream, "%s",arrlong);
+  assert(stream.data == "100 -999 0 0");
     
   ulong[] arrulong = new ulong[4];
   arrulong[0] = 100;
   arrulong[1] = 999;
   arrulong[3] = 0;
-  stream.backend = null; formattedWrite(stream, "", arrulong);
-  assert(stream.backend == "[100 999 0 0]");
+  stream.clear; formattedWrite(stream, "%s", arrulong);
+  assert(stream.data == "100 999 0 0");
   
   string[] arr2 = new string[4];
   arr2[0] = "hello";
   arr2[1] = "world";
   arr2[3] = "foo";
-  stream.backend = null; formattedWrite(stream, "", arr2);
-  assert(stream.backend == "[hello world  foo]");
+  stream.clear; formattedWrite(stream, "%s", arr2);
+  assert(stream.data == "hello world  foo");
 
-  stream.backend = null; formattedWrite(stream, "%.8d", 7);
-  assert(stream.backend == "00000007");
+  stream.clear; formattedWrite(stream, "%.8d", 7);
+  assert(stream.data == "00000007");
 
-  stream.backend = null; formattedWrite(stream, "%.8x", 10);
-  assert(stream.backend == "0000000a");
+  stream.clear; formattedWrite(stream, "%.8x", 10);
+  assert(stream.data == "0000000a");
 
-  stream.backend = null; formattedWrite(stream, "%-3d", 7);
-  assert(stream.backend == "7  ");
+  stream.clear; formattedWrite(stream, "%-3d", 7);
+  assert(stream.data == "7  ");
   
-  stream.backend = null; formattedWrite(stream, "%*d", -3, 7);
-  assert(stream.backend == "7  ");
+  stream.clear; formattedWrite(stream, "%*d", -3, 7);
+  assert(stream.data == "7  ");
 
-  stream.backend = null; formattedWrite(stream, "%.*d", -3, 7);
-  //writeln(stream.backend);
-  assert(stream.backend == "7");
+  stream.clear; formattedWrite(stream, "%.*d", -3, 7);
+  //writeln(stream.data);
+  assert(stream.data == "7");
 
 //  assert(false);
 //   typedef int myint;
 //   myint m = -7;
-//   stream.backend = null; formattedWrite(stream, "", m);
-//   assert(stream.backend == "-7");
+//   stream.clear; formattedWrite(stream, "", m);
+//   assert(stream.data == "-7");
   
-  stream.backend = null; formattedWrite(stream, "", "abc"c);
-  assert(stream.backend == "abc");
-  stream.backend = null; formattedWrite(stream, "", "def"w);
-  assert(stream.backend == "def");
-  stream.backend = null; formattedWrite(stream, "", "ghi"d);
-  assert(stream.backend == "ghi");
+  stream.clear; formattedWrite(stream, "%s", "abc"c);
+  assert(stream.data == "abc");
+  stream.clear; formattedWrite(stream, "%s", "def"w);
+  assert(stream.data == "def", "["~stream.data~"]");
+  stream.clear; formattedWrite(stream, "%s", "ghi"d);
+  assert(stream.data == "ghi");
   
  here:
   void* p = cast(void*)0xDEADBEEF;
-  stream.backend = null; formattedWrite(stream, "", p);
-  writefln("%s", stream.backend);
-  assert(stream.backend == "DEADBEEF");
+  stream.clear; formattedWrite(stream, "%s", p);
+  assert(stream.data == "DEADBEEF");
 
-  stream.backend = null; formattedWrite(stream, "%#x", 0xabcd);
-  assert(stream.backend == "0xabcd");
-  stream.backend = null; formattedWrite(stream, "%#X", 0xABCD);
-  assert(stream.backend == "0XABCD");
+  stream.clear; formattedWrite(stream, "%#x", 0xabcd);
+  assert(stream.data == "0xabcd");
+  stream.clear; formattedWrite(stream, "%#X", 0xABCD);
+  assert(stream.data == "0XABCD");
 
-  stream.backend = null; formattedWrite(stream, "%#o", 012345);
-  assert(stream.backend == "012345");
-  stream.backend = null; formattedWrite(stream, "%o", 9);
-  assert(stream.backend == "11");
+  stream.clear; formattedWrite(stream, "%#o", 012345);
+  assert(stream.data == "012345");
+  stream.clear; formattedWrite(stream, "%o", 9);
+  assert(stream.data == "11");
 
-  stream.backend = null; formattedWrite(stream, "%+d", 123);
-  assert(stream.backend == "+123");
-  stream.backend = null; formattedWrite(stream, "%+d", -123);
-  assert(stream.backend == "-123");
-  stream.backend = null; formattedWrite(stream, "% d", 123);
-  assert(stream.backend == " 123");
-  stream.backend = null; formattedWrite(stream, "% d", -123);
-  assert(stream.backend == "-123");
+  stream.clear; formattedWrite(stream, "%+d", 123);
+  assert(stream.data == "+123");
+  stream.clear; formattedWrite(stream, "%+d", -123);
+  assert(stream.data == "-123");
+  stream.clear; formattedWrite(stream, "% d", 123);
+  assert(stream.data == " 123");
+  stream.clear; formattedWrite(stream, "% d", -123);
+  assert(stream.data == "-123");
   
-  stream.backend = null; formattedWrite(stream, "%%");
-  assert(stream.backend == "%");
+  stream.clear; formattedWrite(stream, "%%");
+  assert(stream.data == "%");
   
-  stream.backend = null; formattedWrite(stream, "%d", true);
-  assert(stream.backend == "1");
-  stream.backend = null; formattedWrite(stream, "%d", false);
-  assert(stream.backend == "0");
+  stream.clear; formattedWrite(stream, "%d", true);
+  assert(stream.data == "1");
+  stream.clear; formattedWrite(stream, "%d", false);
+  assert(stream.data == "0");
     
-  stream.backend = null; formattedWrite(stream, "%d", 'a');
-  assert(stream.backend == "97");
-  wchar wc = 'a';
-  stream.backend = null; formattedWrite(stream, "%d", wc);
-  assert(stream.backend == "97");
-  dchar dc = 'a';
-  stream.backend = null; formattedWrite(stream, "%d", dc);
-  assert(stream.backend == "97");
+    stream.clear; formattedWrite(stream, "%d", 'a');
+    assert(stream.data == "97", stream.data);
+    wchar wc = 'a';
+    stream.clear; formattedWrite(stream, "%d", wc);
+    assert(stream.data == "97");
+    dchar dc = 'a';
+    stream.clear; formattedWrite(stream, "%d", dc);
+    assert(stream.data == "97");
 
   byte b = byte.max;
-  stream.backend = null; formattedWrite(stream, "%x", b);
-  assert(stream.backend == "7f");
-  stream.backend = null; formattedWrite(stream, "%x", ++b);
-  assert(stream.backend == "80");
-  stream.backend = null; formattedWrite(stream, "%x", ++b);
-  assert(stream.backend == "81");
+  stream.clear; formattedWrite(stream, "%x", b);
+  assert(stream.data == "7f");
+  stream.clear; formattedWrite(stream, "%x", ++b);
+  assert(stream.data == "80");
+  stream.clear; formattedWrite(stream, "%x", ++b);
+  assert(stream.data == "81");
 
   short sh = short.max;
-  stream.backend = null; formattedWrite(stream, "%x", sh);
-  assert(stream.backend == "7fff");
-  stream.backend = null; formattedWrite(stream, "%x", ++sh);
-  assert(stream.backend == "8000");
-  stream.backend = null; formattedWrite(stream, "%x", ++sh);
-  assert(stream.backend == "8001");
+  stream.clear; formattedWrite(stream, "%x", sh);
+  assert(stream.data == "7fff");
+  stream.clear; formattedWrite(stream, "%x", ++sh);
+  assert(stream.data == "8000");
+  stream.clear; formattedWrite(stream, "%x", ++sh);
+  assert(stream.data == "8001");
   
   i = int.max;
-  stream.backend = null; formattedWrite(stream, "%x", i);
-  assert(stream.backend == "7fffffff");
-  stream.backend = null; formattedWrite(stream, "%x", ++i);
-  assert(stream.backend == "80000000");
-  stream.backend = null; formattedWrite(stream, "%x", ++i);
-  assert(stream.backend == "80000001");
+  stream.clear; formattedWrite(stream, "%x", i);
+  assert(stream.data == "7fffffff");
+  stream.clear; formattedWrite(stream, "%x", ++i);
+  assert(stream.data == "80000000");
+  stream.clear; formattedWrite(stream, "%x", ++i);
+  assert(stream.data == "80000001");
 
-  stream.backend = null; formattedWrite(stream, "%x", 10);
-  assert(stream.backend == "a");
-  stream.backend = null; formattedWrite(stream, "%X", 10);
-  assert(stream.backend == "A");
-  stream.backend = null; formattedWrite(stream, "%x", 15);
-  assert(stream.backend == "f");
-  stream.backend = null; formattedWrite(stream, "%X", 15);
-  assert(stream.backend == "F");
+  stream.clear; formattedWrite(stream, "%x", 10);
+  assert(stream.data == "a");
+  stream.clear; formattedWrite(stream, "%X", 10);
+  assert(stream.data == "A");
+  stream.clear; formattedWrite(stream, "%x", 15);
+  assert(stream.data == "f");
+  stream.clear; formattedWrite(stream, "%X", 15);
+  assert(stream.data == "F");
 
   Object c = null;
-  stream.backend = null; formattedWrite(stream, "", c);
-  assert(stream.backend == "null");
+    stream.clear; formattedWrite(stream, "%s", c);
+    assert(stream.data == "null");
 
-  enum TestEnum
-  {
-    Value1, Value2
-  }
-  stream.backend = null; formattedWrite(stream, "%s", TestEnum.Value2);
-  assert(stream.backend == "1");
+    enum TestEnum
+    {
+        Value1, Value2
+    }
+    stream.clear; formattedWrite(stream, "%s", TestEnum.Value2);
+    assert(stream.data == "1", stream.data);
 
   //invariant(char[5])[int] aa = ([3:"hello", 4:"betty"]);
-  //stream.backend = null; formattedWrite(stream, "%s", aa.values);
-  //std.c.stdio.fwrite(stream.backend.ptr, stream.backend.length, 1, stderr);
-  //assert(stream.backend == "[[h,e,l,l,o],[b,e,t,t,y]]");
-  //stream.backend = null; formattedWrite(stream, "%s", aa);
-  //assert(stream.backend == "[3:[h,e,l,l,o],4:[b,e,t,t,y]]");
+  //stream.clear; formattedWrite(stream, "%s", aa.values);
+  //std.c.stdio.fwrite(stream.data.ptr, stream.data.length, 1, stderr);
+  //assert(stream.data == "[[h,e,l,l,o],[b,e,t,t,y]]");
+  //stream.clear; formattedWrite(stream, "%s", aa);
+  //assert(stream.data == "[3:[h,e,l,l,o],4:[b,e,t,t,y]]");
 
   static const dchar[] ds = ['a','b'];
   for (int j = 0; j < ds.length; ++j)
     {
-      stream.backend = null; formattedWrite(stream, " %d", ds[j]);
+      stream.clear; formattedWrite(stream, " %d", ds[j]);
       if (j == 0)
-	assert(stream.backend == " 97");
+	assert(stream.data == " 97");
       else
-	assert(stream.backend == " 98");
+	assert(stream.data == " 98");
     }
 
-  stream.backend = null; formattedWrite(stream, "%.-3d", 7);
-  assert(stream.backend == "7", ">" ~ stream.backend ~ "<");
+  stream.clear; formattedWrite(stream, "%.-3d", 7);
+  assert(stream.data == "7", ">" ~ stream.data ~ "<");
   
 
   // systematic test
@@ -2934,7 +2888,7 @@
                           foreach (prec; precs)
                               foreach (format; formats)
                               {
-                                  stream.backend = null; 
+                                  stream.clear; 
                                   auto fmt = "%" ~ flag1 ~ flag2  ~ flag3
                                       ~ flag4 ~ flag5 ~ width ~ prec ~ format
                                       ~ '\0';
@@ -3012,11 +2966,11 @@
                                       break;
                                   }
                                   auto exp = buf[0 .. strlen(buf.ptr)];
-                                  if (stream.backend != exp)
+                                  if (stream.data != exp)
                                   {
                                       writeln("Format: \"", fmt, '"');
                                       writeln("Expected: >", exp, "<");
-                                      writeln("Actual:   >", stream.backend,
+                                      writeln("Actual:   >", stream.data,
                                               "<");
                                       assert(false);
                                   }
@@ -3044,7 +2998,7 @@
        writefln(b);
    }
 
-   StringWriter!(char) stream;
+   Appender!(char[]) stream;
    alias TypeTuple!(byte, ubyte, short, ushort, int, uint, long, ulong,
        float, double, real,
        ifloat, idouble, ireal, cfloat, cdouble, creal) AllNumerics;
@@ -3056,21 +3010,220 @@
            T value = 1 + 1i;
        else
            T value = 1;
-       stream.backend = null; formattedWrite(stream, "%s", value);
+       stream.clear; formattedWrite(stream, "%s", value);
        static if (is(T : creal))
-           assert(stream.backend == "1+1i");
+           assert(stream.data == "1+1i");
        else
-           assert(stream.backend == "1");
+           assert(stream.data == "1");
        // test typedefs too
        typedef T Wyda;
        Wyda another = 1;
-       stream.backend = null; formattedWrite(stream, "%s", another);
-       assert(stream.backend == "1");
+       stream.clear; formattedWrite(stream, "%s", another);
+       assert(stream.data == "1");
    }
    
    //auto r = std.string.format("%s", aa.values);
-   stream.backend = null; formattedWrite(stream, "%s", aa);
-   assert(stream.backend == "[3:[h,e,l,l,o],4:[b,e,t,t,y]]", stream.backend);
+   stream.clear; formattedWrite(stream, "%s", aa);
+   assert(stream.data == "[3:[h,e,l,l,o],4:[b,e,t,t,y]]", stream.data);
 //    r = std.string.format("%s", aa);
 //   assert(r == "[3:[h,e,l,l,o],4:[b,e,t,t,y]]");
 }
+
+//------------------------------------------------------------------------------
+R formattedRead(R, S...)(R r, const(char)[] fmt, S args)
+{
+    static if (!S.length)
+    {
+        r = parseToFormatSpec(r, fmt);
+        enforce(fmt.length == 0);
+        return r;
+    }
+    else
+    {
+        FormatInfo spec;
+        // The loop below accounts for '*' == fields meant to be read
+        // and skipped
+        for (;;)
+        {
+            r = parseToFormatSpec(r, fmt);
+            spec = FormatInfo.parse(fmt);
+            if (spec.width != spec.DYNAMIC) break;
+            // must skip this field
+            skipData(r, spec);
+        }
+        alias typeof(*args[0]) A;
+        //@@@BUG 2725
+        //static if (is(A X == Tuple!(T), T))
+        static if (is(A.Types[0]))
+        {
+            //@@@BUG
+            //args[0].field[0] = parse!(A.Types[0])(r);
+            // static if (A.Types.length > 1)
+            //     return formattedRead(r, fmt,
+            //             args[0].slice!(1, A.Types.length)(),
+            //             args[1 .. $]);
+            // else
+            //     return formattedRead(r, fmt, args[1 .. $]);
+            // assume it's a tuple
+            foreach (i, T; A.Types)
+            {
+                //writeln("Parsing ", r, " with format ", fmt);
+                args[0].field[i] = unformat!(T)(r, spec);
+                for (;;)
+                {
+                    r = parseToFormatSpec(r, fmt);
+                    spec = FormatInfo.parse(fmt);
+                    if (spec.width != spec.DYNAMIC) break;
+                    // must skip this guy
+                    skipData(r, spec);
+                }
+            }
+            return formattedRead(r, fmt, args[1 .. $]);
+        }
+        else
+        {
+            *args[0] = unformat!(A)(r, spec);
+            return formattedRead(r, fmt, args[1 .. $]);
+        }
+    }
+}
+
+//------------------------------------------------------------------------------
+void skipData(Range)(ref Range input, FormatInfo spec)
+{
+    switch (spec.spec)
+    {
+    case 'c': input.popFront; break;
+    case 'd': assert(false, "Not implemented");
+    case 'u': while (!input.empty && isdigit(input.front)) input.popFront;
+        break;
+    default:
+        assert(false, text("Not understood: ", spec.spec));
+    }
+}
+
+//------------------------------------------------------------------------------
+T unformat(T, Range)(ref Range input, FormatInfo spec) if (isArray!T)
+{
+    Appender!(T) app;
+    for (;;)
+    {
+        auto e = parse!(ElementType!(T))(input);
+        app.put(e);
+        if (!std.string.startsWith(input, spec.innerTrailing)) break; // done
+        input = input[spec.innerTrailing.length .. $];
+        if (input.empty) break; // the trailing is terminator, not
+                                // separator
+    }
+    return app.data;
+}
+
+private template acceptedSpecs(T)
+{
+    static if (isIntegral!T) enum acceptedSpecs = "sdu";// + "coxX" (todo)
+    else static if (isFloatingPoint!T) enum acceptedSpecs = "seEfgG";
+    else enum acceptedSpecs = "";
+}
+
+//------------------------------------------------------------------------------
+T unformat(T, Range)(ref Range input, FormatInfo spec) if (isIntegral!T)
+{
+    enforce(std.algorithm.find("cdosuxX", spec.spec).length,
+            text("Wrong integral type specifier: `", spec.spec, "'"));
+    if (std.algorithm.find("dsu", spec.spec).length)
+    {
+        return parse!T(input);
+    }
+    assert(0, "Parsing spec '"~spec.spec~"' not implemented.");
+}
+
+//------------------------------------------------------------------------------
+T unformat(T, Range)(ref Range input, FormatInfo spec) if (isFloatingPoint!T)
+{
+    enforce(std.algorithm.find(acceptedSpecs!T, spec.spec).length,
+            text("Format specifier `", spec.spec,
+                    "' not accepted for floating point types"));
+    return parse!T(input);
+}
+
+//------------------------------------------------------------------------------
+private R parseToFormatSpec(R)(R r, ref const(char)[] fmt)
+{
+    while (fmt.length)
+    {
+        if (fmt[0] == '%')
+        {
+            if (fmt.length > 1 && fmt[1] == '%')
+            {
+                assert(!r.empty);
+                // Require a '%'
+                if (r.front != '%') break;
+                fmt = fmt[1 .. $];
+                r.popFront();
+            }
+            else
+            {
+                fmt.popFront;
+                break;
+            }
+        }
+        else
+        {
+            if (fmt.front == ' ')
+            {
+                r = std.algorithm.find!(not!isspace)(r);
+            }
+            else
+            {
+                enforce(
+                    !r.empty,
+                    text("parseToFormatSpec: Cannot find character `",
+                            fmt.front, "' in the input string `", r, "'"));
+                if (r.front != fmt.front) break;
+                r.popFront;
+            }
+            fmt.popFront;
+        }
+    }
+    return r;
+}
+
+unittest
+{
+    char[] line = "1 2".dup;
+    string format = "%s %s";
+    int a, b;
+    formattedRead(line, format, &a, &b);
+    assert(a == 1 && b == 2);
+
+    Tuple!(int, float) t;
+    line = "1 2.125".dup;
+    formattedRead(line, format, &t);
+    assert(t.field[0] == 1 && t.field[1] == 2.125);
+
+    line = "1 7643 2.125".dup;
+    formattedRead(line, "%s %*u %s", &t);
+    assert(t.field[0] == 1 && t.field[1] == 2.125);
+}
+
+/*
+ *  Copyright (C) 2004-2006 by Digital Mars, www.digitalmars.com
+ *  Written by Walter Bright and Andrei Alexandrescu
+ *
+ *  This software is provided 'as-is', without any express or implied
+ *  warranty. In no event will the authors be held liable for any damages
+ *  arising from the use of this software.
+ *
+ *  Permission is granted to anyone to use this software for any purpose,
+ *  including commercial applications, and to alter it and redistribute it
+ *  freely, subject to the following restrictions:
+ *
+ *  o  The origin of this software must not be misrepresented; you must not
+ *     claim that you wrote the original software. If you use this software
+ *     in a product, an acknowledgment in the product documentation would be
+ *     appreciated but is not required.
+ *  o  Altered source versions must be plainly marked as such, and must not
+ *     be misrepresented as being the original software.
+ *  o  This notice may not be removed or altered from any source
+ *     distribution.
+ */
diff -r f12bfe124807 d/phobos2/std/functional.d
--- a/d/phobos2/std/functional.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/functional.d	Thu Oct 14 14:12:53 2010 +0100
@@ -36,12 +36,9 @@
 
 module std.functional;
 
-import std.string; // for making string functions visible in *naryFun
-import std.conv; // for making conversions visible in *naryFun
-import std.typetuple;
-import std.typecons;
-import std.stdio;
-import std.metastrings;
+import std.metastrings, std.stdio, std.traits, std.typecons, std.typetuple;
+// for making various functions visible in *naryFun
+import std.algorithm, std.contracts, std.conv, std.math, std.range, std.string; 
 
 /**
 Transforms a string representing an expression into a unary
@@ -55,42 +52,80 @@
 ----
 */
 
-template unaryFun(alias comp, bool byRef = false)
+template unaryFun(alias funbody, bool byRef = false, string parmName = "a")
 {
-    alias unaryFunImpl!(comp, byRef).result unaryFun;
+    alias unaryFunImpl!(funbody, byRef, parmName).result unaryFun;
 }
 
-template unaryFunImpl(alias comp, bool byRef) {
-    static if (is(typeof(comp) : string))
+template unaryFunImpl(alias fun, bool byRef, string parmName = "a")
+{
+    static if (is(typeof(fun) : string))
     {
+        template Body(ElementType)
+        {
+            enum testAsExpression = "{"~ElementType.stringof
+                ~" "~parmName~"; return ("~fun~");}()";
+            enum testAsStmts = "{"~ElementType.stringof
+                ~" "~parmName~"; "~fun~"}()";
+            // pragma(msg, "Expr: "~testAsExpression);
+            // pragma(msg, "Stmts: "~testAsStmts);
+            static if (__traits(compiles, mixin(testAsExpression)))
+            {
+                enum string code = "return (" ~ fun ~ ");";
+                alias typeof(mixin(testAsExpression)) ReturnType;
+            }
+            // else static if (__traits(compiles, mixin(testAsStmts)))
+            // {
+            //     enum string code = fun;
+            //     alias typeof(mixin(testAsStmts)) ReturnType;
+            // }
+            else
+            {
+                // Credit for this idea goes to Don Clugston
+                // static assert is a bit broken,
+                // better to do it this way to provide a backtrace.
+                // pragma(msg, "Bad unary function: " ~ fun ~ " for type "
+                //         ~ ElementType.stringof);
+                static assert(false, "Bad unary function: " ~ fun ~
+                        " for type " ~ ElementType.stringof);
+            }
+        }
         static if (byRef)
         {
-            void result(ElementType)(ref ElementType a)
+            Body!(ElementType).ReturnType result(ElementType)(ref ElementType a)
             {
-                mixin(comp ~ ";");
+                mixin(Body!(ElementType).code);
             }
         }
         else
         {
-            // @@@BUG1816@@@: typeof(mixin(comp)) should work
-            typeof({ static ElementType a; return mixin(comp);}())
-                result(ElementType)(ElementType a)
+            Body!(ElementType).ReturnType result(ElementType)(ElementType __a)
             {
-                return mixin(comp);
+                mixin("alias __a "~parmName~";");
+                mixin(Body!(ElementType).code);
             }
+            // string mixme = "Body!(ElementType).ReturnType"
+            //     " result(ElementType)(ElementType a)
+            // { " ~ Body!(ElementType).code ~ " }";
+            // mixin(mixme);
         }
     }
     else
     {
-        //pragma(msg, comp.stringof);
-        alias comp result;
+        alias fun result;
     }
 }
 
 unittest
 {
-    static int f1(int a) { return a; }
+    static int f1(int a) { return a + 1; }
     static assert(is(typeof(unaryFun!(f1)(1)) == int));
+    assert(unaryFun!(f1)(41) == 42);
+    int f2(int a) { return a + 1; }
+    static assert(is(typeof(unaryFun!(f2)(1)) == int));
+    assert(unaryFun!(f2)(41) == 42);
+    assert(unaryFun!("a + 1")(41) == 42);
+    //assert(unaryFun!("return a + 1;")(41) == 42);
 }
 
 /**
@@ -108,31 +143,83 @@
 ----
 */
 
-template binaryFun(alias comp)
+template binaryFun(alias funbody, string parm1Name = "a",
+        string parm2Name = "b")
 {
-    alias binaryFunImpl!(comp).binaryFun binaryFun;
+    alias binaryFunImpl!(funbody, parm1Name, parm2Name).result binaryFun;
 }
 
-template binaryFunImpl(alias comp)
+template binaryFunImpl(alias fun,
+        string parm1Name, string parm2Name)
 {
-    static if (is(typeof(comp) : string))
+    static if (is(typeof(fun) : string))
     {
-        // @@@BUG1816@@@: typeof(mixin(comp)) should work
-        typeof({
-                    static ElementType1 a;
-                    static ElementType2 b;
-                    return mixin(comp);
-                }())
-            binaryFun(ElementType1, ElementType2)
-            (ElementType1 a, ElementType2 b)
+        template Body(ElementType1, ElementType2)
         {
-            return mixin(comp);
+            enum testAsExpression = "{"~ElementType1.stringof
+                ~" "~parm1Name~"; "~ElementType2.stringof
+                ~" "~parm2Name~"; return ("~fun~");}()";
+            enum testAsStmts = "{"~ElementType1.stringof
+                ~" "~parm1Name~"; "~ElementType2.stringof
+                ~" "~parm2Name~"; "~fun~"}()";
+            static if (__traits(compiles, mixin(testAsExpression)))
+            {
+                enum string code = "return (" ~ fun ~ ");";
+                alias typeof(mixin(testAsExpression)) ReturnType;
+            }
+            // else static if (__traits(compiles, mixin(testAsStmts)))
+            // {
+            //     enum string code = fun;
+            //     alias typeof(mixin(testAsStmts)) ReturnType;
+            // }
+            else
+            {
+                // Credit for this idea goes to Don Clugston
+                enum string msg = 
+                    "Bad binary function q{" ~ fun ~ "}."
+                    ~" You need to use a valid D expression using symbols "
+                    ~parm1Name~" of type "~ElementType1.stringof~" and "
+                    ~parm2Name~" of type "~ElementType2.stringof~"."
+                    ~(fun.length && fun[$ - 1] == ';'
+                            ? " The trailing semicolon is _not_ needed."
+                            : "")
+                    ~(fun.length && fun[$ - 1] == '}'
+                            ? " The trailing bracket is mistaken."
+                            : "");
+                static assert(false, msg);
+            }
+        }
+        Body!(ElementType1, ElementType2).ReturnType
+            result(ElementType1, ElementType2)
+            (ElementType1 __a, ElementType2 __b)
+        {
+            mixin("alias __a "~parm1Name~";");
+            mixin("alias __b "~parm2Name~";");
+            mixin(Body!(ElementType1, ElementType2).code);
         }
     }
     else
     {
-        alias comp binaryFun;
+        alias fun result;
     }
+    // static if (is(typeof(comp) : string))
+    // {
+    //     // @@@BUG1816@@@: typeof(mixin(comp)) should work
+    //     typeof({
+    //                 static ElementType1 a;
+    //                 static ElementType2 b;
+    //                 return mixin(comp);
+    //             }())
+    //         binaryFun(ElementType1, ElementType2)
+    //         (ElementType1 a, ElementType2 b)
+    //     {
+    //         return mixin(comp);
+    //     }
+    // }
+    // else
+    // {
+    //     alias comp binaryFun;
+    // }
 }
 
 unittest
@@ -140,6 +227,16 @@
     alias binaryFun!(q{a < b}) less;
     assert(less(1, 2) && !less(2, 1));
     assert(less("1", "2") && !less("2", "1"));
+
+    static int f1(int a, string b) { return a + 1; }
+    static assert(is(typeof(binaryFun!(f1)(1, "2")) == int));
+    assert(binaryFun!(f1)(41, "a") == 42);
+    string f2(int a, string b) { return b ~ "2"; }
+    static assert(is(typeof(binaryFun!(f2)(1, "1")) == string));
+    assert(binaryFun!(f2)(1, "4") == "42");
+    assert(binaryFun!("a + b")(41, 1) == 42);
+    //@@BUG
+    //assert(binaryFun!("return a + b;")(41, 1) == 42);
 }
 
 /*
@@ -183,9 +280,47 @@
     assert(zyx(5, 4) == foo(4, 5));
 }
 
+/**
+Negates predicate $(D pred).
+
+Example:
+----
+string a = "   Hello, world!";
+assert(find!(not!isspace)(a) == "Hello, world!");
+----
+ */
 template not(alias pred)
 {
-    bool not(T...)(T args) { return !unaryFun!(pred)(args); }
+    bool not(T...)(T args) { return !pred(args); }
+}
+
+/**
+Curries $(D fun) by tying its first argument to a particular value.
+
+Example:
+
+----
+int fun(int a, int b) { return a + b; }
+assert(curry!(fun, 5)(6) == 11);
+----
+ */
+template curry(alias fun, alias arg)
+{
+    ReturnType!fun curry(ParameterTypeTuple!(fun)[1] arg2)
+    {
+        return fun(arg, arg2);
+    }
+}
+
+unittest
+{
+    static int f1(int a, int b) { return a + b; }
+    assert(curry!(f1, 5)(6) == 11);
+    int x = 5;
+    int f2(int a, int b) { return a + b; }
+    assert(curry!(f2, x)(6) == 11);
+    auto f3 = &curry!(f2, x);
+    assert(f3(6) == 11);
 }
 
 /*private*/ template Adjoin(F...)
@@ -202,6 +337,16 @@
             alias typeof({ V values; return headFun(values); }()) Head;
             alias TypeTuple!(Head, Adjoin!(F[1 .. $]).For!(V).Result) Result;
         }
+
+        Tuple!(Result) fun(V...)(V a)
+        {
+            typeof(return) result;
+            foreach (i, Unused; Result)
+            {
+                result.field[i] = F[i](a);
+            }
+            return result;
+        }
     }
 }
 
@@ -218,7 +363,7 @@
 static int f2(int a) { return a / 2; }
 auto x = adjoin!(f1, f2)(5);
 assert(is(typeof(x) == Tuple!(bool, int)));
-assert(x._0 == true && x._1 == 2);
+assert(x._0 == true && x.field[1] == 2);
 ----
 */
 template adjoin(F...)
@@ -226,10 +371,9 @@
     Tuple!(Adjoin!(F).For!(V).Result) adjoin(V...)(V a)
     {
         typeof(return) result;
-        foreach (i, r; F)
+        foreach (i, Unused; Adjoin!(F).For!(V).Result)
         {
-            // @@@BUG@@@
-            mixin("result.field!("~ToString!(i)~") = F[i](a);");
+            result.field[i] = F[i](a);
         }
         return result;
     }
@@ -242,7 +386,7 @@
     auto x = adjoin!(F1, F2)(5);
     alias Adjoin!(F1, F2).For!(int).Result R;
     assert(is(typeof(x) == Tuple!(bool, int)));
-    assert(x._0 == true && x._1 == 2);
+    assert(x.field[0] && x.field[1] == 2);
 }
 
 // /*private*/ template NaryFun(string fun, string letter, V...)
@@ -351,14 +495,14 @@
 
 unittest
 {
-    string foo(int a) { return to!(string)(a); }
-    int bar(string a) { return to!(int)(a) + 1; }
-    double baz(int a) { return a + 0.5; }
-    assert(compose!(baz, bar, foo)(1) == 2.5);
-    assert(pipe!(foo, bar, baz)(1) == 2.5);
+    // string foo(int a) { return to!(string)(a); }
+    // int bar(string a) { return to!(int)(a) + 1; }
+    // double baz(int a) { return a + 0.5; }
+    // assert(compose!(baz, bar, foo)(1) == 2.5);
+    // assert(pipe!(foo, bar, baz)(1) == 2.5);
     
-    assert(compose!(baz, `to!(int)(a) + 1`, foo)(1) == 2.5);
-    assert(compose!(baz, bar)("1"[]) == 2.5);
+    // assert(compose!(baz, `to!(int)(a) + 1`, foo)(1) == 2.5);
+    // assert(compose!(baz, bar)("1"[]) == 2.5);
     
     // @@@BUG@@@
     //assert(compose!(baz, bar)("1") == 2.5);
diff -r f12bfe124807 d/phobos2/std/getopt.d
--- a/d/phobos2/std/getopt.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/getopt.d	Thu Oct 14 14:12:53 2010 +0100
@@ -51,6 +51,7 @@
 module std.getopt;
 private import std.string, std.conv, std.traits, std.contracts, std.bitmanip,
     std.algorithm, std.ctype;
+
 //version (unittest)
 //{
     import std.stdio; // for testing only
@@ -173,13 +174,14 @@
 keys and values can be of any parsable types.
  
 $(LI $(I Delegate options.) An option can be bound to a delegate with
-the signature $(D void delegate(string option)) or $(D void
-delegate(string option, string value)).
+the signature $(D void delegate()), $(D void delegate(string option))
+or $(D void delegate(string option, string value)).
 
-$(UL $(LI In the $(D void delegate(string option)) case, the option
-string (without the leading dash(es)) is passed to the delegate. After
-that, the option string is considered handled and removed from the
-options array.)
+$(UL $(LI In the $(D void delegate()) case, the delegate is invoked
+whenever the option is seen.) $(LI In the $(D void delegate(string
+option)) case, the option string (without the leading dash(es)) is
+passed to the delegate. After that, the option string is considered
+handled and removed from the options array.)
  
 ---------
 void main(string[] args)
@@ -308,25 +310,7 @@
 
 void getopt(T...)(ref string[] args, T opts) {
     enforce(args.length,
-            "Invalid arguments string passed: program name missing");
-
-    // break space-separated options
-    for (size_t i; i < args.length; )
-    {
-        auto a = args[i];
-        if (a.length && a[0] == optionChar && std.algorithm.canFind!(isspace)(a))
-        {
-            // multiple options wrapped in one
-            auto more = split(a);
-            args = args[0 .. i] ~ more ~ args[i + 1 .. $];
-            i += more.length;
-        }
-        else
-        {
-            ++i;
-        }
-    }
-    
+            "Invalid arguments string passed: program name missing");    
     configuration cfg;
     return getoptImpl(args, cfg, opts);
 }
@@ -427,8 +411,11 @@
             break;
         } else {
             // non-boolean option, which might include an argument
-            enum isDelegateWithOneParameter = is(typeof(receiver("")) : void);
-            if (!val && !incremental && !isDelegateWithOneParameter) {
+            //enum isDelegateWithOneParameter = is(typeof(receiver("")) : void);
+            enum isDelegateWithLessThanTwoParameters =
+                is(typeof(receiver) == delegate) &&
+                !is(typeof(receiver("", "")));
+            if (!isDelegateWithLessThanTwoParameters && !val && !incremental) {
                 // eat the next argument too
                 val = args[i];
                 args = args[0 .. i] ~ args[i + 1 .. $];
@@ -451,12 +438,18 @@
                     // option with argument
                     receiver(option, val);
                 }
-                else
+                else static if (is(typeof(receiver("")) : void)) 
                 {
                     static assert(is(typeof(receiver("")) : void));
                     // boolean-style receiver
                     receiver(option);
                 }
+                else
+                {
+                    static assert(is(typeof(receiver()) : void));
+                    // boolean-style receiver without argument
+                    receiver();
+                }
             }
             else static if (isArray!(typeof(*receiver)))
             {
@@ -582,7 +575,7 @@
     
     string data = "file.dat";
     int length = 24;
-    bool verbose = true;
+    bool verbose = false;
     args = (["program.name", "--length=5",
                       "--file", "dat.file", "--verbose"]).dup;
     getopt(
@@ -642,6 +635,15 @@
     getopt(args, "verbose", &myHandler2);
     assert(verbosityLevel == 2);
 
+    verbosityLevel = 1;
+    void myHandler3()
+    {
+        verbosityLevel = 2;
+    }
+    args = (["program.name", "--verbose"]).dup;
+    getopt(args, "verbose", &myHandler3);
+    assert(verbosityLevel == 2);
+
     bool foo, bar;
     args = (["program.name", "--foo", "--bAr"]).dup;
     getopt(args,
diff -r f12bfe124807 d/phobos2/std/intrinsic.d
--- a/d/phobos2/std/intrinsic.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/intrinsic.d	Thu Oct 14 14:12:53 2010 +0100
@@ -3,12 +3,6 @@
 // www.digitalmars.com
 // Placed into the public domain
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, May 2006
-*/
-
 /** These functions are built-in intrinsics to the compiler.
  *
 	Intrinsic functions are functions built in to the compiler,
@@ -49,7 +43,7 @@
     return i; // supposed to be undefined
 }
 else
-    pure nothrow int bsf(uint v);
+pure nothrow int bsf(uint v);
 
 /**
  * Scans the bits in v from the most significant bit
@@ -92,7 +86,7 @@
     return i; // supposed to be undefined
 }
 else
-    pure nothrow int bsr(uint v);
+pure nothrow int bsr(uint v);
 
 /**
  * Tests the bit.
@@ -103,7 +97,8 @@
     return (p[bitnum / (uint.sizeof*8)] & (1<<(bitnum & ((uint.sizeof*8)-1)))) ? -1 : 0 ;
 }
 else
-    pure nothrow int bt(in uint *p, uint bitnum);
+pure nothrow int bt(in uint *p, uint bitnum);
+
 /**
  * Tests and complements the bit.
  */
@@ -132,7 +127,7 @@
     return result ? -1 : 0;
 }
 else
-    int btr(uint *p, uint bitnum);
+int btr(uint *p, uint bitnum);
 
 /**
  * Tests and sets the bit.
@@ -201,7 +196,7 @@
     return result ? -1 : 0;
 }
 else
-    int bts(uint *p, uint bitnum);
+int bts(uint *p, uint bitnum);
 
 
 /**
@@ -215,7 +210,7 @@
     return ((v&0xFF)<<24)|((v&0xFF00)<<8)|((v&0xFF0000)>>>8)|((v&0xFF000000)>>>24);
 }
 else
-    pure nothrow uint bswap(uint v);
+pure uint bswap(uint v);
 
 
 /**
@@ -224,7 +219,7 @@
 version (GNU)
     ubyte  inp(uint p) { return 0; }
 else
-    ubyte  inp(uint port_address);
+ubyte  inp(uint port_address);
 
 /**
  * ditto
@@ -232,7 +227,7 @@
 version (GNU)
     ushort inpw(uint p) { return 0; }
 else
-    ushort inpw(uint port_address);
+ushort inpw(uint port_address);
 
 /**
  * ditto
@@ -240,7 +235,7 @@
 version (GNU)
     uint   inpl(uint p) { return 0; }
 else
-    uint   inpl(uint port_address);
+uint   inpl(uint port_address);
 
 
 /**
@@ -249,7 +244,7 @@
 version (GNU)
     ubyte  outp(uint p, ubyte v) { return v; }
 else
-    ubyte  outp(uint port_address, ubyte value);
+ubyte  outp(uint port_address, ubyte value);
 
 /**
  * ditto
@@ -257,7 +252,7 @@
 version (GNU)
     ushort outpw(uint p, ushort v) { return v; }
 else
-    ushort outpw(uint port_address, ushort value);
+ushort outpw(uint port_address, ushort value);
 
 /**
  * ditto
@@ -265,6 +260,6 @@
 version (GNU)
     uint   outpl(uint p, uint v) { return v; }
 else
-    uint   outpl(uint port_address, uint value);
+uint   outpl(uint port_address, uint value);
 
 
diff -r f12bfe124807 d/phobos2/std/loader.d
--- a/d/phobos2/std/loader.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/loader.d	Thu Oct 14 14:12:53 2010 +0100
@@ -34,36 +34,6 @@
  *
  * ////////////////////////////////////////////////////////////////////////// */
 
-/*
-    Copyright for Darwin specific code
-
-    Copyright (c) 2002 Peter O'Gorman <ogorman@users.sourceforge.net>
-
-    Permission is hereby granted, free of charge, to any person obtaining
-    a copy of this software and associated documentation files (the
-    "Software"), to deal in the Software without restriction, including
-    without limitation the rights to use, copy, modify, merge, publish,
-    distribute, sublicense, and/or sell copies of the Software, and to
-    permit persons to whom the Software is furnished to do so, subject to
-    the following conditions:
-
-    The above copyright notice and this permission notice shall be
-    included in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, June 2006 (applied patches from Anders F Bjrklund.)
-*/
 
 
 /** \file D/std/loader.d This file contains the \c D standard library 
@@ -79,6 +49,7 @@
  */
 
 private import std.string;
+import std.conv;
 private import std.c.string;
 private import std.c.stdlib;
 private import std.c.stdio;
@@ -92,11 +63,6 @@
  * External function declarations
  */
 
-version(linux)
-    version = dlopen;
-else version (freebsd)
-    version = dlopen;
-
 version(Windows)
 {
     private import std.c.windows.windows;
@@ -107,115 +73,15 @@
         alias HMODULE HModule_;
     }
 }
-else version(dlopen)
+else version(Posix)
 {
-    private import std.c.linux.linux;
+    private import core.sys.posix.dlfcn;
 
     extern(C)
     {
 	alias void* HModule_;
     }
 }
-else version(darwin)
-{
-    extern(C)
-    {
-        // #include <mach-o/loader.h>
-
-        struct mach_header
-        {
-            uint    magic;      /* mach magic number identifier */
-            uint    cputype;    /* cpu specifier */
-            uint    cpusubtype; /* machine specifier */
-            uint    filetype;   /* type of file */
-            uint    ncmds;      /* number of load commands */
-            uint    sizeofcmds; /* the size of all the load commands */
-            uint    flags;      /* flags */
-        }
-        
-        /* Constant for the magic field of the mach_header */
-        const uint MH_MAGIC = 0xfeedface;   // the mach magic number
-        const uint MH_CIGAM = 0xcefaedfe;   // x86 variant
-	const uint MH_MAGIC_64 = 0xfeedfacf;  // the 64-bit mach magic number
-	const uint MH_CIGAM_64 = 0xcffaedfe;  // NXSwapInt(MH_MAGIC_64)
-
-        // #include <mach-o/dyld.h>
-        
-        typedef void *NSObjectFileImage;
-        
-        typedef void *NSModule;
-        
-        typedef void *NSSymbol;
-
-        enum // DYLD_BOOL: uint
-        {
-            FALSE,
-            TRUE
-        }
-        alias uint DYLD_BOOL;
-
-        enum // NSObjectFileImageReturnCode: uint
-        {
-            NSObjectFileImageFailure, /* for this a message is printed on stderr */
-            NSObjectFileImageSuccess,
-            NSObjectFileImageInappropriateFile,
-            NSObjectFileImageArch,
-            NSObjectFileImageFormat, /* for this a message is printed on stderr */
-            NSObjectFileImageAccess
-        }
-        alias uint NSObjectFileImageReturnCode;
-        
-        enum // NSLinkEditErrors: uint
-        {
-            NSLinkEditFileAccessError,
-            NSLinkEditFileFormatError,
-            NSLinkEditMachResourceError,
-            NSLinkEditUnixResourceError,
-            NSLinkEditOtherError,
-            NSLinkEditWarningError,
-            NSLinkEditMultiplyDefinedError,
-            NSLinkEditUndefinedError
-        }
-        alias uint NSLinkEditErrors;
-
-
-        alias NSModule HModule_;
-    
-        NSObjectFileImageReturnCode NSCreateObjectFileImageFromFile(in char *pathName, NSObjectFileImage* objectFileImage);
-        DYLD_BOOL NSDestroyObjectFileImage(NSObjectFileImage objectFileImage);
-   
-        mach_header * NSAddImage(in char *image_name, uint options);
-        const uint NSADDIMAGE_OPTION_NONE = 0x0;
-        const uint NSADDIMAGE_OPTION_RETURN_ON_ERROR = 0x1;
-        const uint NSADDIMAGE_OPTION_WITH_SEARCHING = 0x2;
-        const uint NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED = 0x4;
-        const uint NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME = 0x8;
-
-        NSModule NSLinkModule(NSObjectFileImage objectFileImage, in char* moduleName, uint options);
-        const uint NSLINKMODULE_OPTION_NONE = 0x0;
-        const uint NSLINKMODULE_OPTION_BINDNOW = 0x01;
-        const uint NSLINKMODULE_OPTION_PRIVATE = 0x02;
-        const uint NSLINKMODULE_OPTION_RETURN_ON_ERROR = 0x04;
-        const uint NSLINKMODULE_OPTION_DONT_CALL_MOD_INIT_ROUTINES = 0x08;
-        const uint NSLINKMODULE_OPTION_TRAILING_PHYS_NAME = 0x10;
-        DYLD_BOOL NSUnLinkModule(NSModule module_, uint options);
-    
-        void NSLinkEditError(NSLinkEditErrors *c, int *errorNumber, char **fileName, char **errorString);
-   
-        DYLD_BOOL NSIsSymbolNameDefined(char *symbolName);
-        DYLD_BOOL NSIsSymbolNameDefinedInImage(mach_header *image, char *symbolName);
-        NSSymbol NSLookupAndBindSymbol(char *symbolName);
-        NSSymbol NSLookupSymbolInModule(NSModule module_, char* symbolName);
-        NSSymbol NSLookupSymbolInImage(mach_header *image, char *symbolName, uint options);
-        const uint NSLOOKUPSYMBOLINIMAGE_OPTION_BIND = 0x0;
-        const uint NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW = 0x1;
-        const uint NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_FULLY = 0x2;
-        const uint NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR = 0x4;
-
-        void* NSAddressOfSymbol(NSSymbol symbol);
-        char* NSNameOfSymbol(NSSymbol symbol);
-    }
-}
 else
 {
 	const int platform_not_discriminated = 0;
@@ -391,7 +257,7 @@
         return szFileName[0 .. cch].idup;
     }
 }
-else version(dlopen)
+else version(Posix)
 {
     private class ExeModuleInfo
     {
@@ -581,261 +447,6 @@
         return mi.m_name;
     }
 }
-else version(darwin)
-{
-    private class ExeModuleInfo
-    {
-    public:
-        int         m_cRefs;
-        HModule_    m_hmod;
-        string      m_name;
-
-        this(HModule_ hmod, string name)
-        {
-            m_cRefs =   1;
-            m_hmod  =   hmod;
-            m_name  =   name;
-        }
-    };
-
-    private void record_error_()
-    {
-        NSLinkEditErrors error;
-        int errno;
-        char *fileName;
-        char *err = null;
-
-        NSLinkEditError(&error, &errno, &fileName, &err);
-        printf("NSLinkEditError: %d %d - %s %s\n", cast(uint) error, errno, fileName, err);
-        
-        s_lastError = (err == null) ? "" : err[0 .. std.string.strlen(err)].idup;
-    }
-
-    private int                     s_init;
-    private ExeModuleInfo [char[]]  s_modules;
-    private string                  s_lastError;    // This is NOT thread-specific
-
-    private int ExeModule_Init_()
-    {
-        if(1 == ++s_init)
-        {
-            return 0;
-        }
-
-        return 1;
-    }
-
-    private void ExeModule_Uninit_()
-    {
-        if(0 == --s_init)
-        {
-        }
-    }
-
-    private HXModule ExeModule_Load_(in string moduleName)
-    in
-    {
-        assert(null !is moduleName);
-    }
-    body
-    {
-        ExeModuleInfo   *p_mi = moduleName in s_modules;
-
-        if(p_mi != null)
-        {
-            return (++(*p_mi).m_cRefs, cast(HXModule)*p_mi);
-        }
-        else
-        {
-            NSModule handle = null;
-            NSObjectFileImage fileImage = null;
-            auto filename = toStringz(moduleName);
-            // printf("DEBUG Trying to load: %s\n", filename);
-
-            NSObjectFileImageReturnCode returnCode =
-                NSCreateObjectFileImageFromFile(filename, &fileImage);
-            if(returnCode == NSObjectFileImageSuccess)
-            {
-                handle = NSLinkModule(fileImage,filename, 
-                    NSLINKMODULE_OPTION_RETURN_ON_ERROR |
-                    NSLINKMODULE_OPTION_PRIVATE |
-                    NSLINKMODULE_OPTION_BINDNOW);
-                NSDestroyObjectFileImage(fileImage);
-            }
-            else if(returnCode == NSObjectFileImageInappropriateFile)
-            {
-                NSDestroyObjectFileImage(fileImage);
-                /* Could be dynamic library rather than a bundle */
-                handle = cast(NSModule) NSAddImage(filename,
-                    NSADDIMAGE_OPTION_RETURN_ON_ERROR);
-            }
-            else
-            {
-                // printf("Failed: %d\n", returnCode);
-                s_lastError = "NSCreateObjectFileImageFromFile failed";
-                return null;
-            }
-            
-            if (handle == null)
-            {
-                record_error_();
-        
-                return null;
-            }
-            else
-            {
-                ExeModuleInfo   mi  =   new ExeModuleInfo(handle, moduleName);
-
-                s_modules[moduleName]   =   mi;
-
-                return cast(HXModule)mi;
-            }        
-        }
-    }
-
-    private HXModule ExeModule_AddRef_(in HXModule hModule)
-    in
-    {
-        assert(null !is hModule);
-
-        ExeModuleInfo   mi = cast(ExeModuleInfo)hModule;
-
-        assert(0 < mi.m_cRefs);
-        assert(null !is mi.m_hmod);
-        assert(null !is mi.m_name);
-        assert(null !is s_modules[mi.m_name]);
-        assert(mi is s_modules[mi.m_name]);
-    }
-    body
-    {
-        ExeModuleInfo   mi = cast(ExeModuleInfo)hModule;
-
-        if(null !is mi)
-        {
-            return (++mi.m_cRefs, cast(HXModule)hModule);
-        }
-        else
-        {
-            return null;
-        }
-    }
-
-    private void ExeModule_Release_(inout HXModule hModule)
-    in
-    {
-        assert(null !is hModule);
-
-        ExeModuleInfo   mi = cast(ExeModuleInfo)hModule;
-
-        assert(0 < mi.m_cRefs);
-        assert(null !is mi.m_hmod);
-        assert(null !is mi.m_name);
-        assert(null !is s_modules[mi.m_name]);
-        assert(mi is s_modules[mi.m_name]);
-    }
-    body
-    {
-        ExeModuleInfo   mi      =   cast(ExeModuleInfo)hModule;
-
-        if(0 == --mi.m_cRefs)
-        {
-            string      name    =   mi.m_name;
-            uint        magic;
-            
-            magic = (* cast(mach_header *) mi.m_hmod).magic;
-            if ( magic == MH_MAGIC || magic == MH_CIGAM ||
-		 magic == MH_MAGIC_64 || magic == MH_CIGAM_64)
-            {
-                // Can not unlink dynamic libraries on Darwin
-            }
-            else if (NSUnLinkModule(mi.m_hmod, 0) == FALSE)
-            {
-                // printf("DEBUG: Could not unlink module %.*s\n", name);
-            }
-            s_modules.remove(name);
-            delete mi;
-        }
-
-        hModule = null;
-    }
-
-    private void *ExeModule_GetSymbol_(inout HXModule hModule, in char[] symbolName)
-    in
-    {
-        assert(null !is hModule);
-
-        ExeModuleInfo   mi = cast(ExeModuleInfo)hModule;
-
-        assert(0 < mi.m_cRefs);
-        assert(null !is mi.m_hmod);
-        assert(null !is mi.m_name);
-        assert(null !is s_modules[mi.m_name]);
-        assert(mi is s_modules[mi.m_name]);
-    }
-    body
-    {
-        ExeModuleInfo   mi      =   cast(ExeModuleInfo)hModule;
-        
-        NSModule handle = mi.m_hmod;
-        uint magic = (* cast(mach_header *) handle).magic;
-        char *name = ("_" ~ symbolName ~ "\0").ptr;
-        NSSymbol symbol = null;
- 
-        if ( (handle == cast(NSModule) -1) &&
-            NSIsSymbolNameDefined(name))
-            /* Global context, use NSLookupAndBindSymbol */
-            symbol = NSLookupAndBindSymbol(name);
-        else if ( ( magic == MH_MAGIC || magic == MH_CIGAM ||
-		    magic == MH_MAGIC_64 || magic == MH_CIGAM_64
-		    ) &&
-            NSIsSymbolNameDefinedInImage(cast(mach_header *) handle, name))
-            symbol = NSLookupSymbolInImage(cast(mach_header *) handle, name,
-                NSLOOKUPSYMBOLINIMAGE_OPTION_BIND |
-                NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR);
-        else
-            symbol = NSLookupSymbolInModule(handle, name);
-        
-        if (symbol == null)
-        {
-            // printf("DEBUG: Symbol not found: %s\n", name);
-            return null;
-        }
-        
-        void *address = NSAddressOfSymbol(symbol);
-
-        if(address == null)
-        {
-            record_error_();
-        }
-
-        return address;
-    }
-
-    private string ExeModule_Error_()
-    {
-        return s_lastError;
-    }
-
-    private string ExeModule_GetPath_(HXModule hModule)
-    in
-    {
-        assert(null !is hModule);
-
-        ExeModuleInfo   mi = cast(ExeModuleInfo)hModule;
-
-        assert(0 < mi.m_cRefs);
-        assert(null !is mi.m_hmod);
-        assert(null !is mi.m_name);
-        assert(null !is s_modules[mi.m_name]);
-        assert(mi is s_modules[mi.m_name]);
-    }
-    body
-    {
-        ExeModuleInfo   mi = cast(ExeModuleInfo)hModule;
-
-        return mi.m_name;
-    }
-}
 else
 {
 	const int platform_not_discriminated = 0;
@@ -860,12 +471,12 @@
     {
       version (Posix)
       {
-	char[80] buf = void;
-	super(std.string.toString(_d_gnu_cbridge_strerror(errcode, buf.ptr, buf.length)).idup);
+          char[80] buf = void;
+          super(to!string(strerror_r(errcode, buf.ptr, buf.length)).idup);
       }
       else
       {
-	super(std.string.toString(strerror(errcode)).idup);
+          super(to!string(strerror(errcode)));
       }
     }
 }
@@ -897,11 +508,7 @@
 		if (m_hModule == null)
 		    throw new ExeModuleException(GetLastError());
 	    }
-	    else version (dlopen)
-	    {
-		m_hModule = ExeModule_AddRef(hModule);
-	    }
-	    else version (darwin)
+	    else version (Posix)
 	    {
 		m_hModule = ExeModule_AddRef(hModule);
 	    }
@@ -923,13 +530,7 @@
 	    if (null is m_hModule)
 		throw new ExeModuleException(GetLastError());
 	}
-	else version (dlopen)
-	{
-	    m_hModule = ExeModule_Load(moduleName);
-	    if (null is m_hModule)
-		throw new ExeModuleException(ExeModule_Error());
-	}
-	else version (darwin)
+	else version (Posix)
 	{
 	    m_hModule = ExeModule_Load(moduleName);
 	    if (null is m_hModule)
@@ -962,11 +563,7 @@
 		if(!FreeLibrary(cast(HModule_)m_hModule))
 		    throw new ExeModuleException(GetLastError());
 	    }
-	    else version (dlopen)
-	    {
-		ExeModule_Release(m_hModule);
-	    }
-	    else version (darwin)
+	    else version (Posix)
 	    {
 		ExeModule_Release(m_hModule);
 	    }
@@ -994,16 +591,7 @@
 		throw new ExeModuleException(GetLastError());
 	    }
 	}
-	else version (dlopen)
-	{
-	    void *symbol = ExeModule_GetSymbol(m_hModule, symbolName);
-
-	    if(null is symbol)
-	    {
-		throw new ExeModuleException(ExeModule_Error());
-	    }
-	}
-	else version (darwin)
+	else version (Posix)
 	{
 	    void *symbol = ExeModule_GetSymbol(m_hModule, symbolName);
 
@@ -1059,11 +647,7 @@
 
 	    return szFileName[0 .. cch].idup;
 	}
-	else version (dlopen)
-	{
-	    return ExeModule_GetPath_(m_hModule);
-	}
-	else version (darwin)
+	else version (Posix)
 	{
 	    return ExeModule_GetPath_(m_hModule);
 	}
@@ -1095,8 +679,7 @@
             {
                 auto ExeModule xmod =   new ExeModule(moduleName);
 
-                printf("\"%.*s\" is loaded\n", cast(int) moduleName.length,
-		    moduleName.ptr);
+                printf("\"%.*s\" is loaded\n", moduleName);
 
                 void    *symbol =   xmod.getSymbol(symbolName);
 
diff -r f12bfe124807 d/phobos2/std/math.d
--- a/d/phobos2/std/math.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/math.d	Thu Oct 14 14:12:53 2010 +0100
@@ -1,5 +1,4 @@
 // Written in the D programming language
-
 /**
  * Elementary mathematical functions.
  *
@@ -7,6 +6,9 @@
  * floating-point arithmetic, including the use of camelCase names rather
  * than C99-style lower case names. All of these functions behave correctly
  * when presented with an infinity or NaN.
+ * 
+ * Unlike C, there is no global 'errno' variable. Consequently, almost all of
+ * these functions are pure nothrow.
  *  
  * Authors:
  *      Walter Bright, Don Clugston
@@ -39,41 +41,6 @@
  *      SQRT = &radix;
  *      HALF = &frac12;
  */
-/*
- * Copyright:
- *      Copyright (c) 2001-2005 by Digital Mars,
- *      All Rights Reserved,
- *      www.digitalmars.com
- * License:
- *  This software is provided 'as-is', without any express or implied
- *  warranty. In no event will the authors be held liable for any damages
- *  arising from the use of this software.
- *
- *  Permission is granted to anyone to use this software for any purpose,
- *  including commercial applications, and to alter it and redistribute it
- *  freely, subject to the following restrictions:
- *
- *  <ul>
- *  <li> The origin of this software must not be misrepresented; you must not
- *       claim that you wrote the original software. If you use this software
- *       in a product, an acknowledgment in the product documentation would be
- *       appreciated but is not required.
- *  </li>
- *  <li> Altered source versions must be plainly marked as such, and must not
- *       be misrepresented as being the original software.
- *  </li>
- *  <li> This notice may not be removed or altered from any source
- *       distribution.
- *  </li>
- *  </ul>
- */
-
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, September 2007
-*/
-
 module(system) std.math;
 
 //debug=math;           // uncomment to turn on debugging printf's
@@ -84,29 +51,20 @@
 private import std.c.math;
 private import std.traits;
 
-version (GNU)
-{
-    // Some functions are missing from msvcrt...
-    version (Windows)
-	version = GNU_msvcrt_math;
-
-    // Use extended asm for x86
-    version(X86)
-	version = GCC_ExtAsm_X86;
-}
-
 version(GNU){
     // GDC can't actually do inline asm.
 } else version(D_InlineAsm_X86) {
     version = Naked_D_InlineAsm_X86;
-} else version(LDC) {    
+}
+version(LDC) {    
     import ldc.intrinsics;
-    version(X86)
-    {
-        version = LDC_X86;
-    }
 }
 
+version(DigitalMars){
+    version=INLINE_YL2X;	// x87 has opcodes for these
+}
+
+
 private:
 /*
  * The following IEEE 'real' formats are currently supported:
@@ -134,16 +92,15 @@
 // They supplement the built-in floating point properties.
 template floatTraits(T) {
  // EXPMASK is a ushort mask to select the exponent portion (without sign)
- // POW2MANTDIG = pow(2, real.mant_dig) is the value such that
- //  (smallest_denormal)*POW2MANTDIG == real.min
  // EXPPOS_SHORT is the index of the exponent when represented as a ushort array.
  // SIGNPOS_BYTE is the index of the sign when represented as a ubyte array.
+ // RECIP_EPSILON is the value such that (smallest_denormal) * RECIP_EPSILON == T.min
+    enum T RECIP_EPSILON = (1/T.epsilon);
  static if (T.mant_dig == 24) { // float
     enum ushort EXPMASK = 0x7F80;
     enum ushort EXPBIAS = 0x3F00;
     enum uint EXPMASK_INT = 0x7F80_0000;
     enum uint MANTISSAMASK_INT = 0x007F_FFFF;
-    enum real POW2MANTDIG = 0x1p+24;
     version(LittleEndian) {
       enum EXPPOS_SHORT = 1;
     } else {
@@ -154,7 +111,6 @@
     enum ushort EXPBIAS = 0x3FE0;
     enum uint EXPMASK_INT = 0x7FF0_0000;
     enum uint MANTISSAMASK_INT = 0x000F_FFFF; // for the MSB only
-    enum real POW2MANTDIG = 0x1p+53;
     version(LittleEndian) {
       enum EXPPOS_SHORT = 3;
       enum SIGNPOS_BYTE = 7;
@@ -165,7 +121,6 @@
  } else static if (T.mant_dig == 64) { // real80
     enum ushort EXPMASK = 0x7FFF;
     enum ushort EXPBIAS = 0x3FFE;
-    enum real POW2MANTDIG = 0x1p+63;
     version(LittleEndian) {
       enum EXPPOS_SHORT = 4;
       enum SIGNPOS_BYTE = 9;
@@ -173,9 +128,8 @@
       enum EXPPOS_SHORT = 0;
       enum SIGNPOS_BYTE = 0;
     }
- } else static if (real.mant_dig == 113){ // quadruple
+ } else static if (T.mant_dig == 113){ // quadruple
     enum ushort EXPMASK = 0x7FFF;
-    enum real POW2MANTDIG = 0x1p+113;
     version(LittleEndian) {
       enum EXPPOS_SHORT = 7;
       enum SIGNPOS_BYTE = 15;
@@ -183,10 +137,9 @@
       enum EXPPOS_SHORT = 0;
       enum SIGNPOS_BYTE = 0;
     }
- } else static if (real.mant_dig == 106) { // doubledouble
+ } else static if (T.mant_dig == 106) { // doubledouble
     enum ushort EXPMASK = 0x7FF0;
-    enum real POW2MANTDIG = 0x1p+53;  // doubledouble denormals are strange
-    // and the exponent byte is not unique
+    // the exponent byte is not unique
     version(LittleEndian) {
       enum EXPPOS_SHORT = 7; // [3] is also an exp short
       enum SIGNPOS_BYTE = 15;
@@ -205,6 +158,7 @@
     enum MANTISSA_LSB = 1;
     enum MANTISSA_MSB = 0;
 }
+
 public:
 
 class NotImplemented : Error
@@ -245,14 +199,13 @@
         LOG2            0.23210 11520 47674 77674 61076 11263 26013 37111
  */
 
-
 /***********************************
  * Calculates the absolute value
  *
  * For complex numbers, abs(z) = sqrt( $(POWER z.re, 2) + $(POWER z.im, 2) )
  * = hypot(z.re, z.im).
  */
-Num abs(Num)(Num x) if (is(typeof(Num >= 0)) && is(typeof(-Num)) &&
+pure nothrow Num abs(Num)(Num x) if (is(typeof(Num >= 0)) && is(typeof(-Num)) &&
         !(is(Num* : const(ifloat*)) || is(Num* : const(idouble*))
                 || is(Num* : const(ireal*))))
 {
@@ -262,7 +215,7 @@
         return x>=0 ? x : -x;
 }
 
-auto abs(Num)(Num z)
+pure nothrow auto abs(Num)(Num z)
     if (is(Num* : const(cfloat*)) || is(Num* : const(cdouble*))
             || is(Num* : const(creal*)))
 {
@@ -270,13 +223,14 @@
 }
 
 /** ditto */
-real abs(Num)(Num y)
+pure nothrow real abs(Num)(Num y)
     if (is(Num* : const(ifloat*)) || is(Num* : const(idouble*))
             || is(Num* : const(ireal*)))
 {
     return fabs(y.im);
 }
 
+
 unittest
 {
     assert(isIdentical(abs(-0.0L), 0.0L));
@@ -286,7 +240,7 @@
     assert(abs(71.6Li) == 71.6L);
     assert(abs(-56) == 56);
     assert(abs(2321312L)  == 2321312L);
-    assert(mfeq(abs(-1+1i), sqrt(2.0), .0000001));
+    assert(abs(-1+1i) == sqrt(2.0));
 }
 
 /***********************************
@@ -297,17 +251,18 @@
  * Note that z * conj(z) = $(POWER z.re, 2) - $(POWER z.im, 2)
  * is always a real number
  */
-creal conj(creal z)
+pure nothrow creal conj(creal z)
 {
     return z.re - z.im*1i;
 }
 
 /** ditto */
-ireal conj(ireal y)
+pure nothrow ireal conj(ireal y)
 {
     return -y;
 }
 
+
 unittest
 {
     assert(conj(7 + 3i) == 7-3i);
@@ -344,7 +299,7 @@
  */
 
 version(GNU) alias std.c.math.sinl sin; else
-pure nothrow real sin(real x);	/* intrinsic */
+pure nothrow real sin(real x);       /* intrinsic */
 
 
 /***********************************
@@ -355,7 +310,7 @@
  * If both sin($(THETA)) and cos($(THETA)) are required,
  * it is most efficient to use expi($(THETA)).
  */
-creal sin(creal z)
+pure nothrow creal sin(creal z)
 {
   creal cs = expi(z.re);
   creal csh = coshisinh(z.im);
@@ -363,7 +318,7 @@
 }
 
 /** ditto */
-ireal sin(ireal y)
+pure nothrow ireal sin(ireal y)
 {
   return cosh(y.im)*1i;
 }
@@ -379,24 +334,23 @@
  *
  *  cos(z) = cos(z.re)*cosh(z.im) - sin(z.re)*sinh(z.im)i
  */
-creal cos(creal z)
+pure nothrow creal cos(creal z)
 {
   creal cs = expi(z.re);
   creal csh = coshisinh(z.im);
   return cs.re * csh.re - cs.im * csh.im * 1i;
 }
- 
+
 /** ditto */
-real cos(ireal y)
+pure nothrow real cos(ireal y)
 {
   return cosh(y.im);
 }
- 
+
 unittest{
   assert(cos(0.0+0.0i)==1.0);
   assert(cos(1.3L+0.0i)==cos(1.3L));
-  // @@@FAILS 
-  //assert(cos(5.2Li)== cosh(5.2L));
+  assert(cos(5.2Li)== cosh(5.2L));
 }
 
 /****************************************************************************
@@ -410,7 +364,6 @@
  *      )
  */
 
-version(GNU) alias std.c.math.tanl tan; else
 pure nothrow real tan(real x)
 {
     version(Naked_D_InlineAsm_X86) {
@@ -447,7 +400,7 @@
 Lret:
     ;
     } else {
-        return stdc.math.tanl(x);
+        return std.c.math.tanl(x);
     }
 }
 
@@ -485,12 +438,6 @@
 
     for (i = 0; i < vals.length; i++)
     {
-        /* Library tanl does not have the same limit as the fptan
-           instruction. */
-        version (GNU)
-            if (i == vals.length - 1)
-	        continue;
-
         real x = vals[i][0];
         real r = vals[i][1];
         real t = tan(x);
@@ -596,16 +543,16 @@
  *      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)0.0) $(TD no) )
  *      )
  */
-real cosh(real x)               {
+pure nothrow real cosh(real x)               {
     //  cosh = (exp(x)+exp(-x))/2.
     // The naive implementation works correctly. 
     real y = exp(x);
     return (y + 1.0/y) * 0.5;
 }
 /// ditto
-double cosh(double x)               { return cosh(cast(real)x); }
+pure nothrow double cosh(double x)               { return cosh(cast(real)x); }
 /// ditto
-float cosh(float x)               { return cosh(cast(real)x); }
+pure nothrow float cosh(float x)               { return cosh(cast(real)x); }
 
 
 /***********************************
@@ -617,7 +564,7 @@
  *      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)$(INFIN)) $(TD no))
  *      )
  */
-real sinh(real x)
+pure nothrow real sinh(real x)
 {
     //  sinh(x) =  (exp(x)-exp(-x))/2;    
     // Very large arguments could cause an overflow, but
@@ -630,9 +577,9 @@
     return 0.5 * y / (y+1) * (y+2);
 }
 /// ditto
-double sinh(double x)               { return sinh(cast(real)x); }
+pure nothrow double sinh(double x)               { return sinh(cast(real)x); }
 /// ditto
-float sinh(float x)               { return sinh(cast(real)x); }
+pure nothrow float sinh(float x)               { return sinh(cast(real)x); }
 
 
 /***********************************
@@ -644,7 +591,7 @@
  *      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)1.0) $(TD no))
  *      )
  */
-real tanh(real x)
+pure nothrow real tanh(real x)
 {
     //  tanh(x) = (exp(x) - exp(-x))/(exp(x)+exp(-x))
     if (fabs(x) > real.mant_dig * LN2) {
@@ -654,20 +601,20 @@
     return y / (y + 2);
 }
 /// ditto
-double tanh(double x)             { return tanh(cast(real)x); }
+pure nothrow double tanh(double x)             { return tanh(cast(real)x); }
 /// ditto
-float tanh(float x)               { return tanh(cast(real)x); }
+pure nothrow float tanh(float x)               { return tanh(cast(real)x); }
 
 private:
 /* Returns cosh(x) + I * sinh(x)
  * Only one call to exp() is performed.
  */
-creal coshisinh(real x)
+pure nothrow creal coshisinh(real x)
 {
     // See comments for cosh, sinh.
     if (fabs(x) > real.mant_dig * LN2) {
         real y = exp(fabs(x));
-        return y*0.5 + 0.5i * copysign(y, x);
+        return y * 0.5 + 0.5i * copysign(y, x);
     } else {
         real y = expm1(x);
         return (y + 1.0 + 1.0/(y + 1.0)) * 0.5 + 0.5i * y / (y+1) * (y+2);
@@ -675,9 +622,9 @@
 }
 
 unittest {
-    creal c = coshisinh(3.0);
-    assert(c.re == cosh(3.0));
-    assert(c.im == sinh(3.0));
+    creal c = coshisinh(3.0L);
+    assert(c.re == cosh(3.0L));
+    assert(c.im == sinh(3.0L));
 }
 
 public:
@@ -693,12 +640,12 @@
  *      $(TABLE_SV
  *    $(SVH  x,     acosh(x) )
  *    $(SV  $(NAN), $(NAN) )
- *    $(SV  <1,     $(NAN) )
+ *    $(SV  $(LT)1,     $(NAN) )
  *    $(SV  1,      0       )
  *    $(SV  +$(INFIN),+$(INFIN))
  *  )
  */
-real acosh(real x)
+pure nothrow real acosh(real x)
 {
     if (x > 1/real.epsilon)
         return LN2 + log(x);
@@ -706,9 +653,9 @@
         return log(x + sqrt(x*x - 1));
 }
 /// ditto
-double acosh(double x)             { return acosh(cast(real)x); }
+pure nothrow double acosh(double x)             { return acosh(cast(real)x); }
 /// ditto
-float acosh(float x)               { return acosh(cast(real)x); }
+pure nothrow float acosh(float x)               { return acosh(cast(real)x); }
 
 
 unittest
@@ -735,7 +682,7 @@
  *    $(SV  $(PLUSMN)$(INFIN),$(PLUSMN)$(INFIN))
  *    )
  */
-real asinh(real x)
+pure nothrow real asinh(real x)
 {
     if (fabs(x) > 1 / real.epsilon) {   // beyond this point, x*x + 1 == x*x
             return copysign(LN2 + log(fabs(x)), x);
@@ -745,9 +692,9 @@
     }
 }
 /// ditto
-double asinh(double x)             { return asinh(cast(real)x); }
+pure nothrow double asinh(double x)             { return asinh(cast(real)x); }
 /// ditto
-float asinh(float x)               { return asinh(cast(real)x); }
+pure nothrow float asinh(float x)               { return asinh(cast(real)x); }
 
 unittest
 {
@@ -775,15 +722,15 @@
  *    $(SV  -$(INFIN), -0)
  * )
  */
-real atanh(real x)
+pure nothrow real atanh(real x)
 {
     // log( (1+x)/(1-x) ) == log ( 1 + (2*x)/(1-x) )
-    return copysign(0.5 * log1p( 2 * x / (1 - x) ), x);
+    return  0.5 * log1p( 2 * x / (1 - x) );
 }
 /// ditto
-double atanh(double x)             { return atanh(cast(real)x); }
+pure nothrow double atanh(double x)             { return atanh(cast(real)x); }
 /// ditto
-float atanh(float x)               { return atanh(cast(real)x); }
+pure nothrow float atanh(float x)               { return atanh(cast(real)x); }
 
 
 unittest
@@ -822,6 +769,8 @@
  *      )
  */
 
+pure nothrow
+{
 version(GNU)
 {
     float sqrt(float x)   { return std.c.math.sqrtf(x); }
@@ -830,15 +779,13 @@
 }
 else
 {
-    pure nothrow
-    {
-	float sqrt(float x);    /* intrinsic */
-	double sqrt(double x);  /* intrinsic */ /// ditto
-	real sqrt(real x);      /* intrinsic */ /// ditto
-    }
+    float sqrt(float x);    /* intrinsic */
+    double sqrt(double x);  /* intrinsic */ /// ditto
+    real sqrt(real x);      /* intrinsic */ /// ditto
+}
 }
 
-creal sqrt(creal z)
+pure nothrow creal sqrt(creal z)
 {
     creal c;
     real x,y,w,r;
@@ -889,20 +836,21 @@
  *    $(TR $(TD $(NAN))        $(TD $(NAN))    )
  *  )
  */
-real exp(real x) {
+pure nothrow real exp(real x) {
     version(Naked_D_InlineAsm_X86) {
    //  e^x = 2^(LOG2E*x)
    // (This is valid because the overflow & underflow limits for exp
    // and exp2 are so similar).
     return exp2(LOG2E*x);
     } else {
-	return std.c.math.expl(x);
-    }
+        return std.c.math.exp(x);        
+    }    
 }
 /// ditto
-double exp(double x)             { return std.c.math.exp(x); }
+pure nothrow double exp(double x)             { return exp(cast(real)x); }
 /// ditto
-float exp(float x)               { return std.c.math.expf(x); }
+pure nothrow float exp(float x)               { return exp(cast(real)x); }
+
 
 /**
  * Calculates the value of the natural logarithm base (e)
@@ -919,10 +867,80 @@
  *    $(TR $(TD $(NAN))        $(TD $(NAN))       )
  *  )
  */
-version (GNU_msvcrt_math) { /* nothing */ } else
-real expm1(real x)
+pure nothrow real expm1(real x) 
 {
-    return std.c.math.expm1l(x);
+    version(Naked_D_InlineAsm_X86) {
+      enum { PARAMSIZE = (real.sizeof+3)&(0xFFFF_FFFC) } // always a multiple of 4
+      asm {
+        /*  expm1() for x87 80-bit reals, IEEE754-2008 conformant.
+         * Author: Don Clugston.
+         * 
+         *    expm1(x) = 2^(rndint(y))* 2^(y-rndint(y)) - 1 where y = LN2*x.
+         *    = 2rndy * 2ym1 + 2rndy - 1, where 2rndy = 2^(rndint(y))
+         *     and 2ym1 = (2^(y-rndint(y))-1).
+         *    If 2rndy  < 0.5*real.epsilon, result is -1.
+         *    Implementation is otherwise the same as for exp2()
+         */
+        naked;        
+        fld real ptr [ESP+4] ; // x
+        mov AX, [ESP+4+8]; // AX = exponent and sign
+        sub ESP, 12+8; // Create scratch space on the stack 
+        // [ESP,ESP+2] = scratchint
+        // [ESP+4..+6, +8..+10, +10] = scratchreal
+        // set scratchreal mantissa = 1.0
+        mov dword ptr [ESP+8], 0;
+        mov dword ptr [ESP+8+4], 0x80000000;
+        and AX, 0x7FFF; // drop sign bit
+        cmp AX, 0x401D; // avoid InvalidException in fist
+        jae L_extreme;
+        fldl2e;
+        fmul ; // y = x*log2(e)       
+        fist dword ptr [ESP]; // scratchint = rndint(y)
+        fisub dword ptr [ESP]; // y - rndint(y)
+        // and now set scratchreal exponent
+        mov EAX, [ESP];
+        add EAX, 0x3fff;
+        jle short L_largenegative;
+        cmp EAX,0x8000;
+        jge short L_largepositive;
+        mov [ESP+8+8],AX;        
+        f2xm1; // 2^(y-rndint(y)) -1 
+        fld real ptr [ESP+8] ; // 2^rndint(y)
+        fmul ST(1), ST;
+        fld1;
+        fsubp ST(1), ST;
+        fadd;        
+        add ESP,12+8;        
+        ret PARAMSIZE;
+        
+L_extreme: // Extreme exponent. X is very large positive, very
+        // large negative, infinity, or NaN.
+        fxam;
+        fstsw AX;
+        test AX, 0x0400; // NaN_or_zero, but we already know x!=0 
+        jz L_was_nan;  // if x is NaN, returns x
+        test AX, 0x0200;
+        jnz L_largenegative;
+L_largepositive:        
+        // Set scratchreal = real.max. 
+        // squaring it will create infinity, and set overflow flag.
+        mov word  ptr [ESP+8+8], 0x7FFE;
+        fstp ST(0), ST;
+        fld real ptr [ESP+8];  // load scratchreal
+        fmul ST(0), ST;        // square it, to create havoc!
+L_was_nan:
+        add ESP,12+8;
+        ret PARAMSIZE;
+L_largenegative:        
+        fstp ST(0), ST;
+        fld1;
+        fchs; // return -1. Underflow flag is not set.
+        add ESP,12+8;
+        ret PARAMSIZE;
+      }
+    } else {
+        return std.c.math.expm1(x);                
+    }
 }
 
 /**
@@ -935,21 +953,93 @@
  *    $(TR $(TD $(NAN))        $(TD $(NAN))    )
  *  )
  */
-version (GNU_Need_exp2_log2)
+pure nothrow real exp2(real x) 
 {
-real exp2(float x)		{ return std.c.math.powf(2, x); }
-/// ditto
-real exp2(double x)		{ return std.c.math.pow(2, x); }
-/// ditto
-real exp2(real x)		{ return std.c.math.powl(2, x); }
-}
-else
-{
-float exp2(float x)		{ return std.c.math.exp2f(x); }
-/// ditto
-double exp2(double x)		{ return std.c.math.exp2(x); }
-/// ditto
-real exp2(real x)               { return std.c.math.exp2l(x); }
+    version(Naked_D_InlineAsm_X86) {
+      enum { PARAMSIZE = (real.sizeof+3)&(0xFFFF_FFFC) } // always a multiple of 4
+      asm {
+        /*  exp2() for x87 80-bit reals, IEEE754-2008 conformant.
+         * Author: Don Clugston.
+         * 
+         * exp2(x) = 2^(rndint(x))* 2^(y-rndint(x))
+         * The trick for high performance is to avoid the fscale(28cycles on core2),
+         * frndint(19 cycles), leaving f2xm1(19 cycles) as the only slow instruction.
+         * 
+         * We can do frndint by using fist. BUT we can't use it for huge numbers,
+         * because it will set the Invalid Operation flag if overflow or NaN occurs.
+         * Fortunately, whenever this happens the result would be zero or infinity.
+         * 
+         * We can perform fscale by directly poking into the exponent. BUT this doesn't
+         * work for the (very rare) cases where the result is subnormal. So we fall back
+         * to the slow method in that case.
+         */
+        naked;        
+        fld real ptr [ESP+4] ; // x
+        mov AX, [ESP+4+8]; // AX = exponent and sign
+        sub ESP, 12+8; // Create scratch space on the stack 
+        // [ESP,ESP+2] = scratchint
+        // [ESP+4..+6, +8..+10, +10] = scratchreal
+        // set scratchreal mantissa = 1.0
+        mov dword ptr [ESP+8], 0;
+        mov dword ptr [ESP+8+4], 0x80000000;
+        and AX, 0x7FFF; // drop sign bit
+        cmp AX, 0x401D; // avoid InvalidException in fist
+        jae L_extreme;
+        fist dword ptr [ESP]; // scratchint = rndint(x)
+        fisub dword ptr [ESP]; // x - rndint(x)
+        // and now set scratchreal exponent
+        mov EAX, [ESP];
+        add EAX, 0x3fff;
+        jle short L_subnormal;
+        cmp EAX,0x8000;
+        jge short L_overflow;
+        mov [ESP+8+8],AX;        
+L_normal:
+        f2xm1;
+        fld1;
+        fadd; // 2^(x-rndint(x))
+        fld real ptr [ESP+8] ; // 2^rndint(x)
+        add ESP,12+8;        
+        fmulp ST(1), ST;
+        ret PARAMSIZE;
+
+L_subnormal:
+        // Result will be subnormal.
+        // In this rare case, the simple poking method doesn't work. 
+        // The speed doesn't matter, so use the slow fscale method.
+        fild dword ptr [ESP];  // scratchint
+        fld1;
+        fscale;
+        fstp real ptr [ESP+8]; // scratchreal = 2^scratchint
+        fstp ST(0),ST;         // drop scratchint        
+        jmp L_normal;
+        
+L_extreme: // Extreme exponent. X is very large positive, very
+        // large negative, infinity, or NaN.
+        fxam;
+        fstsw AX;
+        test AX, 0x0400; // NaN_or_zero, but we already know x!=0 
+        jz L_was_nan;  // if x is NaN, returns x
+        // set scratchreal = real.min
+        // squaring it will return 0, setting underflow flag
+        mov word  ptr [ESP+8+8], 1;
+        test AX, 0x0200;
+        jnz L_waslargenegative;
+L_overflow:        
+        // Set scratchreal = real.max.
+        // squaring it will create infinity, and set overflow flag.
+        mov word  ptr [ESP+8+8], 0x7FFE;
+L_waslargenegative:        
+        fstp ST(0), ST;
+        fld real ptr [ESP+8];  // load scratchreal
+        fmul ST(0), ST;        // square it, to create havoc!
+L_was_nan:
+        add ESP,12+8;
+        ret PARAMSIZE;
+      }
+    } else {
+        return std.c.math.exp2(x);
+    }    
 }
 
 unittest{
@@ -966,15 +1056,9 @@
  * almost twice as fast as calculating sin(y) and cos(y) separately,
  * and is the preferred method when both are required.
  */
-creal expi(real y)
+pure nothrow creal expi(real y)
 {
-    version(GCC_ExtAsm_X86)
-    {
-	real re = void, im = void;
-	asm { "fsincos" : "=&t" re , "=u" im : "0" y; }
-	return re + im * 1i;
-    }
-    else version(D_InlineAsm_X86)
+    version(Naked_D_InlineAsm_X86)
     {
         asm
         {
@@ -1013,19 +1097,15 @@
  *      $(TR $(TD $(PLUSMN)$(NAN)) $(TD $(PLUSMN)$(NAN)) $(TD int.min))
  *      )
  */
-
-
 real frexp(real value, out int exp)
 {
-    version (DMD) {
-
     ushort* vu = cast(ushort*)&value;
     long* vl = cast(long*)&value;
     uint ex;
     alias floatTraits!(real) F;
 
     ex = vu[F.EXPPOS_SHORT] & F.EXPMASK;
-    static if (real.mant_dig == 64) { // real80
+  static if (real.mant_dig == 64) { // real80
     if (ex) { // If exponent is non-zero
         if (ex == F.EXPMASK) {   // infinity or NaN
             if (*vl &  0x7FFF_FFFF_FFFF_FFFF) {  // NaN
@@ -1045,9 +1125,9 @@
         exp = 0;
     } else {
         // denormal
-        value *= F.POW2MANTDIG;
+        value *= F.RECIP_EPSILON;
         ex = vu[F.EXPPOS_SHORT] & F.EXPMASK;
-        exp = ex - F.EXPBIAS - 63;
+        exp = ex - F.EXPBIAS - real.mant_dig + 1;
         vu[F.EXPPOS_SHORT] = (0x8000 & vu[F.EXPPOS_SHORT]) | 0x3FFE;
     }
   } else static if (real.mant_dig == 113) { // quadruple      
@@ -1074,9 +1154,9 @@
             exp = 0;
     } else {
         // denormal
-        value *= F.POW2MANTDIG;
+        value *= F.RECIP_EPSILON;
         ex = vu[F.EXPPOS_SHORT] & F.EXPMASK;
-        exp = ex - F.EXPBIAS - 113;
+        exp = ex - F.EXPBIAS - real.mant_dig + 1;
         vu[F.EXPPOS_SHORT] = 
                   cast(ushort)((0x8000 & vu[F.EXPPOS_SHORT]) | 0x3FFE);
     }
@@ -1100,52 +1180,29 @@
         exp = 0;
     } else {
         // denormal
-        ushort sgn;
-        sgn = cast(ushort)((0x8000 & vu[F.EXPPOS_SHORT])| 0x3FE0);
-        *vl &= 0x7FFF_FFFF_FFFF_FFFF;
-
-        int i = -0x3FD + 11;
-        do {
-            i--;
-            *vl <<= 1;
-        } while (*vl > 0);
-        exp = i;
-        vu[F.EXPPOS_SHORT] = sgn;
+        value *= F.RECIP_EPSILON;
+        ex = vu[F.EXPPOS_SHORT] & F.EXPMASK;
+        exp = (ex - F.EXPBIAS)>>> 4 - real.mant_dig + 1;
+        vu[F.EXPPOS_SHORT] = 
+                  cast(ushort)((0x8000 & vu[F.EXPPOS_SHORT]) | 0x3FE0);
     }
   } else { //static if(real.mant_dig==106) // doubledouble
     throw new NotImplemented("frexp");
   }
   return value;
-
-    }
-    else version(GNU)
-    {
-	switch (gcc.fpcls.fpclassify(value)) {
-	case gcc.fpcls.FP_NORMAL:
-	case gcc.fpcls.FP_ZERO:
-	case gcc.fpcls.FP_SUBNORMAL: // I can only hope the library frexp normalizes the value...
-	    return std.c.math.frexpl(value, & exp);
-	case gcc.fpcls.FP_INFINITE:
-	    exp = gcc.fpcls.signbit(value) ? int.min : int.max;
-	    return value;
-	case gcc.fpcls.FP_NAN:
-	    exp = int.min;
-	    return value;
-	}
-    }
 }
 
 
 unittest
 {
-    static real vals[][3] =	// x,frexp,exp
+    static real vals[][3] =     // x,frexp,exp
     [
         [0.0,   0.0,    0],
         [-0.0,  -0.0,   0],
         [1.0,   .5,     1],
         [-1.0,  -.5,    1],
         [2.0,   .5,     2],
-        [double.min/2.0, .5, -1022],
+    [double.min/2.0, .5, -1022],
         [real.infinity,real.infinity,int.max],
         [-real.infinity,-real.infinity,int.min],
         [real.nan,real.nan,int.min],
@@ -1155,19 +1212,16 @@
     int i;
 
     for (i = 0; i < vals.length; i++) {
-	if (real.min_exp > -16381)
-	    continue;
         real x = vals[i][0];
         real e = vals[i][1];
         int exp = cast(int)vals[i][2];
         int eptr;
         real v = frexp(x, eptr);
-//        printf("frexp(%La) = %La, should be %La, eptr = %d, should be %d\n",
-//                x, v, e, eptr, exp);
         assert(isIdentical(e, v));
         assert(exp == eptr);
 
     }
+    /+
    static if (real.mant_dig == 64) {
      static real extendedvals[][3] = [ // x,frexp,exp
         [0x1.a5f1c2eb3fe4efp+73, 0x1.A5F1C2EB3FE4EFp-1,   74],    // normal
@@ -1184,8 +1238,9 @@
         real v = frexp(x, eptr);
         assert(isIdentical(e, v));
         assert(exp == eptr);
+
     }
-    }
+    }+/
 }
 
 /******************************************
@@ -1215,6 +1270,17 @@
 version(GNU) alias std.c.math.ldexpl ldexp; else
 pure nothrow real ldexp(real n, int exp);    /* intrinsic */
 
+unittest {
+    assert(ldexp(1, -16384) == 0x1p-16384L);
+    assert(ldexp(1, -16382) == 0x1p-16382L);
+    int x;
+    real n = frexp(0x1p-16384L, x);
+    assert(n==0.5L);
+    assert(x==-16383);
+    assert(ldexp(n, x)==0x1p-16384L);
+    
+}
+
 /**************************************
  * Calculate the natural logarithm of x.
  *
@@ -1226,7 +1292,18 @@
  *    )
  */
 
-real log(real x)                { return std.c.math.logl(x); }
+pure nothrow real log(real x)
+{
+    version (INLINE_YL2X)
+	return yl2x(x, LN2);
+    else
+	return std.c.math.logl(x);
+}
+
+unittest
+{
+    assert(log(E) == 1);
+}
 
 /**************************************
  * Calculate the base-10 logarithm of x.
@@ -1239,7 +1316,18 @@
  *      )
  */
 
-real log10(real x)              { return std.c.math.log10l(x); }
+pure nothrow real log10(real x)
+{
+    version (INLINE_YL2X)
+	return yl2x(x, LOG2);
+    else
+	return std.c.math.log10l(x);
+}
+
+unittest
+{
+    assert(log10(1000) == 3);
+}
 
 /******************************************
  *      Calculates the natural logarithm of 1 + x.
@@ -1256,7 +1344,15 @@
  *  )
  */
 
-real log1p(real x)              { return std.c.math.log1pl(x); }
+pure nothrow real log1p(real x) {
+   version(INLINE_YL2X) {
+       // On x87, yl2xp1 is valid if and only if -0.5 <= lg(x) <= 0.5,
+       //    ie if -0.29<=x<=0.414
+       return (fabs(x) <= 0.25)  ? yl2xp1(x, LN2) : yl2x(x+1, LN2);
+   } else {
+      return std.c.math.log1pl(x); 
+   }
+}
 
 /***************************************
  * Calculates the base-2 logarithm of x:
@@ -1269,8 +1365,13 @@
  *  $(TR $(TD +$(INFIN))    $(TD +$(INFIN)) $(TD no)           $(TD no) )
  *  )
  */
-version (GNU_Need_exp2_log2) real log2(real x) { return std.c.math.logl(x) / LOG2; } else
-real log2(real x)               { return std.c.math.log2l(x); }
+pure nothrow real log2(real x)
+{
+    version (INLINE_YL2X)
+	return yl2x(x, 1);
+    else
+	return std.c.math.log2l(x);
+}
 
 /*****************************************
  * Extracts the exponent of x as a signed integral value.
@@ -1318,13 +1419,13 @@
  */
 real scalbn(real x, int n)
 {
-    version(D_InlineAsm_X86) {
+    version(Naked_D_InlineAsm_X86) {
         // scalbnl is not supported on DMD-Windows, so use asm.
         asm {
             fild n;
             fld x;
             fscale;
-            fstp ST(1)/*, ST*/;
+            fstp ST(1), ST;
         }
     } else {
         return std.c.math.scalbnl(x, n);
@@ -1357,7 +1458,12 @@
  *      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD +$(INFIN)) )
  *      )
  */
-version (GNU) alias std.c.math.fabsl fabs; else
+version (GNU) 
+pure nothrow real fabs(real x)
+{
+    return std.c.math.fabsl(x);
+}
+else
 pure nothrow real fabs(real x);      /* intrinsic */
 
 
@@ -1380,103 +1486,68 @@
  *  )
  */
 
-real hypot(real x, real y)
+pure nothrow real hypot(real x, real y)
 {
-    /*
-     * This is based on code from:
-     * Cephes Math Library Release 2.1:  January, 1989
-     * Copyright 1984, 1987, 1989 by Stephen L. Moshier
-     * Direct inquiries to 30 Frost Street, Cambridge, MA 02140
-     */
+    // Scale x and y to avoid underflow and overflow.
+    // If one is huge and the other tiny, return the larger. 
+    // If both are huge, avoid overflow by scaling by 1/sqrt(real.max/2).
+    // If both are tiny, avoid underflow by scaling by sqrt(real.min*real.epsilon).         
 
-    enum int PRECL = 32;
-    enum int MAXEXPL = real.max_exp; //16384;
-    enum int MINEXPL = real.min_exp; //-16384;
-
-    real xx, yy, b, re, im;
-    int ex, ey, e;
-
-    // Note, hypot(INFINITY, NAN) = INFINITY.
-    if (isInfinity(x) || isInfinity(y))
-        return real.infinity;
-
-    if (isNaN(x))
-        return x;
-    if (isNaN(y))
-        return y;
-
-    re = fabs(x);
-    im = fabs(y);
-
-    if (re == 0.0)
-        return im;
-    if (im == 0.0)
-        return re;
-
-    // Get the exponents of the numbers
-    xx = frexp(re, ex);
-    yy = frexp(im, ey);
-
-    // Check if one number is tiny compared to the other
-    e = ex - ey;
-    if (e > PRECL)
-        return re;
-    if (e < -PRECL)
-        return im;
-
-    // Find approximate exponent e of the geometric mean.
-    e = (ex + ey) >> 1;
-
-    // Rescale so mean is about 1
-    xx = ldexp(re, -e);
-    yy = ldexp(im, -e);
-
-    // Hypotenuse of the right triangle
-    b = sqrt(xx * xx  +  yy * yy);
-
-    // Compute the exponent of the answer.
-    yy = frexp(b, ey);
-    ey = e + ey;
-
-    // Check it for overflow and underflow.
-    if (ey > MAXEXPL + 2)
-    {
-        //return __matherr(_OVERFLOW, INFINITY, x, y, "hypotl");
-        return real.infinity;
+    real SQRTMIN = 0.5*sqrt(real.min); // This is a power of 2.
+    real SQRTMAX = 1.0L/SQRTMIN; // 2^((max_exp)/2) = nextUp(sqrt(real.max))
+    
+    assert(2*(SQRTMAX/2)*(SQRTMAX/2) <= real.max);
+    assert(real.min*real.max>2 && real.min*real.max<=4); // Proves that sqrt(real.max) ~~  0.5/sqrt(real.min)
+        
+    real u = fabs(x);
+    real v = fabs(y);    
+    if (u >= SQRTMAX*0.5) {
+        if (v < SQRTMAX*real.epsilon)   return u; // hypot(huge, tiny) == huge
+        if (u == real.infinity && v!=v) return u; // hypot(inf, nan) == inf
+    } else if (v >= SQRTMAX*0.5) { 
+        if (u < SQRTMAX*real.epsilon)   return v; // hypot(tiny, huge) == huge        
+        if (v == real.infinity && u!=u) return v; // hypot(nan, inf) == inf
+    } else if (u<=SQRTMIN || v<=SQRTMIN){
+        // at least one is tiny, avoid underflow
+        u *= SQRTMAX / real.epsilon; v *= SQRTMAX/real.epsilon;
+        return sqrt(u*u + v*v) * SQRTMIN * real.epsilon;
+    } else {
+        // both are in the normal range
+        return sqrt(u*u + v*v);
     }
-    if (ey < MINEXPL - 2)
-        return 0.0;
-
-    // Undo the scaling
-    b = ldexp(b, e);
-    return b;
+    // hypot(huge, huge) -- avoid overflow
+    u *= SQRTMIN*0.5; v *= SQRTMIN*0.5;    
+    return sqrt(u*u + v*v) * SQRTMAX * 2.0;
 }
 
 unittest
 {
     static real vals[][3] =     // x,y,hypot
-    [
-        [ 0,      0,      0],
-        [ 0,      -0,     0],
-        [ 3,      4,      5],
-        [ -300,   -400,   500],
-        [ real.min, real.min, 0x1.6a09e667f3bcc908p-16382L],
-        [ real.max/2, real.max/2, 0x1.6a09e667f3bcc908p+16383L],
-        [ real.infinity, real.nan, real.infinity],
-        [ real.nan, real.nan, real.nan],
-    ];
-
-    for (int i = 0; i < vals.length; i++)
-    {
-	if (i == 5 && real.max_exp < 16383)
-	    continue;
-
-        real x = vals[i][0];
-        real y = vals[i][1];
-        real z = vals[i][2];
-        real h = hypot(x, y);
-        assert(isIdentical(z, h));
-    }
+        [
+            [ 0.0,     0.0,   0.0],
+            [ 0.0,    -0.0,   0.0],
+            [ -0.0,   -0.0,   0.0],
+            [ 3.0,     4.0,   5.0],
+            [ -300,   -400,   500],
+            [88/(64*sqrt(real.min)), 105/(64*sqrt(real.min)), 137/(64*sqrt(real.min))],
+            [88/(128*sqrt(real.min)), 105/(128*sqrt(real.min)), 137/(128*sqrt(real.min))],
+            [3*real.min*real.epsilon, 4*real.min*real.epsilon, 5*real.min*real.epsilon],
+            [ real.min, real.min, sqrt(2.0L)*real.min],
+            [ real.max/sqrt(2.0L), real.max/sqrt(2.0L), real.max],
+            [ real.infinity, real.nan, real.infinity],
+            [ real.nan, real.infinity, real.infinity],
+            [ real.nan, real.nan, real.nan],
+            [ real.nan, real.max, real.nan],
+            [ real.max, real.nan, real.nan],
+        ];
+        for (int i = 0; i < vals.length; i++)
+        {
+            real x = vals[i][0];
+            real y = vals[i][1];
+            real z = vals[i][2];
+            real h = hypot(x, y);
+            assert(isIdentical(z, h));
+        }
 }
 
 /**********************************
@@ -1484,7 +1555,6 @@
  *
  * <img src="erf.gif" alt="error function">
  */
-version (GNU_msvcrt_math) { /* nothing */ } else
 real erf(real x)                { return std.c.math.erfl(x); }
 
 /**********************************
@@ -1492,7 +1562,6 @@
  *
  * <img src="erfc.gif" alt="complementary error function">
  */
-version (GNU_msvcrt_math) { /* nothing */ } else
 real erfc(real x)               { return std.c.math.erfcl(x); }
 
 /***********************************
@@ -1506,11 +1575,10 @@
  *      $(TABLE_SV
  *      $(TR $(TH x)                 $(TH lgamma(x)) $(TH invalid?))
  *      $(TR $(TD $(NAN))            $(TD $(NAN))    $(TD yes))
- *      $(TR $(TD integer <= 0)      $(TD +$(INFIN)) $(TD yes))
+ *      $(TR $(TD integer $(LT)= 0)      $(TD +$(INFIN)) $(TD yes))
  *      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD +$(INFIN)) $(TD no))
  *      )
  */
-/* Documentation prepared by Don Clugston */
 real lgamma(real x)
 {
     return std.c.math.lgammal(x);
@@ -1542,12 +1610,6 @@
  *      $(LINK http://en.wikipedia.org/wiki/Gamma_function),
  *      $(LINK http://www.netlib.org/cephes/ldoubdoc.html#gamma)
  */
-version (GNU_Need_tgamma)
-{
-    private import etc.gamma;
-    alias etc.gamma.tgamma tgamma;
-}
-else
 real tgamma(real x)
 {
     return std.c.math.tgammal(x);
@@ -1574,11 +1636,6 @@
  * Unlike the rint functions, nearbyint does not raise the
  * FE_INEXACT exception.
  */
-version (GNU_Need_nearbyint)
-{
-    // not implemented yet
-}
-else
 real nearbyint(real x) { return std.c.math.nearbyintl(x); }
 
 /**********************************
@@ -1606,7 +1663,7 @@
 {
     version (Posix)
         return std.c.math.llrintl(x);
-    else version(D_InlineAsm_X86)
+    else version(Naked_D_InlineAsm_X86)
     {
         long n;
         asm
@@ -1625,38 +1682,6 @@
  * If the fractional part of x is exactly 0.5, the return value is rounded to
  * the even integer.
  */
-version (GNU_Need_round)
-{
-    real round(real x)
-    {
-	real y = floor(x);
-	real r = x - y;
-	if (r > 0.5)
-	    return y + 1;
-	else if (r == 0.5)
-	{
-	    r = y - 2.0 * floor(0.5 * y);
-	    if (r == 1.0)
-		return y + 1;
-	}
-	return y;
-    }
-    unittest {
-	real r;
-	assert(isNan(round(real.nan)));
-	r = round(real.infinity);
-	assert(isInfinity(r) && r > 0);
-	r = round(-real.infinity);
-	assert(isInfinity(r) && r < 0);
-	assert(round(3.4) == 3);
-	assert(round(3.5) == 4);
-	assert(round(3.6) == 4);
-	assert(round(-3.4) == -3);
-	assert(round(-3.5) == -4);
-	assert(round(-3.6) == -4);
-    }
-}
-else
 real round(real x) { return std.c.math.roundl(x); }
 
 /**********************************************
@@ -1664,40 +1689,17 @@
  *
  * If the fractional part of x is exactly 0.5, the return value is rounded
  * away from zero.
- *
- * Note: Not supported on windows
  */
 long lround(real x)
 {
     version (Posix)
-        return std.c.math.llroundl(x);
-    else
-        throw new NotImplemented("lround");
-}
+        return std.c.math.llroundl(x);    else        throw new NotImplemented("lround");}
 
 /****************************************************
  * Returns the integer portion of x, dropping the fractional portion.
  *
  * This is also known as "chop" rounding.
  */
-version (GNU_Need_trunc)
-{
-    real trunc(real n) { return n >= 0 ? std.math.floor(n) : std.c.matheil(n); }
-    unittest
-    {
-	real r;
-	r = trunc(real.infinity);
-	assert(isInfinity(r) && r > 0);
-	r = trunc(-real.infinity);
-	assert(isInfinity(r) && r < 0);
-	assert(isNan(trunc(real.nan)));
-	assert(trunc(3.3) == 3);
-	assert(trunc(3.6) == 3);
-	assert(trunc(-3.3) == -3);
-	assert(trunc(-3.6) == -3);
-    }
-}
-else
 real trunc(real x) { return std.c.math.truncl(x); }
 
 /****************************************************
@@ -1732,16 +1734,11 @@
         throw new NotImplemented("remquo");
 }
 
-
-import gcc.fpcls;
-
 /*********************************
  * Returns !=0 if e is a NaN.
  */
 
-int isNaN(real x) { return fpclassify(x)==FP_NAN; }
-/*
-int isNaN(real x)
+pure nothrow int isNaN(real x)
 {
   alias floatTraits!(real) F;
   static if (real.mant_dig==53) { // double
@@ -1762,7 +1759,7 @@
       return x!=x;
   }
 }
-*/
+
 
 unittest
 {
@@ -1778,19 +1775,12 @@
  * Returns !=0 if e is finite (not infinite or $(NAN)).
  */
 
-int isFinite(real x)
-{
-    int r = fpclassify(x);
-    return r != FP_NAN && r != FP_INFINITE;
-}
-/*
-int isFinite(real e)
+pure nothrow int isFinite(real e)
 {
     alias floatTraits!(real) F;
     ushort* pe = cast(ushort *)&e;
     return (pe[F.EXPPOS_SHORT] & F.EXPMASK) != F.EXPMASK;
 }
-*/
 
 unittest
 {
@@ -1808,18 +1798,7 @@
  * be converted to normal reals.
  */
 
-int isNormal(float x) { return fpclassify(x)==FP_NORMAL; }
-
-/// ditto
-
-int isNormal(double x) { return fpclassify(x)==FP_NORMAL; }
-
-/// ditto
-
-int isNormal(real x) { return fpclassify(x)==FP_NORMAL; }
-
-/*
-int isNormal(X)(X x)
+pure nothrow int isNormal(X)(X x)
 {
     alias floatTraits!(X) F;
 
@@ -1831,7 +1810,7 @@
         return (e != F.EXPMASK && e!=0);
     }
 }
-*/
+
 
 unittest
 {
@@ -1861,7 +1840,11 @@
  * be converted to normal reals.
  */
 
-int isSubnormal(float x) { return fpclassify(x) == FP_SUBNORMAL; }
+pure nothrow int isSubnormal(float f)
+{
+    uint *p = cast(uint *)&f;
+    return (*p & 0x7F80_0000) == 0 && *p & 0x007F_FFFF;
+}
 
 unittest
 {
@@ -1873,16 +1856,12 @@
 
 /// ditto
 
-int isSubnormal(double x) { return fpclassify(x) == FP_SUBNORMAL; }
-
-/*
-int isSubnormal(double d)
+pure nothrow int isSubnormal(double d)
 {
     uint *p = cast(uint *)&d;
     return (p[MANTISSA_MSB] & 0x7FF0_0000) == 0
         && (p[MANTISSA_LSB] || p[MANTISSA_MSB] & 0x000F_FFFF);
 }
-*/
 
 unittest
 {
@@ -1894,10 +1873,7 @@
 
 /// ditto
 
-int isSubnormal(real x) { return fpclassify(x) == FP_SUBNORMAL; }
-
-/*
-int isSubnormal(real x)
+pure nothrow int isSubnormal(real x)
 {
     alias floatTraits!(real) F;
     static if (real.mant_dig == 53) { // double
@@ -1913,10 +1889,10 @@
 
         return (pe[F.EXPPOS_SHORT] & F.EXPMASK) == 0 && *ps > 0;
     } else { // double double
-        return isSubnormal(cast(double*)(&x)[MANTISSA_MSB]);
+        return isSubnormal((cast(double*)&x)[MANTISSA_MSB]);
     }
 }
-*/
+
 unittest
 {
     real f;
@@ -1929,10 +1905,7 @@
  * Return !=0 if e is $(PLUSMN)$(INFIN).
  */
 
-int isInfinity(real x) { return fpclassify(x)==FP_INFINITE; }
-
-/*
-int isInfinity(real x)
+pure nothrow bool isInfinity(real x)
 {
     alias floatTraits!(real) F;
     static if (real.mant_dig == 53) { // double
@@ -1948,12 +1921,11 @@
     } else { // real80
         ushort e = cast(ushort)(F.EXPMASK & (cast(ushort *)&x)[F.EXPPOS_SHORT]);
         ulong*  ps = cast(ulong *)&x;
-
-        return e == F.EXPMASK && *ps == 0x8000_0000_0000_0000;
+        // On Motorola 68K, infinity can have hidden bit=1 or 0. On x86, it is always 1.
+        return e == F.EXPMASK && (*ps & 0x7FFF_FFFF_FFFF_FFFF) == 0;
    }
 }
-*/
-    
+
 unittest
 {
     assert(isInfinity(float.infinity));
@@ -1971,7 +1943,7 @@
  * and two $(NAN)s are identical if they have the same 'payload'.
  */
 
-bool isIdentical(real x, real y)
+pure nothrow bool isIdentical(real x, real y)
 {
     // We're doing a bitwise comparison so the endianness is irrelevant.
     long*   pxs = cast(long *)&x;
@@ -1992,14 +1964,10 @@
  * Return 1 if sign bit of e is set, 0 if not.
  */
 
-alias gcc.fpcls.signbit signbit;
-
-/*
-int signbit(real x)
+pure nothrow int signbit(real x)
 {
     return ((cast(ubyte *)&x)[floatTraits!(real).SIGNPOS_BYTE] & 0x80) != 0;
 }
-*/
 
 unittest
 {
@@ -2016,8 +1984,7 @@
  * Return a value composed of to with from's sign bit.
  */
 
-version (X86)
-real copysign(real to, real from)
+pure nothrow real copysign(real to, real from)
 {
     ubyte* pto   = cast(ubyte *)&to;
     const ubyte* pfrom = cast(ubyte *)&from;
@@ -2027,8 +1994,6 @@
     pto[F.SIGNPOS_BYTE] |= pfrom[F.SIGNPOS_BYTE] & 0x80;
     return to;
 }
-else version (GNU)
-    alias std.c.math.copysignl copysign;
 
 unittest
 {
@@ -2054,8 +2019,7 @@
 Returns $(D -1) if $(D x < 0), $(D x) if $(D x == 0), $(D 1) if
 $(D x > 0), and $(NAN) if x==$(NAN).
  */
-
-F sgn(F)(F x)
+pure nothrow F sgn(F)(F x)
 {
     // @@@TODO@@@: make this faster
     return x > 0 ? 1 : x < 0 ? -1 : x;
@@ -2087,9 +2051,9 @@
 pure nothrow real NaN(ulong payload)
 {
     static if (real.mant_dig == 64) { //real80
-	ulong v = 3; // implied bit = 1, quiet bit = 1
+      ulong v = 3; // implied bit = 1, quiet bit = 1
     } else {
-	ulong v = 2; // no implied bit. quiet bit = 1
+      ulong v = 2; // no implied bit. quiet bit = 1
     }
 
     ulong a = payload;
@@ -2110,27 +2074,27 @@
     a >>=29;
 
     static if (real.mant_dig == 53) { // double
-	v |=0x7FF0_0000_0000_0000;
-	real x;
-	* cast(ulong *)(&x) = v;
-	return x;
+        v |=0x7FF0_0000_0000_0000;
+        real x;
+        * cast(ulong *)(&x) = v;
+        return x;
     } else {
-	v <<=11;
-	a &= 0x7FF;
-	v |= a;
-	real x = real.nan;
-	// Extended real bits
-	static if (real.mant_dig==113) { //quadruple
-	    v<<=1; // there's no implicit bit
-	    version(LittleEndian) {
-		*cast(ulong*)(6+cast(ubyte*)(&x)) = v;
-	    } else {
-		*cast(ulong*)(2+cast(ubyte*)(&x)) = v;
-	    }
-	} else { // real80
-	    * cast(ulong *)(&x) = v;
-	}
-	return x;
+        v <<=11;
+        a &= 0x7FF;
+        v |= a;
+        real x = real.nan;
+        // Extended real bits
+        static if (real.mant_dig==113) { //quadruple
+          v<<=1; // there's no implicit bit
+          version(LittleEndian) {
+            *cast(ulong*)(6+cast(ubyte*)(&x)) = v;
+          } else {
+            *cast(ulong*)(2+cast(ubyte*)(&x)) = v;
+          }        
+        } else { // real80
+            * cast(ulong *)(&x) = v;
+        }
+        return x;
     }
 }
 
@@ -2148,20 +2112,20 @@
 {
     //  assert(isNaN(x));
     static if (real.mant_dig == 53) {
-	ulong m = *cast(ulong *)(&x);
-	// Make it look like an 80-bit significand
-	// Skip exponent, and quiet bit
-	m &= 0x0007_FFFF_FFFF_FFFF;
-	m <<= 10;
+        ulong m = *cast(ulong *)(&x);
+        // Make it look like an 80-bit significand.
+        // Skip exponent, and quiet bit
+        m &= 0x0007_FFFF_FFFF_FFFF;
+        m <<= 10;
     } else static if (real.mant_dig==113) { // quadruple
-	version(LittleEndian) {
-	    ulong m = *cast(ulong*)(6+cast(ubyte*)(&x));
-	} else {
-	    ulong m = *cast(ulong*)(2+cast(ubyte*)(&x));
-	}
-	m>>=1; // there's no implicit bit
+        version(LittleEndian) {
+            ulong m = *cast(ulong*)(6+cast(ubyte*)(&x));
+        } else {
+            ulong m = *cast(ulong*)(2+cast(ubyte*)(&x));
+        }
+        m>>=1; // there's no implicit bit
     } else {
-	ulong m = *cast(ulong *)(&x);
+        ulong m = *cast(ulong *)(&x);
     }
     // ignore implicit bit and quiet bit
     ulong f = m & 0x3FFF_FF00_0000_0000L;
@@ -2173,22 +2137,22 @@
 
 debug(UnitTest) {
 unittest {
-    real nan4 = NaN(0x789_ABCD_EF12_3456);
-    static if (real.mant_dig == 64 || real.mant_dig==113) {
-	assert (getNaNPayload(nan4) == 0x789_ABCD_EF12_3456);
-    } else {
-	assert (getNaNPayload(nan4) == 0x1_ABCD_EF12_3456);
-    }
-    double nan5 = nan4;
-    assert (getNaNPayload(nan5) == 0x1_ABCD_EF12_3456);
-    float nan6 = nan4;
-    assert (getNaNPayload(nan6) == 0x12_3456);
-    nan4 = NaN(0xFABCD);
-    assert (getNaNPayload(nan4) == 0xFABCD);
-    nan6 = nan4;
-    assert (getNaNPayload(nan6) == 0xFABCD);
-    nan5 = NaN(0x100_0000_0000_3456);
-    assert(getNaNPayload(nan5) == 0x0000_0000_3456);
+  real nan4 = NaN(0x789_ABCD_EF12_3456);
+  static if (real.mant_dig == 64 || real.mant_dig==113) {
+      assert (getNaNPayload(nan4) == 0x789_ABCD_EF12_3456);
+  } else {
+      assert (getNaNPayload(nan4) == 0x1_ABCD_EF12_3456);
+  }
+  double nan5 = nan4;
+  assert (getNaNPayload(nan5) == 0x1_ABCD_EF12_3456);
+  float nan6 = nan4;
+  assert (getNaNPayload(nan6) == 0x12_3456);
+  nan4 = NaN(0xFABCD);
+  assert (getNaNPayload(nan4) == 0xFABCD);
+  nan6 = nan4;
+  assert (getNaNPayload(nan6) == 0xFABCD);
+  nan5 = NaN(0x100_0000_0000_3456);
+  assert(getNaNPayload(nan5) == 0x0000_0000_3456);
 }
 }
 
@@ -2206,11 +2170,8 @@
  *    $(SV  $(INFIN),     $(INFIN) )
  *    $(SV  $(NAN),       $(NAN)   )
  * )
- *
- * Remarks:
- * This function is included in the forthcoming IEEE 754R standard.
  */
-real nextUp(real x)
+pure nothrow real nextUp(real x)
 {
     alias floatTraits!(real) F;
     static if (real.mant_dig == 53) { // double
@@ -2277,13 +2238,11 @@
             }
         }
         return x;
-    } else { // doubledouble
-        assert(0, "Not implemented");
-    }
+    } // doubledouble is not supported
 }
 
 /** ditto */
-double nextUp(double x)
+pure nothrow double nextUp(double x)
 {
     ulong *ps = cast(ulong *)&x;
 
@@ -2305,7 +2264,7 @@
 }
 
 /** ditto */
-float nextUp(float x)
+pure nothrow float nextUp(float x)
 {
     uint *ps = cast(uint *)&x;
 
@@ -2340,23 +2299,20 @@
  *    $(SV  -$(INFIN),    -$(INFIN) )
  *    $(SV  $(NAN),       $(NAN)    )
  * )
- *
- * Remarks:
- * This function is included in the forthcoming IEEE 754R standard.
  */
-real nextDown(real x)
+pure nothrow real nextDown(real x)
 {
     return -nextUp(-x);
 }
 
 /** ditto */
-double nextDown(double x)
+pure nothrow double nextDown(double x)
 {
     return -nextUp(-x);
 }
 
 /** ditto */
-float nextDown(float x)
+pure nothrow float nextDown(float x)
 {
     return -nextUp(-x);
 }
@@ -2365,6 +2321,70 @@
     assert( nextDown(1.0 + real.epsilon) == 1.0);
 }
 
+unittest {
+    static if (real.mant_dig == 64) {
+        
+     // Tests for 80-bit reals
+       assert(isIdentical(nextUp(NaN(0xABC)), NaN(0xABC)));
+       // negative numbers
+       assert( nextUp(-real.infinity) == -real.max );
+       assert( nextUp(-1.0L-real.epsilon) == -1.0 );
+       assert( nextUp(-2.0L) == -2.0 + real.epsilon);
+       // denormals and zero
+       assert( nextUp(-real.min) == -real.min*(1-real.epsilon) );
+       assert( nextUp(-real.min*(1-real.epsilon)) == -real.min*(1-2*real.epsilon) );
+       assert( isIdentical(-0.0L, nextUp(-real.min*real.epsilon)) );
+       assert( nextUp(-0.0L) == real.min*real.epsilon );
+       assert( nextUp(0.0L) == real.min*real.epsilon );
+       assert( nextUp(real.min*(1-real.epsilon)) == real.min );
+       assert( nextUp(real.min) == real.min*(1+real.epsilon) );
+       // positive numbers
+       assert( nextUp(1.0L) == 1.0 + real.epsilon );
+       assert( nextUp(2.0L-real.epsilon) == 2.0 );
+       assert( nextUp(real.max) == real.infinity );
+       assert( nextUp(real.infinity)==real.infinity );
+    }
+
+       double n = NaN(0xABC);
+       assert(isIdentical(nextUp(n), n));
+       // negative numbers
+       assert( nextUp(-double.infinity) == -double.max );
+       assert( nextUp(-1-double.epsilon) == -1.0 );
+       assert( nextUp(-2.0) == -2.0 + double.epsilon);
+       // denormals and zero
+
+       assert( nextUp(-double.min) == -double.min*(1-double.epsilon) );
+       assert( nextUp(-double.min*(1-double.epsilon)) == -double.min*(1-2*double.epsilon) );
+       assert( isIdentical(-0.0, nextUp(-double.min*double.epsilon)) );
+       assert( nextUp(0.0) == double.min*double.epsilon );
+       assert( nextUp(-0.0) == double.min*double.epsilon );
+       assert( nextUp(double.min*(1-double.epsilon)) == double.min );
+       assert( nextUp(double.min) == double.min*(1+double.epsilon) );
+       // positive numbers
+       assert( nextUp(1.0) == 1.0 + double.epsilon );
+       assert( nextUp(2.0-double.epsilon) == 2.0 );
+       assert( nextUp(double.max) == double.infinity );
+
+       float fn = NaN(0xABC);
+       assert(isIdentical(nextUp(fn), fn));
+       float f = -float.min*(1-float.epsilon);
+       float f1 = -float.min;
+       assert( nextUp(f1) ==  f);
+       f = 1.0f+float.epsilon;
+       f1 = 1.0f;
+       assert( nextUp(f1) == f );
+       f1 = -0.0f;
+       assert( nextUp(f1) == float.min*float.epsilon);
+       assert( nextUp(float.infinity)==float.infinity );
+
+       assert(nextDown(1.0L+real.epsilon)==1.0);
+       assert(nextDown(1.0+double.epsilon)==1.0);
+       f = 1.0f+float.epsilon;
+       assert(nextDown(f)==1.0);
+       assert(nextafter(1.0+real.epsilon, -real.infinity)==1.0);
+}
+
+
 
 /******************************************
  * Calculates the next representable value after x in the direction of y.
@@ -2377,42 +2397,15 @@
  * This function is not generally very useful; it's almost always better to use
  * the faster functions nextUp() or nextDown() instead.
  *
- * IEEE 754 requirements not implemented on Windows:
  * The FE_INEXACT and FE_OVERFLOW exceptions will be raised if x is finite and
  * the function result is infinite. The FE_INEXACT and FE_UNDERFLOW
  * exceptions will be raised if the function value is subnormal, and x is
  * not equal to y.
  */
-real nextafter(real x, real y)
+T nextafter(T)(T x, T y)
 {
-    version (Windows) {
-        if (x==y) return y;
-        return (y>x) ? nextUp(x) : nextDown(x);
-    } else {
-        return std.c.math.nextafterl(x, y);
-    }
-}
-
-/// ditto
-float nextafter(float x, float y)
-{
-    version (Windows) {
-        if (x==y) return y;
-        return (y>x) ? nextUp(x) : nextDown(x);
-    } else {
-        return std.c.math.nextafterf(x, y);
-    }
-}
-
-/// ditto
-double nextafter(double x, double y)
-{
-    version (Windows) {
-        if (x==y) return y;
-        return (y>x) ? nextUp(x) : nextDown(x);
-    } else {
-        return std.c.math.nextafter(x, y);
-    }
+    if (x==y) return y;
+    return ((y>x) ? nextUp(x) :  nextDown(x));     
 }
 
 unittest
@@ -2441,17 +2434,17 @@
  *      $(TR $(TD x $(LT)= y) $(TD +0.0))
  *      )
  */
-real fdim(real x, real y) { return (x > y) ? x - y : +0.0; }
+pure nothrow real fdim(real x, real y) { return (x > y) ? x - y : +0.0; }
 
 /****************************************
  * Returns the larger of x and y.
  */
-real fmax(real x, real y) { return x > y ? x : y; }
+pure nothrow real fmax(real x, real y) { return x > y ? x : y; }
 
 /****************************************
  * Returns the smaller of x and y.
  */
-real fmin(real x, real y) { return x < y ? x : y; }
+pure nothrow real fmin(real x, real y) { return x < y ? x : y; }
 
 /**************************************
  * Returns (x * y) + z, rounding only once according to the
@@ -2459,19 +2452,19 @@
  *
  * BUGS: Not currently implemented - rounds twice.
  */
-real fma(real x, real y, real z) { return (x * y) + z; }
+pure nothrow real fma(real x, real y, real z) { return (x * y) + z; }
 
 /*******************************************************************
  * Fast integral powers.
  */
 
-F pow(F)(F x, uint n) if (isFloatingPoint!(F))
+pure nothrow F pow(F)(F x, uint n) if (isFloatingPoint!(F))
 {
     if (n > int.max)
     {
-        assert(n >> 1 <= int.max);
+        //assert(n >> 1 <= int.max);
         // must reduce n so we can call the pow(real, int) overload
-        invariant result = pow(x*x, cast(int) (n >> 1));
+        auto result = pow(x*x, cast(int) (n >> 1));
         return (n & 1)
             ? result * x // odd power
             : result;
@@ -2481,10 +2474,10 @@
 
 /// Ditto
 
-F pow(F)(F x, int n) if (isFloatingPoint!(F))
+pure nothrow F pow(F)(F x, int n) if (isFloatingPoint!(F))
 {
     real p = 1.0, v = void;
-
+    int m = n;
     if (n < 0)
     {
         switch (n)
@@ -2496,7 +2489,7 @@
         default:
         }
 
-        n = -n;
+        m = -n;
         v = p / x;
     }
     else
@@ -2517,10 +2510,10 @@
 
     while (1)
     {
-        if (n & 1)
+        if (m & 1)
             p *= v;
-        n >>= 1;
-        if (!n)
+        m >>= 1;
+        if (!m)
             break;
         v *= v;
     }
@@ -2572,8 +2565,7 @@
 
 F pow(F)(F x, F y) if (isFloatingPoint!(F))
 {
-    //version (linux) // C pow() often does not handle special values correctly
-    version (GNU) // ...assume the same for all GCC targets
+    version (linux) // C pow() often does not handle special values correctly
     {
         if (isNaN(y))
             return y;
@@ -2663,6 +2655,11 @@
             }
         }
     }
+/*
+version(INLINE_YL2X) {
+return exp2(yl2x(y, x));
+}
+*/
     return std.c.math.powl(x, y);
 }
 
@@ -2682,10 +2679,6 @@
     assert(pow(x, -8) == 1 / ((x * x) * (x * x) * (x * x) * (x * x)));
 }
 
-version (X86)
-{
-// These routines assume Intel 80-bit floating point format
-
 /**************************************
  * To what precision is x equal to y?
  *
@@ -2701,13 +2694,10 @@
  *      $(TR $(TD any)    $(TD $(NAN))     $(TD 0))
  *      )
  */
-int feqrel(X)(X x, X y)
+pure nothrow int feqrel(X)(X x, X y)  if (isFloatingPoint!(X))
 {
     /* Public Domain. Author: Don Clugston, 18 Aug 2005.
      */
-  static assert(is(X==real) || is(X==double) || is(X==float),
-        "Only float, double, and real are supported by feqrel");
-
   static if (X.mant_dig == 106) { // doubledouble.
      if (cast(double*)(&x)[MANTISSA_MSB] == cast(double*)(&y)[MANTISSA_MSB]) {
          return double.mant_dig
@@ -2753,7 +2743,7 @@
         // For denormals, we need to add the number of zeros that
         // lie at the start of diff's significand.
         // We do this by multiplying by 2^real.mant_dig
-        diff *= F.POW2MANTDIG;
+        diff *= F.RECIP_EPSILON;
         return bitsdiff + X.mant_dig - pd[F.EXPPOS_SHORT];
     }
 
@@ -2769,8 +2759,6 @@
               return 1;
         } else return 0;
      }
- } else {
-    throw new NotImplemented("feqrel");
  }
 }
 
@@ -2818,12 +2806,6 @@
    assert(feqrel(real.max,-real.max)==0);
 }
 
-} // version(X86)
-else
-{
-    // not implemented
-}
-
 package: // Not public yet
 /* Return the value that lies halfway between x and y on the IEEE number line.
  *
@@ -2840,7 +2822,7 @@
  *   ieeeMean(x, y) = sqrt(x * y).
  *
  */
-T ieeeMean(T)(T x, T y)
+pure nothrow T ieeeMean(T)(T x, T y)
 in {
     // both x and y must have the same sign, and must not be NaN.
     assert(signbit(x) == signbit(y));
@@ -2944,119 +2926,118 @@
 
 public:
 
-    
-// The space allocated for real varies across targets.
-version (D_InlineAsm_X86)
-{
-    static if (real.sizeof == 10)
-	{ version = poly_10; }
-    else static if (real.sizeof == 12)
-	{ version = poly_12; }
-}
 
 /***********************************
  * Evaluate polynomial A(x) = $(SUB a, 0) + $(SUB a, 1)x + $(SUB a, 2)$(POWER x,2)
  *                          + $(SUB a,3)$(POWER x,3); ...
+ *
  * Uses Horner's rule A(x) = $(SUB a, 0) + x($(SUB a, 1) + x($(SUB a, 2) 
  *                         + x($(SUB a, 3) + ...)))
  * Params:
  *      A =     array of coefficients $(SUB a, 0), $(SUB a, 1), etc.
  */
-real poly(real x, const real[] A)
+pure nothrow real poly(real x, const real[] A)
 in
 {
     assert(A.length > 0);
 }
 body
 {
-    version (poly_10)
+    version (Naked_D_InlineAsm_X86)
     {
+        version (Windows)
+        {
         // BUG: This code assumes a frame pointer in EBP.
-        asm    // assembler by W. Bright
+            asm // assembler by W. Bright
+            {
+                // EDX = (A.length - 1) * real.sizeof
+                mov     ECX,A[EBP]              ; // ECX = A.length
+                dec     ECX                     ;
+                lea     EDX,[ECX][ECX*8]        ;
+                add     EDX,ECX                 ;
+                add     EDX,A+4[EBP]            ;
+                fld     real ptr [EDX]          ; // ST0 = coeff[ECX]
+                jecxz   return_ST               ;
+                fld     x[EBP]                  ; // ST0 = x
+                fxch    ST(1)                   ; // ST1 = x, ST0 = r
+                align   4                       ;
+        L2:     fmul    ST,ST(1)                ; // r *= x
+                fld     real ptr -10[EDX]       ;
+                sub     EDX,10                  ; // deg--
+                faddp   ST(1),ST                ;
+                dec     ECX                     ;
+                jne     L2                      ;
+                fxch    ST(1)                   ; // ST1 = r, ST0 = x
+                fstp    ST(0)                   ; // dump x
+                align   4                       ;
+        return_ST:                              ;
+                ;
+            }
+        }
+        else version (linux)
         {
-            // EDX = (A.length - 1) * real.sizeof
-            mov     ECX,A[EBP]              ; // ECX = A.length
-            dec     ECX                     ;
-            lea     EDX,[ECX][ECX*8]        ;
-            add     EDX,ECX                 ;
-            add     EDX,A+4[EBP]            ;
-            fld     real ptr [EDX]          ; // ST0 = coeff[ECX]
-            jecxz   return_ST               ;
-            fld     x[EBP]                  ; // ST0 = x
-            fxch    ST(1)                   ; // ST1 = x, ST0 = r
-            align   4                       ;
-            L2:     fmul    ST,ST(1)        ; // r *= x
-            fld     real ptr -10[EDX]       ;
-            sub     EDX,10                  ; // deg--
-            faddp   ST(1),ST                ;
-            dec     ECX                     ;
-            jne     L2                      ;
-            fxch    ST(1)                   ; // ST1 = r, ST0 = x
-            fstp    ST(0)                   ; // dump x
-            align   4                       ;
-            return_ST:                      ;
-            ;
+            asm // assembler by W. Bright
+            {
+                // EDX = (A.length - 1) * real.sizeof
+                mov     ECX,A[EBP]              ; // ECX = A.length
+                dec     ECX                     ;
+                lea     EDX,[ECX*8]             ;
+                lea     EDX,[EDX][ECX*4]        ;
+                add     EDX,A+4[EBP]            ;
+                fld     real ptr [EDX]          ; // ST0 = coeff[ECX]
+                jecxz   return_ST               ;
+                fld     x[EBP]                  ; // ST0 = x
+                fxch    ST(1)                   ; // ST1 = x, ST0 = r
+                align   4                       ;
+        L2:     fmul    ST,ST(1)                ; // r *= x
+                fld     real ptr -12[EDX]       ;
+                sub     EDX,12                  ; // deg--
+                faddp   ST(1),ST                ;
+                dec     ECX                     ;
+                jne     L2                      ;
+                fxch    ST(1)                   ; // ST1 = r, ST0 = x
+                fstp    ST(0)                   ; // dump x
+                align   4                       ;
+        return_ST:                              ;
+                ;
+            }
         }
-    }
-    else version (poly_12)
-    {
-        asm    // above code with modifications for GCC
+        else version (OSX)
         {
-            // EDX = (A.length - 1) * real.sizeof
-            mov     ECX,A[EBP]              ; // ECX = A.length
-            dec     ECX                     ;
-            lea     EDX,[ECX][ECX*2]        ;
-            lea     EDX,[EDX*4]             ;
-            add     EDX,A+4[EBP]            ;
-            fld     real ptr [EDX]          ; // ST0 = coeff[ECX]
-            jecxz   return_ST               ;
-            fld     x                       ; // ST0 = x
-            fxch    ST(1)                   ; // ST1 = x, ST0 = r
-            align   4                       ;
-    L2:     fmul    ST,ST(1)                ; // r *= x
-            fld     real ptr -12[EDX]       ;
-            sub     EDX,12                  ; // deg--
-            faddp   ST(1),ST                ;
-            dec     ECX                     ;
-            jne     L2                      ;
-            fxch    ST(1)                   ; // ST1 = r, ST0 = x
-            fstp    ST(0)                   ; // dump x
-            align   4                       ;
-        return_ST:                          ;
-                                            ;
+            asm // assembler by W. Bright
+            {
+                // EDX = (A.length - 1) * real.sizeof
+                mov     ECX,A[EBP]              ; // ECX = A.length
+                dec     ECX                     ;
+                lea     EDX,[ECX*8]             ;
+                add     EDX,EDX                 ;
+                add     EDX,A+4[EBP]            ;
+                fld     real ptr [EDX]          ; // ST0 = coeff[ECX]
+                jecxz   return_ST               ;
+                fld     x[EBP]                  ; // ST0 = x
+                fxch    ST(1)                   ; // ST1 = x, ST0 = r
+                align   4                       ;
+        L2:     fmul    ST,ST(1)                ; // r *= x
+                fld     real ptr -16[EDX]       ;
+                sub     EDX,16                  ; // deg--
+                faddp   ST(1),ST                ;
+                dec     ECX                     ;
+                jne     L2                      ;
+                fxch    ST(1)                   ; // ST1 = r, ST0 = x
+                fstp    ST(0)                   ; // dump x
+                align   4                       ;
+        return_ST:                              ;
+                ;
+            }
         }
-    }
-    else version (OSX)
-    {
-        asm // assembler by W. Bright
-        {
-            // EDX = (A.length - 1) * real.sizeof
-            mov     ECX,A[EBP]              ; // ECX = A.length
-            dec     ECX                     ;
-            lea     EDX,[ECX*8]             ;
-            add     EDX,EDX                 ;
-            add     EDX,A+4[EBP]            ;
-            fld     real ptr [EDX]          ; // ST0 = coeff[ECX]
-            jecxz   return_ST               ;
-            fld     x[EBP]                  ; // ST0 = x
-            fxch    ST(1)                   ; // ST1 = x, ST0 = r
-            align   4                       ;
-    L2:     fmul    ST,ST(1)                ; // r *= x
-            fld     real ptr -16[EDX]       ;
-            sub     EDX,16                  ; // deg--
-            faddp   ST(1),ST                ;
-            dec     ECX                     ;
-            jne     L2                      ;
-            fxch    ST(1)                   ; // ST1 = r, ST0 = x
-            fstp    ST(0)                   ; // dump x
-            align   4                       ;
-    return_ST:                              ;
-                                            ;
-        }
+	else
+	{
+	    static assert(0);
+	}
     }
     else
     {
-        ptrdiff_t i = A.length - 1;
+        int i = A.length - 1;
         real r = A[i];
         while (--i >= 0)
         {
@@ -3081,10 +3062,11 @@
    admitting a maximum relative difference $(D maxRelDiff) and a
    maximum absolute difference $(D maxAbsDiff).
  */
-bool approxEqual(T, U, V)(T lhs, U rhs, V maxRelDiff, V maxAbsDiff = 0)
+// BUG: Not nothrow, because of the assert in the array case. 
+pure bool approxEqual(T, U, V)(T lhs, U rhs, V maxRelDiff, V maxAbsDiff = 0)
 {
     static if (isArray!(T)) {
-        invariant n = lhs.length;
+        immutable n = lhs.length;
         static if (isArray!(U)) {
             // Two arrays
             assert(n == rhs.length);
@@ -3119,7 +3101,7 @@
 /**
    Returns $(D approxEqual(lhs, rhs, 0.01)).
  */
-bool approxEqual(T, U)(T lhs, U rhs) {
+pure bool approxEqual(T, U)(T lhs, U rhs) {
     return approxEqual(lhs, rhs, 0.01);
 }
 
@@ -3138,3 +3120,49 @@
 alias isNormal isnormal;
 alias isSubnormal issubnormal;
 alias isInfinity isinf;
+
+/* **********************************
+ * Building block functions, they
+ * translate to a single x87 instruction.
+ */
+
+pure nothrow real yl2x(real x, real y);		// y * log2(x)
+pure nothrow real yl2xp1(real x, real y);	// y * log2(x + 1)
+
+unittest
+{
+    version (INLINE_YL2X)
+    {
+	assert(yl2x(1024, 1) == 10);
+	assert(yl2xp1(1023, 1) == 10);
+    }
+}
+
+/*
+ * Copyright:
+ *      Copyright (c) 2001-2009 by Digital Mars,
+ *      All Rights Reserved,
+ *      http://www.digitalmars.com
+ * License:
+ *  This software is provided 'as-is', without any express or implied
+ *  warranty. In no event will the authors be held liable for any damages
+ *  arising from the use of this software.
+ *
+ *  Permission is granted to anyone to use this software for any purpose,
+ *  including commercial applications, and to alter it and redistribute it
+ *  freely, subject to the following restrictions:
+ *
+ *  <ul>
+ *  <li> The origin of this software must not be misrepresented; you must not
+ *       claim that you wrote the original software. If you use this software
+ *       in a product, an acknowledgment in the product documentation would be
+ *       appreciated but is not required.
+ *  </li>
+ *  <li> Altered source versions must be plainly marked as such, and must not
+ *       be misrepresented as being the original software.
+ *  </li>
+ *  <li> This notice may not be removed or altered from any source
+ *       distribution.
+ *  </li>
+ *  </ul>
+ */
diff -r f12bfe124807 d/phobos2/std/md5.d
--- a/d/phobos2/std/md5.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/md5.d	Thu Oct 14 14:12:53 2010 +0100
@@ -82,12 +82,6 @@
 documentation and/or software.
  */
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, September 2004
-*/
-
 module std.md5;
 
 //debug=md5;		// uncomment to turn on debugging printf's
@@ -96,10 +90,6 @@
 import std.contracts;
 import std.c.stdio : printf;
 
-version(D_InlineAsm)
-    version(X86)
-	version = Asm86;
-
 /***************************************
  * Computes MD5 digest of several arrays of data.
  */
@@ -115,14 +105,14 @@
     context.finish(digest);
 }
 
-/******************
- * Prints a message digest in hexadecimal to stdout.
- */
-void printDigest(const ubyte digest[16])
-{
-    foreach (ubyte u; digest)
-	printf("%02x", u);
-}
+// /******************
+//  * Prints a message digest in hexadecimal to stdout.
+//  */
+// void printDigest(const ubyte digest[16])
+// {
+//     foreach (ubyte u; digest)
+//         printf("%02x", u);
+// }
 
 /****************************************
  * Converts MD5 digest to a string.
@@ -130,14 +120,14 @@
 
 string digestToString(const ubyte[16] digest)
 {
-    char[] result = new char[32];
+    auto result = new char[32];
     int i;
-
+    
     foreach (ubyte u; digest)
     {
-	result[i] = std.string.hexdigits[u >> 4];
-	result[i + 1] = std.string.hexdigits[u & 15];
-	i += 2;
+        result[i] = std.string.hexdigits[u >> 4];
+        result[i + 1] = std.string.hexdigits[u & 15];
+        i += 2;
     }
     return assumeUnique(result);
 }
@@ -209,28 +199,14 @@
      */
     static uint ROTATE_LEFT(uint x, uint n)
     {
-	version (Asm86)
+	version (X86)
 	{
-	    version (GNU)
-	    {
-		asm
-		{
-		    naked ;
-		    mov ECX, n ;
-		    mov EAX, x ;
-		    rol EAX, CL ;
-		    ret ;
-		}
-	    }
-	    else
-	    {
-		asm
-		{   naked			;
-		    mov	ECX,EAX		;
-		    mov	EAX,4[ESP]	;
-		    rol	EAX,CL		;
-		    ret	4		;
-		}
+	    asm
+	    {   naked			;
+		mov	ECX,EAX		;
+		mov	EAX,4[ESP]	;
+		rol	EAX,CL		;
+		ret	4		;
 	    }
 	}
 	else
@@ -284,9 +260,8 @@
      */
     void update(const void[] input)
     {
-      uint index, partLen;
-      size_t i;
-      size_t inputLen = input.length;
+      uint i, index, partLen;
+      uint inputLen = input.length;
 
       /* Compute number of bytes mod 64 */
       index = (cast(uint)count >> 3) & (64 - 1);
diff -r f12bfe124807 d/phobos2/std/mmfile.d
--- a/d/phobos2/std/mmfile.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/mmfile.d	Thu Oct 14 14:12:53 2010 +0100
@@ -26,66 +26,45 @@
 /**
  * Read and write memory mapped files.
  * Macros:
- *	WIKI=Phobos/StdMmfile
+ *  WIKI=Phobos/StdMmfile
  */
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, September 2004
-*/
-
 module std.mmfile;
 
 private import std.file;
-private import std.c.stdio;
-private import std.c.stdlib;
+private import core.stdc.stdio;
+private import core.stdc.stdlib;
+private import core.stdc.errno;
 private import std.path;
 private import std.string;
+import std.contracts, std.conv, std.stdio;
 
 //debug = MMFILE;
 
 version (Win32)
 {
-	private import std.c.windows.windows;
-	private import std.utf;
-	
-	private uint dwVersion;
-	
-	static this()
-	{	// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/sysinfo/base/getversion.asp
-		dwVersion = GetVersion();
-	}
-
-	private const bool Have_MMFile = true; // private for now...
+    private import std.c.windows.windows;
+    private import std.utf;
+    
+    private uint dwVersion;
+    
+    static this()
+    {
+        /* http://msdn.microsoft.com/library/default.asp?url=/library/en-us
+           /sysinfo/base/getversion.asp */
+        dwVersion = GetVersion();
+    }
 }
 else version (Posix)
 {
-	version (GNU_Unix_Have_MMap)
-	{
-	    private import std.c.unix.unix;
-	    alias std.c.unix.unix unix;
-
-	    version = unix_mm;
-	    private const bool Have_MMFile = true;
-	}
-	else
-	{
-	    private const bool Have_MMFile = false;
-	}
-
+    private import core.sys.posix.fcntl;
+    private import core.sys.posix.unistd;
+	private import core.sys.posix.sys.mman;
+    private import core.sys.posix.sys.stat;
 }
 else
 {
-	private const bool Have_MMFile = false;
-	// Can't simply fail because std.stream imports this module.
-	//static assert(0);
-}
-
-static if (Have_MMFile)
-{
-    private import std.file;
-    private import std.path;
+    static assert(0);
 }
 
 /**
@@ -97,556 +76,607 @@
      * The mode the memory mapped file is opened with.
      */
     enum Mode
-    {	Read,		/// read existing file
-	ReadWriteNew,	/// delete existing file, write new file
-	ReadWrite,	/// read/write existing file, create if not existing
-	ReadCopyOnWrite, /// read/write existing file, copy on write
-    }
-    
+    {
+        Read,       /// read existing file
+            ReadWriteNew,   /// delete existing file, write new file
+            ReadWrite,  /// read/write existing file, create if not existing
+            ReadCopyOnWrite, /// read/write existing file, copy on write
+            }
+
     /**
      * Open memory mapped file filename for reading.
      * File is closed when the object instance is deleted.
      * Throws:
-     *	std.file.FileException
+     *  std.file.FileException
      */
     this(string filename)
     {
-		this(filename, Mode.Read, 0, null);
+        this(filename, Mode.Read, 0, null);
+    }
+
+    version(linux) this(File file, Mode mode = Mode.Read, ulong size = 0,
+            void* address = null, size_t window = 0)
+    {
+        this(file.fileno, mode, size, address, window);
+    }
+    
+    version(linux) private this(int fildes, Mode mode, ulong size,
+            void* address, size_t window)
+    {
+        int oflag;
+        int fmode;
+    
+        switch (mode)
+        {
+        case Mode.Read:
+            flags = MAP_SHARED;
+            prot = PROT_READ;
+            oflag = O_RDONLY;
+            fmode = 0;
+            break;
+    
+        case Mode.ReadWriteNew:
+            assert(size != 0);
+            flags = MAP_SHARED;
+            prot = PROT_READ | PROT_WRITE;
+            oflag = O_CREAT | O_RDWR | O_TRUNC;
+            fmode = 0660;
+            break;
+    
+        case Mode.ReadWrite:
+            flags = MAP_SHARED;
+            prot = PROT_READ | PROT_WRITE;
+            oflag = O_CREAT | O_RDWR;
+            fmode = 0660;
+            break;
+    
+        case Mode.ReadCopyOnWrite:
+            flags = MAP_PRIVATE;
+            prot = PROT_READ | PROT_WRITE;
+            oflag = O_RDWR;
+            fmode = 0;
+            break;
+
+        default:
+            assert(0);
+        }
+
+        // Adjust size
+        struct_stat64 statbuf = void;
+        errnoEnforce(fstat64(fd, &statbuf) == 0);
+        if (prot & PROT_WRITE && size > statbuf.st_size)
+        {
+            // Need to make the file size bytes big
+            lseek(fd, cast(int)(size - 1), SEEK_SET);
+            char c = 0;
+            core.sys.posix.unistd.write(fd, &c, 1);
+        }
+        else if (prot & PROT_READ && size == 0)
+            size = statbuf.st_size;
+        this.size = size;
+
+        // Map the file into memory!
+        size_t initial_map = (window && 2*window<size)
+            ? 2*window : cast(size_t)size;
+        auto p = mmap(address, initial_map, prot, flags, fd, 0);
+        if (p == MAP_FAILED) {
+            errnoEnforce(false, "Could not map file into memory");
+        }
+        data = p[0 .. initial_map];
     }
     
     /**
      * Open memory mapped file filename in mode.
      * File is closed when the object instance is deleted.
      * Params:
-     *	filename = name of the file.
-     *		If null, an anonymous file mapping is created.
-     *	mode = access mode defined above.
-     *	size =  the size of the file. If 0, it is taken to be the
-     *		size of the existing file.
-     *	address = the preferred address to map the file to,
-     *		although the system is not required to honor it.
-     *		If null, the system selects the most convenient address.
-     *	window = preferred block size of the amount of data to map at one time
-     *		with 0 meaning map the entire file. The window size must be a
-     *		multiple of the memory allocation page size. 
+     *  filename = name of the file.
+     *      If null, an anonymous file mapping is created.
+     *  mode = access mode defined above.
+     *  size =  the size of the file. If 0, it is taken to be the
+     *      size of the existing file.
+     *  address = the preferred address to map the file to,
+     *      although the system is not required to honor it.
+     *      If null, the system selects the most convenient address.
+     *  window = preferred block size of the amount of data to map at one time
+     *      with 0 meaning map the entire file. The window size must be a
+     *      multiple of the memory allocation page size. 
      * Throws:
-     *	std.file.FileException
+     *  std.file.FileException
      */
     this(string filename, Mode mode, ulong size, void* address,
-			size_t window = 0)
+            size_t window = 0)
     {
-		this.filename = filename;
-		this.mMode = mode;
-		this.window = window;
-		this.address = address;
-	
-		version (Win32)
-		{
-			void* p;
-			uint dwDesiredAccess2;
-			uint dwShareMode;
-			uint dwCreationDisposition;
-			uint flProtect;
-	    
-			if (dwVersion & 0x80000000 && (dwVersion & 0xFF) == 3)
-			{
-			    throw new FileException(filename,
-				"Win32s does not implement mm files");
-			}
-	    
-			switch (mode)
-			{
-			    case Mode.Read:
-				dwDesiredAccess2 = GENERIC_READ;
-				dwShareMode = FILE_SHARE_READ;
-				dwCreationDisposition = OPEN_EXISTING;
-				flProtect = PAGE_READONLY;
-				dwDesiredAccess = FILE_MAP_READ;
-				break;
+        this.filename = filename;
+        this.mMode = mode;
+        this.window = window;
+        this.address = address;
+    
+        version (Win32)
+        {
+            void* p;
+            uint dwDesiredAccess2;
+            uint dwShareMode;
+            uint dwCreationDisposition;
+            uint flProtect;
+        
+            if (dwVersion & 0x80000000 && (dwVersion & 0xFF) == 3)
+            {
+                throw new FileException(filename,
+                        "Win32s does not implement mm files");
+            }
+        
+            switch (mode)
+            {
+            case Mode.Read:
+                dwDesiredAccess2 = GENERIC_READ;
+                dwShareMode = FILE_SHARE_READ;
+                dwCreationDisposition = OPEN_EXISTING;
+                flProtect = PAGE_READONLY;
+                dwDesiredAccess = FILE_MAP_READ;
+                break;
 
-			    case Mode.ReadWriteNew:
-				assert(size != 0);
-				dwDesiredAccess2 = GENERIC_READ | GENERIC_WRITE;
-				dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
-				dwCreationDisposition = CREATE_ALWAYS;
-				flProtect = PAGE_READWRITE;
-				dwDesiredAccess = FILE_MAP_WRITE;
-				break;
+            case Mode.ReadWriteNew:
+                assert(size != 0);
+                dwDesiredAccess2 = GENERIC_READ | GENERIC_WRITE;
+                dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
+                dwCreationDisposition = CREATE_ALWAYS;
+                flProtect = PAGE_READWRITE;
+                dwDesiredAccess = FILE_MAP_WRITE;
+                break;
 
-			    case Mode.ReadWrite:
-				dwDesiredAccess2 = GENERIC_READ | GENERIC_WRITE;
-				dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
-				dwCreationDisposition = OPEN_ALWAYS;
-				flProtect = PAGE_READWRITE;
-				dwDesiredAccess = FILE_MAP_WRITE;
-				break;
+            case Mode.ReadWrite:
+                dwDesiredAccess2 = GENERIC_READ | GENERIC_WRITE;
+                dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
+                dwCreationDisposition = OPEN_ALWAYS;
+                flProtect = PAGE_READWRITE;
+                dwDesiredAccess = FILE_MAP_WRITE;
+                break;
 
-			    case Mode.ReadCopyOnWrite:
-				if (dwVersion & 0x80000000)
-				{
-				    throw new FileException(filename,
-					"Win9x does not implement copy on write");
-				}
-				dwDesiredAccess2 = GENERIC_READ | GENERIC_WRITE;
-				dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
-				dwCreationDisposition = OPEN_EXISTING;
-				flProtect = PAGE_WRITECOPY;
-				dwDesiredAccess = FILE_MAP_COPY;
-				break;
+            case Mode.ReadCopyOnWrite:
+                if (dwVersion & 0x80000000)
+                {
+                    throw new FileException(filename,
+                            "Win9x does not implement copy on write");
+                }
+                dwDesiredAccess2 = GENERIC_READ | GENERIC_WRITE;
+                dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
+                dwCreationDisposition = OPEN_EXISTING;
+                flProtect = PAGE_WRITECOPY;
+                dwDesiredAccess = FILE_MAP_COPY;
+                break;
 
-			    default:
-				assert(0);
-			}
-		
-			if (filename)
-			{
-				if (useWfuncs)
-				{
-					auto namez = std.utf.toUTF16z(filename);
-					hFile = CreateFileW(namez,
-							dwDesiredAccess2,
-							dwShareMode,
-							null,
-							dwCreationDisposition,
-							FILE_ATTRIBUTE_NORMAL,
-							cast(HANDLE)null);
-				}
-				else
-				{
-					auto namez = std.file.toMBSz(filename);
-					hFile = CreateFileA(namez,
-							dwDesiredAccess2,
-							dwShareMode,
-							null,
-							dwCreationDisposition,
-							FILE_ATTRIBUTE_NORMAL,
-							cast(HANDLE)null);
-				}
-				if (hFile == INVALID_HANDLE_VALUE)
-					goto err1;
-			}
-			else
-				hFile = null;
-		
-			int hi = cast(int)(size>>32);
-			hFileMap = CreateFileMappingA(hFile, null, flProtect, hi, cast(uint)size, null);
-			if (hFileMap == null)               // mapping failed
-				goto err1;
-		
-			if (size == 0)
-			{
-				uint sizehi;
-				uint sizelow = GetFileSize(hFile,&sizehi);
-				size = (cast(ulong)sizehi << 32) + sizelow;
-			}
-			this.size = size;
-		
-			size_t initial_map = (window && 2*window<size)? 2*window : cast(size_t)size;
-			p = MapViewOfFileEx(hFileMap, dwDesiredAccess, 0, 0, initial_map, address);
-			if (!p) goto err1;
-			data = p[0 .. initial_map];
-		
-			debug (MMFILE) printf("MmFile.this(): p = %p, size = %d\n", p, size);
-			return;
-		
-			err1:
-			if (hFileMap != null)
-				CloseHandle(hFileMap);
-			hFileMap = null;
-		
-			if (hFile != INVALID_HANDLE_VALUE)
-				CloseHandle(hFile);
-			hFile = INVALID_HANDLE_VALUE;
-		
-			errNo();
-		}
-		else version (unix_mm)
-		{
-                        auto namez = toStringz(filename);
-			void* p;
-			int oflag;
-			int fmode;
-	
-			switch (mode)
-			{
-				case Mode.Read:
-					flags = MAP_SHARED;
-					prot = PROT_READ;
-					oflag = O_RDONLY;
-					fmode = 0;
-					break;
-	
-				case Mode.ReadWriteNew:
-					assert(size != 0);
-					flags = MAP_SHARED;
-					prot = PROT_READ | PROT_WRITE;
-					oflag = O_CREAT | O_RDWR | O_TRUNC;
-					fmode = 0660;
-					break;
-	
-				case Mode.ReadWrite:
-					flags = MAP_SHARED;
-					prot = PROT_READ | PROT_WRITE;
-					oflag = O_CREAT | O_RDWR;
-					fmode = 0660;
-					break;
-	
-				case Mode.ReadCopyOnWrite:
-					flags = MAP_PRIVATE;
-					prot = PROT_READ | PROT_WRITE;
-					oflag = O_RDWR;
-					fmode = 0;
-					break;
+            default:
+                assert(0);
+            }
+        
+            if (filename)
+            {
+                if (useWfuncs)
+                {
+                    auto namez = std.utf.toUTF16z(filename);
+                    hFile = CreateFileW(namez,
+                            dwDesiredAccess2,
+                            dwShareMode,
+                            null,
+                            dwCreationDisposition,
+                            FILE_ATTRIBUTE_NORMAL,
+                            cast(HANDLE)null);
+                }
+                else
+                {
+                    auto namez = std.file.toMBSz(filename);
+                    hFile = CreateFileA(namez,
+                            dwDesiredAccess2,
+                            dwShareMode,
+                            null,
+                            dwCreationDisposition,
+                            FILE_ATTRIBUTE_NORMAL,
+                            cast(HANDLE)null);
+                }
+                if (hFile == INVALID_HANDLE_VALUE)
+                    goto err1;
+            }
+            else
+                hFile = null;
+        
+            int hi = cast(int)(size>>32);
+            hFileMap = CreateFileMappingA(hFile, null, flProtect,
+                    hi, cast(uint)size, null);
+            if (hFileMap == null)               // mapping failed
+                goto err1;
+        
+            if (size == 0)
+            {
+                uint sizehi;
+                uint sizelow = GetFileSize(hFile,&sizehi);
+                size = (cast(ulong)sizehi << 32) + sizelow;
+            }
+            this.size = size;
+        
+            size_t initial_map = (window && 2*window<size)
+                ? 2*window : cast(size_t)size;
+            p = MapViewOfFileEx(hFileMap, dwDesiredAccess, 0, 0,
+                    initial_map, address);
+            if (!p) goto err1;
+            data = p[0 .. initial_map];
+        
+            debug (MMFILE) printf("MmFile.this(): p = %p, size = %d\n", p, size);
+            return;
+        
+          err1:
+            if (hFileMap != null)
+                CloseHandle(hFileMap);
+            hFileMap = null;
+        
+            if (hFile != INVALID_HANDLE_VALUE)
+                CloseHandle(hFile);
+            hFile = INVALID_HANDLE_VALUE;
+        
+            errnoEnforce(false);
+        }
+        else version (Posix)
+        {
+            auto namez = toStringz(filename);
+            void* p;
+            int oflag;
+            int fmode;
+    
+            switch (mode)
+            {
+            case Mode.Read:
+                flags = MAP_SHARED;
+                prot = PROT_READ;
+                oflag = O_RDONLY;
+                fmode = 0;
+                break;
+    
+            case Mode.ReadWriteNew:
+                assert(size != 0);
+                flags = MAP_SHARED;
+                prot = PROT_READ | PROT_WRITE;
+                oflag = O_CREAT | O_RDWR | O_TRUNC;
+                fmode = 0660;
+                break;
+    
+            case Mode.ReadWrite:
+                flags = MAP_SHARED;
+                prot = PROT_READ | PROT_WRITE;
+                oflag = O_CREAT | O_RDWR;
+                fmode = 0660;
+                break;
+    
+            case Mode.ReadCopyOnWrite:
+                flags = MAP_PRIVATE;
+                prot = PROT_READ | PROT_WRITE;
+                oflag = O_RDWR;
+                fmode = 0;
+                break;
 
-				default:
-					assert(0);
-			}
-	
-			if (filename.length)
-			{	
-				struct_stat statbuf;
-	
-				fd = unix.open(namez, oflag, fmode);
-				if (fd == -1)
-				{
-					// printf("\topen error, errno = %d\n",getErrno());
-					errNo();
-				}
-	
-				if (unix.fstat(fd, &statbuf))
-				{
-					//printf("\tfstat error, errno = %d\n",getErrno());
-					unix.close(fd);
-					errNo();
-				}
-	
-				if (prot & PROT_WRITE && size > statbuf.st_size)
-				{
-					// Need to make the file size bytes big
-					unix.lseek(fd, cast(off_t)(size - 1), SEEK_SET);
-					char c = 0;
-					unix.write(fd, &c, 1);
-				}
-				else if (prot & PROT_READ && size == 0)
-					size = cast(ulong)statbuf.st_size;
-			}
-			else
-			{
-				fd = -1;
-version (linux)			flags |= MAP_ANONYMOUS;
-else version (OSX)		flags |= MAP_ANON;
-else				static assert(0);
-			}
-			this.size = size;
-			size_t initial_map = (window && 2*window<size)? 2*window : cast(size_t)size;
-			p = mmap(address, initial_map, prot, flags, fd, 0);
-			if (p == MAP_FAILED) {
-			  if (fd != -1)
-			    unix.close(fd);
-			  errNo();
-			}
+            default:
+                assert(0);
+            }
+    
+            if (filename.length)
+            {   
+                fd = .open(namez, oflag, fmode);
+                errnoEnforce(fd != -1, "Could not open file "~filename);
+    
+                struct_stat64 statbuf;
+                if (fstat64(fd, &statbuf))
+                {
+                    //printf("\tfstat error, errno = %d\n",getErrno());
+                    .close(fd);
+                    errnoEnforce(false, "Could not stat file "~filename);
+                }
+    
+                if (prot & PROT_WRITE && size > statbuf.st_size)
+                {
+                    // Need to make the file size bytes big
+                    .lseek(fd, cast(int)(size - 1), SEEK_SET);
+                    char c = 0;
+                    core.sys.posix.unistd.write(fd, &c, 1);
+                }
+                else if (prot & PROT_READ && size == 0)
+                    size = statbuf.st_size;
+            }
+            else
+            {
+                fd = -1;
+                //assert(false, "@@@Sean, please fix the MAP_ANONYMOUS thing.");
+                enum MAP_ANONYMOUS = 0x20;
+                flags |= MAP_ANONYMOUS;
+            }
+            this.size = size;
+            size_t initial_map = (window && 2*window<size)
+                ? 2*window : cast(size_t)size;
+            p = mmap(address, initial_map, prot, flags, fd, 0);
+            if (p == MAP_FAILED) {
+                if (fd != -1)
+                    .close(fd);
+                errnoEnforce(fd != -1, "Could not map file "~filename);
+            }
 
-			data = p[0 .. initial_map];
-		}
-		else static if (! Have_MMFile)
-		{
-		    throw new FileException("This system does support memory mapped files");
-		}
-		else
-		{
-			static assert(0);
-		}
-	}
+            data = p[0 .. initial_map];
+        }
+        else
+        {
+            static assert(0);
+        }
+    }
 
-	/**
-	 * Flushes pending output and closes the memory mapped file.
-	 */
-	~this()
-	{
-		debug (MMFILE) printf("MmFile.~this()\n");
-		unmap();
-		version (Win32)
-		{
-			if (hFileMap != null && CloseHandle(hFileMap) != TRUE)
-				errNo();
-			hFileMap = null;
+    /**
+     * Flushes pending output and closes the memory mapped file.
+     */
+    ~this()
+    {
+        debug (MMFILE) printf("MmFile.~this()\n");
+        unmap();
+        version (Win32)
+        {
+            errnoEnforce(hFileMap == null || CloseHandle(hFileMap) == TRUE,
+                    "Could not close file handle");
+            hFileMap = null;
 
-			if (hFile && hFile != INVALID_HANDLE_VALUE && CloseHandle(hFile) != TRUE)
-				errNo();
-			hFile = INVALID_HANDLE_VALUE;
-		}
-		else version (unix_mm)
-		{
-			if (fd != -1 && unix.close(fd) == -1)
-				errNo();
-			fd = -1;
-		}
-		else static if (! Have_MMFile)
-		{
-		} 
-		else
-		{
-			static assert(0);
-		}
-		data = null;
-	}
+            errnoEnforce(!hFile || hFile == INVALID_HANDLE_VALUE
+                    || CloseHandle(hFile) == TRUE,
+                    "Could not close handle");
+            hFile = INVALID_HANDLE_VALUE;
+        }
+        else version (Posix)
+        {
+            errnoEnforce(fd == -1 || fd <= 2
+                    || .close(fd) != -1,
+                    "Could not close handle");
+            fd = -1;
+        }
+        else
+        {
+            static assert(0);
+        }
+        data = null;
+    }
 
-	/* Flush any pending output.
-	*/
-	void flush()
-	{
-		debug (MMFILE) printf("MmFile.flush()\n");
-		version (Win32)
-		{
-			FlushViewOfFile(data.ptr, data.length);
-		}
-		else version (unix_mm)
-		{
-			int i;
+    /* Flush any pending output.
+     */
+    void flush()
+    {
+        debug (MMFILE) printf("MmFile.flush()\n");
+        version (Win32)
+        {
+            FlushViewOfFile(data.ptr, data.length);
+        }
+        else version (Posix)
+        {
+            int i;
+            i = msync(cast(void*)data, data.length, MS_SYNC);   // sys/mman.h
+            errnoEnforce(i == 0, "msync failed");
+        }
+        else
+        {
+            static assert(0);
+        }
+    }
 
-			i = msync(cast(void*)data, data.length, MS_SYNC);	// sys/mman.h
-			if (i != 0)
-				errNo();
-		}
-		else static if (! Have_MMFile)
-		{
-		} 
-		else
-		{
-			static assert(0);
-		}
-	}
+    /**
+     * Gives size in bytes of the memory mapped file.
+     */
+    ulong length()
+    {
+        debug (MMFILE) printf("MmFile.length()\n");
+        return size;
+    }
 
-	/**
-	 * Gives size in bytes of the memory mapped file.
-	 */
-	ulong length()
-	{
-		debug (MMFILE) printf("MmFile.length()\n");
-		return size;
-	}
+    /**
+     * Read-only property returning the file mode.
+     */
+    Mode mode()
+    {
+        debug (MMFILE) printf("MmFile.mode()\n");
+        return mMode;
+    }
 
-	/**
-	 * Read-only property returning the file mode.
-	 */
-	Mode mode()
-	{
-		debug (MMFILE) printf("MmFile.mode()\n");
-		return mMode;
-	}
+    /**
+     * Returns entire file contents as an array.
+     */
+    void[] opSlice()
+    {
+        debug (MMFILE) printf("MmFile.opSlice()\n");
+        return opSlice(0,size);
+    }
 
-	/**
-	 * Returns entire file contents as an array.
-	 */
-	void[] opSlice()
-	{
-		debug (MMFILE) printf("MmFile.opSlice()\n");
-		return opSlice(0,size);
-	}
+    /**
+     * Returns slice of file contents as an array.
+     */
+    void[] opSlice(ulong i1, ulong i2)
+    {
+        debug (MMFILE) printf("MmFile.opSlice(%lld, %lld)\n", i1, i2);
+        ensureMapped(i1,i2);
+        size_t off1 = cast(size_t)(i1-start);
+        size_t off2 = cast(size_t)(i2-start);
+        return data[off1 .. off2];
+    }
 
-	/**
-	 * Returns slice of file contents as an array.
-	 */
-	void[] opSlice(ulong i1, ulong i2)
-	{
-		debug (MMFILE) printf("MmFile.opSlice(%lld, %lld)\n", i1, i2);
-		ensureMapped(i1,i2);
-		size_t off1 = cast(size_t)(i1-start);
-		size_t off2 = cast(size_t)(i2-start);
-		return data[off1 .. off2];
-	}
+    /**
+     * Returns byte at index i in file.
+     */
+    ubyte opIndex(ulong i)
+    {
+        debug (MMFILE) printf("MmFile.opIndex(%lld)\n", i);
+        ensureMapped(i);
+        size_t off = cast(size_t)(i-start);
+        return (cast(ubyte[])data)[off];
+    }
 
-	/**
-	 * Returns byte at index i in file.
-	 */
-	ubyte opIndex(ulong i)
-	{
-		debug (MMFILE) printf("MmFile.opIndex(%lld)\n", i);
-		ensureMapped(i);
-		size_t off = cast(size_t)(i-start);
-		return (cast(ubyte[])data)[off];
-	}
+    /**
+     * Sets and returns byte at index i in file to value.
+     */
+    ubyte opIndexAssign(ubyte value, ulong i)
+    {
+        debug (MMFILE) printf("MmFile.opIndex(%lld, %d)\n", i, value);
+        ensureMapped(i);
+        size_t off = cast(size_t)(i-start);
+        return (cast(ubyte[])data)[off] = value;
+    }
 
-	/**
-	 * Sets and returns byte at index i in file to value.
-	 */
-	ubyte opIndexAssign(ubyte value, ulong i)
-	{
-		debug (MMFILE) printf("MmFile.opIndex(%lld, %d)\n", i, value);
-		ensureMapped(i);
-		size_t off = cast(size_t)(i-start);
-		return (cast(ubyte[])data)[off] = value;
-	}
 
+    // return true if the given position is currently mapped
+    private int mapped(ulong i) 
+    {
+        debug (MMFILE) printf("MmFile.mapped(%lld, %lld, %d)\n", i,start, 
+                data.length);
+        return i >= start && i < start+data.length;
+    }
 
-	// return true if the given position is currently mapped
-	private int mapped(ulong i) 
-	{
-		debug (MMFILE) printf("MmFile.mapped(%lld, %lld, %d)\n", i,start, 
-				data.length);
-		return i >= start && i < start+data.length;
-	}
+    // unmap the current range
+    private void unmap() 
+    {
+        debug (MMFILE) printf("MmFile.unmap()\n");
+        version(Windows) {
+            /* Note that under Windows 95, UnmapViewOfFile() seems to return
+             * random values, not TRUE or FALSE.
+             */
+            errnoEnforce(!data || UnmapViewOfFile(data.ptr) != FALSE ||
+                    (dwVersion & 0x80000000) != 0);
+        } else {
+            errnoEnforce(!data || munmap(cast(void*)data, data.length) == 0,
+                    "munmap failed");
+        }
+        data = null;
+    }
 
-	// unmap the current range
-	private void unmap() 
-	{
-		debug (MMFILE) printf("MmFile.unmap()\n");
-		version(Windows) {
-			/* Note that under Windows 95, UnmapViewOfFile() seems to return
-			* random values, not TRUE or FALSE.
-			*/
-			if (data && UnmapViewOfFile(data.ptr) == FALSE &&
-				(dwVersion & 0x80000000) == 0)
-				errNo();
-		} else version (unix_mm) {
-			if (data && munmap(cast(void*)data, data.length) != 0)
-				errNo();
-		}
-		data = null;
-	}
+    // map range
+    private void map(ulong start, size_t len) 
+    {
+        debug (MMFILE) printf("MmFile.map(%lld, %d)\n", start, len);
+        void* p;
+        if (start+len > size)
+            len = cast(size_t)(size-start);
+        version(Windows) {
+            uint hi = cast(uint)(start>>32);
+            p = MapViewOfFileEx(hFileMap, dwDesiredAccess, hi, cast(uint)start, len, address);
+            errnoEnforce(p);
+        } else {
+            p = mmap(address, len, prot, flags, fd, cast(int)start);
+            errnoEnforce(p != MAP_FAILED);
+        }
+        data = p[0 .. len];
+        this.start = start;
+    }
 
-	// map range
-	private void map(ulong start, size_t len) 
-	{
-		debug (MMFILE) printf("MmFile.map(%lld, %d)\n", start, len);
-		void* p;
-		if (start+len > size)
-			len = cast(size_t)(size-start);
-		version(Windows) {
-			uint hi = cast(uint)(start>>32);
-			p = MapViewOfFileEx(hFileMap, dwDesiredAccess, hi, cast(uint)start, len, address);
-			if (!p) errNo();
-		} else version (unix_mm) {
-			p = mmap(address, len, prot, flags, fd, cast(off_t)start);
-			if (p == MAP_FAILED) errNo();
-		}
-		data = p[0 .. len];
-		this.start = start;
-	}
+    // ensure a given position is mapped
+    private void ensureMapped(ulong i) 
+    {
+        debug (MMFILE) printf("MmFile.ensureMapped(%lld)\n", i);
+        if (!mapped(i)) {
+            unmap();
+            if (window == 0) {
+                map(0,cast(size_t)size);
+            } else {
+                ulong block = i/window;
+                if (block == 0)
+                    map(0,2*window);
+                else 
+                    map(window*(block-1),3*window);
+            }
+        }
+    }
 
-	// ensure a given position is mapped
-	private void ensureMapped(ulong i) 
-	{
-		debug (MMFILE) printf("MmFile.ensureMapped(%lld)\n", i);
-		if (!mapped(i)) {
-			unmap();
-			if (window == 0) {
-				map(0,cast(size_t)size);
-			} else {
-				ulong block = i/window;
-				if (block == 0)
-					map(0,2*window);
-				else 
-					map(window*(block-1),3*window);
-			}
-		}
-	}
+    // ensure a given range is mapped
+    private void ensureMapped(ulong i, ulong j) 
+    {
+        debug (MMFILE) printf("MmFile.ensureMapped(%lld, %lld)\n", i, j);
+        if (!mapped(i) || !mapped(j-1)) {
+            unmap();
+            if (window == 0) {
+                map(0,cast(size_t)size);
+            } else {
+                ulong iblock = i/window;
+                ulong jblock = (j-1)/window;
+                if (iblock == 0) {
+                    map(0,cast(size_t)(window*(jblock+2)));
+                } else {
+                    map(window*(iblock-1),cast(size_t)(window*(jblock-iblock+3)));
+                }
+            }
+        }
+    }
 
-	// ensure a given range is mapped
-	private void ensureMapped(ulong i, ulong j) 
-	{
-		debug (MMFILE) printf("MmFile.ensureMapped(%lld, %lld)\n", i, j);
-		if (!mapped(i) || !mapped(j-1)) {
-			unmap();
-			if (window == 0) {
-				map(0,cast(size_t)size);
-			} else {
-				ulong iblock = i/window;
-				ulong jblock = (j-1)/window;
-				if (iblock == 0) {
-					map(0,cast(size_t)(window*(jblock+2)));
-				} else {
-					map(window*(iblock-1),cast(size_t)(window*(jblock-iblock+3)));
-				}
-			}
-		}
-	}
+private:
+    string filename;
+    void[] data;
+    ulong  start;
+    size_t window;
+    ulong  size;
+    Mode   mMode;
+    void*  address;
 
-	private:
-	string filename;
-	void[] data;
-	ulong  start;
-	size_t window;
-	ulong  size;
-	Mode   mMode;
-	void*  address;
+    version (Win32)
+    {
+        HANDLE hFile = INVALID_HANDLE_VALUE;
+        HANDLE hFileMap = null;
+        uint dwDesiredAccess;
+    }
+    else version (Posix)
+    {
+        int fd;
+        int prot;
+        int flags;
+        int fmode;
+    }
+    else
+    {
+        static assert(0);
+    }
 
-	version (Win32)
-	{
-		HANDLE hFile = INVALID_HANDLE_VALUE;
-		HANDLE hFileMap = null;
-		uint dwDesiredAccess;
-	}
-	else version (unix_mm)
-	{
-		int fd;
-		int prot;
-		int flags;
-		int fmode;
-	}
-	else static if (! Have_MMFile)
-	{
-	}
-	else
-	{
-		static assert(0);
-	}
-
-	// Report error, where errno gives the error number
-	void errNo()
-	{
-		version (Win32)
-		{
-			throw new FileException(filename, GetLastError());
-		}
-		else version (Posix)
-		{
-			throw new FileException(filename, getErrno());
-		}
-		else static if (! Have_MMFile)
-		{
-			throw new FileException(filename, "MMFile unsupported");
-		}
-		else
-		{
-			static assert(0);
-		}
-	}
+    // Report error, where errno gives the error number
+    // void errNo()
+    // {
+    //     version (Win32)
+    //     {
+    //         throw new FileException(filename, GetLastError());
+    //     }
+    //     else version (linux)
+    //     {
+    //         throw new FileException(filename, getErrno());
+    //     }
+    //     else
+    //     {
+    //         static assert(0);
+    //     }
+    // }
 }
 
-unittest {
-    static if (Have_MMFile)
-    {
-	const size_t K = 1024;
-	size_t win = 64*K; // assume the page size is 64K
-	version(Win32) {
-		/+ these aren't defined in std.c.windows.windows so let's use the default
+unittest
+{
+    const size_t K = 1024;
+    size_t win = 64*K; // assume the page size is 64K
+    version(Win32) {
+        /+ these aren't defined in std.c.windows.windows so let's use default
          SYSTEM_INFO sysinfo;
          GetSystemInfo(&sysinfo);
          win = sysinfo.dwAllocationGranularity;
-		+/
-	} else version (Posix) {
-		// getpagesize() is not defined in the unix D headers so use the guess
-	}
-	MmFile mf = new MmFile("testing.txt",MmFile.Mode.ReadWriteNew,100*K,null,win);
-	ubyte[] str = cast(ubyte[])"1234567890";
-	ubyte[] data = cast(ubyte[])mf[0 .. 10];
-	data[] = str[];
-	assert( mf[0 .. 10] == str );
-	data = cast(ubyte[])mf[50 .. 60];
-	data[] = str[];
-	assert( mf[50 .. 60] == str );
-	ubyte[] data2 = cast(ubyte[])mf[20*K .. 60*K];
-	assert( data2.length == 40*K );
-	assert( data2[length-1] == 0 );
-	mf[100*K-1] = cast(ubyte)'b';
-	data2 = cast(ubyte[])mf[21*K .. 100*K];
-	assert( data2.length == 79*K );
-	assert( data2[length-1] == 'b' );
-	delete mf;
-	std.file.remove("testing.txt");
-
-	// Create anonymous mapping
-	auto test = new MmFile(null, MmFile.Mode.ReadWriteNew, 1024*1024, null);
+         +/
+    } else version (linux) {
+        // getpagesize() is not defined in the unix D headers so use the guess
     }
+    MmFile mf = new MmFile("testing.txt",MmFile.Mode.ReadWriteNew,
+            100*K,null,win);
+    ubyte[] str = cast(ubyte[])"1234567890";
+    ubyte[] data = cast(ubyte[])mf[0 .. 10];
+    data[] = str[];
+    assert( mf[0 .. 10] == str );
+    data = cast(ubyte[])mf[50 .. 60];
+    data[] = str[];
+    assert( mf[50 .. 60] == str );
+    ubyte[] data2 = cast(ubyte[])mf[20*K .. 60*K];
+    assert( data2.length == 40*K );
+    assert( data2[length-1] == 0 );
+    mf[100*K-1] = cast(ubyte)'b';
+    data2 = cast(ubyte[])mf[21*K .. 100*K];
+    assert( data2.length == 79*K );
+    assert( data2[length-1] == 'b' );
+    delete mf;
+    std.file.remove("testing.txt");
+    // Create anonymous mapping
+    auto test = new MmFile(null, MmFile.Mode.ReadWriteNew, 1024*1024, null);
 }
diff -r f12bfe124807 d/phobos2/std/numeric.d
--- a/d/phobos2/std/numeric.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/numeric.d	Thu Oct 14 14:12:53 2010 +0100
@@ -9,50 +9,288 @@
 
 WIKI = Phobos/StdNumeric
 
-Author:
+Authors:
 
 $(WEB erdani.org, Andrei Alexandrescu), Don Clugston
 */
 
-/*
- *  Copyright (C) 2004-2006 by Digital Mars, www.digitalmars.com
- *  Written by Andrei Alexandrescu, www.erdani.org
- *
- *  This software is provided 'as-is', without any express or implied
- *  warranty. In no event will the authors be held liable for any damages
- *  arising from the use of this software.
- *
- *  Permission is granted to anyone to use this software for any purpose,
- *  including commercial applications, and to alter it and redistribute it
- *  freely, subject to the following restrictions:
- *
- *  o  The origin of this software must not be misrepresented; you must not
- *     claim that you wrote the original software. If you use this software
- *     in a product, an acknowledgment in the product documentation would be
- *     appreciated but is not required.
- *  o  Altered source versions must be plainly marked as such, and must not
- *     be misrepresented as being the original software.
- *  o  This notice may not be removed or altered from any source
- *     distribution.
- */
-
 module std.numeric;
+import std.algorithm;
+import std.array;
+import std.bitmanip;
 import std.typecons;
 import std.math;
 import std.traits;
 import std.contracts;
 import std.random;
 import std.string;
+import std.range;
+import std.c.stdlib;
+import std.functional;
+import std.typetuple;
 version(unittest)
 {
     import std.stdio;
+    import std.conv;
 }
 
 /**
-   Implements the $(LINK2 http://tinyurl.com/2zb9yr,secant method) for
-   finding a root of the function $(D_PARAM f) starting from points
-   [xn_1, x_n] (ideally close to the root). $(D_PARAM Num) may be
-   $(D_PARAM float), $(D_PARAM double), or $(D_PARAM real).
+Flags for custom floating-point formats. In the case of $(LUCKY
+IEEE754) types, all of these flags are applied. 
+ */
+private enum CustomFloatFlags
+{
+/**
+Store values in normalized form by default, i.e. the fraction is
+assumed to be $(D 1.nnnn), not $(D 0.nnnn). Normalization is the
+default in all $(LUCKY IEE754) types. If a floating-point type is
+defined to store only numbers inside $(D (-1, 1)), normalization may
+not be useful.
+ */ 
+    storeNormalized = 1,
+/**
+Allow denormalized values (a la $(LUCKY IEEE754 denormalized)).
+If this flag is on, a value with an exponent
+containing all bits zero is considered to contain a denormalized
+value.
+ */ 
+    allowDenorm = 2,
+/**
+Support for infinity values (a la $(LUCKY IEEE754 _infinity)). If this
+flag is on, a value with an exponent containing all bits one and
+fraction zero is assumed to contain a (valid) allowDenormalized value. The sign,
+if applicable, is decided by the sign bit.
+ */ 
+        infinity = 4,
+/**
+Support for NaN (Not a Number) values (a la $(LUCKY IEEE754 Not a Number)).
+If this flag is on, a value with an exponent containing all
+bits one and a nonzero fraction is considered to contain a
+allowDenormalized value.
+ */ 
+        nan = 8,
+/**
+Include _all of the above options.
+ */
+        all = storeNormalized | allowDenorm | infinity | nan
+        }
+
+/**
+Allows user code to define custom floating-point formats. These
+formats are for storage only; to do operations on custom
+floating-point types, one must extract the value into a $(D float) or
+$(D double). After the operation is completed the result can be
+deposited in a custom floating-point value by using its assignment
+operator.
+
+Example:
+----
+// Define a 16-bit floating point type
+alias CustomFloat!(1, 5, 10) HalfFloat;
+auto x = HalfFloat(0.125);
+assert(halfFloat.get!float == 0.125);
+----
+ */
+struct CustomFloat(
+    bool signBit,       // allocate a sign bit? (true for float)
+    uint fractionBits,  // fraction bits (23 for float)
+    uint exponentBits,  // exponent bits (8 for float)
+    uint bias = (1u << (exponentBits - 1)) - 1, // bias (127 for float)
+    CustomFloatFlags flags = CustomFloatFlags.all)
+{
+    alias CustomFloatFlags Flags;
+    private enum totalSize = signBit + fractionBits + exponentBits;
+    static assert(totalSize % 8 == 0);
+    private mixin(bitfields!(
+                bool, "sign", signBit,
+                uint, "fraction", fractionBits,
+                uint, "exponent", exponentBits));
+    
+/**
+Initialize from a $(D float).
+ */
+    this(float input) { this = input; }
+/**
+Initialize from a $(D double).
+ */
+    this(double input) { this = input; }
+/**
+Assigns from either a $(D float) or a $(D double).
+ */ 
+    void opAssign(F)(F input) if (indexOf!(Unqual!F, float, double) >= 0)
+    {
+        static if (is(Unqual!F == float))
+            auto value = FloatRep(input);
+        else
+            auto value = DoubleRep(input);
+        // Assign the sign bit
+        static if (!signBit) enforce(!value.sign);
+        else sign = value.sign;
+
+        // Assign the exponent and fraction
+        auto e = value.exponent;
+        if (e == 0)
+        {
+            // denormalized source value
+            static if (flags & Flags.allowDenorm)
+            {
+                exponent = 0;
+                fraction = cast(typeof(fraction_max)) value.fraction;
+            }
+            else
+            {
+                assert(0);
+            }
+        }
+        else if (e == value.exponent_max)
+        {
+            // infinity or NaN
+            if (value.fraction == 0)
+                // Infinity
+                static if (flags & Flags.infinity)
+                {
+                    fraction = 0;
+                    exponent = exponent_max;
+                }
+                else
+                {
+                    assert(0);
+                }
+            else
+            {
+                // NaN
+                static if (flags & Flags.nan)
+                {
+                    fraction = cast(typeof(fraction())) value.fraction;
+                    exponent = exponent_max;
+                }
+                else
+                {
+                    assert(0);
+                }
+            }
+        }
+        else
+        {
+            // normal value
+            exponent = cast(typeof(exponent_max))
+                (value.exponent + (bias - value.bias));
+            static if (fractionBits >= value.fractionBits)
+            {
+                fraction = cast(typeof(fraction_max))
+                    (value.fraction << (fractionBits - value.fractionBits));
+            }
+            else
+            {
+                fraction = cast(typeof(fraction_max))
+                    (value.fraction >> (value.fractionBits - fractionBits));
+            }
+        }
+    }
+
+/**
+Fetches the stored value either as a $(D float) or $(D double).
+ */
+    F get(F)()
+    {
+        static if (is(Unqual!F == float))
+            FloatRep result = void;
+        else
+            DoubleRep result = void;
+        static if (signBit) result.sign = sign;
+        else result.sign = 0;
+        auto e = exponent;
+        if (e == 0)
+        {
+            // denormalized value
+            result.exponent = 0;
+            result.fraction = fraction;
+        }
+        else if (e == exponent_max)
+        {
+            // infinity or NaN
+        }
+        else
+        {
+            // normal value
+            result.exponent = cast(typeof(result.exponent_max))
+                (exponent + (result.bias - bias));
+            static if (fractionBits <= result.fractionBits)
+            {
+                alias Select!(result.fractionBits >= 32, ulong, uint) S;
+                result.fraction = cast(typeof(result.fraction_max))
+                    (cast(S) fraction << (result.fractionBits - fractionBits));
+            }
+            else
+            {
+                result.fraction = cast(typeof(result.fraction()))
+                    (fraction >> (fractionBits - result.fractionBits));
+            }
+        }
+        return result.value;
+    }
+}
+
+unittest
+{
+    alias TypeTuple!(
+        CustomFloat!(1, 5, 10),
+        CustomFloat!(0, 5, 11),
+        CustomFloat!(0, 1, 15)
+        ) FPTypes;
+    foreach (F; FPTypes)
+    {
+        auto x = F(0.125);
+        assert(x.get!float == 0.125F);
+        assert(x.get!double == 0.125);
+    }
+}
+
+/**
+Defines the fastest type to use when storing temporaries of a
+calculation intended to ultimately yield a result of type $(D F)
+(where $(D F) must be one of $(D float), $(D double), or $(D
+real)). When doing a multi-step computation, you may want to store
+intermediate results as $(D FPTemporary!F).
+
+Example:
+----
+// Average numbers in an array
+double avg(in double[] a)
+{
+    if (a.length == 0) return 0;
+    FPTemporary!double result = 0;
+    foreach (e; a) result += e;
+    return result / a.length;
+}
+----
+
+The necessity of $(D FPTemporary) stems from the optimized
+floating-point operations and registers present in virtually all
+processors. When adding numbers in the example above, the addition may
+in fact be done in $(D real) precision internally. In that case,
+storing the intermediate $(D result) in $(D double format) is not only
+less precise, it is also (surprisingly) slower, because a conversion
+from $(D real) to $(D double) is performed every pass through the
+loop. This being a lose-lose situation, $(D FPTemporary!F) has been
+defined as the $(I fastest) type to use for calculations at precision
+$(D F). There is no need to define a type for the $(I most accurate)
+calculations, as that is always $(D real).
+
+Finally, there is no guarantee that using $(D FPTemporary!F) will
+always be fastest, as the speed of floating-point calculations depends
+on very many factors.
+ */
+template FPTemporary(F) if (isFloatingPoint!F)
+{
+    alias real FPTemporary;
+}
+
+/**
+Implements the $(WEB tinyurl.com/2zb9yr, secant method) for finding a
+root of the function $(D fun) starting from points $(D [xn_1, x_n])
+(ideally close to the root). $(D Num) may be $(D float), $(D double),
+or $(D real).
 
 Example:
 
@@ -60,21 +298,21 @@
 float f(float x) {
     return cos(x) - x*x*x;
 }
-auto x = secantMethod(&f, 0f, 1f);
+auto x = secantMethod!(f)(0f, 1f);
 assert(approxEqual(x, 0.865474));
 ----
 */
-template secantMethod(alias F)
+template secantMethod(alias fun)
 {
     Num secantMethod(Num)(Num xn_1, Num xn) {
-        auto fxn = F(xn_1), d = xn_1 - xn;
+        auto fxn = unaryFun!(fun)(xn_1), d = xn_1 - xn;
         typeof(fxn) fxn_1;
         xn = xn_1;
         while (!approxEqual(d, 0) && isfinite(d)) {
             xn_1 = xn;
             xn -= d;
             fxn_1 = fxn;
-            fxn = F(xn);
+            fxn = unaryFun!(fun)(xn);
             d *= -fxn / (fxn - fxn_1);
         }
         return xn;
@@ -83,12 +321,15 @@
 
 unittest
 {
-    scope(failure) writeln(stderr, "Failure testing secantMethod");
+    scope(failure) stderr.writeln("Failure testing secantMethod");
     float f(float x) {
         return cos(x) - x*x*x;
     }
     invariant x = secantMethod!(f)(0f, 1f);
     assert(approxEqual(x, 0.865474));
+    auto d = &f;
+    invariant y = secantMethod!(d)(0f, 1f);
+    assert(approxEqual(y, 0.865474));
 }
 
 
@@ -96,13 +337,9 @@
 // Return true if a and b have opposite sign.
 bool oppositeSigns(T)(T a, T b)
 {
-    // Use signbit() if available, otherwise check the signs.
-    static if (is(typeof(signbit(a)))) {    
-        return (signbit(a) ^ signbit(b))!=0;
-    } else return (a>0 && b<0) || (a>0 && b<0);
+    return signbit(a) != signbit(b);
 }
 
-
 public:
 
 /**  Find a real root of a real function f(x) via bracketing.
@@ -133,7 +370,7 @@
 {
     auto r = findRoot(f, a, b, f(a), f(b), (T lo, T hi){ return false; });
     // Return the first value if it is smaller or NaN
-    return fabs(r._2) !> fabs(r._3) ? r._0 : r._1;
+    return fabs(r.field[2]) !> fabs(r.field[3]) ? r.field[0] : r.field[1];
 }
 
 /** Find root of a real function f(x) by bracketing, allowing the
@@ -151,8 +388,8 @@
  *
  * fax = Value of $(D f(ax)).
  *
- * fax = Value of $(D f(ax)) and $(D f(bx)). ($(D f(ax)) and $(D
- * f(bx)) are commonly known in advance.)
+ * fbx = Value of $(D f(bx)). ($(D f(ax)) and $(D f(bx)) are commonly
+ * known in advance.)
  *
  * 
  * tolerance = Defines an early termination condition. Receives the
@@ -173,7 +410,7 @@
     bool delegate(T lo, T hi) tolerance)
 in {
     assert(ax<>=0 && bx<>=0, "Limits must not be NaN");
-    assert(oppositeSigns(fax, fbx), "Parameters must bracket the root.");
+    assert(signbit(fax) != signbit(fbx), "Parameters must bracket the root.");
 }
 body {   
 // This code is (heavily) modified from TOMS748 (www.netlib.org). Some ideas
@@ -205,7 +442,7 @@
             return;
         }
         // Determine new enclosing interval
-        if (oppositeSigns(fa, fc)) {
+        if (signbit(fa) != signbit(fc)) {
             d = b;
             fd = fb;
             b = c;
@@ -228,7 +465,7 @@
             // Catastrophic cancellation
             if (a == 0) a = copysign(0.0L, b);
             else if (b == 0) b = copysign(0.0L, a);
-            else if (oppositeSigns(a, b)) return 0;
+            else if (signbit(a) != signbit(b)) return 0;
             T c = ieeeMean(a, b); 
             return c;
         }
@@ -410,8 +647,8 @@
     return Tuple!(T, T, R, R)(a, b, fa, fb);
 }
 
-unittest{
-    
+unittest
+{    
     int numProblems = 0;
     int numCalls;
     
@@ -422,8 +659,8 @@
         auto result = findRoot(f, x1, x2, f(x1), f(x2),
           (real lo, real hi) { return false; });
         
-        auto flo = f(result._0);
-        auto fhi = f(result._1);
+        auto flo = f(result.field[0]);
+        auto fhi = f(result.field[1]);
         if (flo!=0) {
             assert(oppositeSigns(flo, fhi));
         }
@@ -589,51 +826,958 @@
 */        
 }
 
-template tabulateFixed(alias fun, uint n,
-        real maxError, real left, real right)
+/**
+Computes $(LUCKY Euclidean distance) between input ranges $(D a) and
+$(D b). The two ranges must have the same length. The three-parameter
+version stops computation as soon as the distance is greater than or
+equal to $(D limit) (this is useful to save computation if a small
+distance is sought).
+ */
+CommonType!(ElementType!(Range1), ElementType!(Range2))
+euclideanDistance(Range1, Range2)(Range1 a, Range2 b)
+    if (isInputRange!(Range1) && isInputRange!(Range2))
 {
-    ReturnType!(fun) tabulateFixed(ParameterTypeTuple!(fun) arg)
+    enum bool haveLen = hasLength!(Range1) && hasLength!(Range2);
+    static if (haveLen) enforce(a.length == b.length);
+    typeof(return) result = 0;
+    for (; !a.empty; a.popFront, b.popFront)
     {
-        alias ParameterTypeTuple!(fun)[0] num;
-        static num[n] table;
-        alias arg[0] x;
-        enforce(left <= x && x < right);
-        invariant i = cast(uint) (table.length
-                * ((x - left) / (right - left)));
-        assert(i < n);
-        if (isnan(table[i])) {
-            // initialize it
-            auto x1 = left + i * (right - left) / n;
-            auto x2 = left + (i + 1) * (right - left) / n;
-            invariant y1 = fun(x1), y2 = fun(x2);
-            invariant y = 2 * y1 * y2 / (y1 + y2);
-            num wyda(num xx) { return fun(xx) - y; }
-            auto bestX = findRoot(&wyda, x1, x2);
-            table[i] = fun(bestX);
-            invariant leftError = abs((table[i] - y1) / y1);
-            enforce(leftError <= maxError, text(leftError, " > ", maxError));
-            invariant rightError = abs((table[i] - y2) / y2);
-            enforce(rightError <= maxError, text(rightError, " > ", maxError));
+        auto t = a.front - b.front;
+        result += t * t;
+    }
+    static if (!haveLen) enforce(b.empty);
+    return sqrt(result);
+}
+
+/// Ditto
+CommonType!(ElementType!(Range1), ElementType!(Range2))
+euclideanDistance(Range1, Range2, F)(Range1 a, Range2 b, F limit)
+    if (isInputRange!(Range1) && isInputRange!(Range2))
+{
+    limit *= limit;
+    enum bool haveLen = hasLength!(Range1) && hasLength!(Range2);
+    static if (haveLen) enforce(a.length == b.length);
+    typeof(return) result = 0;
+    for (; ; a.popFront, b.popFront)
+    {
+        if (a.empty)
+        {
+            static if (!haveLen) enforce(b.empty);
+            break;
         }
-        return table[i];
+        auto t = a.front - b.front;
+        result += t * t;
+        if (result >= limit) break;
     }
+    return sqrt(result);
 }
 
 unittest
 {
-  version (none) // fails unit tests
-  {
-    enum epsilon = 0.01;
-    alias tabulateFixed!(tanh, 700, epsilon, 0.2, 3) fasttanh;
-    uint testSize = 100000;
-    auto rnd = Random(unpredictableSeed);
-    foreach (i; 0 .. testSize) {
-        invariant x = uniform(rnd, 0.2F, 3.0F);
-        invariant float y = fasttanh(x), w = tanh(x);
-        invariant e = abs(y - w) / w;
-        //writefln("%.20f", e);
-        enforce(e <= epsilon, text("x = ", x, ", fasttanh(x) = ", y,
-                        ", tanh(x) = ", w, ", relerr = ", e));
+    double[] a = [ 1., 2., ];
+    double[] b = [ 4., 6., ];
+    assert(euclideanDistance(a, b) == 5);
+    assert(euclideanDistance(a, b, 5) == 5);
+    assert(euclideanDistance(a, b, 4) == 5);
+    assert(euclideanDistance(a, b, 2) == 3);
+}
+
+/**
+Computes the $(LUCKY dot product) of input ranges $(D a) and $(D
+b). The two ranges must have the same length. If both ranges define
+length, the check is done once; otherwise, it is done at each
+iteration.
+ */
+CommonType!(ElementType!(Range1), ElementType!(Range2))
+dotProduct(Range1, Range2)(Range1 a, Range2 b)
+    if (isInputRange!(Range1) && isInputRange!(Range2) &&
+            !(isArray!(Range1) && isArray!(Range2)))
+{
+    enum bool haveLen = hasLength!(Range1) && hasLength!(Range2);
+    static if (haveLen) enforce(a.length == b.length);
+    typeof(return) result = 0;
+    for (; !a.empty; a.popFront, b.popFront)
+    {
+        result += a.front * b.front;
     }
-  }
+    static if (!haveLen) enforce(b.empty);
+    return result;
 }
+
+/// Ditto
+Unqual!(CommonType!(F1, F2))
+dotProduct(F1, F2)(in F1[] avector, in F2[] bvector)
+{
+    invariant n = avector.length;
+    assert(n == bvector.length);
+    auto avec = avector.ptr, bvec = bvector.ptr;
+    typeof(return) sum0 = 0.0, sum1 = 0.0;
+    
+    const all_endp = avec + n;
+    const smallblock_endp = avec + (n & ~3);
+    const bigblock_endp = avec + (n & ~15);
+    
+    for (; avec != bigblock_endp; avec += 16, bvec += 16)
+    {
+        sum0 += avec[0] * bvec[0];
+        sum1 += avec[1] * bvec[1];
+        sum0 += avec[2] * bvec[2];
+        sum1 += avec[3] * bvec[3];
+        sum0 += avec[4] * bvec[4];
+        sum1 += avec[5] * bvec[5];
+        sum0 += avec[6] * bvec[6];
+        sum1 += avec[7] * bvec[7];
+        sum0 += avec[8] * bvec[8];
+        sum1 += avec[9] * bvec[9];
+        sum0 += avec[10] * bvec[10];
+        sum1 += avec[11] * bvec[11];
+        sum0 += avec[12] * bvec[12];
+        sum1 += avec[13] * bvec[13];
+        sum0 += avec[14] * bvec[14];
+        sum1 += avec[15] * bvec[15];
+    }
+    
+    for (; avec != smallblock_endp; avec += 4, bvec += 4) {
+        sum0 += avec[0] * bvec[0];
+        sum1 += avec[1] * bvec[1];
+        sum0 += avec[2] * bvec[2];
+        sum1 += avec[3] * bvec[3];
+    }
+    
+    sum0 += sum1;
+    
+    /* Do trailing portion in naive loop. */
+    while (avec != all_endp)
+        sum0 += (*avec++) * (*bvec++);
+    
+    return sum0;
+}
+
+unittest
+{
+    double[] a = [ 1., 2., ];
+    double[] b = [ 4., 6., ];
+    assert(dotProduct(a, b) == 16);
+}
+
+/**
+Computes the $(LUCKY cosine similarity) of input ranges $(D a) and $(D
+b). The two ranges must have the same length. If both ranges define
+length, the check is done once; otherwise, it is done at each
+iteration. If either range has all-zero elements, return 0.
+ */
+CommonType!(ElementType!(Range1), ElementType!(Range2))
+cosineSimilarity(Range1, Range2)(Range1 a, Range2 b)
+    if (isInputRange!(Range1) && isInputRange!(Range2))
+{
+    enum bool haveLen = hasLength!(Range1) && hasLength!(Range2);
+    static if (haveLen) enforce(a.length == b.length);
+    FPTemporary!(typeof(return)) norma = 0, normb = 0, dotprod = 0;
+    for (; !a.empty; a.popFront, b.popFront)
+    {
+        immutable t1 = a.front, t2 = b.front;
+        norma += t1 * t1;
+        normb += t2 * t2;
+        dotprod += t1 * t2;
+    }
+    static if (!haveLen) enforce(b.empty);
+    if (norma == 0 || normb == 0) return 0;
+    return dotprod / sqrt(norma * normb);
+}
+
+unittest
+{
+    double[] a = [ 1., 2., ];
+    double[] b = [ 4., 3., ];
+    // writeln(cosineSimilarity(a, b));
+    // writeln(10.0 / sqrt(5.0 * 25));
+    assert(approxEqual(
+                cosineSimilarity(a, b), 10.0 / sqrt(5.0 * 25),
+                0.01));
+}
+
+/**
+Normalizes values in $(D range) by multiplying each element with a
+number chosen such that values sum up to $(D sum). If elements in $(D
+range) sum to zero, assigns $(D sum / range.length) to
+all. Normalization makes sense only if all elements in $(D range) are
+positive. $(D normalize) assumes that is the case without checking it.
+
+Returns: $(D true) if normalization completed normally, $(D false) if
+all elements in $(D range) were zero or if $(D range) is empty.
+ */
+bool normalize(R)(R range, ElementType!(R) sum = 1) if (isForwardRange!(R))
+{
+    ElementType!(R) s = 0;
+    // Step 1: Compute sum and length of the range
+    static if (hasLength!(R))
+    {
+        const length = range.length;
+        foreach (e; range)
+        {
+            s += e;
+        }
+    }
+    else
+    {
+        uint length = 0;
+        foreach (e; range)
+        {
+            s += e;
+            ++length;
+        }
+    }
+    // Step 2: perform normalization
+    if (s == 0)
+    {
+        if (length)
+        {
+            auto f = sum / range.length;
+            foreach (ref e; range) e = f;
+        }
+        return false;
+    }
+    // The path most traveled
+    assert(s >= 0);
+    auto f = sum / s;
+    foreach (ref e; range) e *= f;
+    return true;
+}
+
+unittest
+{
+    double[] a = [];
+    assert(!normalize(a));
+    a = [ 1., 3. ];
+    assert(normalize(a));
+    assert(a == [ 0.25, 0.75 ]);
+    a = [ 0., 0. ];
+    assert(!normalize(a));
+    assert(a == [ 0.5, 0.5 ]);
+}
+
+/**
+Computes $(LUCKY _entropy) of input range $(D r) in bits. This
+function assumes (without checking) that the values in $(D r) are all
+in $(D [0, 1]). For the entropy to be meaningful, often $(D r) should
+be normalized too (i.e., its values should sum to 1). The
+two-parameter version stops evaluating as soon as the intermediate
+result is greater than or equal to $(D max).
+ */
+ElementType!Range entropy(Range)(Range r) if (isInputRange!Range)
+{
+    typeof(return) result = 0.0;
+    foreach (e; r)
+    {
+        if (!e) continue;
+        result -= e * log2(e);
+    }
+    return result;
+}
+
+/// Ditto
+ElementType!Range entropy(Range, F)(Range r, F max)
+if (isInputRange!Range
+        && !is(CommonType!(ElementType!Range, F) == void))
+{
+    typeof(return) result = 0.0;
+    foreach (e; r)
+    {
+        if (!e) continue;
+        result -= e * log2(e);
+        if (result >= max) break;
+    }
+    return result;
+}
+
+unittest
+{
+    double[] p = [ 0.0, 0, 0, 1 ];
+    assert(entropy(p) == 0);
+    p = [ 0.25, 0.25, 0.25, 0.25 ];
+    assert(entropy(p) == 2);
+    assert(entropy(p, 1) == 1);
+}
+
+/**
+Computes the $(LUCKY Kullback-Leibler divergence) between input ranges
+$(D a) and $(D b), which is the sum $(D ai * log(ai / bi)). The base
+of logarithm is 2. The ranges are assumed to contain elements in $(D
+[0, 1]). Usually the ranges are normalized probability distributions,
+but this is not required or checked by $(D
+kullbackLeiblerDivergence). If any element of $(D b) is zero, returns
+infinity. If the inputs are normalized, the result is positive.
+ */
+CommonType!(ElementType!Range1, ElementType!Range2)
+kullbackLeiblerDivergence(Range1, Range2)(Range1 a, Range2 b)
+    if (isInputRange!(Range1) && isInputRange!(Range2))
+{
+    enum bool haveLen = hasLength!(Range1) && hasLength!(Range2);
+    static if (haveLen) enforce(a.length == b.length);
+    FPTemporary!(typeof(return)) result = 0;
+    for (; !a.empty; a.popFront, b.popFront)
+    {
+        immutable t1 = a.front;
+        if (t1 == 0) continue;
+        immutable t2 = b.front;
+        if (t2 == 0) return result.infinity;
+        assert(t1 > 0 && t2 > 0);
+        result += t1 * log2(t1 / t2);
+    }
+    static if (!haveLen) enforce(b.empty);
+    return result;
+}
+
+unittest
+{
+    double[] p = [ 0.0, 0, 0, 1 ];
+    assert(kullbackLeiblerDivergence(p, p) == 0);
+    double[] p1 = [ 0.25, 0.25, 0.25, 0.25 ];
+    assert(kullbackLeiblerDivergence(p1, p1) == 0);
+    assert(kullbackLeiblerDivergence(p, p1) == 2);
+    assert(kullbackLeiblerDivergence(p1, p) == double.infinity);
+    double[] p2 = [ 0.2, 0.2, 0.2, 0.4 ];
+    assert(approxEqual(kullbackLeiblerDivergence(p1, p2), 0.0719281));
+    assert(approxEqual(kullbackLeiblerDivergence(p2, p1), 0.0780719));
+}
+
+/**
+Computes the $(LUCKY Jensen-Shannon divergence) between $(D a) and $(D
+b), which is the sum $(D (ai * log(2 * ai / (ai + bi)) + bi * log(2 *
+bi / (ai + bi))) / 2). The base of logarithm is 2. The ranges are
+assumed to contain elements in $(D [0, 1]). Usually the ranges are
+normalized probability distributions, but this is not required or
+checked by $(D jensenShannonDivergence). If the inputs are normalized,
+the result is bounded within $(D [0, 1]). The three-parameter version
+stops evaluations as soon as the intermediate result is greater than
+or equal to $(D limit).
+ */
+CommonType!(ElementType!Range1, ElementType!Range2)
+jensenShannonDivergence(Range1, Range2)(Range1 a, Range2 b)
+    if (isInputRange!Range1 && isInputRange!Range2)
+{
+    enum bool haveLen = hasLength!(Range1) && hasLength!(Range2);
+    static if (haveLen) enforce(a.length == b.length);
+    FPTemporary!(typeof(return)) result = 0;
+    for (; !a.empty; a.popFront, b.popFront)
+    {
+        immutable t1 = a.front;
+        immutable t2 = b.front;
+        immutable avg = (t1 + t2) / 2;
+        if (t1 != 0)
+        {
+            result += t1 * log2(t1 / avg);
+        }
+        if (t2 != 0)
+        {
+            result += t2 * log2(t2 / avg);
+        }
+    }
+    static if (!haveLen) enforce(b.empty);
+    return result / 2;
+}
+
+/// Ditto
+CommonType!(ElementType!Range1, ElementType!Range2)
+jensenShannonDivergence(Range1, Range2, F)(Range1 a, Range2 b, F limit)
+   if (isInputRange!Range1 && isInputRange!Range2
+           && is(typeof(CommonType!(ElementType!Range1, ElementType!Range2).init
+                           >= F.init) : bool))
+{
+    enum bool haveLen = hasLength!(Range1) && hasLength!(Range2);
+    static if (haveLen) enforce(a.length == b.length);
+    FPTemporary!(typeof(return)) result = 0;
+    limit *= 2;
+    for (; !a.empty; a.popFront, b.popFront)
+    {
+        immutable t1 = a.front;
+        immutable t2 = b.front;
+        immutable avg = (t1 + t2) / 2;
+        if (t1 != 0)
+        {
+            result += t1 * log2(t1 / avg);
+        }
+        if (t2 != 0)
+        {
+            result += t2 * log2(t2 / avg);
+        }
+        if (result >= limit) break;
+    }
+    static if (!haveLen) enforce(b.empty);
+    return result / 2;
+}
+
+unittest
+{
+    double[] p = [ 0.0, 0, 0, 1 ];
+    assert(jensenShannonDivergence(p, p) == 0);
+    double[] p1 = [ 0.25, 0.25, 0.25, 0.25 ];
+    assert(jensenShannonDivergence(p1, p1) == 0);
+    assert(approxEqual(jensenShannonDivergence(p1, p), 0.548795));
+    double[] p2 = [ 0.2, 0.2, 0.2, 0.4 ];
+    assert(approxEqual(jensenShannonDivergence(p1, p2), 0.0186218));
+    assert(approxEqual(jensenShannonDivergence(p2, p1), 0.0186218));
+    assert(approxEqual(jensenShannonDivergence(p2, p1, 0.005), 0.00602366));
+}
+
+// template tabulateFixed(alias fun, uint n,
+//         real maxError, real left, real right)
+// {
+//     ReturnType!(fun) tabulateFixed(ParameterTypeTuple!(fun) arg)
+//     {
+//         alias ParameterTypeTuple!(fun)[0] num;
+//         static num[n] table;
+//         alias arg[0] x;
+//         enforce(left <= x && x < right);
+//         invariant i = cast(uint) (table.length
+//                 * ((x - left) / (right - left)));
+//         assert(i < n);
+//         if (isnan(table[i])) {
+//             // initialize it
+//             auto x1 = left + i * (right - left) / n;
+//             auto x2 = left + (i + 1) * (right - left) / n;
+//             invariant y1 = fun(x1), y2 = fun(x2);
+//             invariant y = 2 * y1 * y2 / (y1 + y2);
+//             num wyda(num xx) { return fun(xx) - y; }
+//             auto bestX = findRoot(&wyda, x1, x2);
+//             table[i] = fun(bestX);
+//             invariant leftError = abs((table[i] - y1) / y1);
+//             enforce(leftError <= maxError, text(leftError, " > ", maxError));
+//             invariant rightError = abs((table[i] - y2) / y2);
+//             enforce(rightError <= maxError, text(rightError, " > ", maxError));
+//         }
+//         return table[i];
+//     }
+// }
+
+// unittest
+// {
+//     enum epsilon = 0.01;
+//     alias tabulateFixed!(tanh, 700, epsilon, 0.2, 3) fasttanh;
+//     uint testSize = 100000;
+//     auto rnd = Random(unpredictableSeed);
+//     foreach (i; 0 .. testSize) {
+//         invariant x = uniform(rnd, 0.2F, 3.0F);
+//         invariant float y = fasttanh(x), w = tanh(x);
+//         invariant e = abs(y - w) / w;
+//         //writefln("%.20f", e);
+//         enforce(e <= epsilon, text("x = ", x, ", fasttanh(x) = ", y,
+//                         ", tanh(x) = ", w, ", relerr = ", e));
+//     }
+// }
+
+/**
+The so-called "all-lengths gap-weighted string kernel" computes a
+similarity measure between $(D s) and $(D t) based on all of their
+common subsequences of all lengths. Gapped subsequences are also
+included.
+
+To understand what $(D gapWeightedSimilarity(s, t, lambda)) computes,
+consider first the case $(D lambda = 1) and the strings $(D s =
+["Hello", "brave", "new", "world"]) and $(D t = ["Hello", "new",
+"world"]). In that case, $(D gapWeightedSimilarity) counts the
+following matches:
+
+$(OL $(LI three matches of length 1, namely $(D "Hello"), $(D "new"),
+and $(D "world");) $(LI three matches of length 2, namely ($(D
+"Hello", "new")), ($(D "Hello", "world")), and ($(D "new", "world"));)
+$(LI one match of length 3, namely ($(D "Hello", "new", "world")).))
+
+The call $(D gapWeightedSimilarity(s, t, 1)) simply counts all of
+these matches and adds them up, returning 7.
+
+----
+string[] s = ["Hello", "brave", "new", "world"];
+string[] t = ["Hello", "new", "world"];
+assert(gapWeightedSimilarity(s, t, 1) == 7);
+----
+
+Note how the gaps in matching are simply ignored, for example ($(D
+"Hello", "new")) is deemed as good a match as ($(D "new",
+"world")). This may be too permissive for some applications. To
+eliminate gapped matches entirely, use $(D lambda = 0):
+
+----
+string[] s = ["Hello", "brave", "new", "world"];
+string[] t = ["Hello", "new", "world"];
+assert(gapWeightedSimilarity(s, t, 0) == 4);
+----
+
+The call above eliminated the gapped matches ($(D "Hello", "new")),
+($(D "Hello", "world")), and ($(D "Hello", "new", "world")) from the
+tally. That leaves only 4 matches.
+
+The most interesting case is when gapped matches still participate in
+the result, but not as strongly as ungapped matches. The result will
+be a smooth, fine-grained similarity measure between the input
+strings. This is where values of $(D lambda) between 0 and 1 enter
+into play: gapped matches are $(I exponentially penalized with the
+number of gaps) with base $(D lambda). This means that an ungapped
+match adds 1 to the return value; a match with one gap in either
+string adds $(D lambda) to the return value; ...; a match with a total
+of $(D n) gaps in both strings adds $(D pow(lambda, n)) to the return
+value. In the example above, we have 4 matches without gaps, 2 matches
+with one gap, and 1 match with three gaps. The latter match is ($(D
+"Hello", "world")), which has two gaps in the first string and one gap
+in the second string, totaling to three gaps. Summing these up we get
+$(D 4 + 2 * lambda + pow(lambda, 3)).
+
+----
+string[] s = ["Hello", "brave", "new", "world"];
+string[] t = ["Hello", "new", "world"];
+assert(gapWeightedSimilarity(s, t, 0.5) == 4 + 0.5 * 2 + 0.125);
+----
+
+$(D gapWeightedSimilarity) is useful wherever a smooth similarity
+measure between sequences allowing for approximate matches is
+needed. The examples above are given with words, but any sequences
+with elements comparable for equality are allowed, e.g. characters or
+numbers. $(D gapWeightedSimilarity) uses a highly optimized dynamic
+programming implementation that needs $(D 16 * min(s.length,
+t.length)) extra bytes of memory and $(BIGOH s.length * t.length) time
+to complete.
+ */
+F gapWeightedSimilarity(alias comp = "a == b", R1, R2, F)(R1 s, R2 t, F lambda)
+    if (isRandomAccessRange!(R1) && hasLength!(R1)
+            && isRandomAccessRange!(R2) && hasLength!(R2))
+{
+    if (s.length < t.length) return gapWeightedSimilarity(t, s, lambda);
+    if (!t.length) return 0;
+    immutable tl1 = t.length + 1;
+    auto dpvi = enforce(cast(F*) malloc(F.sizeof * 2 * t.length));
+    auto dpvi1 = dpvi + t.length;
+    scope(exit) free(dpvi < dpvi1 ? dpvi : dpvi1);
+    dpvi[0 .. t.length] = 0;
+    dpvi1[0] = 0;
+    immutable lambda2 = lambda * lambda;
+
+    F result = 0;
+    foreach (i; 0 .. s.length)
+    {
+        const si = s[i];
+        for (size_t j = 0;;)
+        {
+            F dpsij = void;
+            if (binaryFun!(comp)(si, t[j]))
+            {
+                dpsij = 1 + dpvi[j];
+                result += dpsij;
+            }
+            else
+            {
+                dpsij = 0;
+            }
+            immutable j1 = j + 1;
+            if (j1 == t.length) break;
+            dpvi1[j1] = dpsij + lambda * (dpvi1[j] + dpvi[j1])
+                - lambda2 * dpvi[j];
+            j = j1;
+        }
+        swap(dpvi, dpvi1);
+    }
+    return result;
+}
+
+unittest
+{
+    string[] s = ["Hello", "brave", "new", "world"];
+    string[] t = ["Hello", "new", "world"];
+    assert(gapWeightedSimilarity(s, t, 1) == 7);
+    assert(gapWeightedSimilarity(s, t, 0) == 4);
+    assert(gapWeightedSimilarity(s, t, 0.5) == 4 + 2 * 0.5 + 0.125);
+}
+
+/**
+The similarity per $(D gapWeightedSimilarity) has an issue in that it
+grows with the lengths of the two strings, even though the strings are
+not actually very similar. For example, the range $(D ["Hello",
+"world"]) is increasingly similar with the range $(D ["Hello",
+"world", "world", "world",...]) as more instances of $(D "world") are
+appended. To prevent that, $(D gapWeightedSimilarityNormalized)
+computes a normalized version of the similarity that is computed as
+$(D gapWeightedSimilarity(s, t, lambda) /
+sqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t,
+lambda))). The function $(D gapWeightedSimilarityNormalized) (a
+so-called normalized kernel) is bounded in $(D [0, 1]), reaches $(D 0)
+only for ranges that don't match in any position, and $(D 1) only for
+identical ranges.
+
+Example:
+----
+string[] s = ["Hello", "brave", "new", "world"];
+string[] t = ["Hello", "new", "world"];
+assert(gapWeightedSimilarity(s, s, 1) == 15);
+assert(gapWeightedSimilarity(t, t, 1) == 7);
+assert(gapWeightedSimilarity(s, t, 1) == 7);
+assert(gapWeightedSimilarityNormalized(s, t, 1) ==
+7. / sqrt(15. * 7));
+----
+
+The optional parameters $(D sSelfSim) and $(D tSelfSim) are meant for
+avoiding duplicate computation. Many applications may have already
+computed $(D gapWeightedSimilarity(s, s, lambda)) and/or $(D
+gapWeightedSimilarity(t, t, lambda)). In that case, they can be passed
+as $(D sSelfSim) and $(D tSelfSim), respectively.
+ */
+Select!(isFloatingPoint!(F), F, double)
+gapWeightedSimilarityNormalized
+(alias comp = "a == b", R1, R2, F)(R1 s, R2 t, F lambda,
+        F sSelfSim = F.init, F tSelfSim = F.init)
+    if (isRandomAccessRange!(R1) && hasLength!(R1)
+            && isRandomAccessRange!(R2) && hasLength!(R2))
+{
+    static bool uncomputed(F n)
+    {
+        static if (isFloatingPoint!(F)) return isnan(n);
+        else return n == n.init;
+    }
+    if (uncomputed(sSelfSim))
+        sSelfSim = gapWeightedSimilarity!(comp)(s, s, lambda);
+    if (sSelfSim == 0) return 0;
+    if (uncomputed(tSelfSim))
+        tSelfSim = gapWeightedSimilarity!(comp)(t, t, lambda);
+    if (tSelfSim == 0) return 0;
+    return gapWeightedSimilarity!(comp)(s, t, lambda)
+        / sqrt(cast(typeof(return)) sSelfSim * tSelfSim);
+}
+
+unittest
+{
+    string[] s = ["Hello", "brave", "new", "world"];
+    string[] t = ["Hello", "new", "world"];
+    assert(gapWeightedSimilarity(s, s, 1) == 15);
+    assert(gapWeightedSimilarity(t, t, 1) == 7);
+    assert(gapWeightedSimilarity(s, t, 1) == 7);
+    assert(approxEqual(gapWeightedSimilarityNormalized(s, t, 1),
+                    7. / sqrt(15. * 7), 0.01));
+}
+
+/**
+Similar to $(D gapWeightedSimilarity), just works in an incremental
+manner by first revealing the matches of length 1, then gapped matches
+of length 2, and so on. The memory requirement is $(BIGOH s.length *
+t.length). The time complexity is $(BIGOH s.length * t.length) time
+for computing each step. Continuing on the previous example:
+
+----
+string[] s = ["Hello", "brave", "new", "world"];
+string[] t = ["Hello", "new", "world"];
+auto simIter = gapWeightedSimilarityIncremental(s, t, 1);
+assert(simIter.front == 3); // three 1-length matches
+simIter.popFront;
+assert(simIter.front == 3); // three 2-length matches
+simIter.popFront;
+assert(simIter.front == 1); // one 3-length match
+simIter.popFront;
+assert(simIter.empty);     // no more match
+----
+
+The implementation is based on the pseudocode in Fig. 4 of the paper
+$(WEB jmlr.csail.mit.edu/papers/volume6/rousu05a/rousu05a.pdf,
+"Efcient Computation of Gapped Substring Kernels on Large Alphabets")
+by Rousu et al., with additional algorithmic and systems-level
+optimizations.
+ */
+struct GapWeightedSimilarityIncremental(Range, F = double)
+    if (isRandomAccessRange!(Range) && hasLength!(Range))
+{
+private:
+    Range s, t;
+    F currentValue = 0;
+    F * kl;
+    size_t gram = void;
+    F lambda = void, lambda2 = void;
+
+public:
+/**
+Constructs an object given two ranges $(D s) and $(D t) and a penalty
+$(D lambda). Constructor completes in $(BIGOH s.length * t.length)
+time and computes all matches of length 1.
+ */
+    this(Range s, Range t, F lambda) {
+        enforce(lambda > 0);
+        this.lambda = lambda;
+        this.lambda2 = lambda * lambda; // for efficiency only
+
+        size_t iMin = size_t.max, jMin = size_t.max,
+            iMax = 0, jMax = 0;
+        /* initialize */
+        Tuple!(uint, uint) * k0;
+        size_t k0len;
+        scope(exit) free(k0);
+        currentValue = 0;
+        foreach (i, si; s) {
+            foreach (j; 0 .. t.length) {
+                if (si != t[j]) continue;
+                k0 = cast(typeof(k0))
+                    realloc(k0, ++k0len * (*k0).sizeof);
+                with (k0[k0len - 1]) {
+                    field[0] = i;
+                    field[1] = j;
+                }
+                // Maintain the minimum and maximum i and j
+                if (iMin > i) iMin = i;
+                if (iMax < i) iMax = i;
+                if (jMin > j) jMin = j;
+                if (jMax < j) jMax = j;
+            }
+        }
+        
+        if (iMin > iMax) return;        
+        assert(k0len);
+
+        currentValue = k0len;
+        // Chop strings down to the useful sizes
+        s = s[iMin .. iMax + 1];
+        t = t[jMin .. jMax + 1];
+        this.s = s;
+        this.t = t;
+
+        // Si = errnoEnforce(cast(F *) malloc(t.length * F.sizeof));
+        kl = errnoEnforce(cast(F *) malloc(s.length * t.length * F.sizeof));
+
+        kl[0 .. s.length * t.length] = 0;
+        foreach (pos; 0 .. k0len) {
+            with (k0[pos]) {
+                kl[(field[0] - iMin) * t.length + field[1] -jMin] = lambda2;
+            }
+        }
+    }
+
+/**
+Returns $(D this).
+ */
+    ref GapWeightedSimilarityIncremental opSlice()
+    {
+        return this;
+    }
+
+/**
+Computes the match of the popFront length. Completes in $(BIGOH s.length *
+t.length) time.
+ */ 
+    void popFront() {
+        // This is a large source of optimization: if similarity at
+        // the gram-1 level was 0, then we can safely assume
+        // similarity at the gram level is 0 as well.
+        if (empty) return;
+        
+        // Now attempt to match gapped substrings of length `gram'
+        ++gram;
+        currentValue = 0;
+
+        auto Si = cast(F*) alloca(t.length * F.sizeof);
+        Si[0 .. t.length] = 0;
+        foreach (i; 0 .. s.length)
+        {
+            const si = s[i];
+            F Sij_1 = 0;
+            F Si_1j_1 = 0;
+            auto kli = kl + i * t.length;
+            for (size_t j = 0;;)
+            {
+                const klij = kli[j];
+                const Si_1j = Si[j];
+                const tmp = klij + lambda * (Si_1j + Sij_1) - lambda2 * Si_1j_1;
+                // now update kl and currentValue
+                if (si == t[j])
+                    currentValue += kli[j] = lambda2 * Si_1j_1;
+                else
+                    kli[j] = 0;
+                // commit to Si
+                Si[j] = tmp;
+                if (++j == t.length) break;
+                // get ready for the popFront step; virtually increment j,
+                // so essentially stuffj_1 <-- stuffj
+                Si_1j_1 = Si_1j;
+                Sij_1 = tmp;
+            }
+        }
+        currentValue /= pow(lambda, 2 * (gram + 1));
+        
+        version (none)
+        {
+            Si_1[0 .. t.length] = 0;
+            kl[0 .. min(t.length, maxPerimeter + 1)] = 0;
+            foreach (i; 1 .. min(s.length, maxPerimeter + 1)) {
+                auto kli = kl + i * t.length;
+                assert(s.length > i);
+                const si = s[i];
+                auto kl_1i_1 = kl_1 + (i - 1) * t.length;
+                kli[0] = 0;
+                F lastS = 0;
+                foreach (j; 1 .. min(maxPerimeter - i + 1, t.length)) {
+                    immutable j_1 = j - 1;
+                    immutable tmp = kl_1i_1[j_1]
+                        + lambda * (Si_1[j] + lastS)
+                        - lambda2 * Si_1[j_1];
+                    kl_1i_1[j_1] = float.nan;
+                    Si_1[j_1] = lastS;
+                    lastS = tmp;
+                    if (si == t[j]) {
+                        currentValue += kli[j] = lambda2 * lastS;
+                    } else {
+                        kli[j] = 0;
+                    }
+                }
+                Si_1[t.length - 1] = lastS;
+            }
+            currentValue /= pow(lambda, 2 * (gram + 1));
+            // get ready for the popFront computation
+            swap(kl, kl_1);
+        }
+    }
+
+/**
+Returns the gapped similarity at the current match length (initially
+1, grows with each call to $(D popFront)).
+ */
+    F front() { return currentValue; }
+
+/**
+Returns whether there are more matches.
+ */
+    bool empty() {
+        if (currentValue) return false;
+        if (kl) {
+            free(kl);
+            kl = null;
+        }
+        return true;
+    }
+}
+
+/**
+Ditto
+ */
+GapWeightedSimilarityIncremental!(R, F) gapWeightedSimilarityIncremental(R, F)
+(R r1, R r2, F penalty)
+{
+    return typeof(return)(r1, r2, penalty);
+}
+
+unittest
+{
+    string[] s = ["Hello", "brave", "new", "world"];
+    string[] t = ["Hello", "new", "world"];
+    auto simIter = gapWeightedSimilarityIncremental(s, t, 1.0);
+    //foreach (e; simIter) writeln(e);
+    assert(simIter.front == 3); // three 1-length matches
+    simIter.popFront;
+    assert(simIter.front == 3, text(simIter.front)); // three 2-length matches
+    simIter.popFront;
+    assert(simIter.front == 1); // one 3-length matches
+    simIter.popFront;
+    assert(simIter.empty);     // no more match
+
+    s = ["Hello"];
+    t = ["bye"];
+    simIter = gapWeightedSimilarityIncremental(s, t, 0.5);
+    assert(simIter.empty);
+
+    s = ["Hello"];
+    t = ["Hello"];
+    simIter = gapWeightedSimilarityIncremental(s, t, 0.5);
+    assert(simIter.front == 1); // one match
+    simIter.popFront;
+    assert(simIter.empty);
+
+    s = ["Hello", "world"];
+    t = ["Hello"];
+    simIter = gapWeightedSimilarityIncremental(s, t, 0.5);
+    assert(simIter.front == 1); // one match
+    simIter.popFront;
+    assert(simIter.empty);
+
+    s = ["Hello", "world"];
+    t = ["Hello", "yah", "world"];
+    simIter = gapWeightedSimilarityIncremental(s, t, 0.5);
+    assert(simIter.front == 2); // two 1-gram matches
+    simIter.popFront;
+    assert(simIter.front == 0.5, text(simIter.front)); // one 2-gram match, 1 gap
+}
+
+unittest
+{
+    GapWeightedSimilarityIncremental!(string[]) sim =
+        GapWeightedSimilarityIncremental!(string[])(
+            ["nyuk", "I", "have", "no", "chocolate", "giba"],
+            ["wyda", "I", "have", "I", "have", "have", "I", "have", "hehe"],
+            0.5);
+    double witness[] = [ 7., 4.03125, 0, 0 ];
+    foreach (e; sim)
+    {
+        //writeln(e);
+        assert(e == witness.front);
+        witness.popFront;
+    }
+    witness = [ 3., 1.3125, 0.25 ];
+    sim = GapWeightedSimilarityIncremental!(string[])(
+        ["I", "have", "no", "chocolate"],
+        ["I", "have", "some", "chocolate"],
+        0.5);
+    foreach (e; sim)
+    {
+        //writeln(e);
+        assert(e == witness.front);
+        witness.popFront;
+    }
+    assert(witness.empty);
+}
+
+/*
+ *  Copyright (C) 2004-2009 by Digital Mars, www.digitalmars.com
+ *  Written by Andrei Alexandrescu, www.erdani.org
+ *
+ *  This software is provided 'as-is', without any express or implied
+ *  warranty. In no event will the authors be held liable for any damages
+ *  arising from the use of this software.
+ *
+ *  Permission is granted to anyone to use this software for any purpose,
+ *  including commercial applications, and to alter it and redistribute it
+ *  freely, subject to the following restrictions:
+ *
+ *  o  The origin of this software must not be misrepresented; you must not
+ *     claim that you wrote the original software. If you use this software
+ *     in a product, an acknowledgment in the product documentation would be
+ *     appreciated but is not required.
+ *  o  Altered source versions must be plainly marked as such, and must not
+ *     be misrepresented as being the original software.
+ *  o  This notice may not be removed or altered from any source
+ *     distribution.
+ */
+/+
+/**
+Primes generator
+*/
+struct Primes(UIntType)
+{
+    private UIntType[] found = [ 2 ];
+
+    UIntType front() { return found[$ - 1]; }
+
+    void popFront()
+    {
+      outer:
+        for (UIntType candidate = front + 1 + (front != 2); ; candidate += 2)
+        {
+            UIntType stop = cast(uint) sqrt(cast(double) candidate);
+            foreach (e; found)
+            {
+                if (e > stop) break;
+                if (candidate % e == 0) continue outer;
+            }
+            // found!
+            found ~= candidate;
+            break;
+        }
+    }
+
+    enum bool empty = false;
+}
+
+unittest
+{
+    foreach (e; take(10, Primes!(uint)())) writeln(e);
+}
++/
diff -r f12bfe124807 d/phobos2/std/openrj.d
--- a/d/phobos2/std/openrj.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/openrj.d	Thu Oct 14 14:12:53 2010 +0100
@@ -1069,8 +1069,7 @@
             try
             {
                 printf( "std.openrj test:\n\tmodule:      \t%.*s\n\tdescription: \t%.*s\n\tversion:     \t%d.%d.%d.%d\n"
-                    ,   cast(int) std.openrj.VERSION.name.length
-                    ,   std.openrj.VERSION.name.ptr
+                    ,   std.openrj.VERSION.name
                     ,   std.openrj.VERSION.description
                     ,   std.openrj.VERSION.major
                     ,   std.openrj.VERSION.minor
@@ -1115,18 +1114,14 @@
                     printf("  Record\n");
                     foreach(Field field; record.fields)
                     {
-                        printf("    Field: %.*s=%.*s\n",
-			    cast(int) field.name.length, field.name.ptr,
-			    cast(int) field.value.length, field.value.ptr);
+                        printf("    Field: %.*s=%.*s\n", field.name, field.value);
                     }
                 }
 
                 printf("Fields (%u)\n", database.numFields);
                 foreach(Field field; database)
                 {
-                        printf("    Field: %.*s=%.*s\n",
-			    cast(int) field.name.length, field.name.ptr,
-			    cast(int) field.value.length, field.value.ptr);
+                        printf("    Field: %.*s=%.*s\n", field.name, field.value);
                 }
 
                 Record[]    records =   database.getRecordsContainingField("Name");
@@ -1136,16 +1131,13 @@
                     printf("  Record\n");
                     foreach(Field field; record.fields)
                     {
-                        printf("    Field: %.*s=%.*s\n",
-			    cast(int) field.name.length, field.name.ptr,
-			    cast(int) field.value.length, field.value.ptr);
+                        printf("    Field: %.*s=%.*s\n", field.name, field.value);
                     }
                 }
             }
             catch(Exception x)
             {
-                char[] s = x.toString();
-                printf("Exception: %.*s\n", cast(int) s.length, s.ptr);
+                printf("Exception: %.*s\n", x.toString());
             }
         }
 
diff -r f12bfe124807 d/phobos2/std/outbuffer.d
--- a/d/phobos2/std/outbuffer.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/outbuffer.d	Thu Oct 14 14:12:53 2010 +0100
@@ -16,9 +16,7 @@
 
 /* NOTE: This file has been patched from the original DMD distribution to
    work with the GDC compiler.
-
-   Modified by David Friedman, September 2004
-*/
+ */
 
 module std.outbuffer;
 
@@ -43,7 +41,7 @@
 class OutBuffer
 {
     ubyte data[];
-    size_t offset;
+    uint offset;
 
     invariant()
     {
@@ -71,7 +69,7 @@
      */
 
 
-    void reserve(size_t nbytes)
+    void reserve(uint nbytes)
 	in
 	{
 	    assert(offset + nbytes >= offset);
@@ -101,6 +99,16 @@
 	    offset += bytes.length;
 	}
 
+    void write(in wchar[] chars)
+	{
+        write(cast(ubyte[]) chars);
+	}
+
+    void write(const(dchar)[] chars)
+	{
+        write(cast(ubyte[]) chars);
+	}
+
     void write(ubyte b)		/// ditto
 	{
 	    reserve(ubyte.sizeof);
@@ -110,12 +118,13 @@
 
     void write(byte b) { write(cast(ubyte)b); }		/// ditto
     void write(char c) { write(cast(ubyte)c); }		/// ditto
+    void write(dchar c) { write(cast(uint)c); }		/// ditto
 
     void write(ushort w)		/// ditto
     {
-	reserve(ushort.sizeof);
-	*cast(ushort *)&data[offset] = w;
-	offset += ushort.sizeof;
+        reserve(ushort.sizeof);
+        *cast(ushort *)&data[offset] = w;
+        offset += ushort.sizeof;
     }
 
     void write(short s) { write(cast(ushort)s); }		/// ditto
@@ -166,14 +175,18 @@
 	offset += real.sizeof;
     }
 
-    void write(string s)		/// ditto
+    void write(in char[] s)		/// ditto
     {
-	write(cast(ubyte[])s);
+        write(cast(ubyte[])s);
     }
+    // void write(immutable(char)[] s)		/// ditto
+    // {
+    //     write(cast(ubyte[])s);
+    // }
 
     void write(OutBuffer buf)		/// ditto
     {
-	write(buf.toBytes());
+        write(buf.toBytes());
     }
 
     /****************************************
@@ -191,7 +204,7 @@
      * 0-fill to align on power of 2 boundary.
      */
 
-    void alignSize(size_t alignsize)
+    void alignSize(uint alignsize)
     in
     {
 	assert(alignsize && (alignsize & (alignsize - 1)) == 0);
@@ -201,7 +214,7 @@
 	assert((offset & (alignsize - 1)) == 0);
     }
     body
-    {   size_t nbytes;
+    {   uint nbytes;
 
 	nbytes = offset & (alignsize - 1);
 	if (nbytes)
@@ -225,7 +238,7 @@
     void align4()
     {
 	if (offset & 3)
-	{   size_t nbytes = (4 - offset) & 3;
+	{   uint nbytes = (4 - offset) & 3;
 	    fill0(nbytes);
 	}
     }
@@ -250,35 +263,23 @@
 	char* p;
 	uint psize;
 	int count;
-	va_list args_copy;
 
 	auto f = toStringz(format);
 	p = buffer.ptr;
 	psize = buffer.length;
 	for (;;)
 	{
-	    va_copy(args_copy, args);
 	    version(Win32)
 	    {
-		count = _vsnprintf(p,psize,f,args_copy);
+		count = _vsnprintf(p,psize,f,args);
 		if (count != -1)
 		    break;
 		psize *= 2;
 		p = cast(char *) alloca(psize);	// buffer too small, try again with larger size
 	    }
-	    else version(GNU) {
-		count = vsnprintf(p,psize,f,args_copy);
-		if (count == -1)
-		    psize *= 2;
-		else if (count >= psize)
-		    psize = count + 1;
-		else
-		    break;
-		p = cast(char *) alloca(psize);	// buffer too small, try again with larger size
-	    }
-	    else version(linux)
+	    version(Posix)
 	    {
-		count = vsnprintf(p,psize,f,args_copy);
+		count = vsnprintf(p,psize,f,args);
 		if (count == -1)
 		    psize *= 2;
 		else if (count >= psize)
@@ -327,7 +328,7 @@
      * all data past index.
      */
 
-    void spread(size_t index, size_t nbytes)
+    void spread(uint index, uint nbytes)
 	in
 	{
 	    assert(index <= offset);
@@ -337,7 +338,7 @@
 	    reserve(nbytes);
 
 	    // This is an overlapping copy - should use memmove()
-	    for (size_t i = offset; i > index; )
+	    for (uint i = offset; i > index; )
 	    {
 		--i;
 		data[i + nbytes] = data[i];
@@ -355,9 +356,9 @@
     //printf("buf = %p\n", buf);
     //printf("buf.offset = %x\n", buf.offset);
     assert(buf.offset == 0);
-    buf.write("hello");
+    buf.write("hello"[]);
     buf.write(cast(byte)0x20);
-    buf.write("world");
+    buf.write("world"[]);
     buf.printf(" %d", 6);
     //printf("buf = '%.*s'\n", buf.toString());
     assert(cmp(buf.toString(), "hello world 6") == 0);
diff -r f12bfe124807 d/phobos2/std/path.d
--- a/d/phobos2/std/path.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/path.d	Thu Oct 14 14:12:53 2010 +0100
@@ -12,7 +12,7 @@
  *
  * $(WEB digitalmars.com, Walter Bright), Grzegorz Adam Hankiewicz,
 Thomas K&uuml;hne, $(WEB erdani.org, Andrei Alexandrescu)
- * 
+ *
  * Macros:
  *	WIKI = Phobos/StdPath
  * Copyright:
@@ -21,25 +21,17 @@
  *
  */
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, March 2006
-*/
-
 module std.path;
 
 //debug=path;		// uncomment to turn on debugging printf's
 //private import std.stdio;
 
-private import std.string;
-private import std.file;
-private import std.contracts;
+import std.contracts, std.conv, std.file, std.process, std.string, std.traits;
+import core.stdc.errno, core.stdc.stdlib;
 
 version(Posix)
 {
-    private import std.c.stdlib;
-    private import std.c.unix.unix;
+    private import core.sys.posix.pwd;
     private import core.exception : onOutOfMemoryError;
 }
 
@@ -61,7 +53,7 @@
     invariant char[1] curdir = ".";	 /// String representing the current directory.
     invariant char[2] pardir = ".."; /// String representing the parent directory.
 }
-else version(Posix)
+version(Posix)
 {
     /** String used to separate directory names in a path. Under
      *  Windows this is a backslash, under Linux a slash. */
@@ -78,10 +70,6 @@
     invariant char[1] curdir = ".";	 /// String representing the current directory.
     invariant char[2] pardir = ".."; /// String representing the parent directory.
 }
-else
-{
-    static assert(1);
-}
 
 /*****************************
  * Compare file names.
@@ -140,7 +128,7 @@
 	    if (fullname[i] == ':' || fullname[i] == '\\')
 		break;
 	}
-	else version(Posix)
+	version(Posix)
 	{
 	    if (fullname[i] == '/')
 		break;
@@ -304,7 +292,7 @@
 		if (fullname[i - 1] == ':' || fullname[i - 1] == '\\')
 		    break;
 	    }
-	    else version(Posix)
+	    version(Posix)
 	    {
 		if (fullname[i - 1] == '/')
 		    break;
@@ -341,10 +329,9 @@
     version (Posix)
 	result = basename("a/b.cde", ".cde");
     assert(result == "b");
- 
+
 }
 
-
 /**************************
  * Extracts the directory part of a path.
  *
@@ -395,7 +382,7 @@
                 break;
             }
         }
-        else version(Posix)
+        version(Posix)
         {
             if (fullname[i - 1] == sep[0])
             {   i--;
@@ -403,7 +390,26 @@
             }
         }
     }
-    return i == 0 ? "." : fullname[0 .. i];
+    return i == 0 ? to!(Char[])(".") : fullname[0 .. i];
+}
+
+unittest
+{
+    assert(dirname("") == ".");
+    assert(dirname("fileonly") == ".");
+    version (Posix)
+    {
+        assert(dirname("/path/to/file") == "/path/to");
+    }
+    else
+    {
+        version (Win32)
+        {
+            assert(dirname(r"\path\to\file") == r"\path\to");
+            assert(dirname(r"\foo") == r"\");
+            assert(dirname(r"c:\foo") == r"c:\");
+        }
+    }
 }
 
 /** Alias for $(D_PARAM dirname), kept for backward
@@ -415,13 +421,6 @@
     string filename = "foo/bar";
     auto d = getDirName(filename);
     assert(d == "foo");
-
-    version (Win32)
-    {
-	assert(dirname(r"\path\to\file") == r"\path\to");
-	assert(dirname(r"\foo") == r"\");
-	assert(dirname(r"c:\foo") == r"c:\");
-    }
 }
 
 /********************************
@@ -442,27 +441,28 @@
  * -----
  */
 
-string getDrive(string fullname)
-    out (result)
-    {
-	assert(result.length <= fullname.length);
-    }
-    body
-    {
+String getDrive(String)(String fullname) if (isSomeString!(String))
+// @@@ BUG 2799
+// out(result)
+// {
+//     assert(result.length <= fullname.length);
+// }
+body
+{
 	version(Win32)
 	{
-	    for (size_t i = 0; i < fullname.length; i++)
+	    foreach (i; 0 .. fullname.length)
 	    {
-		if (fullname[i] == ':')
-		    return fullname[0 .. i + 1];
+            if (fullname[i] == ':')
+                return fullname[0 .. i + 1];
 	    }
 	    return null;
 	}
-	else version(Posix)
+	version(Posix)
 	{
 	    return null;
 	}
-    }
+}
 
 /****************************
  * Appends a default extension to a filename.
@@ -571,7 +571,7 @@
  * -----
  */
 
-bool isabs(string path)
+bool isabs(in char[] path)
 {
     auto d = getDrive(path);
     version (Windows)
@@ -666,63 +666,63 @@
  * -----
  */
 
-string join(string p1, string p2, string[] more...)
+string join(in char[] p1, in char[] p2, in char[][] more...)
 {
-  version (Posix)
-  {
-    if (!more.length)
+    version (Posix)
     {
-        if (isabs(p2)) return p2;
-        if (p1.endsWith(sep) || altsep.length && p1.endsWith(altsep))
+        if (!more.length)
         {
-            return p1 ~ p2;
+            if (isabs(p2)) return p2.idup;
+            if (p1.endsWith(sep) || altsep.length && p1.endsWith(altsep))
+            {
+                return cast(string) (p1 ~ p2);
+            }
+            return cast(string) (p1 ~ sep ~ p2);
         }
-        return p1 ~ sep ~ p2;
+        // more components present
+        return join(join(p1, p2), more[0], more[1 .. $]);
     }
-    // more components present
-    return join(join(p1, p2), more[0], more[1 .. $]);
-  }
-  else version (Windows)
-  { // The other version fails unit testing when under windows
-    if (!p2.length)
-        return p1;
-    if (!p1.length)
-        return p2;
+    version (Windows)
+    { // The other version fails unit testing when under windows
+        if (!p2.length)
+            return p1.idup;
+        if (!p1.length)
+            return p2.idup;
 
-    string p;
-    string d1;
+        string p;
+        const(char)[] d1;
 
-    if (getDrive(p2))
-    {
-	p = p2;
+        if (getDrive(p2))
+        {
+            p = p2.idup;
+        }
+        else
+        {
+            d1 = getDrive(p1);
+            if (p1.length == d1.length)
+            {
+                p = cast(string) (p1 ~ p2);
+            }
+            else if (p2[0] == '\\')
+            {
+                if (d1.length == 0)
+                    p = p2.idup;
+                else if (p1[p1.length - 1] == '\\')
+                    p = cast(string) (p1 ~ p2[1 .. p2.length]);
+                else
+                    p = cast(string) (p1 ~ p2);
+            }
+            else if (p1[p1.length - 1] == '\\')
+            {
+                p = cast(string) (p1 ~ p2);
+            }
+            else
+            {
+                p = cast(string)(p1 ~ sep ~ p2);
+            }
+        }
+        return p;
     }
-    else
-    {
-	d1 = getDrive(p1);
-	if (p1.length == d1.length)
-	{
-	    p = p1 ~ p2;
-	}
-	else if (p2[0] == '\\')
-	{
-	    if (d1.length == 0)
-		p = p2;
-	    else if (p1[p1.length - 1] == '\\')
-		p = p1 ~ p2[1 .. p2.length];
-	    else
-		p = p1 ~ p2;
-	}
-	else if (p1[p1.length - 1] == '\\')
-	{
-	    p = p1 ~ p2;
-	}
-	else
-	{
-	    p = cast(string)(p1 ~ sep ~ p2);
-	}
-    }
-    return p;
-  }
 }
 
 unittest
@@ -845,17 +845,10 @@
 	}
 	return true;
     }
-    else version (Posix)
+    version (Posix)
     {
 	return c1 == c2;
     }
-    /* this is filesystem-dependent, figure out the filesystem?
-    else version (GNU)
-    {
-	// %% figure out filesystem?
-	return c1 == c2;
-    }
-    */
 }
 
 /************************************
@@ -905,7 +898,7 @@
  * -----
  */
 
-bool fnmatch(string filename, string pattern)
+bool fnmatch(in char[] filename, in char[] pattern)
     in
     {
 	// Verify that pattern[] is valid
@@ -932,9 +925,8 @@
     body
     {
 	char nc;
-	int not;
+        int not;
 	int anymatch;
-
 	int ni;       // ni == name index
 	foreach (pi; 0 .. pattern.length) // pi == pattern index
 	{
@@ -1116,37 +1108,33 @@
     version (Posix)
     {
 	// Retrieve the current home variable.
-	char* c_home = getenv("HOME");
+        auto c_home = std.process.getenv("HOME");
 
-	// Testing when there is no environment variable.
-	unsetenv("HOME");
-	assert(expandTilde("~/") == "~/");
-	assert(expandTilde("~") == "~");
-
-	// Testing when an environment variable is set.
-	int ret = setenv("HOME", "dmd/test\0", 1);
-	assert(ret == 0);
-	assert(expandTilde("~/") == "dmd/test/");
-	assert(expandTilde("~") == "dmd/test");
-
-	// The same, but with a variable ending in a slash.
-	ret = setenv("HOME", "dmd/test/\0", 1);
-	assert(ret == 0);
-	assert(expandTilde("~/") == "dmd/test/");
-	assert(expandTilde("~") == "dmd/test");
-
-	// Recover original HOME variable before continuing.
-	if (c_home)
-	    setenv("HOME", c_home, 1);
-	else
-	    unsetenv("HOME");
-
-	// Test user expansion for root. Are there unices without /root?
-	/*
-	assert(expandTilde("~root") == "/root");
-	assert(expandTilde("~root/") == "/root/");
-	*/
-	assert(expandTilde("~Idontexist/hey") == "~Idontexist/hey");
+        // Testing when there is no environment variable.
+        unsetenv("HOME");
+        assert(expandTilde("~/") == "~/");
+        assert(expandTilde("~") == "~");
+        
+        // Testing when an environment variable is set.
+        std.process.setenv("HOME", "dmd/test\0", 1);
+        assert(expandTilde("~/") == "dmd/test/");
+        assert(expandTilde("~") == "dmd/test");
+        
+        // The same, but with a variable ending in a slash.
+        std.process.setenv("HOME", "dmd/test/\0", 1);
+        assert(expandTilde("~/") == "dmd/test/");
+        assert(expandTilde("~") == "dmd/test");
+        
+        // Recover original HOME variable before continuing.
+        if (c_home)
+            std.process.setenv("HOME", c_home, 1);
+        else
+            unsetenv("HOME");
+        
+        // Test user expansion for root. Are there unices without /root?
+        assert(expandTilde("~root") == "/root");
+        assert(expandTilde("~root/") == "/root/");
+        assert(expandTilde("~Idontexist/hey") == "~Idontexist/hey");
     }
 }
 
@@ -1160,9 +1148,9 @@
 {
     assert(path.length >= 1);
     assert(path[0] == '~');
-    
+
     // Get HOME and use that to replace the tilde.
-    char* home = getenv("HOME");
+    auto home = core.stdc.stdlib.getenv("HOME");
     if (home == null)
         return path;
 
@@ -1211,7 +1199,7 @@
 
     // Extract username, searching for path separator.
     string username;
-    ptrdiff_t last_char = find(path, sep[0]);
+    int last_char = find(path, sep[0]);
 
     if (last_char == -1)
     {
@@ -1223,10 +1211,7 @@
         username = path[1 .. last_char] ~ '\0';
     }
     assert(last_char > 1);
-    
-    version (GNU_Unix_Have_getpwnam_r)
-    {
-    
+
     // Reserve C memory for the getpwnam_r() function.
     passwd result;
     int extra_memory_size = 5 * 1024;
@@ -1240,8 +1225,8 @@
 
 	// Obtain info from database.
 	passwd *verify;
-	std.c.stdlib.setErrno(0);
-	if (getpwnam_r(username.ptr, &result, cast(char*) extra_memory, extra_memory_size,
+	setErrno(0);
+	if (getpwnam_r(cast(char*) username.ptr, &result, cast(char*) extra_memory, extra_memory_size,
 		&verify) == 0)
 	{
 	    // Failure if verify doesn't point at result.
@@ -1251,19 +1236,8 @@
 	    break;
 	}
 
-	switch (std.c.stdlib.getErrno()) {
-	case 0:
-	case ENOENT:
-	case ESRCH:
-	case EBADF:
-	case EPERM:
-	    goto Lnotfound;
-	case ERANGE:
-	    break;
-	default:
-	    // not just out of memory: EMFILE, ENFILE too
+	if (errno != ERANGE)
 	    goto Lerror;
-	}
 
 	// extra_memory isn't large enough
 	std.c.stdlib.free(extra_memory);
@@ -1282,22 +1256,6 @@
 	std.c.stdlib.free(extra_memory);
     onOutOfMemoryError();
     return null;
-
-    }
-    else
-    {
-	passwd * result;
-
-	/* This does not guarantee another thread will not
-	   use getpwnam at the same time */
-	synchronized {
-	    result = getpwnam(username);
-	}
-	
-	if (result)
-	    path = combineCPathWithDPath(result.pw_dir, path, last_char);
-	return path;
-    }
 }
 
 }
diff -r f12bfe124807 d/phobos2/std/perf.d
--- a/d/phobos2/std/perf.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/perf.d	Thu Oct 14 14:12:53 2010 +0100
@@ -17,11 +17,6 @@
  *
  * ////////////////////////////////////////////////////////////////////////// */
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, May 2008
-*/
 
 /** 
  * Platform-independent performance measurement and timing classes.
@@ -784,7 +779,20 @@
 }
 else version(Posix)
 {
-    private import std.c.unix.unix; // for timeval, timezone, and gettimeofday
+    extern (C)
+    {
+	private struct timeval
+	{
+	    int tv_sec;	   // The number of seconds, since Jan. 1, 1970, in the time value.
+	    int tv_usec;   // The number of microseconds in the time value.
+	};
+	private struct timezone
+	{
+	    int tz_minuteswest; // minutes west of Greenwich.
+	    int tz_dsttime;	// type of dst corrections to apply.
+	};
+	private void gettimeofday(timeval *tv, timezone *tz);
+    }
 
     /* ////////////////////////////////////////////////////////////////////////// */
 
diff -r f12bfe124807 d/phobos2/std/process.d
--- a/d/phobos2/std/process.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/process.d	Thu Oct 14 14:12:53 2010 +0100
@@ -25,11 +25,6 @@
  *  o  This notice may not be removed or altered from any source
  *     distribution.
  */
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, October 2004
-*/
 
 /**
 Authors:
@@ -42,13 +37,14 @@
 WIKI=Phobos/StdProcess
 */
 
-
 module std.process;
 
 private import std.c.stdlib;
 private import std.c.string;
+private import std.conv;
 private import std.string;
 private import std.c.process;
+private import core.stdc.errno;
 private import std.contracts;
 version (Windows)
 {
@@ -57,7 +53,7 @@
 }
 version (Posix)
 {
-    private import std.stdio : popen, readln, fclose;
+    private import std.stdio;
 }
 
 /**
@@ -67,7 +63,7 @@
    interpreter is found, and zero otherwise. If $(D command) is not
    null, returns -1 on error, or the exit status of command (which may
    in turn signal an error in command's execution).
- 
+
    Note: On Unix systems, the homonym C function (which is accessible
    to D programs as $(LINK2 std_c_process.html, std.c._system))
    returns a code in the same format as
@@ -125,7 +121,7 @@
 
     toAStringz(argv, argv_);
 
-    version(Posix)
+    version (Posix)
     {
         return _spawnvp(mode, toStringz(pathname), argv_);
     }
@@ -135,9 +131,10 @@
     }
 }
 
-version(Posix)
+version (Posix)
 {
-private import std.c.unix.unix;
+private import core.sys.posix.unistd;
+private import core.sys.posix.sys.wait;
 int _spawnvp(int mode, in char *pathname, in char **argv)
 {
     int retval = 0;
@@ -181,12 +178,12 @@
     }
 
 Lerror:
-    retval = getErrno;
+    retval = errno;
     char[80] buf = void;
     throw new Exception(
-        "Cannot spawn " ~ toString(pathname) ~ "; "
-                      ~ toString(_d_gnu_cbridge_strerror(retval, buf.ptr, buf.length))
-                      ~ " [errno " ~ toString(retval) ~ "]");
+        "Cannot spawn " ~ to!string(pathname) ~ "; "
+        ~ to!string(strerror_r(retval, buf.ptr, buf.length))
+        ~ " [errno " ~ to!string(retval) ~ "]");
 }   // _spawnvp
 private
 {
@@ -241,7 +238,7 @@
 /** ditto */
 int execvpe(in string pathname, in string[] argv, in string[] envp)
 {
-version(GNU_Need_execvpe)
+version(Posix)
 {
     // Is pathname rooted?
     if(pathname[0] == '/')
@@ -252,10 +249,11 @@
     else
     {
         // No, so must traverse PATHs, looking for first match
-	string[]    envPaths    =   std.string.split(std.string.toString(std.c.stdlib.getenv("PATH")), ":");
+        string[]    envPaths    =   std.string.split(
+            to!string(std.c.stdlib.getenv("PATH")), ":");
         int         iRet        =   0;
 
-        // Note: if any call to execve() succeeds, this process will cease 
+        // Note: if any call to execve() succeeds, this process will cease
         // execution, so there's no need to check the execve() result through
         // the loop.
 
@@ -273,7 +271,7 @@
         return iRet;
     }
 }
-else
+else version(Windows)
 {
     auto argv_ = cast(const(char)**)alloca((char*).sizeof * (1 + argv.length));
     auto envp_ = cast(const(char)**)alloca((char*).sizeof * (1 + envp.length));
@@ -282,12 +280,17 @@
     toAStringz(envp, envp_);
 
     return std.c.process.execvpe(toStringz(pathname), argv_, envp_);
+}
+else
+{
+    static assert(0);
 } // version
 }
 
 version(Posix)
 {
-    alias std.c.process.getpid getpid;
+    //alias std.c.process.getpid getpid;
+    import core.sys.posix.unistd : getpid;
 }
 else version (Windows)
 {
@@ -314,35 +317,33 @@
 */
 string shell(string cmd)
 {
-version (linux)
-{
-    auto f = enforce(popen(cmd, "r"), "Could not execute: "~cmd);
-    scope(failure) f is null || fclose(f);
-    char[] line;
-    string result;
-    while (readln(f, line))
+    version (linux)
     {
-        result ~= line;
+        File f;
+        f.popen(cmd, "r");
+        char[] line;
+        string result;
+        while (f.readln(line))
+        {
+            result ~= line;
+        }
+        f.close;
+        return result;
     }
-    auto error = fclose(f) != 0;
-    f = null;
-    enforce(!error, "Process \""~cmd~"\" finished in error.");
-    return result;
-}
-else
-{
-    enforce(false, "shell() function not yet implemented on Windows");
-    return null;
-}
+    else
+    {
+        enforce(false, "shell() function not yet implemented on Windows");
+        return null;
+    }
 }
 
 unittest
 {
-version (linux)
-{
-    auto x = shell("echo wyda");
-    assert(x == "wyda\n");
-}
+    version (linux)
+    {
+        auto x = shell("echo wyda");
+        assert(x == "wyda\n");
+    }
 }
 
 /**
@@ -364,7 +365,7 @@
 exception. Calls $(LINK2 std_c_stdlib.html#_setenv,
 std.c.stdlib._setenv) internally. */
 
-void setenv(in char[] name, in char[] value, bool overwrite)
+version(Posix) void setenv(in char[] name, in char[] value, bool overwrite)
 {
     errnoEnforce(
         std.c.stdlib.setenv(toStringz(name), toStringz(value), overwrite) == 0);
@@ -374,7 +375,7 @@
 Removes variable $(D name) from the environment. Calls $(LINK2
 std_c_stdlib.html#_unsetenv, std.c.stdlib._unsetenv) internally. */
 
-void unsetenv(in char[] name)
+version(Posix) void unsetenv(in char[] name)
 {
     errnoEnforce(std.c.stdlib.unsetenv(toStringz(name)) == 0);
 }
@@ -405,7 +406,7 @@
         else
         {
             string[]    dummy_env;
-            
+
             dummy_env ~= "VAL0=value";
             dummy_env ~= "VAL1=value";
 
@@ -420,7 +421,7 @@
 //          int i = execvp(args[1], args[1 .. args.length]);
             int i = execvpe(args[1], args[1 .. args.length], dummy_env);
 
-            printf("exec??() has returned! Error code: %d; errno: %d\n", i, /* std.c.stdlib.getErrno() */-1);
+            printf("exec??() has returned! Error code: %d; errno: %d\n", i, /* errno */-1);
 
             return 0;
         }
diff -r f12bfe124807 d/phobos2/std/random.d
--- a/d/phobos2/std/random.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/random.d	Thu Oct 14 14:12:53 2010 +0100
@@ -13,21 +13,20 @@
 is the $(D_PARAM Mt19937) generator, which derives its name from
 "$(WEB math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html, Mersenne
 Twister) with a period of 2 to the power of 19937". In
-memory-constrained situations, $(WEB
-en.wikipedia.org/wiki/Linear_congruential_generator, linear
-congruential) generators such as $(D MinstdRand0) and $(D MinstdRand)
-might be useful. The standard library provides an alias $(D_PARAM
-Random) for whichever generator it finds the most fit for the target
-environment.
-   
+memory-constrained situations, $(LUCKY linear congruential) generators
+such as $(D MinstdRand0) and $(D MinstdRand) might be useful. The
+standard library provides an alias $(D_PARAM Random) for whichever
+generator it considers the most fit for the target environment.
+
 Example:
 
 ----
+// Generate a uniformly-distributed integer in the range [0, 15)
+auto i = uniform(0, 15);
+// Generate a uniformly-distributed real in the range [0, 100$(RPAREN)
+// using a specific random generator
 Random gen;
-// Generate a uniformly-distributed integer in the range [0, 15]
-auto i = uniform!(int)(gen, 0, 15);
-// Generate a uniformly-distributed real in the range [0, 100$(RPAREN)
-auto r = uniform!(real)(gen, 0.0L, 100.0L);
+auto r = uniform(0.0L, 100.0L, gen);
 ----
 
 In addition to random number generators, this module features
@@ -52,34 +51,25 @@
 WIKI = Phobos/StdRandom
 */
 
-// random.d
-// www.digitalmars.com
-
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, September 2007
-*/
-
 module std.random;
 
-import std.stdio, std.math, std.c.time, std.traits, std.contracts, std.conv,
-    std.algorithm, std.process, std.date;
+import std.algorithm, std.c.time, std.contracts, std.conv, std.date, std.math,
+    std.numeric, std.process, std.range, std.stdio, std.traits;
 
 // Segments of the code in this file Copyright (c) 1997 by Rick Booth
 // From "Inner Loops" by Rick Booth, Addison-Wesley
 
 // Work derived from:
 
-/* 
+/*
    A C-program for MT19937, with initialization improved 2002/1/26.
    Coded by Takuji Nishimura and Makoto Matsumoto.
 
-   Before using, initialize the state by using init_genrand(seed)  
+   Before using, initialize the state by using init_genrand(seed)
    or init_by_array(init_key, key_length).
 
    Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
-   All rights reserved.                          
+   All rights reserved.
 
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
@@ -92,8 +82,8 @@
         notice, this list of conditions and the following disclaimer in the
         documentation and/or other materials provided with the distribution.
 
-     3. The names of its contributors may not be used to endorse or promote 
-        products derived from this software without specific prior written 
+     3. The names of its contributors may not be used to endorse or promote
+        products derived from this software without specific prior written
         permission.
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
@@ -118,54 +108,47 @@
 {
     extern(Windows) int QueryPerformanceCounter(ulong *count);
 }
-else version (Posix)
+
+version (Posix)
 {
-    private import std.c.unix.unix;
+    private import core.sys.posix.sys.time;
 }
 
 /**
-   Linear Congruential generator.
-*/
-
+Linear Congruential generator.
+ */
 struct LinearCongruentialEngine(UIntType, UIntType a, UIntType c, UIntType m)
 {
-/// Alias for the generated type $(D_PARAM UIntType).
-    alias UIntType ResultType;
-    static invariant
-    {
-        /// Does this generator have a fixed range? ($(D_PARAM true)).
-        bool hasFixedRange = true;
-        /// Lowest generated value.
-        ResultType min = ( c == 0 ? 1 : 0 );
-        /// Highest generated value.
-        ResultType max = m - 1;
+    /// Does this generator have a fixed range? ($(D_PARAM true)).
+    enum bool hasFixedRange = true;
+    /// Lowest generated value ($(D 1) if $(D c == 0), $(D 0) otherwise).
+    enum UIntType min = ( c == 0 ? 1 : 0 );
+    /// Highest generated value ($(D modulus - 1)).
+    enum UIntType max = m - 1;
 /**
-   The parameters of this distribution. The random number is $(D_PARAM x =
-        (x * a + c) % m).
-*/
-        UIntType
-            multiplier = a,
-            ///ditto
-            increment = c,
-            ///ditto
-            modulus = m;
-    }
-    
+The parameters of this distribution. The random number is $(D_PARAM x
+= (x * multipler + increment) % modulus).
+ */
+    enum UIntType multiplier = a;
+    ///ditto
+    enum UIntType increment = c;
+    ///ditto
+    enum UIntType modulus = m;
+
     static assert(isIntegral!(UIntType));
     static assert(m == 0 || a < m);
     static assert(m == 0 || c < m);
     static assert(m == 0 ||
-                  (cast(ulong)a * (m-1) + c) % m == (c < a ? c - a + m : c - a));
+            (cast(ulong)a * (m-1) + c) % m == (c < a ? c - a + m : c - a));
 
 /**
-     Constructs a $(D_PARAM LinearCongruentialEngine) generator.
-*/
-    /*static LinearCongruentialEngine opCall(UIntType x0 = 1)
+Constructs a $(D_PARAM LinearCongruentialEngine) generator seeded with
+$(D x0).
+ */
+    this(UIntType x0)
     {
-        LinearCongruentialEngine result;
-        result.seed(x0);
-        return result;
-    }*/
+        seed(x0);
+    }
 
 /**
    (Re)seeds the generator.
@@ -175,57 +158,66 @@
         static if (c == 0)
         {
             enforce(x0, "Invalid (zero) seed for "
-                    ~LinearCongruentialEngine.stringof);
+                    ~ LinearCongruentialEngine.stringof);
         }
         _x = modulus ? (x0 % modulus) : x0;
+        popFront;
     }
 
 /**
-   Returns the next number in the random sequence.
+   Advances the random sequence.
 */
-    UIntType next()
+    void popFront()
     {
-        static if (m) 
+        static if (m)
             _x = cast(UIntType) ((cast(ulong) a * _x + c) % m);
         else
             _x = a * _x + c;
-        return _x;
     }
 
 /**
-   Discards next $(D_PARAM n) samples.
+   Returns the current number in the random sequence.
 */
-    void discard(ulong n)
+    UIntType front()
     {
-        while (n--) next;
+        return _x;
     }
-
+/**
+Always $(D true) (random generators are infinite ranges).
+ */
+    enum bool empty = false;
+    
 /**
    Compares against $(D_PARAM rhs) for equality.
-*/
-    bool opEquals(LinearCongruentialEngine rhs)
+ */
+    bool opEquals(LinearCongruentialEngine rhs) const
     {
         return _x == rhs._x;
     }
-    
-    private UIntType _x = 1;
+
+    private UIntType _x = m ? a + c : (a + c) % m;
 };
 
 /**
-   Define $(D_PARAM LinearCongruentialEngine) generators with "good"
-   parameters.
+Define $(D_PARAM LinearCongruentialEngine) generators with well-chosen
+parameters. $(D MinstdRand0) implements Park and Miller's "minimal
+standard" $(WEB
+wikipedia.org/wiki/Park%E2%80%93Miller_random_number_generator,
+generator) that uses 16807 for the multiplier. $(D MinstdRand)
+implements a variant that has slightly better spectral behavior by
+using the multiplier 48271. Both generators are rather simplistic.
 
-   Example:
+Example:
 
-   ----
-   // seed with a constant
-   auto rnd0 = MinstdRand0(1);
-   auto n = rnd0.next; // same for each run
-   // Seed with an unpredictable value
-   rnd0.seed(unpredictableSeed);
-   n = rnd0.next; // different across runs
-   ----
-*/
+----
+// seed with a constant
+auto rnd0 = MinstdRand0(1);
+auto n = rnd0.popFront; // same for each run
+// Seed with an unpredictable value
+rnd0.seed(unpredictableSeed);
+n = rnd0.popFront; // different across runs
+----
+ */
 alias LinearCongruentialEngine!(uint, 16807, 0, 2147483647) MinstdRand0;
 /// ditto
 alias LinearCongruentialEngine!(uint, 48271, 0, 2147483647) MinstdRand;
@@ -239,73 +231,71 @@
         101027544,1457850878,1458777923,2007237709,823564440,1115438165,
         1784484492,74243042,114807987,1137522503,1441282327,16531729,
         823378840,143542612 ];
-    auto rnd0 = MinstdRand0(1);
+    //auto rnd0 = MinstdRand0(1);
+    MinstdRand0 rnd0;
     foreach (e; checking0)
     {
-        assert(rnd0.next == e);
+        assert(rnd0.front == e);
+        rnd0.popFront;
     }
     // Test the 10000th invocation
     // Correct value taken from:
     // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf
     rnd0.seed;
-    rnd0.discard(9999);
-    assert(rnd0.next == 1043618065);
+    advance(rnd0, 9999);
+    assert(rnd0.front == 1043618065);
 
     // Test MinstdRand
     auto checking = [48271UL,182605794,1291394886,1914720637,2078669041,
                      407355683];
-    auto rnd = MinstdRand(1);
+    //auto rnd = MinstdRand(1);
+    MinstdRand rnd;
     foreach (e; checking)
     {
-        assert(rnd.next == e);
+        assert(rnd.front == e);
+        rnd.popFront;
     }
 
     // Test the 10000th invocation
     // Correct value taken from:
     // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf
     rnd.seed;
-    rnd.discard(9999);
-    assert(rnd.next == 399268537);
+    advance(rnd, 9999);
+    assert(rnd.front == 399268537);
 }
 
 /**
-   The $(LINK2 http://math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html,
-   Mersenne Twister generator).
-*/
+The $(WEB math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html, Mersenne
+Twister) generator.
+ */
 struct MersenneTwisterEngine(
     UIntType, size_t w, size_t n, size_t m, size_t r,
     UIntType a, size_t u, size_t s,
     UIntType b, size_t t,
     UIntType c, size_t l)
 {
-/// Result type (an alias for $(D_PARAM UIntType)).
-    alias UIntType ResultType;
-
 /**
-   Parameter for the generator.
+Parameter for the generator.
 */
-    static invariant
-    {
-        size_t wordSize = w;
-        size_t stateSize = n;
-        size_t shiftSize = m;
-        size_t maskBits = r;
-        UIntType xorMask = a;
-        UIntType temperingU = u;
-        size_t temperingS = s;
-        UIntType temperingB = b;
-        size_t temperingT = t;
-        UIntType temperingC = c;
-        size_t temperingL = l;
-    }
+    enum size_t wordSize = w;
+    enum size_t stateSize = n;
+    enum size_t shiftSize = m;
+    enum size_t maskBits = r;
+    enum UIntType xorMask = a;
+    enum UIntType temperingU = u;
+    enum size_t temperingS = s;
+    enum UIntType temperingB = b;
+    enum size_t temperingT = t;
+    enum UIntType temperingC = c;
+    enum size_t temperingL = l;
 
     /// Smallest generated value (0).
-    static invariant UIntType min = 0;
+    enum UIntType min = 0;
     /// Largest generated value.
-    static invariant UIntType max =
+    enum UIntType max =
         w == UIntType.sizeof * 8 ? UIntType.max : (1u << w) - 1;
     /// The default seed value.
-    static invariant UIntType defaultSeed = 5489u;
+    enum UIntType defaultSeed = 5489u;
 
     static assert(1 <= m && m <= n);
     static assert(0 <= r && 0 <= u && 0 <= s && 0 <= t && 0 <= l);
@@ -314,21 +304,19 @@
     static assert(a <= max && b <= max && c <= max);
 
 /**
-   Constructs a MersenneTwisterEngine object
+   Constructs a MersenneTwisterEngine object.
 */
-    /*static MersenneTwisterEngine opCall(ResultType value)
+    this(UIntType value)
     {
-        MersenneTwisterEngine result;
-        result.seed(value);
-        return result;
-    }*/
-    
+        seed(value);
+    }
+
 /**
-   Constructs a MersenneTwisterEngine object
+   Seeds a MersenneTwisterEngine object.
 */
-    void seed(ResultType value = defaultSeed)
+    void seed(UIntType value = defaultSeed)
     {
-        static if (w == ResultType.sizeof * 8)
+        static if (w == UIntType.sizeof * 8)
         {
             mt[0] = value;
         }
@@ -338,38 +326,42 @@
             mt[0] = value % (max + 1);
         }
         for (mti = 1; mti < n; ++mti) {
-            mt[mti] = 
+            mt[mti] =
                 cast(UIntType)
-                (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> (w - 2))) + mti); 
+                (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> (w - 2))) + mti);
             /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
             /* In the previous versions, MSBs of the seed affect   */
             /* only MSBs of the array mt[].                        */
             /* 2002/01/09 modified by Makoto Matsumoto             */
-            mt[mti] &= ResultType.max;
+            //mt[mti] &= ResultType.max;
             /* for >32 bit machines */
         }
+        popFront;
     }
 
 /**
-   Returns the next random value.
+   Advances the generator.
 */
-    uint next()
+    void popFront()
     {
-        static invariant ResultType
-            upperMask = ~((cast(ResultType) 1u <<
-                           (ResultType.sizeof * 8 - (w - r))) - 1),
-            lowerMask = (cast(ResultType) 1u << r) - 1;
+        enum UIntType
+            upperMask = ~((cast(UIntType) 1u <<
+                           (UIntType.sizeof * 8 - (w - r))) - 1),
+            lowerMask = (cast(UIntType) 1u << r) - 1;
+        static invariant UIntType mag01[2] = [0x0UL, a];
 
         ulong y = void;
-        static invariant ResultType mag01[2] = [0x0UL, a];
 
         if (mti >= n)
         {
             /* generate N words at one time */
-            if (mti == n + 1)   /* if init_genrand() has not been called, */
-                seed(5489UL); /* a default initial seed is used */
-            
-            int kk = 0;            
+            if (mti == n + 1)  /* if init_genrand() has not been called, */
+            {
+                seed(defaultSeed); /* a default initial seed is used */
+                return popFront;
+            }
+
+            int kk = 0;
             for (; kk < n - m; ++kk)
             {
                 y = (mt[kk] & upperMask)|(mt[kk + 1] & lowerMask);
@@ -385,31 +377,41 @@
             y = (mt[n -1] & upperMask)|(mt[0] & lowerMask);
             mt[n - 1] = cast(UIntType) (mt[m - 1] ^ (y >> 1)
                                         ^ mag01[cast(UIntType) y & 0x1U]);
-            
+
             mti = 0;
         }
-        
+
         y = mt[mti++];
-        
+
         /* Tempering */
         y ^= (y >> temperingU);
         y ^= (y << temperingS) & temperingB;
         y ^= (y << temperingT) & temperingC;
         y ^= (y >> temperingL);
-        
-        return cast(UIntType) y;
+
+        _y = cast(UIntType) y;
     }
 
 /**
-   Discards next $(D_PARAM n) samples.
-*/
-    void discard(ulong n)
+   Returns the current random value.
+ */
+    UIntType front()
     {
-        while (n--) next;
+        if (mti == n + 1)
+        {
+            popFront;
+        }
+        return _y;
     }
 
-    private ResultType mt[n];
+/**
+Always $(D false).
+ */
+    enum bool empty = false;
+    
+    private UIntType mt[n];
     private size_t mti = n + 1; /* means mt is not initialized */
+    UIntType _y = UIntType.max;
 }
 
 /**
@@ -425,10 +427,10 @@
 ----
 // seed with a constant
 Mt19937 gen;
-auto n = gen.next; // same for each run
+auto n = gen.front; // same for each run
 // Seed with an unpredictable value
 gen.seed(unpredictableSeed);
-n = gen.next; // different across runs
+n = gen.front; // different across runs
 ----
  */
 alias MersenneTwisterEngine!(uint, 32, 624, 397, 31, 0x9908b0df, 11, 7,
@@ -438,21 +440,11 @@
 unittest
 {
     Mt19937 gen;
-    gen.discard(9999);
-    assert(gen.next == 4123659995);
+    advance(gen, 9999);
+    assert(gen.front == 4123659995);
 }
 
 /**
-The "default", "favorite", "suggested" random number generator on the
-current platform. It is a typedef for one of the previously-defined
-generators. You may want to use it if (1) you need to generate some
-nice random numbers, and (2) you don't care for the minutiae of the
-method being used.
- */
-
-alias Mt19937 Random;
-
-/**
 A "good" seed for initializing random number engines. Initializing
 with $(D_PARAM unpredictableSeed) makes engines generate different
 random number sequences every run.
@@ -461,9 +453,9 @@
 
 ----
 auto rnd = Random(unpredictableSeed);
-auto n = rnd.next;
+auto n = rnd.front;
 ...
-----   
+----
 */
 
 uint unpredictableSeed()
@@ -474,7 +466,8 @@
         rand.seed(getpid ^ cast(uint)getUTCtime);
         seeded = true;
     }
-    return cast(uint) (getUTCtime ^ rand.next);
+    rand.popFront;
+    return cast(uint) (getUTCtime ^ rand.front);
 }
 
 unittest
@@ -485,138 +478,136 @@
 }
 
 /**
-Generates uniformly-distributed numbers within a range using an
-external generator. The $(D boundaries) parameter controls the shape
-of the interval (open vs. closed on either side). Valid values for $(D
-boundaries) are "[]", "$(LPAREN)]", "[$(RPAREN)", and "()". The
-default interval is [a, b$(RPAREN).
+The "default", "favorite", "suggested" random number generator type on
+the current platform. It is an alias for one of the previously-defined
+generators. You may want to use it if (1) you need to generate some
+nice random numbers, and (2) you don't care for the minutiae of the
+method being used.
+ */
+
+alias Mt19937 Random;
+
+/**
+Global random number generator used by various functions in this
+module whenever no generator is specified. It is allocated per-thread
+and initialized to an unpredictable value for each thread.
+ */
+ref Random rndGen()
+{
+    static Random result;
+    static bool initialized;
+    if (!initialized)
+    {
+        result = Random(unpredictableSeed);
+        initialized = true;
+    }
+    return result;
+}
+
+/**
+Generates a number between $(D a) and $(D b). The $(D boundaries)
+parameter controls the shape of the interval (open vs. closed on
+either side). Valid values for $(D boundaries) are $(D "[]"), $(D
+"$(LPAREN)]"), $(D "[$(RPAREN)"), and $(D "()"). The default interval
+is closed to the left and open to the right.
 
 Example:
 
 ----
-auto a = new double[20];
-Random gen;
-auto rndIndex = UniformDistribution!(uint)(0, a.length);
-auto rndValue = UniformDistribution!(double)(0, 1);
-// Get a random index into the array
-auto i = rndIndex.next(gen);
-// Get a random probability, i.e., a real number in [0, 1$(RPAREN)
-auto p = rndValue.next(gen);
-// Assign that value to that array element
-a[i] = p;
-auto digits = UniformDistribution!(char, "[]")('0', '9');
-auto percentages = UniformDistribution!(double, "$(LPAREN)]")(0.0, 100.0);
-// Get a digit in ['0', '9']
-auto digit = digits.next(gen); 
-// Get a number in $(LPAREN)0.0, 100.0]
-auto p = percentages.next(gen);
+Random gen(unpredictableSeed);
+// Generate an integer in [0, 1023]
+auto a = uniform(0, 1024, gen);
+// Generate a float in [0, 1$(RPAREN)
+auto a = uniform(0.0f, 1.0f, gen);
 ----
-*/
-struct UniformDistribution(NumberType, string boundaries = "[)")
+ */
+version(ddoc)
+    CommonType!(T1, T2) uniform(string boundaries = "[$(RPAREN)",
+            T1, T2, UniformRandomNumberGenerator)
+        (T1 a, T2 b, ref UniformRandomNumberGenerator urng);
+else
+    CommonType!(T1, T2) uniform(string boundaries = "[)",
+            T1, T2, UniformRandomNumberGenerator)
+(T1 a, T2 b, ref UniformRandomNumberGenerator urng)
+if (is(CommonType!(T1, UniformRandomNumberGenerator) == void) &&
+        !is(CommonType!(T1, T2) == void))
 {
-    enum char leftLim = boundaries[0], rightLim = boundaries[1];
-    static assert((leftLim == '[' || leftLim == '(')
-                  && (rightLim == ']' || rightLim == ')'));
-
-    alias NumberType InputType;
-    alias NumberType ResultType;
-/**
-Constructs a $(D UniformDistribution) able to generate numbers between
-$(D a) and $(D b). The bounds of the interval are controlled by the
-template argument, e.g. $(D UniformDistribution!(double, "[]")(0, 1))
-generates numbers in the interval [0.0, 1.0].
-*/
-    static UniformDistribution opCall(NumberType a, NumberType b)
+    alias CommonType!(T1, T2) NumberType;
+    NumberType _a, _b;
+    static if (boundaries[0] == '(')
+        static if (isIntegral!(NumberType))
+            _a = a + 1;
+        else
+            _a = nextafter(a, a.infinity);
+    else
+        _a = a;
+    static if (boundaries[1] == ')')
+        static if (isIntegral!(NumberType))
+        {
+            static if (_b.min == 0)
+            {
+                if (b == 0) {
+                    // writeln("Invalid distribution range: "
+                    //         ~ boundaries[0] ~ to!(string)(a)
+                    //         ~ ", " ~ to!(string)(b) ~ boundaries[1]);
+                    ++b;
+                }
+            }
+            _b = b - 1;
+        }
+        else
+            _b = nextafter(to!NumberType(b), -_b.infinity);
+    else
+        _b = b;
+    enforce(_a <= _b,
+            text("Invalid distribution range: ", boundaries[0], a,
+                    ", ", b, boundaries[1]));
+    static if (isIntegral!(NumberType))
     {
-        UniformDistribution result;
-        static if (leftLim == '(')
-            result._a = nextLarger(a);
-        else
-            result._a = a;
-        static if (rightLim == ')')
-            result._b = nextSmaller(b);
-        else
-            result._b = b;
-        enforce(result._a <= result._b,
-                "Invalid distribution range: " ~ leftLim ~ to!(string)(a)
-                ~ ", " ~ to!(string)(b) ~ rightLim);
-        return result;
+        auto myRange = _b - _a;
+        if (!myRange) return _a;
+        assert(urng.max - urng.min >= myRange,
+                "UniformIntGenerator.popFront not implemented"
+                " for large ranges");
+        Unsigned!(typeof((urng.max - urng.min + 1) / (myRange + 1)))
+            bucketSize = 1 + (urng.max - urng.min - myRange) / (myRange + 1);
+        //assert(bucketSize, to!(string)(myRange));
+        NumberType r = void;
+        do
+        {
+            r = (urng.front - urng.min) / bucketSize;
+            urng.popFront;
+        }
+        while (r > myRange);
+        return _a + r;
     }
-/**
-Returns the left bound of the random value generated.
-*/
-    ResultType a() { return leftLim == '[' ? _a : nextSmaller(_a); }
+    else
+    {
+        urng.popFront;
+        return _a + (_b - _a) * cast(NumberType) (urng.front - urng.min)
+            / (urng.max - urng.min);
+    }
+}
 
 /**
-Returns the the right bound of the random value generated.
-*/ 
-    ResultType b() { return rightLim == ']' ? _b : nextLarger(_b); }
-
-/**
-Does nothing (provided for conformity with other distributions).
-*/
-    void reset()
-    {
-    }
-
-/**
-Returns a random number using $(D UniformRandomNumberGenerator) as
-back-end.
-*/
-    ResultType next(UniformRandomNumberGenerator)
-        (ref UniformRandomNumberGenerator urng)
-    {
-        static if (isIntegral!(NumberType))
-        {
-            auto myRange = _b - _a;
-            if (!myRange) return _a;
-            assert(urng.max - urng.min >= myRange,
-                   "UniformIntGenerator.next not implemented for large ranges");
-            unsigned!(typeof((urng.max - urng.min + 1) / (myRange + 1)))
-                bucketSize = 1 + (urng.max - urng.min - myRange) / (myRange + 1);
-            assert(bucketSize, to!(string)(myRange));
-            ResultType r = void;
-            do
-            {
-                r = (urng.next - urng.min) / bucketSize;
-            }
-            while (r > myRange);
-            return _a + r;
-        }
-        else
-        {
-            return _a + (_b - _a) * cast(NumberType) (urng.next - urng.min)
-                / (urng.max - urng.min);
-        }
-    }
-    
-private:    
-    NumberType _a = 0, _b = NumberType.max;
-
-    static NumberType nextLarger(NumberType x)
-    {
-        static if (isIntegral!(NumberType))
-            return x + 1;
-        else
-            return nextafter(x, x.infinity);
-    }
-
-    static NumberType nextSmaller(NumberType x)
-    {
-        static if (isIntegral!(NumberType))
-            return x - 1;
-        else
-            return nextafter(x, -x.infinity);
-    }
+As above, but uses the default generator $(D rndGen).
+ */
+version(ddoc)
+    CommonType!(T1, T2) uniform(string boundaries = "[$(RPAREN)", T1, T2)
+        (T1 a, T2 b)  if (!is(CommonType!(T1, T2) == void));
+else
+CommonType!(T1, T2) uniform(string boundaries = "[)", T1, T2)
+(T1 a, T2 b)  if (is(CommonType!(T1, T2)))
+{
+    return uniform!(boundaries, T1, T2, Random)(a, b, rndGen);
 }
 
 unittest
 {
     MinstdRand0 gen;
-    auto rnd1 = UniformDistribution!(int)(0, 15);
     foreach (i; 0 .. 20)
     {
-        auto x = rnd1.next(gen);
+        auto x = uniform(0., 15., gen);
         assert(0 <= x && x <= 15);
         //writeln(x);
     }
@@ -624,58 +615,53 @@
 
 unittest
 {
-    MinstdRand0 gen;
-    foreach (i; 0 .. 20)
-    {
-        auto x = uniform!(double)(gen, 0., 15.);
-        assert(0 <= x && x <= 15);
-        //writeln(x);
-    }
+    auto gen = Mt19937(unpredictableSeed);
+    auto a = uniform(0, 1024, gen);
+    assert(0 <= a && a <= 1024);
+    auto b = uniform(0.0f, 1.0f, gen);
+    assert(0 <= b && b < 1, to!string(b));
+    auto c = uniform(0.0, 1.0);
+    assert(0 <= c && c < 1);
 }
 
 /**
-Convenience function that generates a number in an interval by
-forwarding to $(D UniformDistribution!(T, boundaries)(a, b).next).
-
-Example:
-
-----
-Random gen(unpredictableSeed);
-// Generate an integer in [0, 1024$(RPAREN)
-auto a = uniform(gen, 0, 1024);
-// Generate a float in [0, 1$(RPAREN)
-auto a = uniform(gen, 0.0f, 1.0f);
-----
-*/
-
-T1 uniform(T1, string boundaries = "[)", UniformRandomNumberGenerator, T2)
-    (ref UniformRandomNumberGenerator gen, T1 a, T2 b)
+Generates a uniform probability distribution of size $(D n), i.e., an
+array of size $(D n) of positive numbers of type $(D F) that sum to
+$(D 1). If $(D useThis) is provided, it is used as storage.
+ */
+F[] uniformDistribution(F = double)(size_t n, F[] useThis = null)
 {
-    alias typeof(return) Result;
-    auto dist = UniformDistribution!(Result, boundaries)(a, b);
-    return dist.next(gen);
+    useThis.length = n;
+    foreach (ref e; useThis)
+    {
+        e = uniform(0.0, 1);
+    }
+    normalize(useThis);
+    return useThis;
 }
 
 unittest
 {
-    auto gen = Mt19937(unpredictableSeed);
-    auto a = uniform(gen, 0, 1024);
-    assert(0 <= a && a <= 1024);
-    auto b = uniform(gen, 0.0f, 1.0f);
-    assert(0 <= b && b < 1, to!(string)(b));
+    static assert(is(CommonType!(double, int) == double));
+    auto a = uniformDistribution(5);
+    enforce(a.length == 5);
+    enforce(approxEqual(reduce!"a + b"(a), 1));
+    a = uniformDistribution(10, a);
+    enforce(a.length == 10);
+    enforce(approxEqual(reduce!"a + b"(a), 1));
 }
 
 /**
-Shuffles elements of $(D array) using $(D r) as a shuffler.
-*/
+Shuffles elements of $(D r) using $(D r) as a shuffler. $(D r) must be
+a random-access range with length.
+ */
 
-void randomShuffle(T, SomeRandomGen)(T[] array, ref SomeRandomGen r)
+void randomShuffle(Range, RandomGen = Random)(Range r,
+        ref RandomGen gen = rndGen)
 {
-    foreach (i; 0 .. array.length)
+    foreach (i; 0 .. r.length)
     {
-        // generate a random number i .. n
-        invariant which = i + uniform!(size_t)(r, 0u, array.length - i);
-        swap(array[i], array[which]);
+        swap(r[i], r[i + uniform(0, r.length - i, gen)]);
     }
 }
 
@@ -685,12 +671,13 @@
     auto b = a.dup;
     Mt19937 gen;
     randomShuffle(a, gen);
-    //assert(a == expectedA);
+    assert(a.sort == b.sort);
+    randomShuffle(a);
     assert(a.sort == b.sort);
 }
 
 /**
-Throws a dice with relative probabilities stored in $(D
+Rolls a dice with relative probabilities stored in $(D
 proportions). Returns the index in $(D proportions) that was chosen.
 
 Example:
@@ -706,7 +693,7 @@
 size_t dice(R)(ref R rnd, double[] proportions...) {
     invariant sum = reduce!("(assert(b >= 0), a + b)")(0.0, proportions);
     enforce(sum > 0, "Proportions in a dice cannot sum to zero");
-    invariant point = uniform(rnd, 0.0, sum);
+    invariant point = uniform(0.0, sum, rnd);
     assert(point < sum);
     auto mass = 0.0;
     foreach (i, e; proportions) {
@@ -725,6 +712,102 @@
     assert(i == 0);
 }
 
+/**
+Covers a given range $(D r) in a random manner, i.e. goes through each
+element of $(D r) once and only once, just in a random order. $(D r)
+must be a forward access range with length.
+
+Example:
+----
+int[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];
+auto rnd = Random(unpredictableSeed);
+foreach (e; randomCover(a, rnd))
+{
+    writeln(e);
+}
+----
+ */
+struct RandomCover(Range, Random)
+{
+    private Range _input;
+    private Random _rnd;
+    private bool[] _chosen;
+    private uint _current;
+    private uint _alreadyChosen;
+
+    this(Range input, Random rnd)
+    {
+        _input = input;
+        _rnd = rnd;
+        _chosen.length = _input.length;
+        popFront;
+    }
+
+    auto opSlice()
+    {
+        return this;
+    }
+
+    ref ElementType!(Range) front()
+    {
+        return _input[_current];
+    }
+
+    void popFront()
+    {
+        if (_alreadyChosen >= _input.length)
+        {
+            // No more elements
+            ++_alreadyChosen; // means we're done
+            return;
+        }
+        uint k = _input.length - _alreadyChosen;
+        uint i;
+        foreach (e; _input)
+        {
+            if (_chosen[i]) { ++i; continue; }
+            // Roll a dice with k faces
+            auto chooseMe = uniform(0, k - 1, _rnd) == 0;
+            assert(k > 1 || chooseMe);
+            if (chooseMe)
+            {
+                _chosen[i] = true;
+                _current = i;
+                ++_alreadyChosen;
+                return;
+            }
+            --k;
+            ++i;
+        }
+        assert(false);
+    }
+
+    bool empty() { return _alreadyChosen > _input.length; }
+}
+
+/// Ditto
+RandomCover!(Range, Random) randomCover(Range, Random)(Range r, Random rnd)
+{
+    return typeof(return)(r, rnd);
+}
+
+unittest
+{
+    int[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];
+    auto rnd = Random(unpredictableSeed);
+    RandomCover!(int[], Random) rc = randomCover(a, rnd);
+    int[] b = new int[9];
+    uint i;
+    foreach (e; rc)
+    {
+        //writeln(e);
+        b[i++] = e;
+    }
+    sort(b);
+    assert(a == b, text(b));
+}
+
+//__EOF__
 /* ===================== Random ========================= */
 
 // BUG: not multithreaded
@@ -743,25 +826,25 @@
 
 Note: This is more random, but slower, than C's $(D rand()) function.
 To use C's $(D rand()) instead, import $(D std.c.stdlib).
- 
+
 BUGS: Shares a global single state, not multithreaded.  SCHEDULED FOR
 DEPRECATION.
 
 */
 
-void rand_seed(uint seed, uint index)
+deprecated void rand_seed(uint seed, uint index)
 {
     .seed = seed;
     .index = index;
 }
 
 /**
-Get the next random number in sequence.
+Get the popFront random number in sequence.
 BUGS: Shares a global single state, not multithreaded.
 SCHEDULED FOR DEPRECATION.
 */
 
-uint rand()
+deprecated uint rand()
 {
     static uint xormix1[20] =
     [
@@ -805,30 +888,23 @@
 
     version(Win32)
     {
-	QueryPerformanceCounter(&s);
+        QueryPerformanceCounter(&s);
     }
-    else version(Posix)
+    version(Posix)
     {
-	// time.h
-	// sys/time.h
-
-	timeval tv;
-
-	if (gettimeofday(&tv, null))
-	{   // Some error happened - try time() instead
-	    s = std.c.unix.unix.time(null);
-	}
-	else
-	{
-	    s = cast(ulong)((cast(long)tv.tv_sec << 32) + tv.tv_usec);
-	}
+        // time.h
+        // sys/time.h
+        
+        timeval tv;
+        if (gettimeofday(&tv, null))
+        {   // Some error happened - try time() instead
+            s = core.sys.posix.sys.time.time(null);
+        }
+        else
+        {
+            s = cast(ulong)((cast(long)tv.tv_sec << 32) + tv.tv_usec);
+        }
     }
-    else version(NoSystem)
-    {
-	// nothing
-    }
-    else
-	static assert(false);
     rand_seed(cast(uint) s, cast(uint)(s >> 32));
 }
 
diff -r f12bfe124807 d/phobos2/std/regexp.d
--- a/d/phobos2/std/regexp.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/regexp.d	Thu Oct 14 14:12:53 2010 +0100
@@ -24,12 +24,6 @@
  *     distribution.
  */
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, September 2004
-*/
-
 /**********************************************
  * $(LINK2 http://www.digitalmars.com/ctg/regular.html, Regular
  * expressions) are a powerful method of string pattern matching.  The
@@ -66,17 +60,17 @@
 	$(TD treat as multiple lines separated by newlines)
 	</tr>
 	</table>
- *
- * The $(I format)[] string has the formatting characters:
- *
- *	<table border=1 cellspacing=0 cellpadding=5>
+    *
+    * The $(I format)[] string has the formatting characters:
+    *
+    *	<table border=1 cellspacing=0 cellpadding=5>
 	<caption>Formatting Characters</caption>
 	$(TR $(TH Format) $(TH Replaced With))
 	$(TR
 	$(TD $(B $$))	$(TD $)
 	)
 	$(TR
-	$(TD $(B $&))	$(TD The matched substring.)
+	$(TD $(B $&amp;))	$(TD The matched substring.)
 	)
 	$(TR
 	$(TD $(B $`))	$(TD The portion of string that precedes the matched substring.)
@@ -99,44 +93,44 @@
 	)
 	</table>
 
- *	Any other $ are left as is.
- *
- * References:
- *	$(LINK2 http://en.wikipedia.org/wiki/Regular_expressions, Wikipedia)
- * Macros:
- *	WIKI = StdRegexp
- *	DOLLAR = $
- */
+    *	Any other $ are left as is.
+    *
+    * References:
+    *	$(LINK2 http://en.wikipedia.org/wiki/Regular_expressions, Wikipedia)
+    * Macros:
+    *	WIKI = StdRegexp
+    *	DOLLAR = $
+    */
 
 /*
-	Escape sequences:
-
-	\nnn starts out a 1, 2 or 3 digit octal sequence,
-	where n is an octal digit. If nnn is larger than
-	0377, then the 3rd digit is not part of the sequence
-	and is not consumed.
-	For maximal portability, use exactly 3 digits.
-
-	\xXX starts out a 1 or 2 digit hex sequence. X
-	is a hex character. If the first character after the \x
-	is not a hex character, the value of the sequence is 'x'
-	and the XX are not consumed.
-	For maximal portability, use exactly 2 digits.
-
-	\uUUUU is a unicode sequence. There are exactly
-	4 hex characters after the \u, if any are not, then
-	the value of the sequence is 'u', and the UUUU are not
-	consumed.
-
-	Character classes:
-
-	[a-b], where a is greater than b, will produce
-	an error.
-
-	References:
-
-	http://www.unicode.org/unicode/reports/tr18/
- */
+  Escape sequences:
+
+  \nnn starts out a 1, 2 or 3 digit octal sequence,
+  where n is an octal digit. If nnn is larger than
+  0377, then the 3rd digit is not part of the sequence
+  and is not consumed.
+  For maximal portability, use exactly 3 digits.
+
+  \xXX starts out a 1 or 2 digit hex sequence. X
+  is a hex character. If the first character after the \x
+  is not a hex character, the value of the sequence is 'x'
+  and the XX are not consumed.
+  For maximal portability, use exactly 2 digits.
+
+  \uUUUU is a unicode sequence. There are exactly
+  4 hex characters after the \u, if any are not, then
+  the value of the sequence is 'u', and the UUUU are not
+  consumed.
+
+  Character classes:
+
+  [a-b], where a is greater than b, will produce
+  an error.
+
+  References:
+
+  http://www.unicode.org/unicode/reports/tr18/
+*/
 
 module std.regexp;
 
@@ -144,16 +138,18 @@
 
 private
 {
-    import std.c.stdio;
-    import std.c.stdlib;
-    import std.c.string;
+    import core.stdc.stdio;
+    import core.stdc.stdlib;
+    import core.stdc.string;
     import std.stdio;
     import std.string;
     import std.ctype;
     import std.outbuffer;
     import std.bitmanip;
     import std.utf;
-    import std.intrinsic;
+    import std.algorithm;
+    import std.array;
+    import std.traits;
 }
 
 /** Regular expression to extract an _email address.
@@ -175,7 +171,7 @@
 {
     this(string msg)
     {
-	super(msg);
+        super(msg);
     }
 }
 
@@ -264,40 +260,37 @@
     offset = 0;
     while (r.test(s, lastindex))
     {
-	int so = r.pmatch[0].rm_so;
-	int eo = r.pmatch[0].rm_eo;
-
-	string replacement = dg(r);
-
-	// Optimize by using std.string.replace if possible - Dave Fladebo
-	string slice = result[offset + so .. offset + eo];
-	if (r.attributes & RegExp.REA.global &&		// global, so replace all
-	    !(r.attributes & RegExp.REA.ignoreCase) &&	// not ignoring case
-	    !(r.attributes & RegExp.REA.multiline) &&	// not multiline
-	    pattern == slice)				// simple pattern (exact match, no special characters) 
-	{
-	    debug(regexp)
-		printf("pattern: %.*s, slice: %.*s, replacement: %.*s\n",
-		    cast(int) pattern.length, pattern.ptr,
-		    cast(int) (eo-so), result.ptr + offset,
-		    cast(int) replacement.length, replacement.ptr);
-	    result = std.string.replace(result,slice,replacement);
-	    break;
-	}
-
-	result = replaceSlice(result, result[offset + so .. offset + eo], replacement);
-
-	if (r.attributes & RegExp.REA.global)
-	{
-	    offset += replacement.length - (eo - so);
-
-	    if (lastindex == eo)
-		lastindex++;		// always consume some source
-	    else
-		lastindex = eo;
-	}
-	else
-	    break;
+        int so = r.pmatch[0].rm_so;
+        int eo = r.pmatch[0].rm_eo;
+
+        string replacement = dg(r);
+
+        // Optimize by using std.string.replace if possible - Dave Fladebo
+        string slice = result[offset + so .. offset + eo];
+        if (r.attributes & RegExp.REA.global &&		// global, so replace all
+                !(r.attributes & RegExp.REA.ignoreCase) &&	// not ignoring case
+                !(r.attributes & RegExp.REA.multiline) &&	// not multiline
+                pattern == slice)				// simple pattern (exact match, no special characters) 
+        {
+            debug(regexp)
+                     printf("pattern: %.*s, slice: %.*s, replacement: %.*s\n",pattern,result[offset + so .. offset + eo],replacement);
+            result = std.string.replace(result,slice,replacement);
+            break;
+        }
+
+        result = replaceSlice(result, result[offset + so .. offset + eo], replacement);
+
+        if (r.attributes & RegExp.REA.global)
+        {
+            offset += replacement.length - (eo - so);
+
+            if (lastindex == eo)
+                lastindex++;		// always consume some source
+            else
+                lastindex = eo;
+        }
+        else
+            break;
     }
     delete r;
 
@@ -317,12 +310,12 @@
     assert(r == "hello");
 
     auto s = sub("Strap a rocket engine on a chicken.",
-		 "[ar]",
-	         delegate string (RegExp m)
-	         {
-		    return std.string.toupper(m[0]);
-	         },
-	         "g");
+            "[ar]",
+            delegate string (RegExp m)
+            {
+                return std.string.toupper(m[0]);
+            },
+            "g");
     assert(s == "StRAp A Rocket engine on A chicken.");
 }
 
@@ -360,16 +353,16 @@
 }
 
 /**
-Returns:
-
-  Same as $(D_PARAM find(s, RegExp(pattern, attributes))). 
-
-WARNING:
-
-This function is scheduled for deprecation due to unnecessary
-ambiguity with the homonym function in std.string. Instead of
-$(D_PARAM std.regexp.find(s, p, a)), you may want to use $(D_PARAM
-find(s, RegExp(p, a))).
+   Returns:
+
+   Same as $(D_PARAM find(s, RegExp(pattern, attributes))). 
+
+   WARNING:
+
+   This function is scheduled for deprecation due to unnecessary
+   ambiguity with the homonym function in std.string. Instead of
+   $(D_PARAM std.regexp.find(s, p, a)), you may want to use $(D_PARAM
+   find(s, RegExp(p, a))).
 */
 
 int find(string s, string pattern, string attributes = null)
@@ -379,7 +372,7 @@
     auto r = new RegExp(pattern, attributes);
     if (r.test(s))
     {
-	i = r.pmatch[0].rm_so;
+        i = r.pmatch[0].rm_so;
     }
     delete r;
     return i;
@@ -417,11 +410,11 @@
 
     while (pattern.test(s, lastindex))
     {   int eo = pattern.pmatch[0].rm_eo;
-	i = pattern.pmatch[0].rm_so;
-	if (lastindex == eo)
-	    lastindex++;		// always consume some source
-	else
-	    lastindex = eo;
+        i = pattern.pmatch[0].rm_so;
+        if (lastindex == eo)
+            lastindex++;		// always consume some source
+        else
+            lastindex = eo;
     }
     return i;
 }
@@ -464,11 +457,11 @@
     auto r = new RegExp(pattern, attributes);
     while (r.test(s, lastindex))
     {   int eo = r.pmatch[0].rm_eo;
-	i = r.pmatch[0].rm_so;
-	if (lastindex == eo)
-	    lastindex++;		// always consume some source
-	else
-	    lastindex = eo;
+        i = r.pmatch[0].rm_so;
+        if (lastindex == eo)
+            lastindex++;		// always consume some source
+        else
+            lastindex = eo;
     }
     delete r;
     return i;
@@ -530,11 +523,11 @@
 
     foreach (i, s; split("abcabcabab", RegExp("C.", "i")))
     {
-	//writefln("s[%d] = '%s'", i, s);
-	if (i == 0) assert(s == "ab");
-	else if (i == 1) assert(s == "b");
-	else if (i == 2) assert(s == "bab");
-	else assert(0);
+        //writefln("s[%d] = '%s'", i, s);
+        if (i == 0) assert(s == "ab");
+        else if (i == 1) assert(s == "b");
+        else if (i == 2) assert(s == "bab");
+        else assert(0);
     }
 }
 
@@ -548,7 +541,7 @@
 ambiguity with the homonym function in std.string. Instead of
 $(D_PARAM std.regexp.split(s, p, a)), you may want to use $(D_PARAM
 split(s, RegExp(p, a))).
- */
+*/
 
 string[] split(string s, string pattern, string attributes = null)
 {
@@ -570,11 +563,11 @@
 
     foreach (i, s; split("abcabcabab", "C.", "i"))
     {
-	//writefln("s[%d] = '%s'", i, s);
-	if (i == 0) assert(s == "ab");
-	else if (i == 1) assert(s == "b");
-	else if (i == 2) assert(s == "bab");
-	else assert(0);
+        //writefln("s[%d] = '%s'", i, s);
+        if (i == 0) assert(s == "ab");
+        else if (i == 1) assert(s == "b");
+        else if (i == 2) assert(s == "bab");
+        else assert(0);
     }
 }
 
@@ -608,7 +601,7 @@
     auto r = new RegExp(pattern, attributes);
     if (!r.test(s))
     {	delete r;
-	assert(r is null);
+        assert(r is null);
     }
     return r;
 }
@@ -619,21 +612,20 @@
 
     if (auto m = std.regexp.search("abcdef", "c()"))
     {
-	auto result = std.string.format("%s[%s]%s", m.pre, m[0], m.post);
-	assert(result == "ab[c]def");
-	assert(m[1] == null);
-	assert(m[2] == null);
+        auto result = std.string.format("%s[%s]%s", m.pre, m[0], m.post);
+        assert(result == "ab[c]def");
+        assert(m[1] == null);
+        assert(m[2] == null);
     }
     else
 	assert(0);
 
     if (auto n = std.regexp.search("abcdef", "g"))
     {
-	assert(0);
+        assert(0);
     }
 }
 
-
 /* ********************************* RegExp ******************************** */
 
 /*****************************
@@ -661,8 +653,8 @@
      */
     public this(string pattern, string attributes = null)
     {
-	pmatch = (&gmatch)[0 .. 1];
-	compile(pattern, attributes);
+        pmatch = (&gmatch)[0 .. 1];
+        compile(pattern, attributes);
     }
 
     /*****
@@ -680,25 +672,25 @@
      */
     public static RegExp opCall(string pattern, string attributes = null)
     {
-	return new RegExp(pattern, attributes);
+        return new RegExp(pattern, attributes);
     }
 
     unittest
     {
-	debug(regexp) printf("regexp.opCall.unittest()\n");
-	auto r1 = RegExp("hello", "m");
-	string msg;
-	try
-	{
-	    auto r2 = RegExp("hello", "q");
-	    assert(0);
-	}
-	catch (RegExpException ree)
-	{
-	    msg = ree.toString();
-	    //writefln("message: %s", ree);
-	}
-	assert(msg == "std.regexp.RegExpException: unrecognized attribute");
+        debug(regexp) printf("regexp.opCall.unittest()\n");
+        auto r1 = RegExp("hello", "m");
+        string msg;
+        try
+        {
+            auto r2 = RegExp("hello", "q");
+            assert(0);
+        }
+        catch (RegExpException ree)
+        {
+            msg = ree.toString();
+            //writefln("message: %s", ree);
+        }
+        assert(msg == "std.regexp.RegExpException: unrecognized attribute");
     }
 
     /************************************
@@ -727,42 +719,42 @@
 
     public RegExp search(string string)
     {
-	input = string;
-	pmatch[0].rm_eo = 0;
-	return this;
+        input = string;
+        pmatch[0].rm_eo = 0;
+        return this;
     }
 
     /** ditto */
     public int opApply(int delegate(inout RegExp) dg)
     {
-	int result;
-	RegExp r = this;
-
-	while (test())
-	{
-	    result = dg(r);
-	    if (result)
-		break;
-	}
-
-	return result;
+        int result;
+        RegExp r = this;
+
+        while (test())
+        {
+            result = dg(r);
+            if (result)
+                break;
+        }
+
+        return result;
     }
 
     unittest
     {
-	debug(regexp) printf("regexp.search.unittest()\n");
-
-	int i;
-	foreach(m; RegExp("ab").search("abcabcabab"))
-	{
-	    auto s = std.string.format("%s[%s]%s", m.pre, m[0], m.post);
-	    if (i == 0) assert(s == "[ab]cabcabab");
-	    else if (i == 1) assert(s == "abc[ab]cabab");
-	    else if (i == 2) assert(s == "abcabc[ab]ab");
-	    else if (i == 3) assert(s == "abcabcab[ab]");
-	    else assert(0);
-	    i++;
-	}
+        debug(regexp) printf("regexp.search.unittest()\n");
+
+        int i;
+        foreach(m; RegExp("ab").search("abcabcabab"))
+        {
+            auto s = std.string.format("%s[%s]%s", m.pre, m[0], m.post);
+            if (i == 0) assert(s == "[ab]cabcabab");
+            else if (i == 1) assert(s == "abc[ab]cabab");
+            else if (i == 2) assert(s == "abcabc[ab]ab");
+            else if (i == 3) assert(s == "abcabcab[ab]");
+            else assert(0);
+            i++;
+        }
     }
 
     /******************
@@ -775,16 +767,16 @@
      */
     public string opIndex(size_t n)
     {
-	if (n >= pmatch.length)
-	    return null;
-	else
-	{   size_t rm_so, rm_eo;
-	    rm_so = pmatch[n].rm_so;
-	    rm_eo = pmatch[n].rm_eo;
-	    if (rm_so == rm_eo)
-		return null;
-	    return input[rm_so .. rm_eo];
-	}
+        if (n >= pmatch.length)
+            return null;
+        else
+        {   size_t rm_so, rm_eo;
+            rm_so = pmatch[n].rm_so;
+            rm_eo = pmatch[n].rm_eo;
+            if (rm_so == rm_eo)
+                return null;
+            return input[rm_so .. rm_eo];
+        }
     }
 
     /**
@@ -806,7 +798,7 @@
      */
     public string pre()
     {
-	return input[0 .. pmatch[0].rm_so];
+        return input[0 .. pmatch[0].rm_so];
     }
 
     /*******************
@@ -814,7 +806,7 @@
      */
     public string post()
     {
-	return input[pmatch[0].rm_eo .. $];
+        return input[pmatch[0].rm_eo .. $];
     }
 
     uint re_nsub;		// number of parenthesized subexpression matches
@@ -834,12 +826,12 @@
 
     enum REA
     {
-	global		= 1,	// has the g attribute
-	ignoreCase	= 2,	// has the i attribute
-	multiline	= 4,	// if treat as multiple lines separated
-				// by newlines, or as a single line
-	dotmatchlf	= 8,	// if . matches \n
-    }
+        global		= 1,	// has the g attribute
+            ignoreCase	= 2,	// has the i attribute
+            multiline	= 4,	// if treat as multiple lines separated
+        // by newlines, or as a single line
+            dotmatchlf	= 8,	// if . matches \n
+            }
 
 
 private:
@@ -847,7 +839,7 @@
     size_t src_start;		// starting index for match in input[]
     size_t p;			// position of parser in pattern[]
     regmatch_t gmatch;		// match for the entire regular expression
-				// (serves as storage for pmatch[0])
+    // (serves as storage for pmatch[0])
 
     const(ubyte)[] program;	// pattern[] compiled into regular expression program
     OutBuffer buf;
@@ -859,108 +851,108 @@
 
 // Opcodes
 
-enum : ubyte
-{
-    REend,		// end of program
-    REchar,		// single character
-    REichar,		// single character, case insensitive
-    REdchar,		// single UCS character
-    REidchar,		// single wide character, case insensitive
-    REanychar,		// any character
-    REanystar,		// ".*"
-    REstring,		// string of characters
-    REistring,		// string of characters, case insensitive
-    REtestbit,		// any in bitmap, non-consuming
-    REbit,		// any in the bit map
-    REnotbit,		// any not in the bit map
-    RErange,		// any in the string
-    REnotrange,		// any not in the string
-    REor,		// a | b
-    REplus,		// 1 or more
-    REstar,		// 0 or more
-    REquest,		// 0 or 1
-    REnm,		// n..m
-    REnmq,		// n..m, non-greedy version
-    REbol,		// beginning of line
-    REeol,		// end of line
-    REparen,		// parenthesized subexpression
-    REgoto,		// goto offset
-
-    REwordboundary,
-    REnotwordboundary,
-    REdigit,
-    REnotdigit,
-    REspace,
-    REnotspace,
-    REword,
-    REnotword,
-    REbackref,
-};
+    enum : ubyte
+    {
+        REend,		// end of program
+            REchar,		// single character
+            REichar,		// single character, case insensitive
+            REdchar,		// single UCS character
+            REidchar,		// single wide character, case insensitive
+            REanychar,		// any character
+            REanystar,		// ".*"
+            REstring,		// string of characters
+            REistring,		// string of characters, case insensitive
+            REtestbit,		// any in bitmap, non-consuming
+            REbit,		// any in the bit map
+            REnotbit,		// any not in the bit map
+            RErange,		// any in the string
+            REnotrange,		// any not in the string
+            REor,		// a | b
+            REplus,		// 1 or more
+            REstar,		// 0 or more
+            REquest,		// 0 or 1
+            REnm,		// n..m
+            REnmq,		// n..m, non-greedy version
+            REbol,		// beginning of line
+            REeol,		// end of line
+            REparen,		// parenthesized subexpression
+            REgoto,		// goto offset
+
+            REwordboundary,
+            REnotwordboundary,
+            REdigit,
+            REnotdigit,
+            REspace,
+            REnotspace,
+            REword,
+            REnotword,
+            REbackref,
+            };
 
 // BUG: should this include '$'?
-private int isword(dchar c) { return isalnum(c) || c == '_'; }
-
-private uint inf = ~0u;
+    private int isword(dchar c) { return isalnum(c) || c == '_'; }
+
+    private uint inf = ~0u;
 
 /* ********************************
  * Throws RegExpException on error
  */
 
-public void compile(string pattern, string attributes)
-{
-    //printf("RegExp.compile('%.*s', '%.*s')\n", pattern, attributes);
-
-    this.attributes = 0;
-    foreach (rchar c; attributes)
-    {   REA att;
-
-	switch (c)
-	{
-	    case 'g': att = REA.global;		break;
-	    case 'i': att = REA.ignoreCase;	break;
-	    case 'm': att = REA.multiline;	break;
-	    default:
-		error("unrecognized attribute");
-		return;
-	}
-	if (this.attributes & att)
-	{   error("redundant attribute");
-	    return;
-	}
-	this.attributes |= att;
+    public void compile(string pattern, string attributes)
+    {
+        //printf("RegExp.compile('%.*s', '%.*s')\n", pattern, attributes);
+
+        this.attributes = 0;
+        foreach (rchar c; attributes)
+        {   REA att;
+
+            switch (c)
+            {
+            case 'g': att = REA.global;		break;
+            case 'i': att = REA.ignoreCase;	break;
+            case 'm': att = REA.multiline;	break;
+            default:
+                error("unrecognized attribute");
+                return;
+            }
+            if (this.attributes & att)
+            {   error("redundant attribute");
+                return;
+            }
+            this.attributes |= att;
+        }
+
+        input = null;
+
+        this.pattern = pattern;
+        this.flags = attributes;
+
+        uint oldre_nsub = re_nsub;
+        re_nsub = 0;
+        errors = 0;
+
+        buf = new OutBuffer();
+        buf.reserve(pattern.length * 8);
+        p = 0;
+        parseRegexp();
+        if (p < pattern.length)
+        {	error("unmatched ')'");
+        }
+        optimize();
+        program = buf.data;
+        buf.data = null;
+        delete buf;
+
+        if (re_nsub > oldre_nsub)
+        {
+            if (pmatch.ptr is &gmatch)
+                pmatch = null;
+            pmatch.length = re_nsub + 1;
+        }
+        pmatch[0].rm_so = 0;
+        pmatch[0].rm_eo = 0;
     }
 
-    input = null;
-
-    this.pattern = pattern;
-    this.flags = attributes;
-
-    uint oldre_nsub = re_nsub;
-    re_nsub = 0;
-    errors = 0;
-
-    buf = new OutBuffer();
-    buf.reserve(pattern.length * 8);
-    p = 0;
-    parseRegexp();
-    if (p < pattern.length)
-    {	error("unmatched ')'");
-    }
-    optimize();
-    program = buf.data;
-    buf.data = null;
-    delete buf;
-
-    if (re_nsub > oldre_nsub)
-    {
-	if (pmatch.ptr is &gmatch)
-	    pmatch = null;
-	pmatch.length = re_nsub + 1;
-    }
-    pmatch[0].rm_so = 0;
-    pmatch[0].rm_eo = 0;
-}
-
 /********************************************
  * Split s[] into an array of strings, using the regular
  * expression as the separator.
@@ -968,130 +960,130 @@
  * 	array of slices into s[]
  */
 
-public string[] split(string s)
-{
-    debug(regexp) printf("regexp.split()\n");
-
-    string[] result;
-
-    if (s.length)
+    public string[] split(string s)
     {
-	int p = 0;
-	int q;
-	for (q = p; q != s.length;)
-	{
-	    if (test(s, q))
-	    {	int e;
-
-		q = pmatch[0].rm_so;
-		e = pmatch[0].rm_eo;
-		if (e != p)
-		{
-		    result ~= s[p .. q];
-		    for (int i = 1; i < pmatch.length; i++)
-		    {
-			int so = pmatch[i].rm_so;
-			int eo = pmatch[i].rm_eo;
-			if (so == eo)
-			{   so = 0;	// -1 gives array bounds error
-			    eo = 0;
-			}
-			result ~= s[so .. eo];
-		    }
-		    q = p = e;
-		    continue;
-		}
-	    }
-	    q++;
-	}
-	result ~= s[p .. s.length];
+        debug(regexp) printf("regexp.split()\n");
+
+        string[] result;
+
+        if (s.length)
+        {
+            int p = 0;
+            int q;
+            for (q = p; q != s.length;)
+            {
+                if (test(s, q))
+                {	int e;
+
+                    q = pmatch[0].rm_so;
+                    e = pmatch[0].rm_eo;
+                    if (e != p)
+                    {
+                        result ~= s[p .. q];
+                        for (int i = 1; i < pmatch.length; i++)
+                        {
+                            int so = pmatch[i].rm_so;
+                            int eo = pmatch[i].rm_eo;
+                            if (so == eo)
+                            {   so = 0;	// -1 gives array bounds error
+                                eo = 0;
+                            }
+                            result ~= s[so .. eo];
+                        }
+                        q = p = e;
+                        continue;
+                    }
+                }
+                q++;
+            }
+            result ~= s[p .. s.length];
+        }
+        else if (!test(s))
+            result ~= s;
+        return result;
     }
-    else if (!test(s))
-	result ~= s;
-    return result;
-}
-
-unittest
-{
-    debug(regexp) printf("regexp.split.unittest()\n");
-
-    auto r = new RegExp("a*?", null);
-    string[] result;
-    string j;
-    int i;
-
-    result = r.split("ab");
-
-    assert(result.length == 2);
-    i = std.string.cmp(result[0], "a");
-    assert(i == 0);
-    i = std.string.cmp(result[1], "b");
-    assert(i == 0);
-
-    r = new RegExp("a*", null);
-    result = r.split("ab");
-    assert(result.length == 2);
-    i = std.string.cmp(result[0], "");
-    assert(i == 0);
-    i = std.string.cmp(result[1], "b");
-    assert(i == 0);
-
-    r = new RegExp("<(\\/)?([^<>]+)>", null);
-    result = r.split("a<b>font</b>bar<TAG>hello</TAG>");
-
-    for (i = 0; i < result.length; i++)
+
+    unittest
     {
-	//debug(regexp) printf("result[%d] = '%.*s'\n", i, result[i]);
+        debug(regexp) printf("regexp.split.unittest()\n");
+
+        auto r = new RegExp("a*?", null);
+        string[] result;
+        string j;
+        int i;
+
+        result = r.split("ab");
+
+        assert(result.length == 2);
+        i = std.string.cmp(result[0], "a");
+        assert(i == 0);
+        i = std.string.cmp(result[1], "b");
+        assert(i == 0);
+
+        r = new RegExp("a*", null);
+        result = r.split("ab");
+        assert(result.length == 2);
+        i = std.string.cmp(result[0], "");
+        assert(i == 0);
+        i = std.string.cmp(result[1], "b");
+        assert(i == 0);
+
+        r = new RegExp("<(\\/)?([^<>]+)>", null);
+        result = r.split("a<b>font</b>bar<TAG>hello</TAG>");
+
+        for (i = 0; i < result.length; i++)
+        {
+            //debug(regexp) printf("result[%d] = '%.*s'\n", i, result[i]);
+        }
+
+        j = join(result, ",");
+        //printf("j = '%.*s'\n", j);
+        i = std.string.cmp(j, "a,,b,font,/,b,bar,,TAG,hello,/,TAG,");
+        assert(i == 0);
+
+        r = new RegExp("a[bc]", null);
+        result = r.match("123ab");
+        j = join(result, ",");
+        i = std.string.cmp(j, "ab");
+        assert(i == 0);
+    
+        result = r.match("ac");
+        j = join(result, ",");
+        i = std.string.cmp(j, "ac");
+        assert(i == 0);
     }
 
-    j = join(result, ",");
-    //printf("j = '%.*s'\n", j);
-    i = std.string.cmp(j, "a,,b,font,/,b,bar,,TAG,hello,/,TAG,");
-    assert(i == 0);
-
-    r = new RegExp("a[bc]", null);
-    result = r.match("123ab");
-    j = join(result, ",");
-    i = std.string.cmp(j, "ab");
-    assert(i == 0);
-    
-    result = r.match("ac");
-    j = join(result, ",");
-    i = std.string.cmp(j, "ac");
-    assert(i == 0);
-}
-
 /*************************************************
  * Search string[] for match with regular expression.
  * Returns:
  *	index of match if successful, -1 if not found
  */
 
-public int find(string string)
-{
-    int i;
-
-    i = test(string);
-    if (i)
-	i = pmatch[0].rm_so;
-    else
-	i = -1;			// no match
-    return i;
-}
+    public int find(string string)
+    {
+        int i;
+
+        i = test(string);
+        if (i)
+            i = pmatch[0].rm_so;
+        else
+            i = -1;			// no match
+        return i;
+    }
 
 //deprecated alias find search;
 
-unittest
-{
-    debug(regexp) printf("regexp.find.unittest()\n");
-
-    int i;
-    RegExp r = new RegExp("abc", null);
-    i = r.find("xabcy");
-    assert(i == 1);
-    i = r.find("cba");
-    assert(i == -1);
-}
+    unittest
+    {
+        debug(regexp) printf("regexp.find.unittest()\n");
+
+        int i;
+        RegExp r = new RegExp("abc", null);
+        i = r.find("xabcy");
+        assert(i == 1);
+        i = r.find("cba");
+        assert(i == -1);
+    }
 
 
 /*************************************************
@@ -1101,52 +1093,52 @@
  *	If not global attribute, return array of all matches.
  */
 
-public string[] match(string s)
-{
-    string[] result;
-
-    if (attributes & REA.global)
+    public string[] match(string s)
     {
-	int lastindex = 0;
-
-	while (test(s, lastindex))
-	{   int eo = pmatch[0].rm_eo;
-
-	    result ~= input[pmatch[0].rm_so .. eo];
-	    if (lastindex == eo)
-		lastindex++;		// always consume some source
-	    else
-		lastindex = eo;
-	}
+        string[] result;
+
+        if (attributes & REA.global)
+        {
+            int lastindex = 0;
+
+            while (test(s, lastindex))
+            {   int eo = pmatch[0].rm_eo;
+
+                result ~= input[pmatch[0].rm_so .. eo];
+                if (lastindex == eo)
+                    lastindex++;		// always consume some source
+                else
+                    lastindex = eo;
+            }
+        }
+        else
+        {
+            result = exec(s);
+        }
+        return result;
     }
-    else
+
+    unittest
     {
-	result = exec(s);
+        debug(regexp) printf("regexp.match.unittest()\n");
+
+        int i;
+        string[] result;
+        string j;
+        RegExp r;
+
+        r = new RegExp("a[bc]", null);
+        result = r.match("1ab2ac3");
+        j = join(result, ",");
+        i = std.string.cmp(j, "ab");
+        assert(i == 0);
+
+        r = new RegExp("a[bc]", "g");
+        result = r.match("1ab2ac3");
+        j = join(result, ",");
+        i = std.string.cmp(j, "ab,ac");
+        assert(i == 0);
     }
-    return result;
-}
-
-unittest
-{
-    debug(regexp) printf("regexp.match.unittest()\n");
-
-    int i;
-    string[] result;
-    string j;
-    RegExp r;
-
-    r = new RegExp("a[bc]", null);
-    result = r.match("1ab2ac3");
-    j = join(result, ",");
-    i = std.string.cmp(j, "ab");
-    assert(i == 0);
-
-    r = new RegExp("a[bc]", "g");
-    result = r.match("1ab2ac3");
-    j = join(result, ",");
-    i = std.string.cmp(j, "ab,ac");
-    assert(i == 0);
-}
 
 
 /*************************************************
@@ -1157,79 +1149,75 @@
  * Returns: the new string
  */
 
-public string replace(string s, string format)
-{
-    string result;
-    int lastindex;
-    int offset;
-
-    result = s;
-    lastindex = 0;
-    offset = 0;
-    for (;;)
+    public string replace(string s, string format)
     {
-	if (!test(s, lastindex))
-	    break;
-
-	int so = pmatch[0].rm_so;
-	int eo = pmatch[0].rm_eo;
-
-	string replacement = replace(format);
-
-	// Optimize by using std.string.replace if possible - Dave Fladebo
-	string slice = result[offset + so .. offset + eo];
-	if (attributes & REA.global &&		// global, so replace all
-	   !(attributes & REA.ignoreCase) &&	// not ignoring case
-	   !(attributes & REA.multiline) &&	// not multiline
-	   pattern == slice &&			// simple pattern (exact match, no special characters) 
-	   format == replacement)		// simple format, not $ formats
-	{
-	    debug(regexp)
-		printf("pattern: %.*s, slice: %.*s, format: %.*s, replacement: %.*s\n",
-		    cast(int) pattern.length, pattern.ptr,
-		    cast(int) (eo-so), result.ptr + offset,
-		    cast(int) format.length, format.ptr,
-		    cast(int) replacement.length, replacement.ptr);
-	    result = std.string.replace(result,slice,replacement);
-	    break;
-	}
-
-	result = replaceSlice(result, result[offset + so .. offset + eo], replacement);
-
-	if (attributes & REA.global)
-	{
-	    offset += replacement.length - (eo - so);
-
-	    if (lastindex == eo)
-		lastindex++;		// always consume some source
-	    else
-		lastindex = eo;
-	}
-	else
-	    break;
+        string result;
+        int lastindex;
+        int offset;
+
+        result = s;
+        lastindex = 0;
+        offset = 0;
+        for (;;)
+        {
+            if (!test(s, lastindex))
+                break;
+
+            int so = pmatch[0].rm_so;
+            int eo = pmatch[0].rm_eo;
+
+            string replacement = replace(format);
+
+            // Optimize by using std.string.replace if possible - Dave Fladebo
+            string slice = result[offset + so .. offset + eo];
+            if (attributes & REA.global &&		// global, so replace all
+                    !(attributes & REA.ignoreCase) &&	// not ignoring case
+                    !(attributes & REA.multiline) &&	// not multiline
+                    pattern == slice &&			// simple pattern (exact match, no special characters) 
+                    format == replacement)		// simple format, not $ formats
+            {
+                debug(regexp)
+                         printf("pattern: %.*s, slice: %.*s, format: %.*s, replacement: %.*s\n",pattern,result[offset + so .. offset + eo],format,replacement);
+                result = std.string.replace(result,slice,replacement);
+                break;
+            }
+
+            result = replaceSlice(result, result[offset + so .. offset + eo], replacement);
+
+            if (attributes & REA.global)
+            {
+                offset += replacement.length - (eo - so);
+
+                if (lastindex == eo)
+                    lastindex++;		// always consume some source
+                else
+                    lastindex = eo;
+            }
+            else
+                break;
+        }
+
+        return result;
     }
 
-    return result;
-}
-
-unittest
-{
-    debug(regexp) printf("regexp.replace.unittest()\n");
-
-    int i;
-    string result;
-    RegExp r;
-
-    r = new RegExp("a[bc]", "g");
-    result = r.replace("1ab2ac3", "x$&y");
-    i = std.string.cmp(result, "1xaby2xacy3");
-    assert(i == 0);
-
-    r = new RegExp("ab", "g");
-    result = r.replace("1ab2ac3", "xy");
-    i = std.string.cmp(result, "1xy2ac3");
-    assert(i == 0);
-}
+    unittest
+    {
+        debug(regexp) printf("regexp.replace.unittest()\n");
+
+        int i;
+        string result;
+        RegExp r;
+
+        r = new RegExp("a[bc]", "g");
+        result = r.replace("1ab2ac3", "x$&y");
+        i = std.string.cmp(result, "1xaby2xacy3");
+        assert(i == 0);
+
+        r = new RegExp("ab", "g");
+        result = r.replace("1ab2ac3", "xy");
+        i = std.string.cmp(result, "1xy2ac3");
+        assert(i == 0);
+    }
 
 
 /*************************************************
@@ -1238,15 +1226,14 @@
  *	array of slices into string[] representing matches
  */
 
-public string[] exec(string string)
-{
-    debug(regexp) printf("regexp.exec(string = '%.*s')\n",
-	cast(int) string.length, string.ptr);
-    input = string;
-    pmatch[0].rm_so = 0;
-    pmatch[0].rm_eo = 0;
-    return exec();
-}
+    public string[] exec(string string)
+    {
+        debug(regexp) printf("regexp.exec(string = '%.*s')\n", string);
+        input = string;
+        pmatch[0].rm_so = 0;
+        pmatch[0].rm_eo = 0;
+        return exec();
+    }
 
 /*************************************************
  * Pick up where last exec(string) or exec() left off,
@@ -1255,23 +1242,23 @@
  *	array of slices into string[] representing matches
  */
 
-public string[] exec()
-{
-    if (!test())
-	return null;
-
-    auto result = new string[pmatch.length];
-    for (int i = 0; i < pmatch.length; i++)
+    public string[] exec()
     {
-	if (pmatch[i].rm_so == pmatch[i].rm_eo)
-	    result[i] = null;
-	else
-	    result[i] = input[pmatch[i].rm_so .. pmatch[i].rm_eo];
+        if (!test())
+            return null;
+
+        auto result = new string[pmatch.length];
+        for (int i = 0; i < pmatch.length; i++)
+        {
+            if (pmatch[i].rm_so == pmatch[i].rm_eo)
+                result[i] = null;
+            else
+                result[i] = input[pmatch[i].rm_so .. pmatch[i].rm_eo];
+        }
+
+        return result;
     }
 
-    return result;
-}
-
 /************************************************
  * Search s[] for match.
  * Returns: 0 for no match, !=0 for match
@@ -1298,328 +1285,324 @@
   writefln(x);
 }
 ---
- * which prints: 1
- */
-
+* which prints: 1
+*/
+                //@@@
 public int test(string s)
-{
-    return test(s, 0 /*pmatch[0].rm_eo*/);
-}
+    {
+        return test(s, 0 /*pmatch[0].rm_eo*/);
+    }
 
 /************************************************
  * Pick up where last test(string) or test() left off, and search again.
  * Returns: 0 for no match, !=0 for match
  */
 
-public int test()
-{
-    return test(input, pmatch[0].rm_eo);
-}
+    public int test()
+    {
+        return test(input, pmatch[0].rm_eo);
+    }
 
 /************************************************
  * Test s[] starting at startindex against regular expression.
  * Returns: 0 for no match, !=0 for match
  */
 
-public int test(string s, int startindex)
-{
-    char firstc;
-    uint si;
-
-    input = s;
-    debug (regexp) printf("RegExp.test(input[] = '%.*s', startindex = %d)\n",
-	cast(int) input.length, input.ptr, startindex);
-    pmatch[0].rm_so = 0;
-    pmatch[0].rm_eo = 0;
-    if (startindex < 0 || startindex > input.length)
+    public int test(string s, int startindex)
     {
-	return 0;			// fail
+        char firstc;
+        uint si;
+
+        input = s;
+        debug (regexp) printf("RegExp.test(input[] = '%.*s', startindex = %d)\n", input, startindex);
+        pmatch[0].rm_so = 0;
+        pmatch[0].rm_eo = 0;
+        if (startindex < 0 || startindex > input.length)
+        {
+            return 0;			// fail
+        }
+        //debug(regexp) printProgram(program);
+
+        // First character optimization
+        firstc = 0;
+        if (program[0] == REchar)
+        {
+            firstc = program[1];
+            if (attributes & REA.ignoreCase && isalpha(firstc))
+                firstc = 0;
+        }
+
+        for (si = startindex; ; si++)
+        {
+            if (firstc)
+            {
+                if (si == input.length)
+                    break;			// no match
+                if (input[si] != firstc)
+                {
+                    si++;
+                    if (!chr(si, firstc))	// if first character not found
+                        break;		// no match
+                }
+            }
+            for (int i = 0; i < re_nsub + 1; i++)
+            {
+                pmatch[i].rm_so = -1;
+                pmatch[i].rm_eo = -1;
+            }
+            src_start = src = si;
+            if (trymatch(0, program.length))
+            {
+                pmatch[0].rm_so = si;
+                pmatch[0].rm_eo = src;
+                //debug(regexp) printf("start = %d, end = %d\n", gmatch.rm_so, gmatch.rm_eo);
+                return 1;
+            }
+            // If possible match must start at beginning, we are done
+            if (program[0] == REbol || program[0] == REanystar)
+            {
+                if (attributes & REA.multiline)
+                {
+                    // Scan for the popFront \n
+                    if (!chr(si, '\n'))
+                        break;		// no match if '\n' not found
+                }
+                else
+                    break;
+            }
+            if (si == input.length)
+                break;
+            //debug(regexp) printf("Starting new try: '%.*s'\n", input[si + 1 .. input.length]);
+        }
+        return 0;		// no match
     }
-    //debug(regexp) printProgram(program);
-
-    // First character optimization
-    firstc = 0;
-    if (program[0] == REchar)
-    {
-	firstc = program[1];
-	if (attributes & REA.ignoreCase && isalpha(firstc))
-	    firstc = 0;
-    }
-
-    for (si = startindex; ; si++)
-    {
-	if (firstc)
-	{
-	    if (si == input.length)
-		break;			// no match
-	    if (input[si] != firstc)
-	    {
-		si++;
-		if (!chr(si, firstc))	// if first character not found
-		    break;		// no match
-	    }
-	}
-	for (int i = 0; i < re_nsub + 1; i++)
-	{
-	    pmatch[i].rm_so = -1;
-	    pmatch[i].rm_eo = -1;
-	}
-	src_start = src = si;
-	if (trymatch(0, program.length))
-	{
-	    pmatch[0].rm_so = si;
-	    pmatch[0].rm_eo = src;
-	    //debug(regexp) printf("start = %d, end = %d\n", gmatch.rm_so, gmatch.rm_eo);
-	    return 1;
-	}
-	// If possible match must start at beginning, we are done
-	if (program[0] == REbol || program[0] == REanystar)
-	{
-	    if (attributes & REA.multiline)
-	    {
-		// Scan for the next \n
-		if (!chr(si, '\n'))
-		    break;		// no match if '\n' not found
-	    }
-	    else
-		break;
-	}
-	if (si == input.length)
-	    break;
-	//debug(regexp) printf("Starting new try: '%.*s'\n", input[si + 1 .. input.length]);
-    }
-    return 0;		// no match
-}
 
     /**
        Returns whether string $(D_PARAM s) matches $(D_PARAM this).
     */
-alias test opEquals;
+    alias test opEquals;
 //     bool opEquals(string s)
 //     {
 //         return test(s);
 //     }
 
-unittest
-{
-    assert("abc" == RegExp(".b."));
-    assert("abc" != RegExp(".b.."));
-}
-
-int chr(inout uint si, rchar c)
-{
-    for (; si < input.length; si++)
+    unittest
     {
-	if (input[si] == c)
-	    return 1;
+        assert("abc" == RegExp(".b."));
+        assert("abc" != RegExp(".b.."));
     }
-    return 0;
-}
-
-
-void printProgram(const(ubyte)[] prog)
-{
-  //debug(regexp)
-  {
-    uint pc;
-    uint len;
-    uint n;
-    uint m;
-    ushort *pu;
-    uint *puint;
-    const(ubyte)[] s;
-
-    printf("printProgram()\n");
-    for (pc = 0; pc < prog.length; )
+
+    int chr(inout uint si, rchar c)
     {
-	printf("%3d: ", pc);
-
-	//printf("prog[pc] = %d, REchar = %d, REnmq = %d\n", prog[pc], REchar, REnmq);
-	switch (prog[pc])
-	{
-	    case REchar:
-		printf("\tREchar '%c'\n", prog[pc + 1]);
-		pc += 1 + char.sizeof;
-		break;
-
-	    case REichar:
-		printf("\tREichar '%c'\n", prog[pc + 1]);
-		pc += 1 + char.sizeof;
-		break;
-
-	    case REdchar:
-		printf("\tREdchar '%c'\n", *cast(dchar *)&prog[pc + 1]);
-		pc += 1 + dchar.sizeof;
-		break;
-
-	    case REidchar:
-		printf("\tREidchar '%c'\n", *cast(dchar *)&prog[pc + 1]);
-		pc += 1 + dchar.sizeof;
-		break;
-
-	    case REanychar:
-		printf("\tREanychar\n");
-		pc++;
-		break;
-
-	    case REstring:
-		len = *cast(uint *)&prog[pc + 1];
-		s = (&prog[pc + 1 + uint.sizeof])[0 .. len];
-		printf("\tREstring x%x, '%.*s'\n", len,
-		    cast(int) s.length, s.ptr);
-		pc += 1 + uint.sizeof + len * rchar.sizeof;
-		break;
-
-	    case REistring:
-		len = *cast(uint *)&prog[pc + 1];
-		s = (&prog[pc + 1 + uint.sizeof])[0 .. len];
-		printf("\tREistring x%x, '%.*s'\n", len,
-		    cast(int) s.length, s.ptr);
-		pc += 1 + uint.sizeof + len * rchar.sizeof;
-		break;
-
-	    case REtestbit:
-		pu = cast(ushort *)&prog[pc + 1];
-		printf("\tREtestbit %d, %d\n", pu[0], pu[1]);
-		len = pu[1];
-		pc += 1 + 2 * ushort.sizeof + len;
-		break;
-
-	    case REbit:
-		pu = cast(ushort *)&prog[pc + 1];
-		len = pu[1];
-		printf("\tREbit cmax=%02x, len=%d:", pu[0], len);
-		for (n = 0; n < len; n++)
-		    printf(" %02x", prog[pc + 1 + 2 * ushort.sizeof + n]);
-		printf("\n");
-		pc += 1 + 2 * ushort.sizeof + len;
-		break;
-
-	    case REnotbit:
-		pu = cast(ushort *)&prog[pc + 1];
-		printf("\tREnotbit %d, %d\n", pu[0], pu[1]);
-		len = pu[1];
-		pc += 1 + 2 * ushort.sizeof + len;
-		break;
-
-	    case RErange:
-		len = *cast(uint *)&prog[pc + 1];
-		printf("\tRErange %d\n", len);
-		// BUG: REAignoreCase?
-		pc += 1 + uint.sizeof + len;
-		break;
-
-	    case REnotrange:
-		len = *cast(uint *)&prog[pc + 1];
-		printf("\tREnotrange %d\n", len);
-		// BUG: REAignoreCase?
-		pc += 1 + uint.sizeof + len;
-		break;
-
-	    case REbol:
-		printf("\tREbol\n");
-		pc++;
-		break;
-
-	    case REeol:
-		printf("\tREeol\n");
-		pc++;
-		break;
-
-	    case REor:
-		len = *cast(uint *)&prog[pc + 1];
-		printf("\tREor %d, pc=>%d\n", len, pc + 1 + uint.sizeof + len);
-		pc += 1 + uint.sizeof;
-		break;
-
-	    case REgoto:
-		len = *cast(uint *)&prog[pc + 1];
-		printf("\tREgoto %d, pc=>%d\n", len, pc + 1 + uint.sizeof + len);
-		pc += 1 + uint.sizeof;
-		break;
-
-	    case REanystar:
-		printf("\tREanystar\n");
-		pc++;
-		break;
-
-	    case REnm:
-	    case REnmq:
-		// len, n, m, ()
-		puint = cast(uint *)&prog[pc + 1];
-		len = puint[0];
-		n = puint[1];
-		m = puint[2];
-		printf("\tREnm%s len=%d, n=%u, m=%u, pc=>%d\n",
-		    (prog[pc] == REnmq) ? cast(char*)"q" : cast(char*)" ",
-		    len, n, m, pc + 1 + uint.sizeof * 3 + len);
-		pc += 1 + uint.sizeof * 3;
-		break;
-
-	    case REparen:
-		// len, n, ()
-		puint = cast(uint *)&prog[pc + 1];
-		len = puint[0];
-		n = puint[1];
-		printf("\tREparen len=%d n=%d, pc=>%d\n", len, n, pc + 1 + uint.sizeof * 2 + len);
-		pc += 1 + uint.sizeof * 2;
-		break;
-
-	    case REend:
-		printf("\tREend\n");
-		return;
-
-	    case REwordboundary:
-		printf("\tREwordboundary\n");
-		pc++;
-		break;
-
-	    case REnotwordboundary:
-		printf("\tREnotwordboundary\n");
-		pc++;
-		break;
-
-	    case REdigit:
-		printf("\tREdigit\n");
-		pc++;
-		break;
-
-	    case REnotdigit:
-		printf("\tREnotdigit\n");
-		pc++;
-		break;
-
-	    case REspace:
-		printf("\tREspace\n");
-		pc++;
-		break;
-
-	    case REnotspace:
-		printf("\tREnotspace\n");
-		pc++;
-		break;
-
-	    case REword:
-		printf("\tREword\n");
-		pc++;
-		break;
-
-	    case REnotword:
-		printf("\tREnotword\n");
-		pc++;
-		break;
-
-	    case REbackref:
-		printf("\tREbackref %d\n", prog[1]);
-		pc += 2;
-		break;
-
-	    default:
-		assert(0);
-	}
+        for (; si < input.length; si++)
+        {
+            if (input[si] == c)
+                return 1;
+        }
+        return 0;
     }
-  }
-}
+
+
+    void printProgram(const(ubyte)[] prog)
+    {
+        //debug(regexp)
+        {
+            uint pc;
+            uint len;
+            uint n;
+            uint m;
+            ushort *pu;
+            uint *puint;
+
+            printf("printProgram()\n");
+            for (pc = 0; pc < prog.length; )
+            {
+                printf("%3d: ", pc);
+
+                //printf("prog[pc] = %d, REchar = %d, REnmq = %d\n", prog[pc], REchar, REnmq);
+                switch (prog[pc])
+                {
+                case REchar:
+                    printf("\tREchar '%c'\n", prog[pc + 1]);
+                    pc += 1 + char.sizeof;
+                    break;
+
+                case REichar:
+                    printf("\tREichar '%c'\n", prog[pc + 1]);
+                    pc += 1 + char.sizeof;
+                    break;
+
+                case REdchar:
+                    printf("\tREdchar '%c'\n", *cast(dchar *)&prog[pc + 1]);
+                    pc += 1 + dchar.sizeof;
+                    break;
+
+                case REidchar:
+                    printf("\tREidchar '%c'\n", *cast(dchar *)&prog[pc + 1]);
+                    pc += 1 + dchar.sizeof;
+                    break;
+
+                case REanychar:
+                    printf("\tREanychar\n");
+                    pc++;
+                    break;
+
+                case REstring:
+                    len = *cast(uint *)&prog[pc + 1];
+                    printf("\tREstring x%x, '%.*s'\n", len,
+                            (&prog[pc + 1 + uint.sizeof])[0 .. len]);
+                    pc += 1 + uint.sizeof + len * rchar.sizeof;
+                    break;
+
+                case REistring:
+                    len = *cast(uint *)&prog[pc + 1];
+                    printf("\tREistring x%x, '%.*s'\n", len,
+                            (&prog[pc + 1 + uint.sizeof])[0 .. len]);
+                    pc += 1 + uint.sizeof + len * rchar.sizeof;
+                    break;
+
+                case REtestbit:
+                    pu = cast(ushort *)&prog[pc + 1];
+                    printf("\tREtestbit %d, %d\n", pu[0], pu[1]);
+                    len = pu[1];
+                    pc += 1 + 2 * ushort.sizeof + len;
+                    break;
+
+                case REbit:
+                    pu = cast(ushort *)&prog[pc + 1];
+                    len = pu[1];
+                    printf("\tREbit cmax=%02x, len=%d:", pu[0], len);
+                    for (n = 0; n < len; n++)
+                        printf(" %02x", prog[pc + 1 + 2 * ushort.sizeof + n]);
+                    printf("\n");
+                    pc += 1 + 2 * ushort.sizeof + len;
+                    break;
+
+                case REnotbit:
+                    pu = cast(ushort *)&prog[pc + 1];
+                    printf("\tREnotbit %d, %d\n", pu[0], pu[1]);
+                    len = pu[1];
+                    pc += 1 + 2 * ushort.sizeof + len;
+                    break;
+
+                case RErange:
+                    len = *cast(uint *)&prog[pc + 1];
+                    printf("\tRErange %d\n", len);
+                    // BUG: REAignoreCase?
+                    pc += 1 + uint.sizeof + len;
+                    break;
+
+                case REnotrange:
+                    len = *cast(uint *)&prog[pc + 1];
+                    printf("\tREnotrange %d\n", len);
+                    // BUG: REAignoreCase?
+                    pc += 1 + uint.sizeof + len;
+                    break;
+
+                case REbol:
+                    printf("\tREbol\n");
+                    pc++;
+                    break;
+
+                case REeol:
+                    printf("\tREeol\n");
+                    pc++;
+                    break;
+
+                case REor:
+                    len = *cast(uint *)&prog[pc + 1];
+                    printf("\tREor %d, pc=>%d\n", len, pc + 1 + uint.sizeof + len);
+                    pc += 1 + uint.sizeof;
+                    break;
+
+                case REgoto:
+                    len = *cast(uint *)&prog[pc + 1];
+                    printf("\tREgoto %d, pc=>%d\n", len, pc + 1 + uint.sizeof + len);
+                    pc += 1 + uint.sizeof;
+                    break;
+
+                case REanystar:
+                    printf("\tREanystar\n");
+                    pc++;
+                    break;
+
+                case REnm:
+                case REnmq:
+                    // len, n, m, ()
+                    puint = cast(uint *)&prog[pc + 1];
+                    len = puint[0];
+                    n = puint[1];
+                    m = puint[2];
+                    printf("\tREnm%.*s len=%d, n=%u, m=%u, pc=>%d\n",
+                            (prog[pc] == REnmq) ? "q" : " ",
+                            len, n, m, pc + 1 + uint.sizeof * 3 + len);
+                    pc += 1 + uint.sizeof * 3;
+                    break;
+
+                case REparen:
+                    // len, n, ()
+                    puint = cast(uint *)&prog[pc + 1];
+                    len = puint[0];
+                    n = puint[1];
+                    printf("\tREparen len=%d n=%d, pc=>%d\n", len, n, pc + 1 + uint.sizeof * 2 + len);
+                    pc += 1 + uint.sizeof * 2;
+                    break;
+
+                case REend:
+                    printf("\tREend\n");
+                    return;
+
+                case REwordboundary:
+                    printf("\tREwordboundary\n");
+                    pc++;
+                    break;
+
+                case REnotwordboundary:
+                    printf("\tREnotwordboundary\n");
+                    pc++;
+                    break;
+
+                case REdigit:
+                    printf("\tREdigit\n");
+                    pc++;
+                    break;
+
+                case REnotdigit:
+                    printf("\tREnotdigit\n");
+                    pc++;
+                    break;
+
+                case REspace:
+                    printf("\tREspace\n");
+                    pc++;
+                    break;
+
+                case REnotspace:
+                    printf("\tREnotspace\n");
+                    pc++;
+                    break;
+
+                case REword:
+                    printf("\tREword\n");
+                    pc++;
+                    break;
+
+                case REnotword:
+                    printf("\tREnotword\n");
+                    pc++;
+                    break;
+
+                case REbackref:
+                    printf("\tREbackref %d\n", prog[1]);
+                    pc += 2;
+                    break;
+
+                default:
+                    assert(0);
+                }
+            }
+        }
+    }
 
 
 /**************************************************
@@ -1629,1343 +1612,1315 @@
  *	0 no match
  */
 
-int trymatch(int pc, int pcend)
-{   int srcsave;
-    uint len;
-    uint n;
-    uint m;
-    uint count;
-    uint pop;
-    uint ss;
-    regmatch_t *psave;
-    uint c1;
-    uint c2;
-    ushort* pu;
-    uint* puint;
-
-    debug(regexp)
+    int trymatch(int pc, int pcend)
+    {   int srcsave;
+        uint len;
+        uint n;
+        uint m;
+        uint count;
+        uint pop;
+        uint ss;
+        regmatch_t *psave;
+        uint c1;
+        uint c2;
+        ushort* pu;
+        uint* puint;
+
+        debug(regexp)
+                 printf("RegExp.trymatch(pc = %d, src = '%.*s', pcend = %d)\n",
+                         pc, input[src .. input.length], pcend);
+        srcsave = src;
+        psave = null;
+        for (;;)
+        {
+            if (pc == pcend)		// if done matching
+            {   debug(regex) printf("\tprogend\n");
+                return 1;
+            }
+
+            //printf("\top = %d\n", program[pc]);
+            switch (program[pc])
+            {
+            case REchar:
+                if (src == input.length)
+                    goto Lnomatch;
+                debug(regexp) printf("\tREchar '%c', src = '%c'\n", program[pc + 1], input[src]);
+                if (program[pc + 1] != input[src])
+                    goto Lnomatch;
+                src++;
+                pc += 1 + char.sizeof;
+                break;
+
+            case REichar:
+                if (src == input.length)
+                    goto Lnomatch;
+                debug(regexp) printf("\tREichar '%c', src = '%c'\n", program[pc + 1], input[src]);
+                c1 = program[pc + 1];
+                c2 = input[src];
+                if (c1 != c2)
+                {
+                    if (islower(cast(rchar)c2))
+                        c2 = std.ctype.toupper(cast(rchar)c2);
+                    else
+                        goto Lnomatch;
+                    if (c1 != c2)
+                        goto Lnomatch;
+                }
+                src++;
+                pc += 1 + char.sizeof;
+                break;
+
+            case REdchar:
+                debug(regexp) printf("\tREdchar '%c', src = '%c'\n", *(cast(dchar *)&program[pc + 1]), input[src]);
+                if (src == input.length)
+                    goto Lnomatch;
+                if (*(cast(dchar *)&program[pc + 1]) != input[src])
+                    goto Lnomatch;
+                src++;
+                pc += 1 + dchar.sizeof;
+                break;
+
+            case REidchar:
+                debug(regexp) printf("\tREidchar '%c', src = '%c'\n", *(cast(dchar *)&program[pc + 1]), input[src]);
+                if (src == input.length)
+                    goto Lnomatch;
+                c1 = *(cast(dchar *)&program[pc + 1]);
+                c2 = input[src];
+                if (c1 != c2)
+                {
+                    if (islower(cast(rchar)c2))
+                        c2 = std.ctype.toupper(cast(rchar)c2);
+                    else
+                        goto Lnomatch;
+                    if (c1 != c2)
+                        goto Lnomatch;
+                }
+                src++;
+                pc += 1 + dchar.sizeof;
+                break;
+
+            case REanychar:
+                debug(regexp) printf("\tREanychar\n");
+                if (src == input.length)
+                    goto Lnomatch;
+                if (!(attributes & REA.dotmatchlf) && input[src] == cast(rchar)'\n')
+                    goto Lnomatch;
+                src += std.utf.stride(input, src);
+                //src++;
+                pc++;
+                break;
+
+            case REstring:
+                len = *cast(uint *)&program[pc + 1];
+                debug(regexp) printf("\tREstring x%x, '%.*s'\n", len,
+                        (&program[pc + 1 + uint.sizeof])[0 .. len]);
+                if (src + len > input.length)
+                    goto Lnomatch;
+                if (memcmp(&program[pc + 1 + uint.sizeof], &input[src], len * rchar.sizeof))
+                    goto Lnomatch;
+                src += len;
+                pc += 1 + uint.sizeof + len * rchar.sizeof;
+                break;
+
+            case REistring:
+                len = *cast(uint *)&program[pc + 1];
+                debug(regexp) printf("\tREistring x%x, '%.*s'\n", len,
+                        (&program[pc + 1 + uint.sizeof])[0 .. len]);
+                if (src + len > input.length)
+                    goto Lnomatch;
+                if (icmp((cast(char*)&program[pc + 1 + uint.sizeof])[0..len],
+                                input[src .. src + len]))
+                    goto Lnomatch;
+                src += len;
+                pc += 1 + uint.sizeof + len * rchar.sizeof;
+                break;
+
+            case REtestbit:
+                pu = (cast(ushort *)&program[pc + 1]);
+                debug(regexp) printf("\tREtestbit %d, %d, '%c', x%02x\n",
+                        pu[0], pu[1], input[src], input[src]);
+                if (src == input.length)
+                    goto Lnomatch;
+                len = pu[1];
+                c1 = input[src];
+                //printf("[x%02x]=x%02x, x%02x\n", c1 >> 3, ((&program[pc + 1 + 4])[c1 >> 3] ), (1 << (c1 & 7)));
+                if (c1 <= pu[0] &&
+                        !((&(program[pc + 1 + 4]))[c1 >> 3] & (1 << (c1 & 7))))
+                    goto Lnomatch;
+                pc += 1 + 2 * ushort.sizeof + len;
+                break;
+
+            case REbit:
+                pu = (cast(ushort *)&program[pc + 1]);
+                debug(regexp) printf("\tREbit %d, %d, '%c'\n",
+                        pu[0], pu[1], input[src]);
+                if (src == input.length)
+                    goto Lnomatch;
+                len = pu[1];
+                c1 = input[src];
+                if (c1 > pu[0])
+                    goto Lnomatch;
+                if (!((&program[pc + 1 + 4])[c1 >> 3] & (1 << (c1 & 7))))
+                    goto Lnomatch;
+                src++;
+                pc += 1 + 2 * ushort.sizeof + len;
+                break;
+
+            case REnotbit:
+                pu = (cast(ushort *)&program[pc + 1]);
+                debug(regexp) printf("\tREnotbit %d, %d, '%c'\n",
+                        pu[0], pu[1], input[src]);
+                if (src == input.length)
+                    goto Lnomatch;
+                len = pu[1];
+                c1 = input[src];
+                if (c1 <= pu[0] &&
+                        ((&program[pc + 1 + 4])[c1 >> 3] & (1 << (c1 & 7))))
+                    goto Lnomatch;
+                src++;
+                pc += 1 + 2 * ushort.sizeof + len;
+                break;
+
+            case RErange:
+                len = *cast(uint *)&program[pc + 1];
+                debug(regexp) printf("\tRErange %d\n", len);
+                if (src == input.length)
+                    goto Lnomatch;
+                // BUG: REA.ignoreCase?
+                if (memchr(cast(char*)&program[pc + 1 + uint.sizeof], input[src], len) == null)
+                    goto Lnomatch;
+                src++;
+                pc += 1 + uint.sizeof + len;
+                break;
+
+            case REnotrange:
+                len = *cast(uint *)&program[pc + 1];
+                debug(regexp) printf("\tREnotrange %d\n", len);
+                if (src == input.length)
+                    goto Lnomatch;
+                // BUG: REA.ignoreCase?
+                if (memchr(cast(char*)&program[pc + 1 + uint.sizeof], input[src], len) != null)
+                    goto Lnomatch;
+                src++;
+                pc += 1 + uint.sizeof + len;
+                break;
+
+            case REbol:
+                debug(regexp) printf("\tREbol\n");
+                if (src == 0)
+                {
+                }
+                else if (attributes & REA.multiline)
+                {
+                    if (input[src - 1] != '\n')
+                        goto Lnomatch;
+                }
+                else
+                    goto Lnomatch;
+                pc++;
+                break;
+
+            case REeol:
+                debug(regexp) printf("\tREeol\n");
+                if (src == input.length)
+                {
+                }
+                else if (attributes & REA.multiline && input[src] == '\n')
+                    src++;
+                else
+                    goto Lnomatch;
+                pc++;
+                break;
+
+            case REor:
+                len = (cast(uint *)&program[pc + 1])[0];
+                debug(regexp) printf("\tREor %d\n", len);
+                pop = pc + 1 + uint.sizeof;
+                ss = src;
+                if (trymatch(pop, pcend))
+                {
+                    if (pcend != program.length)
+                    {	int s;
+
+                        s = src;
+                        if (trymatch(pcend, program.length))
+                        {   debug(regexp) printf("\tfirst operand matched\n");
+                            src = s;
+                            return 1;
+                        }
+                        else
+                        {
+                            // If second branch doesn't match to end, take first anyway
+                            src = ss;
+                            if (!trymatch(pop + len, program.length))
+                            {
+                                debug(regexp) printf("\tfirst operand matched\n");
+                                src = s;
+                                return 1;
+                            }
+                        }
+                        src = ss;
+                    }
+                    else
+                    {	debug(regexp) printf("\tfirst operand matched\n");
+                        return 1;
+                    }
+                }
+                pc = pop + len;		// proceed with 2nd branch
+                break;
+
+            case REgoto:
+                debug(regexp) printf("\tREgoto\n");
+                len = (cast(uint *)&program[pc + 1])[0];
+                pc += 1 + uint.sizeof + len;
+                break;
+
+            case REanystar:
+                debug(regexp) printf("\tREanystar\n");
+                pc++;
+                for (;;)
+                {   int s1;
+                    int s2;
+
+                    s1 = src;
+                    if (src == input.length)
+                        break;
+                    if (!(attributes & REA.dotmatchlf) && input[src] == '\n')
+                        break;
+                    src++;
+                    s2 = src;
+
+                    // If no match after consumption, but it
+                    // did match before, then no match
+                    if (!trymatch(pc, program.length))
+                    {
+                        src = s1;
+                        // BUG: should we save/restore pmatch[]?
+                        if (trymatch(pc, program.length))
+                        {
+                            src = s1;		// no match
+                            break;
+                        }
+                    }
+                    src = s2;
+                }
+                break;
+
+            case REnm:
+            case REnmq:
+                // len, n, m, ()
+                puint = cast(uint *)&program[pc + 1];
+                len = puint[0];
+                n = puint[1];
+                m = puint[2];
+                debug(regexp) printf("\tREnm%s len=%d, n=%u, m=%u\n", (program[pc] == REnmq) ? cast(char*)"q" : cast(char*)"", len, n, m);
+                pop = pc + 1 + uint.sizeof * 3;
+                for (count = 0; count < n; count++)
+                {
+                    if (!trymatch(pop, pop + len))
+                        goto Lnomatch;
+                }
+                if (!psave && count < m)
+                {
+                    //version (Win32)
+                    psave = cast(regmatch_t *)alloca((re_nsub + 1) * regmatch_t.sizeof);
+                    //else
+                    //psave = new regmatch_t[re_nsub + 1];
+                }
+                if (program[pc] == REnmq)	// if minimal munch
+                {
+                    for (; count < m; count++)
+                    {   int s1;
+
+                        memcpy(psave, pmatch.ptr, (re_nsub + 1) * regmatch_t.sizeof);
+                        s1 = src;
+
+                        if (trymatch(pop + len, program.length))
+                        {
+                            src = s1;
+                            memcpy(pmatch.ptr, psave, (re_nsub + 1) * regmatch_t.sizeof);
+                            break;
+                        }
+
+                        if (!trymatch(pop, pop + len))
+                        {   debug(regexp) printf("\tdoesn't match subexpression\n");
+                            break;
+                        }
+
+                        // If source is not consumed, don't
+                        // infinite loop on the match
+                        if (s1 == src)
+                        {   debug(regexp) printf("\tsource is not consumed\n");
+                            break;
+                        }
+                    }
+                }
+                else	// maximal munch
+                {
+                    for (; count < m; count++)
+                    {   int s1;
+                        int s2;
+
+                        memcpy(psave, pmatch.ptr, (re_nsub + 1) * regmatch_t.sizeof);
+                        s1 = src;
+                        if (!trymatch(pop, pop + len))
+                        {   debug(regexp) printf("\tdoesn't match subexpression\n");
+                            break;
+                        }
+                        s2 = src;
+
+                        // If source is not consumed, don't
+                        // infinite loop on the match
+                        if (s1 == s2)
+                        {   debug(regexp) printf("\tsource is not consumed\n");
+                            break;
+                        }
+
+                        // If no match after consumption, but it
+                        // did match before, then no match
+                        if (!trymatch(pop + len, program.length))
+                        {
+                            src = s1;
+                            if (trymatch(pop + len, program.length))
+                            {
+                                src = s1;		// no match
+                                memcpy(pmatch.ptr, psave, (re_nsub + 1) * regmatch_t.sizeof);
+                                break;
+                            }
+                        }
+                        src = s2;
+                    }
+                }
+                debug(regexp) printf("\tREnm len=%d, n=%u, m=%u, DONE count=%d\n", len, n, m, count);
+                pc = pop + len;
+                break;
+
+            case REparen:
+                // len, ()
+                debug(regexp) printf("\tREparen\n");
+                puint = cast(uint *)&program[pc + 1];
+                len = puint[0];
+                n = puint[1];
+                pop = pc + 1 + uint.sizeof * 2;
+                ss = src;
+                if (!trymatch(pop, pop + len))
+                    goto Lnomatch;
+                pmatch[n + 1].rm_so = ss;
+                pmatch[n + 1].rm_eo = src;
+                pc = pop + len;
+                break;
+
+            case REend:
+                debug(regexp) printf("\tREend\n");
+                return 1;		// successful match
+
+            case REwordboundary:
+                debug(regexp) printf("\tREwordboundary\n");
+                if (src > 0 && src < input.length)
+                {
+                    c1 = input[src - 1];
+                    c2 = input[src];
+                    if (!(
+                                (isword(cast(rchar)c1) && !isword(cast(rchar)c2)) ||
+                                (!isword(cast(rchar)c1) && isword(cast(rchar)c2))
+                                )
+                        )
+                        goto Lnomatch;
+                }
+                pc++;
+                break;
+
+            case REnotwordboundary:
+                debug(regexp) printf("\tREnotwordboundary\n");
+                if (src == 0 || src == input.length)
+                    goto Lnomatch;
+                c1 = input[src - 1];
+                c2 = input[src];
+                if (
+                    (isword(cast(rchar)c1) && !isword(cast(rchar)c2)) ||
+                    (!isword(cast(rchar)c1) && isword(cast(rchar)c2))
+                    )
+                    goto Lnomatch;
+                pc++;
+                break;
+
+            case REdigit:
+                debug(regexp) printf("\tREdigit\n");
+                if (src == input.length)
+                    goto Lnomatch;
+                if (!isdigit(input[src]))
+                    goto Lnomatch;
+                src++;
+                pc++;
+                break;
+
+            case REnotdigit:
+                debug(regexp) printf("\tREnotdigit\n");
+                if (src == input.length)
+                    goto Lnomatch;
+                if (isdigit(input[src]))
+                    goto Lnomatch;
+                src++;
+                pc++;
+                break;
+
+            case REspace:
+                debug(regexp) printf("\tREspace\n");
+                if (src == input.length)
+                    goto Lnomatch;
+                if (!isspace(input[src]))
+                    goto Lnomatch;
+                src++;
+                pc++;
+                break;
+
+            case REnotspace:
+                debug(regexp) printf("\tREnotspace\n");
+                if (src == input.length)
+                    goto Lnomatch;
+                if (isspace(input[src]))
+                    goto Lnomatch;
+                src++;
+                pc++;
+                break;
+
+            case REword:
+                debug(regexp) printf("\tREword\n");
+                if (src == input.length)
+                    goto Lnomatch;
+                if (!isword(input[src]))
+                    goto Lnomatch;
+                src++;
+                pc++;
+                break;
+
+            case REnotword:
+                debug(regexp) printf("\tREnotword\n");
+                if (src == input.length)
+                    goto Lnomatch;
+                if (isword(input[src]))
+                    goto Lnomatch;
+                src++;
+                pc++;
+                break;
+
+            case REbackref:
+            {
+                n = program[pc + 1];
+                debug(regexp) printf("\tREbackref %d\n", n);
+
+                int so = pmatch[n + 1].rm_so;
+                int eo = pmatch[n + 1].rm_eo;
+                len = eo - so;
+                if (src + len > input.length)
+                    goto Lnomatch;
+                else if (attributes & REA.ignoreCase)
+                {
+                    if (icmp(input[src .. src + len], input[so .. eo]))
+                        goto Lnomatch;
+                }
+                else if (memcmp(&input[src], &input[so], len * rchar.sizeof))
+                    goto Lnomatch;
+                src += len;
+                pc += 2;
+                break;
+            }
+
+            default:
+                assert(0);
+            }
+        }
+
+      Lnomatch:
+        debug(regexp) printf("\tnomatch pc=%d\n", pc);
+        src = srcsave;
+        return 0;
+    }
+
+/* =================== Compiler ================== */
+
+    int parseRegexp()
+    {   uint offset;
+        uint gotooffset;
+        uint len1;
+        uint len2;
+
+        //printf("parseRegexp() '%.*s'\n", pattern[p .. pattern.length]);
+        offset = buf.offset;
+        for (;;)
+        {
+            assert(p <= pattern.length);
+            if (p == pattern.length)
+            {   buf.write(REend);
+                return 1;
+            }
+            switch (pattern[p])
+            {
+            case ')':
+                return 1;
+
+            case '|':
+                p++;
+                gotooffset = buf.offset;
+                buf.write(REgoto);
+                buf.write(cast(uint)0);
+                len1 = buf.offset - offset;
+                buf.spread(offset, 1 + uint.sizeof);
+                gotooffset += 1 + uint.sizeof;
+                parseRegexp();
+                len2 = buf.offset - (gotooffset + 1 + uint.sizeof);
+                buf.data[offset] = REor;
+                (cast(uint *)&buf.data[offset + 1])[0] = len1;
+                (cast(uint *)&buf.data[gotooffset + 1])[0] = len2;
+                break;
+
+            default:
+                parsePiece();
+                break;
+            }
+        }
+    }
+
+    int parsePiece()
+    {   uint offset;
+        uint len;
+        uint n;
+        uint m;
+        ubyte op;
+        int plength = pattern.length;
+
+        //printf("parsePiece() '%.*s'\n", pattern[p .. pattern.length]);
+        offset = buf.offset;
+        parseAtom();
+        if (p == plength)
+            return 1;
+        switch (pattern[p])
+        {
+        case '*':
+            // Special optimization: replace .* with REanystar
+            if (buf.offset - offset == 1 &&
+                    buf.data[offset] == REanychar &&
+                    p + 1 < plength &&
+                    pattern[p + 1] != '?')
+            {
+                buf.data[offset] = REanystar;
+                p++;
+                break;
+            }
+
+            n = 0;
+            m = inf;
+            goto Lnm;
+
+        case '+':
+            n = 1;
+            m = inf;
+            goto Lnm;
+
+        case '?':
+            n = 0;
+            m = 1;
+            goto Lnm;
+
+        case '{':	// {n} {n,} {n,m}
+            p++;
+            if (p == plength || !isdigit(pattern[p]))
+                goto Lerr;
+            n = 0;
+            do
+            {
+                // BUG: handle overflow
+                n = n * 10 + pattern[p] - '0';
+                p++;
+                if (p == plength)
+                    goto Lerr;
+            } while (isdigit(pattern[p]));
+            if (pattern[p] == '}')		// {n}
+            {	m = n;
+                goto Lnm;
+            }
+            if (pattern[p] != ',')
+                goto Lerr;
+            p++;
+            if (p == plength)
+                goto Lerr;
+            if (pattern[p] == /*{*/ '}')	// {n,}
+            {	m = inf;
+                goto Lnm;
+            }
+            if (!isdigit(pattern[p]))
+                goto Lerr;
+            m = 0;			// {n,m}
+            do
+            {
+                // BUG: handle overflow
+                m = m * 10 + pattern[p] - '0';
+                p++;
+                if (p == plength)
+                    goto Lerr;
+            } while (isdigit(pattern[p]));
+            if (pattern[p] != /*{*/ '}')
+                goto Lerr;
+            goto Lnm;
+
+        Lnm:
+            p++;
+            op = REnm;
+            if (p < plength && pattern[p] == '?')
+            {	op = REnmq;	// minimal munch version
+                p++;
+            }
+            len = buf.offset - offset;
+            buf.spread(offset, 1 + uint.sizeof * 3);
+            buf.data[offset] = op;
+            uint* puint = cast(uint *)&buf.data[offset + 1];
+            puint[0] = len;
+            puint[1] = n;
+            puint[2] = m;
+            break;
+
+        default:
+            break;
+        }
+        return 1;
+
+      Lerr:
+        error("badly formed {n,m}");
+        assert(0);
+    }
+
+    int parseAtom()
+    {   ubyte op;
+        uint offset;
+        rchar c;
+
+        //printf("parseAtom() '%.*s'\n", pattern[p .. pattern.length]);
+        if (p < pattern.length)
+        {
+            c = pattern[p];
+            switch (c)
+            {
+            case '*':
+            case '+':
+            case '?':
+                error("*+? not allowed in atom");
+                p++;
+                return 0;
+
+            case '(':
+                p++;
+                buf.write(REparen);
+                offset = buf.offset;
+                buf.write(cast(uint)0);		// reserve space for length
+                buf.write(re_nsub);
+                re_nsub++;
+                parseRegexp();
+                *cast(uint *)&buf.data[offset] =
+                    buf.offset - (offset + uint.sizeof * 2);
+                if (p == pattern.length || pattern[p] != ')')
+                {
+                    error("')' expected");
+                    return 0;
+                }
+                p++;
+                break;
+
+            case '[':
+                if (!parseRange())
+                    return 0;
+                break;
+
+            case '.':
+                p++;
+                buf.write(REanychar);
+                break;
+
+            case '^':
+                p++;
+                buf.write(REbol);
+                break;
+
+            case '$':
+                p++;
+                buf.write(REeol);
+                break;
+
+            case '\\':
+                p++;
+                if (p == pattern.length)
+                {   error("no character past '\\'");
+                    return 0;
+                }
+                c = pattern[p];
+                switch (c)
+                {
+                case 'b':    op = REwordboundary;	 goto Lop;
+                case 'B':    op = REnotwordboundary; goto Lop;
+                case 'd':    op = REdigit;		 goto Lop;
+                case 'D':    op = REnotdigit;	 goto Lop;
+                case 's':    op = REspace;		 goto Lop;
+                case 'S':    op = REnotspace;	 goto Lop;
+                case 'w':    op = REword;		 goto Lop;
+                case 'W':    op = REnotword;	 goto Lop;
+
+                Lop:
+                    buf.write(op);
+                    p++;
+                    break;
+
+                case 'f':
+                case 'n':
+                case 'r':
+                case 't':
+                case 'v':
+                case 'c':
+                case 'x':
+                case 'u':
+                case '0':
+                    c = cast(char)escape();
+                    goto Lbyte;
+
+                case '1': case '2': case '3':
+                case '4': case '5': case '6':
+                case '7': case '8': case '9':
+                    c -= '1';
+                    if (c < re_nsub)
+                    {   buf.write(REbackref);
+                        buf.write(cast(ubyte)c);
+                    }
+                    else
+                    {   error("no matching back reference");
+                        return 0;
+                    }
+                    p++;
+                    break;
+
+                default:
+                    p++;
+                    goto Lbyte;
+                }
+                break;
+
+            default:
+                p++;
+            Lbyte:
+                op = REchar;
+                if (attributes & REA.ignoreCase)
+                {
+                    if (isalpha(c))
+                    {
+                        op = REichar;
+                        c = cast(char)std.ctype.toupper(c);
+                    }
+                }
+                if (op == REchar && c <= 0xFF)
+                {
+                    // Look ahead and see if we can make this into
+                    // an REstring
+                    int q;
+                    int len;
+
+                    for (q = p; q < pattern.length; ++q)
+                    {	rchar qc = pattern[q];
+
+                        switch (qc)
+                        {
+                        case '{':
+                        case '*':
+                        case '+':
+                        case '?':
+                            if (q == p)
+                                goto Lchar;
+                            q--;
+                            break;
+
+                        case '(':	case ')':
+                        case '|':
+                        case '[':	case ']':
+                        case '.':	case '^':
+                        case '$':	case '\\':
+                        case '}':
+                            break;
+
+                        default:
+                            continue;
+                        }
+                        break;
+                    }
+                    len = q - p;
+                    if (len > 0)
+                    {
+                        debug(regexp) printf("writing string len %d, c = '%c', pattern[p] = '%c'\n", len+1, c, pattern[p]);
+                        buf.reserve(5 + (1 + len) * rchar.sizeof);
+                        buf.write((attributes & REA.ignoreCase) ? REistring : REstring);
+                        buf.write(len + 1);
+                        buf.write(c);
+                        buf.write(pattern[p .. p + len]);
+                        p = q;
+                        break;
+                    }
+                }
+                if (c >= 0x80)
+                {
+                    // Convert to dchar opcode
+                    op = (op == REchar) ? REdchar : REidchar;
+                    buf.write(op);
+                    buf.write(c);
+                }
+                else
+                {
+                  Lchar:
+                    debug(regexp) printf("It's an REchar '%c'\n", c);
+                    buf.write(op);
+                    buf.write(cast(char)c);
+                }
+                break;
+            }
+        }
+        return 1;
+    }
+
+private:
+    class Range
     {
-	char[] s = input[src .. input.length];
-	printf("RegExp.trymatch(pc = %d, src = '%.*s', pcend = %d)\n",
-	    pc, cast(int) s.length, s.ptr, pcend);
+        uint maxc;
+        uint maxb;
+        OutBuffer buf;
+        ubyte* base;
+        BitArray bits;
+
+        this(OutBuffer buf)
+        {
+            this.buf = buf;
+            if (buf.data.length)
+                this.base = &buf.data[buf.offset];
+        }
+
+        void setbitmax(uint u)
+        {   uint b;
+
+            //printf("setbitmax(x%x), maxc = x%x\n", u, maxc);
+            if (u > maxc)
+            {
+                maxc = u;
+                b = u / 8;
+                if (b >= maxb)
+                {	uint u2;
+
+                    u2 = base ? base - &buf.data[0] : 0;
+                    buf.fill0(b - maxb + 1);
+                    base = &buf.data[u2];
+                    maxb = b + 1;
+                    //bits = (cast(bit*)this.base)[0 .. maxc + 1];
+                    bits.ptr = cast(uint*)this.base;
+                }
+                bits.len = maxc + 1;
+            }
+        }
+
+        void setbit2(uint u)
+        {
+            setbitmax(u + 1);
+            //printf("setbit2 [x%02x] |= x%02x\n", u >> 3, 1 << (u & 7));
+            bits[u] = 1;
+        }
+
+    };
+
+    int parseRange()
+    {   ubyte op;
+        int c;
+        int c2;
+        uint i;
+        uint cmax;
+        uint offset;
+
+        cmax = 0x7F;
+        p++;
+        op = REbit;
+        if (p == pattern.length)
+            goto Lerr;
+        if (pattern[p] == '^')
+        {   p++;
+            op = REnotbit;
+            if (p == pattern.length)
+                goto Lerr;
+        }
+        buf.write(op);
+        offset = buf.offset;
+        buf.write(cast(uint)0);		// reserve space for length
+        buf.reserve(128 / 8);
+        auto r = new Range(buf);
+        if (op == REnotbit)
+            r.setbit2(0);
+        switch (pattern[p])
+        {
+        case ']':
+        case '-':
+            c = pattern[p];
+            p++;
+            r.setbit2(c);
+            break;
+
+        default:
+            break;
+        }
+
+        enum RS { start, rliteral, dash };
+        RS rs;
+
+        rs = RS.start;
+        for (;;)
+        {
+            if (p == pattern.length)
+                goto Lerr;
+            switch (pattern[p])
+            {
+            case ']':
+                switch (rs)
+                {   case RS.dash:
+                        r.setbit2('-');
+                case RS.rliteral:
+                    r.setbit2(c);
+                    break;
+                case RS.start:
+                    break;
+                default:
+                    assert(0);
+                }
+                p++;
+                break;
+
+            case '\\':
+                p++;
+                r.setbitmax(cmax);
+                if (p == pattern.length)
+                    goto Lerr;
+                switch (pattern[p])
+                {
+                case 'd':
+                    for (i = '0'; i <= '9'; i++)
+                        r.bits[i] = 1;
+                    goto Lrs;
+
+                case 'D':
+                    for (i = 1; i < '0'; i++)
+                        r.bits[i] = 1;
+                    for (i = '9' + 1; i <= cmax; i++)
+                        r.bits[i] = 1;
+                    goto Lrs;
+
+                case 's':
+                    for (i = 0; i <= cmax; i++)
+                        if (isspace(i))
+                            r.bits[i] = 1;
+                    goto Lrs;
+
+                case 'S':
+                    for (i = 1; i <= cmax; i++)
+                        if (!isspace(i))
+                            r.bits[i] = 1;
+                    goto Lrs;
+
+                case 'w':
+                    for (i = 0; i <= cmax; i++)
+                        if (isword(cast(rchar)i))
+                            r.bits[i] = 1;
+                    goto Lrs;
+
+                case 'W':
+                    for (i = 1; i <= cmax; i++)
+                        if (!isword(cast(rchar)i))
+                            r.bits[i] = 1;
+                    goto Lrs;
+
+                Lrs:
+                    switch (rs)
+                    {   case RS.dash:
+                            r.setbit2('-');
+                    case RS.rliteral:
+                        r.setbit2(c);
+                        break;
+                    default:
+                        break;
+                    }
+                    rs = RS.start;
+                    continue;
+
+                default:
+                    break;
+                }
+                c2 = escape();
+                goto Lrange;
+
+            case '-':
+                p++;
+                if (rs == RS.start)
+                    goto Lrange;
+                else if (rs == RS.rliteral)
+                    rs = RS.dash;
+                else if (rs == RS.dash)
+                {
+                    r.setbit2(c);
+                    r.setbit2('-');
+                    rs = RS.start;
+                }
+                continue;
+
+            default:
+                c2 = pattern[p];
+                p++;
+            Lrange:
+                switch (rs)
+                {   case RS.rliteral:
+                        r.setbit2(c);
+                case RS.start:
+                    c = c2;
+                    rs = RS.rliteral;
+                    break;
+
+                case RS.dash:
+                    if (c > c2)
+                    {   error("inverted range in character class");
+                        return 0;
+                    }
+                    r.setbitmax(c2);
+                    //printf("c = %x, c2 = %x\n",c,c2);
+                    for (; c <= c2; c++)
+                        r.bits[c] = 1;
+                    rs = RS.start;
+                    break;
+
+                default:
+                    assert(0);
+                }
+                continue;
+            }
+            break;
+        }
+        if (attributes & REA.ignoreCase)
+        {
+            // BUG: what about dchar?
+            r.setbitmax(0x7F);
+            for (c = 'a'; c <= 'z'; c++)
+            {
+                if (r.bits[c])
+                    r.bits[c + 'A' - 'a'] = 1;
+                else if (r.bits[c + 'A' - 'a'])
+                    r.bits[c] = 1;
+            }
+        }
+        //printf("maxc = %d, maxb = %d\n",r.maxc,r.maxb);
+        (cast(ushort *)&buf.data[offset])[0] = cast(ushort)r.maxc;
+        (cast(ushort *)&buf.data[offset])[1] = cast(ushort)r.maxb;
+        return 1;
+
+      Lerr:
+        error("invalid range");
+        return 0;
     }
-    srcsave = src;
-    psave = null;
-    for (;;)
+
+    void error(string msg)
     {
-	if (pc == pcend)		// if done matching
-	{   debug(regex) printf("\tprogend\n");
-	    return 1;
-	}
-
-	//printf("\top = %d\n", program[pc]);
-	switch (program[pc])
-	{
-	    case REchar:
-		if (src == input.length)
-		    goto Lnomatch;
-		debug(regexp) printf("\tREchar '%c', src = '%c'\n", program[pc + 1], input[src]);
-		if (program[pc + 1] != input[src])
-		    goto Lnomatch;
-		src++;
-		pc += 1 + char.sizeof;
-		break;
-
-	    case REichar:
-		if (src == input.length)
-		    goto Lnomatch;
-		debug(regexp) printf("\tREichar '%c', src = '%c'\n", program[pc + 1], input[src]);
-		c1 = program[pc + 1];
-		c2 = input[src];
-		if (c1 != c2)
-		{
-		    if (islower(cast(rchar)c2))
-			c2 = std.ctype.toupper(cast(rchar)c2);
-		    else
-			goto Lnomatch;
-		    if (c1 != c2)
-			goto Lnomatch;
-		}
-		src++;
-		pc += 1 + char.sizeof;
-		break;
-
-	    case REdchar:
-		debug(regexp) printf("\tREdchar '%c', src = '%c'\n", *(cast(dchar *)&program[pc + 1]), input[src]);
-		if (src == input.length)
-		    goto Lnomatch;
-		if (*(cast(dchar *)&program[pc + 1]) != input[src])
-		    goto Lnomatch;
-		src++;
-		pc += 1 + dchar.sizeof;
-		break;
-
-	    case REidchar:
-		debug(regexp) printf("\tREidchar '%c', src = '%c'\n", *(cast(dchar *)&program[pc + 1]), input[src]);
-		if (src == input.length)
-		    goto Lnomatch;
-		c1 = *(cast(dchar *)&program[pc + 1]);
-		c2 = input[src];
-		if (c1 != c2)
-		{
-		    if (islower(cast(rchar)c2))
-			c2 = std.ctype.toupper(cast(rchar)c2);
-		    else
-			goto Lnomatch;
-		    if (c1 != c2)
-			goto Lnomatch;
-		}
-		src++;
-		pc += 1 + dchar.sizeof;
-		break;
-
-	    case REanychar:
-		debug(regexp) printf("\tREanychar\n");
-		if (src == input.length)
-		    goto Lnomatch;
-		if (!(attributes & REA.dotmatchlf) && input[src] == cast(rchar)'\n')
-		    goto Lnomatch;
-		src += std.utf.stride(input, src);
-		//src++;
-		pc++;
-		break;
-
-	    case REstring:
-		len = *cast(uint *)&program[pc + 1];
-		debug(regexp)
-		{
-		    char[] s = (&program[pc + 1 + uint.sizeof])[0 .. len];
-		    printf("\tREstring x%x, '%.*s'\n", len,
-			cast(int) s.length, s.ptr);
-		}
-		if (src + len > input.length)
-		    goto Lnomatch;
-		if (memcmp(&program[pc + 1 + uint.sizeof], &input[src], len * rchar.sizeof))
-		    goto Lnomatch;
-		src += len;
-		pc += 1 + uint.sizeof + len * rchar.sizeof;
-		break;
-
-	    case REistring:
-		len = *cast(uint *)&program[pc + 1];
-		debug(regexp)
-		{
-		    char[] s = (&program[pc + 1 + uint.sizeof])[0 .. len];
-		    printf("\tREistring x%x, '%.*s'\n", len,
-			cast(int) s.length, s.ptr);
-		}
-		if (src + len > input.length)
-		    goto Lnomatch;
-		version (Win32)
-		{
-		    if (memicmp(cast(char*)&program[pc + 1 + uint.sizeof], &input[src], len * rchar.sizeof))
-			goto Lnomatch;
-		}
-		else
-		{
-		    if (icmp((cast(char*)&program[pc + 1 + uint.sizeof])[0..len],
-			     input[src .. src + len]))
-			goto Lnomatch;
-		}
-		src += len;
-		pc += 1 + uint.sizeof + len * rchar.sizeof;
-		break;
-
-	    case REtestbit:
-		pu = (cast(ushort *)&program[pc + 1]);
-		debug(regexp) printf("\tREtestbit %d, %d, '%c', x%02x\n",
-		    pu[0], pu[1], input[src], input[src]);
-		if (src == input.length)
-		    goto Lnomatch;
-		len = pu[1];
-		c1 = input[src];
-		//printf("[x%02x]=x%02x, x%02x\n", c1 >> 3, ((&program[pc + 1 + 4])[c1 >> 3] ), (1 << (c1 & 7)));
-		if (c1 <= pu[0] &&
-		    !bt(cast(uint*)&(program[pc + 1 + 4]), c1)) // assumes BitArray implementation
-		    goto Lnomatch;
-		pc += 1 + 2 * ushort.sizeof + len;
-		break;
-
-	    case REbit:
-		pu = (cast(ushort *)&program[pc + 1]);
-		debug(regexp) printf("\tREbit %d, %d, '%c'\n",
-		    pu[0], pu[1], input[src]);
-		if (src == input.length)
-		    goto Lnomatch;
-		len = pu[1];
-		c1 = input[src];
-		if (c1 > pu[0])
-		    goto Lnomatch;
-		if (!bt(cast(uint*)&(program[pc + 1 + 4]), c1)) // assumes BitArray implementation
-		    goto Lnomatch;
-		src++;
-		pc += 1 + 2 * ushort.sizeof + len;
-		break;
-
-	    case REnotbit:
-		pu = (cast(ushort *)&program[pc + 1]);
-		debug(regexp) printf("\tREnotbit %d, %d, '%c'\n",
-		    pu[0], pu[1], input[src]);
-		if (src == input.length)
-		    goto Lnomatch;
-		len = pu[1];
-		c1 = input[src];
-		if (c1 <= pu[0] &&
-		    bt(cast(uint*)&(program[pc + 1 + 4]), c1)) // assumes BitArray implementation
-		    goto Lnomatch;
-		src++;
-		pc += 1 + 2 * ushort.sizeof + len;
-		break;
-
-	    case RErange:
-		len = *cast(uint *)&program[pc + 1];
-		debug(regexp) printf("\tRErange %d\n", len);
-		if (src == input.length)
-		    goto Lnomatch;
-		// BUG: REA.ignoreCase?
-		if (memchr(cast(char*)&program[pc + 1 + uint.sizeof], input[src], len) == null)
-		    goto Lnomatch;
-		src++;
-		pc += 1 + uint.sizeof + len;
-		break;
-
-	    case REnotrange:
-		len = *cast(uint *)&program[pc + 1];
-		debug(regexp) printf("\tREnotrange %d\n", len);
-		if (src == input.length)
-		    goto Lnomatch;
-		// BUG: REA.ignoreCase?
-		if (memchr(cast(char*)&program[pc + 1 + uint.sizeof], input[src], len) != null)
-		    goto Lnomatch;
-		src++;
-		pc += 1 + uint.sizeof + len;
-		break;
-
-	    case REbol:
-		debug(regexp) printf("\tREbol\n");
-		if (src == 0)
-		{
-		}
-		else if (attributes & REA.multiline)
-		{
-		    if (input[src - 1] != '\n')
-			goto Lnomatch;
-		}
-		else
-		    goto Lnomatch;
-		pc++;
-		break;
-
-	    case REeol:
-		debug(regexp) printf("\tREeol\n");
-		if (src == input.length)
-		{
-		}
-		else if (attributes & REA.multiline && input[src] == '\n')
-		    src++;
-		else
-		    goto Lnomatch;
-		pc++;
-		break;
-
-	    case REor:
-		len = (cast(uint *)&program[pc + 1])[0];
-		debug(regexp) printf("\tREor %d\n", len);
-		pop = pc + 1 + uint.sizeof;
-		ss = src;
-		if (trymatch(pop, pcend))
-		{
-		    if (pcend != program.length)
-		    {	int s;
-
-			s = src;
-			if (trymatch(pcend, program.length))
-			{   debug(regexp) printf("\tfirst operand matched\n");
-			    src = s;
-			    return 1;
-			}
-			else
-			{
-			    // If second branch doesn't match to end, take first anyway
-			    src = ss;
-			    if (!trymatch(pop + len, program.length))
-			    {
-				debug(regexp) printf("\tfirst operand matched\n");
-				src = s;
-				return 1;
-			    }
-			}
-			src = ss;
-		    }
-		    else
-		    {	debug(regexp) printf("\tfirst operand matched\n");
-			return 1;
-		    }
-		}
-		pc = pop + len;		// proceed with 2nd branch
-		break;
-
-	    case REgoto:
-		debug(regexp) printf("\tREgoto\n");
-		len = (cast(uint *)&program[pc + 1])[0];
-		pc += 1 + uint.sizeof + len;
-		break;
-
-	    case REanystar:
-		debug(regexp) printf("\tREanystar\n");
-		pc++;
-		for (;;)
-		{   int s1;
-		    int s2;
-
-		    s1 = src;
-		    if (src == input.length)
-			break;
-		    if (!(attributes & REA.dotmatchlf) && input[src] == '\n')
-			break;
-		    src++;
-		    s2 = src;
-
-		    // If no match after consumption, but it
-		    // did match before, then no match
-		    if (!trymatch(pc, program.length))
-		    {
-			src = s1;
-			// BUG: should we save/restore pmatch[]?
-			if (trymatch(pc, program.length))
-			{
-			    src = s1;		// no match
-			    break;
-			}
-		    }
-		    src = s2;
-		}
-		break;
-
-	    case REnm:
-	    case REnmq:
-		// len, n, m, ()
-		puint = cast(uint *)&program[pc + 1];
-		len = puint[0];
-		n = puint[1];
-		m = puint[2];
-		debug(regexp) printf("\tREnm%s len=%d, n=%u, m=%u\n", (program[pc] == REnmq) ? cast(char*)"q" : cast(char*)"", len, n, m);
-		pop = pc + 1 + uint.sizeof * 3;
-		for (count = 0; count < n; count++)
-		{
-		    if (!trymatch(pop, pop + len))
-			goto Lnomatch;
-		}
-		if (!psave && count < m)
-		{
-		    //version (Win32)
-			psave = cast(regmatch_t *)alloca((re_nsub + 1) * regmatch_t.sizeof);
-		    //else
-			//psave = new regmatch_t[re_nsub + 1];
-		}
-		if (program[pc] == REnmq)	// if minimal munch
-		{
-		    for (; count < m; count++)
-		    {   int s1;
-
-			memcpy(psave, pmatch.ptr, (re_nsub + 1) * regmatch_t.sizeof);
-			s1 = src;
-
-			if (trymatch(pop + len, program.length))
-			{
-			    src = s1;
-			    memcpy(pmatch.ptr, psave, (re_nsub + 1) * regmatch_t.sizeof);
-			    break;
-			}
-
-			if (!trymatch(pop, pop + len))
-			{   debug(regexp) printf("\tdoesn't match subexpression\n");
-			    break;
-			}
-
-			// If source is not consumed, don't
-			// infinite loop on the match
-			if (s1 == src)
-			{   debug(regexp) printf("\tsource is not consumed\n");
-			    break;
-			}
-		    }
-		}
-		else	// maximal munch
-		{
-		    for (; count < m; count++)
-		    {   int s1;
-			int s2;
-
-			memcpy(psave, pmatch.ptr, (re_nsub + 1) * regmatch_t.sizeof);
-			s1 = src;
-			if (!trymatch(pop, pop + len))
-			{   debug(regexp) printf("\tdoesn't match subexpression\n");
-			    break;
-			}
-			s2 = src;
-
-			// If source is not consumed, don't
-			// infinite loop on the match
-			if (s1 == s2)
-			{   debug(regexp) printf("\tsource is not consumed\n");
-			    break;
-			}
-
-			// If no match after consumption, but it
-			// did match before, then no match
-			if (!trymatch(pop + len, program.length))
-			{
-			    src = s1;
-			    if (trymatch(pop + len, program.length))
-			    {
-				src = s1;		// no match
-				memcpy(pmatch.ptr, psave, (re_nsub + 1) * regmatch_t.sizeof);
-				break;
-			    }
-			}
-			src = s2;
-		    }
-		}
-		debug(regexp) printf("\tREnm len=%d, n=%u, m=%u, DONE count=%d\n", len, n, m, count);
-		pc = pop + len;
-		break;
-
-	    case REparen:
-		// len, ()
-		debug(regexp) printf("\tREparen\n");
-		puint = cast(uint *)&program[pc + 1];
-		len = puint[0];
-		n = puint[1];
-		pop = pc + 1 + uint.sizeof * 2;
-		ss = src;
-		if (!trymatch(pop, pop + len))
-		    goto Lnomatch;
-		pmatch[n + 1].rm_so = ss;
-		pmatch[n + 1].rm_eo = src;
-		pc = pop + len;
-		break;
-
-	    case REend:
-		debug(regexp) printf("\tREend\n");
-		return 1;		// successful match
-
-	    case REwordboundary:
-		debug(regexp) printf("\tREwordboundary\n");
-		if (src > 0 && src < input.length)
-		{
-		    c1 = input[src - 1];
-		    c2 = input[src];
-		    if (!(
-			  (isword(cast(rchar)c1) && !isword(cast(rchar)c2)) ||
-			  (!isword(cast(rchar)c1) && isword(cast(rchar)c2))
-			 )
-		       )
-			goto Lnomatch;
-		}
-		pc++;
-		break;
-
-	    case REnotwordboundary:
-		debug(regexp) printf("\tREnotwordboundary\n");
-		if (src == 0 || src == input.length)
-		    goto Lnomatch;
-		c1 = input[src - 1];
-		c2 = input[src];
-		if (
-		    (isword(cast(rchar)c1) && !isword(cast(rchar)c2)) ||
-		    (!isword(cast(rchar)c1) && isword(cast(rchar)c2))
-		   )
-		    goto Lnomatch;
-		pc++;
-		break;
-
-	    case REdigit:
-		debug(regexp) printf("\tREdigit\n");
-		if (src == input.length)
-		    goto Lnomatch;
-		if (!isdigit(input[src]))
-		    goto Lnomatch;
-		src++;
-		pc++;
-		break;
-
-	    case REnotdigit:
-		debug(regexp) printf("\tREnotdigit\n");
-		if (src == input.length)
-		    goto Lnomatch;
-		if (isdigit(input[src]))
-		    goto Lnomatch;
-		src++;
-		pc++;
-		break;
-
-	    case REspace:
-		debug(regexp) printf("\tREspace\n");
-		if (src == input.length)
-		    goto Lnomatch;
-		if (!isspace(input[src]))
-		    goto Lnomatch;
-		src++;
-		pc++;
-		break;
-
-	    case REnotspace:
-		debug(regexp) printf("\tREnotspace\n");
-		if (src == input.length)
-		    goto Lnomatch;
-		if (isspace(input[src]))
-		    goto Lnomatch;
-		src++;
-		pc++;
-		break;
-
-	    case REword:
-		debug(regexp) printf("\tREword\n");
-		if (src == input.length)
-		    goto Lnomatch;
-		if (!isword(input[src]))
-		    goto Lnomatch;
-		src++;
-		pc++;
-		break;
-
-	    case REnotword:
-		debug(regexp) printf("\tREnotword\n");
-		if (src == input.length)
-		    goto Lnomatch;
-		if (isword(input[src]))
-		    goto Lnomatch;
-		src++;
-		pc++;
-		break;
-
-	    case REbackref:
-	    {
-		n = program[pc + 1];
-		debug(regexp) printf("\tREbackref %d\n", n);
-
-		int so = pmatch[n + 1].rm_so;
-		int eo = pmatch[n + 1].rm_eo;
-		len = eo - so;
-		if (src + len > input.length)
-		    goto Lnomatch;
-		else if (attributes & REA.ignoreCase)
-		{
-		    if (icmp(input[src .. src + len], input[so .. eo]))
-			goto Lnomatch;
-		}
-		else if (memcmp(&input[src], &input[so], len * rchar.sizeof))
-		    goto Lnomatch;
-		src += len;
-		pc += 2;
-		break;
-	    }
-
-	    default:
-		assert(0);
-	}
-    }
-
-Lnomatch:
-    debug(regexp) printf("\tnomatch pc=%d\n", pc);
-    src = srcsave;
-    return 0;
-}
-
-/* =================== Compiler ================== */
-
-int parseRegexp()
-{   uint offset;
-    uint gotooffset;
-    uint len1;
-    uint len2;
-
-    //printf("parseRegexp() '%.*s'\n", pattern[p .. pattern.length]);
-    offset = buf.offset;
-    for (;;)
-    {
-	assert(p <= pattern.length);
-	if (p == pattern.length)
-	{   buf.write(REend);
-	    return 1;
-	}
-	switch (pattern[p])
-	{
-	    case ')':
-		return 1;
-
-	    case '|':
-		p++;
-		gotooffset = buf.offset;
-		buf.write(REgoto);
-		buf.write(cast(uint)0);
-		len1 = buf.offset - offset;
-		buf.spread(offset, 1 + uint.sizeof);
-		gotooffset += 1 + uint.sizeof;
-		parseRegexp();
-		len2 = buf.offset - (gotooffset + 1 + uint.sizeof);
-		buf.data[offset] = REor;
-		(cast(uint *)&buf.data[offset + 1])[0] = len1;
-		(cast(uint *)&buf.data[gotooffset + 1])[0] = len2;
-		break;
-
-	    default:
-		parsePiece();
-		break;
-	}
-    }
-    assert(0);
-}
-
-int parsePiece()
-{   uint offset;
-    uint len;
-    uint n;
-    uint m;
-    ubyte op;
-    int plength = pattern.length;
-
-    //printf("parsePiece() '%.*s'\n", pattern[p .. pattern.length]);
-    offset = buf.offset;
-    parseAtom();
-    if (p == plength)
-	return 1;
-    switch (pattern[p])
-    {
-	case '*':
-	    // Special optimization: replace .* with REanystar
-	    if (buf.offset - offset == 1 &&
-		buf.data[offset] == REanychar &&
-		p + 1 < plength &&
-		pattern[p + 1] != '?')
-	    {
-		buf.data[offset] = REanystar;
-		p++;
-		break;
-	    }
-
-	    n = 0;
-	    m = inf;
-	    goto Lnm;
-
-	case '+':
-	    n = 1;
-	    m = inf;
-	    goto Lnm;
-
-	case '?':
-	    n = 0;
-	    m = 1;
-	    goto Lnm;
-
-	case '{':	// {n} {n,} {n,m}
-	    p++;
-	    if (p == plength || !isdigit(pattern[p]))
-		goto Lerr;
-	    n = 0;
-	    do
-	    {
-		// BUG: handle overflow
-		n = n * 10 + pattern[p] - '0';
-		p++;
-		if (p == plength)
-		    goto Lerr;
-	    } while (isdigit(pattern[p]));
-	    if (pattern[p] == '}')		// {n}
-	    {	m = n;
-		goto Lnm;
-	    }
-	    if (pattern[p] != ',')
-		goto Lerr;
-	    p++;
-	    if (p == plength)
-		goto Lerr;
-	    if (pattern[p] == /*{*/ '}')	// {n,}
-	    {	m = inf;
-		goto Lnm;
-	    }
-	    if (!isdigit(pattern[p]))
-		goto Lerr;
-	    m = 0;			// {n,m}
-	    do
-	    {
-		// BUG: handle overflow
-		m = m * 10 + pattern[p] - '0';
-		p++;
-		if (p == plength)
-		    goto Lerr;
-	    } while (isdigit(pattern[p]));
-	    if (pattern[p] != /*{*/ '}')
-		goto Lerr;
-	    goto Lnm;
-
-	Lnm:
-	    p++;
-	    op = REnm;
-	    if (p < plength && pattern[p] == '?')
-	    {	op = REnmq;	// minimal munch version
-		p++;
-	    }
-	    len = buf.offset - offset;
-	    buf.spread(offset, 1 + uint.sizeof * 3);
-	    buf.data[offset] = op;
-	    uint* puint = cast(uint *)&buf.data[offset + 1];
-	    puint[0] = len;
-	    puint[1] = n;
-	    puint[2] = m;
-	    break;
-
-	default:
-	    break;
-    }
-    return 1;
-
-Lerr:
-    error("badly formed {n,m}");
-    assert(0);
-}
-
-int parseAtom()
-{   ubyte op;
-    uint offset;
-    rchar c;
-
-    //printf("parseAtom() '%.*s'\n", pattern[p .. pattern.length]);
-    if (p < pattern.length)
-    {
-	c = pattern[p];
-	switch (c)
-	{
-	    case '*':
-	    case '+':
-	    case '?':
-		error("*+? not allowed in atom");
-		p++;
-		return 0;
-
-	    case '(':
-		p++;
-		buf.write(REparen);
-		offset = buf.offset;
-		buf.write(cast(uint)0);		// reserve space for length
-		buf.write(re_nsub);
-		re_nsub++;
-		parseRegexp();
-		*cast(uint *)&buf.data[offset] =
-		    buf.offset - (offset + uint.sizeof * 2);
-		if (p == pattern.length || pattern[p] != ')')
-		{
-		    error("')' expected");
-		    return 0;
-		}
-		p++;
-		break;
-
-	    case '[':
-		if (!parseRange())
-		    return 0;
-		break;
-
-	    case '.':
-		p++;
-		buf.write(REanychar);
-		break;
-
-	    case '^':
-		p++;
-		buf.write(REbol);
-		break;
-
-	    case '$':
-		p++;
-		buf.write(REeol);
-		break;
-
-	    case '\\':
-		p++;
-		if (p == pattern.length)
-		{   error("no character past '\\'");
-		    return 0;
-		}
-		c = pattern[p];
-		switch (c)
-		{
-		    case 'b':    op = REwordboundary;	 goto Lop;
-		    case 'B':    op = REnotwordboundary; goto Lop;
-		    case 'd':    op = REdigit;		 goto Lop;
-		    case 'D':    op = REnotdigit;	 goto Lop;
-		    case 's':    op = REspace;		 goto Lop;
-		    case 'S':    op = REnotspace;	 goto Lop;
-		    case 'w':    op = REword;		 goto Lop;
-		    case 'W':    op = REnotword;	 goto Lop;
-
-		    Lop:
-			buf.write(op);
-			p++;
-			break;
-
-		    case 'f':
-		    case 'n':
-		    case 'r':
-		    case 't':
-		    case 'v':
-		    case 'c':
-		    case 'x':
-		    case 'u':
-		    case '0':
-			c = cast(char)escape();
-			goto Lbyte;
-
-		    case '1': case '2': case '3':
-		    case '4': case '5': case '6':
-		    case '7': case '8': case '9':
-			c -= '1';
-			if (c < re_nsub)
-			{   buf.write(REbackref);
-			    buf.write(cast(ubyte)c);
-			}
-			else
-			{   error("no matching back reference");
-			    return 0;
-			}
-			p++;
-			break;
-
-		    default:
-			p++;
-			goto Lbyte;
-		}
-		break;
-
-	    default:
-		p++;
-	    Lbyte:
-		op = REchar;
-		if (attributes & REA.ignoreCase)
-		{
-		    if (isalpha(c))
-		    {
-			op = REichar;
-			c = cast(char)std.ctype.toupper(c);
-		    }
-		}
-		if (op == REchar && c <= 0xFF)
-		{
-		    // Look ahead and see if we can make this into
-		    // an REstring
-		    int q;
-		    int len;
-
-		    for (q = p; q < pattern.length; ++q)
-		    {	rchar qc = pattern[q];
-
-			switch (qc)
-			{
-			    case '{':
-			    case '*':
-			    case '+':
-			    case '?':
-				if (q == p)
-				    goto Lchar;
-				q--;
-				break;
-
-			    case '(':	case ')':
-			    case '|':
-			    case '[':	case ']':
-			    case '.':	case '^':
-			    case '$':	case '\\':
-			    case '}':
-				break;
-
-			    default:
-				continue;
-			}
-			break;
-		    }
-		    len = q - p;
-		    if (len > 0)
-		    {
-			debug(regexp) printf("writing string len %d, c = '%c', pattern[p] = '%c'\n", len+1, c, pattern[p]);
-			buf.reserve(5 + (1 + len) * rchar.sizeof);
-			buf.write((attributes & REA.ignoreCase) ? REistring : REstring);
-			buf.write(len + 1);
-			buf.write(c);
-			buf.write(pattern[p .. p + len]);
-			p = q;
-			break;
-		    }
-		}
-		if (c >= 0x80)
-		{
-		    // Convert to dchar opcode
-		    op = (op == REchar) ? REdchar : REidchar;
-		    buf.write(op);
-		    buf.write(c);
-		}
-		else
-		{
-		 Lchar:
-		    debug(regexp) printf("It's an REchar '%c'\n", c);
-		    buf.write(op);
-		    buf.write(cast(char)c);
-		}
-		break;
-	}
-    }
-    return 1;
-}
-
-private:
-class Range
-{
-    uint maxc;
-    uint maxb;
-    OutBuffer buf;
-    ubyte* base;
-    BitArray bits;
-
-    this(OutBuffer buf)
-    {
-	this.buf = buf;
-	if (buf.data.length)
-	    this.base = &buf.data[buf.offset];
-    }
-
-    void setbitmax(uint u)
-    {   uint b;
-
-	//printf("setbitmax(x%x), maxc = x%x\n", u, maxc);
-	if (u > maxc)
-	{
-	    maxc = u;
-	    b = u / 8;
-	    if (b >= maxb)
-	    {	uint u2;
-
-		u2 = base ? base - &buf.data[0] : 0;
-		++b;
-		version (BigEndian)
-		{
-		    while (b & (uint.sizeof-1))
-			++b;
-		}
-		
-		buf.fill0(b - maxb);
-		base = &buf.data[u2];
-		maxb = b;
-		// %% moved array recreate out of this condition
-		bits.ptr = cast(uint*)this.base;
- 	    }
-	    //bits = (cast(bit*)this.base)[0 .. maxc + 1];
-	    bits.len = maxc + 1;
-	}
-    }
-
-    void setbit2(uint u)
-    {
-	setbitmax(u + 1);
-	//printf("setbit2 [x%02x] |= x%02x\n", u >> 3, 1 << (u & 7));
-	bits[u] = 1;
-    }
-
-};
-
-int parseRange()
-{   ubyte op;
-    int c;
-    int c2;
-    uint i;
-    uint cmax;
-    uint offset;
-
-    cmax = 0x7F;
-    p++;
-    op = REbit;
-    if (p == pattern.length)
-	goto Lerr;
-    if (pattern[p] == '^')
-    {   p++;
-	op = REnotbit;
-	if (p == pattern.length)
-	    goto Lerr;
-    }
-    buf.write(op);
-    offset = buf.offset;
-    buf.write(cast(uint)0);		// reserve space for length
-    buf.reserve(128 / 8);
-    auto r = new Range(buf);
-    if (op == REnotbit)
-	r.setbit2(0);
-    switch (pattern[p])
-    {
-	case ']':
-	case '-':
-	    c = pattern[p];
-	    p++;
-	    r.setbit2(c);
-	    break;
-
-	default:
-	    break;
-    }
-
-    enum RS { start, rliteral, dash };
-    RS rs;
-
-    rs = RS.start;
-    for (;;)
-    {
-	if (p == pattern.length)
-	    goto Lerr;
-	switch (pattern[p])
-	{
-	    case ']':
-		switch (rs)
-		{   case RS.dash:
-			r.setbit2('-');
-		    case RS.rliteral:
-			r.setbit2(c);
-			break;
-		    case RS.start:
-			break;
-		    default:
-			assert(0);
-		}
-		p++;
-		break;
-
-	    case '\\':
-		p++;
-		r.setbitmax(cmax);
-		if (p == pattern.length)
-		    goto Lerr;
-		switch (pattern[p])
-		{
-		    case 'd':
-			for (i = '0'; i <= '9'; i++)
-			    r.bits[i] = 1;
-			goto Lrs;
-
-		    case 'D':
-			for (i = 1; i < '0'; i++)
-			    r.bits[i] = 1;
-			for (i = '9' + 1; i <= cmax; i++)
-			    r.bits[i] = 1;
-			goto Lrs;
-
-		    case 's':
-			for (i = 0; i <= cmax; i++)
-			    if (isspace(i))
-				r.bits[i] = 1;
-			goto Lrs;
-
-		    case 'S':
-			for (i = 1; i <= cmax; i++)
-			    if (!isspace(i))
-				r.bits[i] = 1;
-			goto Lrs;
-
-		    case 'w':
-			for (i = 0; i <= cmax; i++)
-			    if (isword(cast(rchar)i))
-				r.bits[i] = 1;
-			goto Lrs;
-
-		    case 'W':
-			for (i = 1; i <= cmax; i++)
-			    if (!isword(cast(rchar)i))
-				r.bits[i] = 1;
-			goto Lrs;
-
-		    Lrs:
-			switch (rs)
-			{   case RS.dash:
-				r.setbit2('-');
-			    case RS.rliteral:
-				r.setbit2(c);
-				break;
-			    default:
-				break;
-			}
-			rs = RS.start;
-			continue;
-
-		    default:
-			break;
-		}
-		c2 = escape();
-		goto Lrange;
-
-	    case '-':
-		p++;
-		if (rs == RS.start)
-		    goto Lrange;
-		else if (rs == RS.rliteral)
-		    rs = RS.dash;
-		else if (rs == RS.dash)
-		{
-		    r.setbit2(c);
-		    r.setbit2('-');
-		    rs = RS.start;
-		}
-		continue;
-
-	    default:
-		c2 = pattern[p];
-		p++;
-	    Lrange:
-		switch (rs)
-		{   case RS.rliteral:
-			r.setbit2(c);
-		    case RS.start:
-			c = c2;
-			rs = RS.rliteral;
-			break;
-
-		    case RS.dash:
-			if (c > c2)
-			{   error("inverted range in character class");
-			    return 0;
-			}
-			r.setbitmax(c2);
-			//printf("c = %x, c2 = %x\n",c,c2);
-			for (; c <= c2; c++)
-			    r.bits[c] = 1;
-			rs = RS.start;
-			break;
-
-		    default:
-			assert(0);
-		}
-		continue;
-	}
-	break;
-    }
-    if (attributes & REA.ignoreCase)
-    {
-	// BUG: what about dchar?
-	r.setbitmax(0x7F);
-	for (c = 'a'; c <= 'z'; c++)
-	{
-	    if (r.bits[c])
-		r.bits[c + 'A' - 'a'] = 1;
-	    else if (r.bits[c + 'A' - 'a'])
-		r.bits[c] = 1;
-	}
-    }
-    //printf("maxc = %d, maxb = %d\n",r.maxc,r.maxb);
-    (cast(ushort *)&buf.data[offset])[0] = cast(ushort)r.maxc;
-    (cast(ushort *)&buf.data[offset])[1] = cast(ushort)r.maxb;
-    return 1;
-
-Lerr:
-    error("invalid range");
-    return 0;
-}
-
-void error(string msg)
-{
-    errors++;
-    debug(regexp) printf("error: %.*s\n", cast(int) msg.length, msg.ptr);
+        errors++;
+        debug(regexp) printf("error: %.*s\n", msg);
 //assert(0);
 //*(char*)0=0;
-    throw new RegExpException(msg);
-}
+        throw new RegExpException(msg);
+    }
 
 // p is following the \ char
-int escape()
-in
-{
-    assert(p < pattern.length);
-}
-body
-{   int c;
-    int i;
-    rchar tc;
-
-    c = pattern[p];		// none of the cases are multibyte
-    switch (c)
+    int escape()
+    in
     {
-	case 'b':    c = '\b';	break;
-	case 'f':    c = '\f';	break;
-	case 'n':    c = '\n';	break;
-	case 'r':    c = '\r';	break;
-	case 't':    c = '\t';	break;
-	case 'v':    c = '\v';	break;
-
-	// BUG: Perl does \a and \e too, should we?
-
-	case 'c':
-	    ++p;
-	    if (p == pattern.length)
-		goto Lretc;
-	    c = pattern[p];
-	    // Note: we are deliberately not allowing dchar letters
-	    if (!(('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')))
-	    {
-	     Lcerr:
-		error("letter expected following \\c");
-		return 0;
-	    }
-	    c &= 0x1F;
-	    break;
-
-	case '0':
-	case '1':
-	case '2':
-	case '3':
-	case '4':
-	case '5':
-	case '6':
-	case '7':
-	    c -= '0';
-	    for (i = 0; i < 2; i++)
-	    {
-		p++;
-		if (p == pattern.length)
-		    goto Lretc;
-		tc = pattern[p];
-		if ('0' <= tc && tc <= '7')
-		{   c = c * 8 + (tc - '0');
-		    // Treat overflow as if last
-		    // digit was not an octal digit
-		    if (c >= 0xFF)
-		    {	c >>= 3;
-			return c;
-		    }
-		}
-		else
-		    return c;
-	    }
-	    break;
-
-	case 'x':
-	    c = 0;
-	    for (i = 0; i < 2; i++)
-	    {
-		p++;
-		if (p == pattern.length)
-		    goto Lretc;
-		tc = pattern[p];
-		if ('0' <= tc && tc <= '9')
-		    c = c * 16 + (tc - '0');
-		else if ('a' <= tc && tc <= 'f')
-		    c = c * 16 + (tc - 'a' + 10);
-		else if ('A' <= tc && tc <= 'F')
-		    c = c * 16 + (tc - 'A' + 10);
-		else if (i == 0)	// if no hex digits after \x
-		{
-		    // Not a valid \xXX sequence
-		    return 'x';
-		}
-		else
-		    return c;
-	    }
-	    break;
-
-	case 'u':
-	    c = 0;
-	    for (i = 0; i < 4; i++)
-	    {
-		p++;
-		if (p == pattern.length)
-		    goto Lretc;
-		tc = pattern[p];
-		if ('0' <= tc && tc <= '9')
-		    c = c * 16 + (tc - '0');
-		else if ('a' <= tc && tc <= 'f')
-		    c = c * 16 + (tc - 'a' + 10);
-		else if ('A' <= tc && tc <= 'F')
-		    c = c * 16 + (tc - 'A' + 10);
-		else
-		{
-		    // Not a valid \uXXXX sequence
-		    p -= i;
-		    return 'u';
-		}
-	    }
-	    break;
-
-	default:
-	    break;
+        assert(p < pattern.length);
     }
-    p++;
-Lretc:
-    return c;
-}
+    body
+    {   int c;
+        int i;
+        rchar tc;
+
+        c = pattern[p];		// none of the cases are multibyte
+        switch (c)
+        {
+        case 'b':    c = '\b';	break;
+        case 'f':    c = '\f';	break;
+        case 'n':    c = '\n';	break;
+        case 'r':    c = '\r';	break;
+        case 't':    c = '\t';	break;
+        case 'v':    c = '\v';	break;
+
+            // BUG: Perl does \a and \e too, should we?
+
+        case 'c':
+            ++p;
+            if (p == pattern.length)
+                goto Lretc;
+            c = pattern[p];
+            // Note: we are deliberately not allowing dchar letters
+            if (!(('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')))
+            {
+              Lcerr:
+                error("letter expected following \\c");
+                return 0;
+            }
+            c &= 0x1F;
+            break;
+
+        case '0':
+        case '1':
+        case '2':
+        case '3':
+        case '4':
+        case '5':
+        case '6':
+        case '7':
+            c -= '0';
+            for (i = 0; i < 2; i++)
+            {
+                p++;
+                if (p == pattern.length)
+                    goto Lretc;
+                tc = pattern[p];
+                if ('0' <= tc && tc <= '7')
+                {   c = c * 8 + (tc - '0');
+                    // Treat overflow as if last
+                    // digit was not an octal digit
+                    if (c >= 0xFF)
+                    {	c >>= 3;
+                        return c;
+                    }
+                }
+                else
+                    return c;
+            }
+            break;
+
+        case 'x':
+            c = 0;
+            for (i = 0; i < 2; i++)
+            {
+                p++;
+                if (p == pattern.length)
+                    goto Lretc;
+                tc = pattern[p];
+                if ('0' <= tc && tc <= '9')
+                    c = c * 16 + (tc - '0');
+                else if ('a' <= tc && tc <= 'f')
+                    c = c * 16 + (tc - 'a' + 10);
+                else if ('A' <= tc && tc <= 'F')
+                    c = c * 16 + (tc - 'A' + 10);
+                else if (i == 0)	// if no hex digits after \x
+                {
+                    // Not a valid \xXX sequence
+                    return 'x';
+                }
+                else
+                    return c;
+            }
+            break;
+
+        case 'u':
+            c = 0;
+            for (i = 0; i < 4; i++)
+            {
+                p++;
+                if (p == pattern.length)
+                    goto Lretc;
+                tc = pattern[p];
+                if ('0' <= tc && tc <= '9')
+                    c = c * 16 + (tc - '0');
+                else if ('a' <= tc && tc <= 'f')
+                    c = c * 16 + (tc - 'a' + 10);
+                else if ('A' <= tc && tc <= 'F')
+                    c = c * 16 + (tc - 'A' + 10);
+                else
+                {
+                    // Not a valid \uXXXX sequence
+                    p -= i;
+                    return 'u';
+                }
+            }
+            break;
+
+        default:
+            break;
+        }
+        p++;
+      Lretc:
+        return c;
+    }
 
 /* ==================== optimizer ======================= */
 
-void optimize()
-{   ubyte[] prog;
-
-    debug(regexp) printf("RegExp.optimize()\n");
-    prog = buf.toBytes();
-    for (size_t i = 0; 1;)
-    {
-	//printf("\tprog[%d] = %d, %d\n", i, prog[i], REstring);
-	switch (prog[i])
-	{
-	    case REend:
-	    case REanychar:
-	    case REanystar:
-	    case REbackref:
-	    case REeol:
-	    case REchar:
-	    case REichar:
-	    case REdchar:
-	    case REidchar:
-	    case REstring:
-	    case REistring:
-	    case REtestbit:
-	    case REbit:
-	    case REnotbit:
-	    case RErange:
-	    case REnotrange:
-	    case REwordboundary:
-	    case REnotwordboundary:
-	    case REdigit:
-	    case REnotdigit:
-	    case REspace:
-	    case REnotspace:
-	    case REword:
-	    case REnotword:
-		return;
-
-	    case REbol:
-		i++;
-		continue;
-
-	    case REor:
-	    case REnm:
-	    case REnmq:
-	    case REparen:
-	    case REgoto:
-	    {
-		auto bitbuf = new OutBuffer;
-		auto r = new Range(bitbuf);
-		uint offset;
-
-		offset = i;
-		if (starrchars(r, prog[i .. prog.length]))
-		{
-		    debug(regexp) printf("\tfilter built\n");
-		    buf.spread(offset, 1 + 4 + r.maxb);
-		    buf.data[offset] = REtestbit;
-		    (cast(ushort *)&buf.data[offset + 1])[0] = cast(ushort)r.maxc;
-		    (cast(ushort *)&buf.data[offset + 1])[1] = cast(ushort)r.maxb;
-		    i = offset + 1 + 4;
-		    buf.data[i .. i + r.maxb] = r.base[0 .. r.maxb];
-		}
-		return;
-	    }
-	    default:
-		assert(0);
-	}
+    void optimize()
+    {   ubyte[] prog;
+
+        debug(regexp) printf("RegExp.optimize()\n");
+        prog = buf.toBytes();
+        for (size_t i = 0; 1;)
+        {
+            //printf("\tprog[%d] = %d, %d\n", i, prog[i], REstring);
+            switch (prog[i])
+            {
+            case REend:
+            case REanychar:
+            case REanystar:
+            case REbackref:
+            case REeol:
+            case REchar:
+            case REichar:
+            case REdchar:
+            case REidchar:
+            case REstring:
+            case REistring:
+            case REtestbit:
+            case REbit:
+            case REnotbit:
+            case RErange:
+            case REnotrange:
+            case REwordboundary:
+            case REnotwordboundary:
+            case REdigit:
+            case REnotdigit:
+            case REspace:
+            case REnotspace:
+            case REword:
+            case REnotword:
+                return;
+
+            case REbol:
+                i++;
+                continue;
+
+            case REor:
+            case REnm:
+            case REnmq:
+            case REparen:
+            case REgoto:
+            {
+                auto bitbuf = new OutBuffer;
+                auto r = new Range(bitbuf);
+                uint offset;
+
+                offset = i;
+                if (starrchars(r, prog[i .. prog.length]))
+                {
+                    debug(regexp) printf("\tfilter built\n");
+                    buf.spread(offset, 1 + 4 + r.maxb);
+                    buf.data[offset] = REtestbit;
+                    (cast(ushort *)&buf.data[offset + 1])[0] = cast(ushort)r.maxc;
+                    (cast(ushort *)&buf.data[offset + 1])[1] = cast(ushort)r.maxb;
+                    i = offset + 1 + 4;
+                    buf.data[i .. i + r.maxb] = r.base[0 .. r.maxb];
+                }
+                return;
+            }
+            default:
+                assert(0);
+            }
+        }
     }
-}
 
 /////////////////////////////////////////
 // OR the leading character bits into r.
@@ -2974,181 +2929,181 @@
 // Return 1 if success, 0 if we can't build a filter or
 // if there is no point to one.
 
-int starrchars(Range r, const(ubyte)[] prog)
-{   rchar c;
-    uint maxc;
-    uint maxb;
-    uint len;
-    uint b;
-    uint n;
-    uint m;
-    const(ubyte)* pop;
-
-    //printf("RegExp.starrchars(prog = %p, progend = %p)\n", prog, progend);
-    for (size_t i = 0; i < prog.length;)
-    {
-	switch (prog[i])
-	{
-	    case REchar:
-		c = prog[i + 1];
-		if (c <= 0x7F)
-		    r.setbit2(c);
-		return 1;
-
-	    case REichar:
-		c = prog[i + 1];
-		if (c <= 0x7F)
-		{   r.setbit2(c);
-		    r.setbit2(std.ctype.tolower(cast(rchar)c));
-		}
-		return 1;
-
-	    case REdchar:
-	    case REidchar:
-		return 1;
-
-	    case REanychar:
-		return 0;		// no point
-
-	    case REstring:
-		len = *cast(uint *)&prog[i + 1];
-		assert(len);
-		c = *cast(rchar *)&prog[i + 1 + uint.sizeof];
-		debug(regexp) printf("\tREstring %d, '%c'\n", len, c);
-		if (c <= 0x7F)
-		    r.setbit2(c);
-		return 1;
-
-	    case REistring:
-		len = *cast(uint *)&prog[i + 1];
-		assert(len);
-		c = *cast(rchar *)&prog[i + 1 + uint.sizeof];
-		debug(regexp) printf("\tREistring %d, '%c'\n", len, c);
-		if (c <= 0x7F)
-		{   r.setbit2(std.ctype.toupper(cast(rchar)c));
-		    r.setbit2(std.ctype.tolower(cast(rchar)c));
-		}
-		return 1;
-
-	    case REtestbit:
-	    case REbit:
-		maxc = (cast(ushort *)&prog[i + 1])[0];
-		maxb = (cast(ushort *)&prog[i + 1])[1];
-		if (maxc <= 0x7F)
-		    r.setbitmax(maxc);
-		else
-		    maxb = r.maxb;
-		for (b = 0; b < maxb; b++)
-		    r.base[b] |= prog[i + 1 + 4 + b];
-		return 1;
-
-	    case REnotbit:
-		maxc = (cast(ushort *)&prog[i + 1])[0];
-		maxb = (cast(ushort *)&prog[i + 1])[1];
-		if (maxc <= 0x7F)
-		    r.setbitmax(maxc);
-		else
-		    maxb = r.maxb;
-		for (b = 0; b < maxb; b++)
-		    r.base[b] |= ~prog[i + 1 + 4 + b];
-		return 1;
-
-	    case REbol:
-	    case REeol:
-		return 0;
-
-	    case REor:
-		len = (cast(uint *)&prog[i + 1])[0];
-		return starrchars(r, prog[i + 1 + uint.sizeof .. prog.length]) &&
-		       starrchars(r, prog[i + 1 + uint.sizeof + len .. prog.length]);
-
-	    case REgoto:
-		len = (cast(uint *)&prog[i + 1])[0];
-		i += 1 + uint.sizeof + len;
-		break;
-
-	    case REanystar:
-		return 0;
-
-	    case REnm:
-	    case REnmq:
-		// len, n, m, ()
-		len = (cast(uint *)&prog[i + 1])[0];
-		n   = (cast(uint *)&prog[i + 1])[1];
-		m   = (cast(uint *)&prog[i + 1])[2];
-		pop = &prog[i + 1 + uint.sizeof * 3];
-		if (!starrchars(r, pop[0 .. len]))
-		    return 0;
-		if (n)
-		    return 1;
-		i += 1 + uint.sizeof * 3 + len;
-		break;
-
-	    case REparen:
-		// len, ()
-		len = (cast(uint *)&prog[i + 1])[0];
-		n   = (cast(uint *)&prog[i + 1])[1];
-		pop = &prog[0] + i + 1 + uint.sizeof * 2;
-		return starrchars(r, pop[0 .. len]);
-
-	    case REend:
-		return 0;
-
-	    case REwordboundary:
-	    case REnotwordboundary:
-		return 0;
-
-	    case REdigit:
-		r.setbitmax('9');
-		for (c = '0'; c <= '9'; c++)
-		    r.bits[c] = 1;
-		return 1;
-
-	    case REnotdigit:
-		r.setbitmax(0x7F);
-		for (c = 0; c <= '0'; c++)
-		    r.bits[c] = 1;
-		for (c = '9' + 1; c <= r.maxc; c++)
-		    r.bits[c] = 1;
-		return 1;
-
-	    case REspace:
-		r.setbitmax(0x7F);
-		for (c = 0; c <= r.maxc; c++)
-		    if (isspace(c))
-			r.bits[c] = 1;
-		return 1;
-
-	    case REnotspace:
-		r.setbitmax(0x7F);
-		for (c = 0; c <= r.maxc; c++)
-		    if (!isspace(c))
-			r.bits[c] = 1;
-		return 1;
-
-	    case REword:
-		r.setbitmax(0x7F);
-		for (c = 0; c <= r.maxc; c++)
-		    if (isword(cast(rchar)c))
-			r.bits[c] = 1;
-		return 1;
-
-	    case REnotword:
-		r.setbitmax(0x7F);
-		for (c = 0; c <= r.maxc; c++)
-		    if (!isword(cast(rchar)c))
-			r.bits[c] = 1;
-		return 1;
-
-	    case REbackref:
-		return 0;
-
-	    default:
-		assert(0);
-	}
+    int starrchars(Range r, const(ubyte)[] prog)
+    {   rchar c;
+        uint maxc;
+        uint maxb;
+        uint len;
+        uint b;
+        uint n;
+        uint m;
+        const(ubyte)* pop;
+
+        //printf("RegExp.starrchars(prog = %p, progend = %p)\n", prog, progend);
+        for (size_t i = 0; i < prog.length;)
+        {
+            switch (prog[i])
+            {
+            case REchar:
+                c = prog[i + 1];
+                if (c <= 0x7F)
+                    r.setbit2(c);
+                return 1;
+
+            case REichar:
+                c = prog[i + 1];
+                if (c <= 0x7F)
+                {   r.setbit2(c);
+                    r.setbit2(std.ctype.tolower(cast(rchar)c));
+                }
+                return 1;
+
+            case REdchar:
+            case REidchar:
+                return 1;
+
+            case REanychar:
+                return 0;		// no point
+
+            case REstring:
+                len = *cast(uint *)&prog[i + 1];
+                assert(len);
+                c = *cast(rchar *)&prog[i + 1 + uint.sizeof];
+                debug(regexp) printf("\tREstring %d, '%c'\n", len, c);
+                if (c <= 0x7F)
+                    r.setbit2(c);
+                return 1;
+
+            case REistring:
+                len = *cast(uint *)&prog[i + 1];
+                assert(len);
+                c = *cast(rchar *)&prog[i + 1 + uint.sizeof];
+                debug(regexp) printf("\tREistring %d, '%c'\n", len, c);
+                if (c <= 0x7F)
+                {   r.setbit2(std.ctype.toupper(cast(rchar)c));
+                    r.setbit2(std.ctype.tolower(cast(rchar)c));
+                }
+                return 1;
+
+            case REtestbit:
+            case REbit:
+                maxc = (cast(ushort *)&prog[i + 1])[0];
+                maxb = (cast(ushort *)&prog[i + 1])[1];
+                if (maxc <= 0x7F)
+                    r.setbitmax(maxc);
+                else
+                    maxb = r.maxb;
+                for (b = 0; b < maxb; b++)
+                    r.base[b] |= prog[i + 1 + 4 + b];
+                return 1;
+
+            case REnotbit:
+                maxc = (cast(ushort *)&prog[i + 1])[0];
+                maxb = (cast(ushort *)&prog[i + 1])[1];
+                if (maxc <= 0x7F)
+                    r.setbitmax(maxc);
+                else
+                    maxb = r.maxb;
+                for (b = 0; b < maxb; b++)
+                    r.base[b] |= ~prog[i + 1 + 4 + b];
+                return 1;
+
+            case REbol:
+            case REeol:
+                return 0;
+
+            case REor:
+                len = (cast(uint *)&prog[i + 1])[0];
+                return starrchars(r, prog[i + 1 + uint.sizeof .. prog.length]) &&
+                    starrchars(r, prog[i + 1 + uint.sizeof + len .. prog.length]);
+
+            case REgoto:
+                len = (cast(uint *)&prog[i + 1])[0];
+                i += 1 + uint.sizeof + len;
+                break;
+
+            case REanystar:
+                return 0;
+
+            case REnm:
+            case REnmq:
+                // len, n, m, ()
+                len = (cast(uint *)&prog[i + 1])[0];
+                n   = (cast(uint *)&prog[i + 1])[1];
+                m   = (cast(uint *)&prog[i + 1])[2];
+                pop = &prog[i + 1 + uint.sizeof * 3];
+                if (!starrchars(r, pop[0 .. len]))
+                    return 0;
+                if (n)
+                    return 1;
+                i += 1 + uint.sizeof * 3 + len;
+                break;
+
+            case REparen:
+                // len, ()
+                len = (cast(uint *)&prog[i + 1])[0];
+                n   = (cast(uint *)&prog[i + 1])[1];
+                pop = &prog[0] + i + 1 + uint.sizeof * 2;
+                return starrchars(r, pop[0 .. len]);
+
+            case REend:
+                return 0;
+
+            case REwordboundary:
+            case REnotwordboundary:
+                return 0;
+
+            case REdigit:
+                r.setbitmax('9');
+                for (c = '0'; c <= '9'; c++)
+                    r.bits[c] = 1;
+                return 1;
+
+            case REnotdigit:
+                r.setbitmax(0x7F);
+                for (c = 0; c <= '0'; c++)
+                    r.bits[c] = 1;
+                for (c = '9' + 1; c <= r.maxc; c++)
+                    r.bits[c] = 1;
+                return 1;
+
+            case REspace:
+                r.setbitmax(0x7F);
+                for (c = 0; c <= r.maxc; c++)
+                    if (isspace(c))
+                        r.bits[c] = 1;
+                return 1;
+
+            case REnotspace:
+                r.setbitmax(0x7F);
+                for (c = 0; c <= r.maxc; c++)
+                    if (!isspace(c))
+                        r.bits[c] = 1;
+                return 1;
+
+            case REword:
+                r.setbitmax(0x7F);
+                for (c = 0; c <= r.maxc; c++)
+                    if (isword(cast(rchar)c))
+                        r.bits[c] = 1;
+                return 1;
+
+            case REnotword:
+                r.setbitmax(0x7F);
+                for (c = 0; c <= r.maxc; c++)
+                    if (!isword(cast(rchar)c))
+                        r.bits[c] = 1;
+                return 1;
+
+            case REbackref:
+                return 0;
+
+            default:
+                assert(0);
+            }
+        }
+        return 1;
     }
-    return 1;
-}
 
 /* ==================== replace ======================= */
 
@@ -3158,105 +3113,105 @@
  * string, generate and return a new string.
  */
 
-public string replace(string format)
-{
-    return replace3(format, input, pmatch[0 .. re_nsub + 1]);
-}
+    public string replace(string format)
+    {
+        return replace3(format, input, pmatch[0 .. re_nsub + 1]);
+    }
 
 // Static version that doesn't require a RegExp object to be created
 
-public static string replace3(string format, string input, regmatch_t[] pmatch)
-{
-    string result;
-    uint c2;
-    int rm_so;
-    int rm_eo;
-    int i;
+    public static string replace3(string format, string input, regmatch_t[] pmatch)
+    {
+        string result;
+        uint c2;
+        int rm_so;
+        int rm_eo;
+        int i;
 
 //    printf("replace3(format = '%.*s', input = '%.*s')\n", format, input);
-    result.length = format.length;
-    result.length = 0;
-    for (size_t f = 0; f < format.length; f++)
-    {
-	char c = format[f];
-      L1:
-	if (c != '$')
-	{
-	    result ~= c;
-	    continue;
-	}
-	++f;
-	if (f == format.length)
-	{
-	    result ~= '$';
-	    break;
-	}
-	c = format[f];
-	switch (c)
-	{
-	    case '&':
-		rm_so = pmatch[0].rm_so;
-		rm_eo = pmatch[0].rm_eo;
-		goto Lstring;
-
-	    case '`':
-		rm_so = 0;
-		rm_eo = pmatch[0].rm_so;
-		goto Lstring;
-
-	    case '\'':
-		rm_so = pmatch[0].rm_eo;
-		rm_eo = input.length;
-		goto Lstring;
-
-	    case '0': case '1': case '2': case '3': case '4':
-	    case '5': case '6': case '7': case '8': case '9':
-		i = c - '0';
-		if (f + 1 == format.length)
-		{
-		    if (i == 0)
-		    {
-			result ~= '$';
-			result ~= c;
-			continue;
-		    }
-		}
-		else
-		{
-		    c2 = format[f + 1];
-		    if (c2 >= '0' && c2 <= '9')
-		    {   i = (c - '0') * 10 + (c2 - '0');
-			f++;
-		    }
-		    if (i == 0)
-		    {
-			result ~= '$';
-			result ~= c;
-			c = cast(char)c2;
-			goto L1;
-		    }
-		}
-
-		if (i < pmatch.length)
-		{   rm_so = pmatch[i].rm_so;
-		    rm_eo = pmatch[i].rm_eo;
-		    goto Lstring;
-		}
-		break;
-
-	    Lstring:
-		if (rm_so != rm_eo)
-		    result ~= input[rm_so .. rm_eo];
-		break;
-
-	    default:
-		result ~= '$';
-		result ~= c;
-		break;
-	}
+        result.length = format.length;
+        result.length = 0;
+        for (size_t f = 0; f < format.length; f++)
+        {
+            char c = format[f];
+          L1:
+            if (c != '$')
+            {
+                result ~= c;
+                continue;
+            }
+            ++f;
+            if (f == format.length)
+            {
+                result ~= '$';
+                break;
+            }
+            c = format[f];
+            switch (c)
+            {
+            case '&':
+                rm_so = pmatch[0].rm_so;
+                rm_eo = pmatch[0].rm_eo;
+                goto Lstring;
+
+            case '`':
+                rm_so = 0;
+                rm_eo = pmatch[0].rm_so;
+                goto Lstring;
+
+            case '\'':
+                rm_so = pmatch[0].rm_eo;
+                rm_eo = input.length;
+                goto Lstring;
+
+            case '0': case '1': case '2': case '3': case '4':
+            case '5': case '6': case '7': case '8': case '9':
+                i = c - '0';
+                if (f + 1 == format.length)
+                {
+                    if (i == 0)
+                    {
+                        result ~= '$';
+                        result ~= c;
+                        continue;
+                    }
+                }
+                else
+                {
+                    c2 = format[f + 1];
+                    if (c2 >= '0' && c2 <= '9')
+                    {   i = (c - '0') * 10 + (c2 - '0');
+                        f++;
+                    }
+                    if (i == 0)
+                    {
+                        result ~= '$';
+                        result ~= c;
+                        c = cast(char)c2;
+                        goto L1;
+                    }
+                }
+
+                if (i < pmatch.length)
+                {   rm_so = pmatch[i].rm_so;
+                    rm_eo = pmatch[i].rm_eo;
+                    goto Lstring;
+                }
+                break;
+
+            Lstring:
+                if (rm_so != rm_eo)
+                    result ~= input[rm_so .. rm_eo];
+                break;
+
+            default:
+                result ~= '$';
+                result ~= c;
+                break;
+            }
+        }
+        return result;
     }
-    return result;
-}
 
 /************************************
  * Like replace(char[] format), but uses old style formatting:
@@ -3276,49 +3231,49 @@
 		<td>replace with char <i>c</i>.
 		</tr>
 		</table>
- */
-
-public string replaceOld(string format)
-{
-    string result;
+*/
+
+    public string replaceOld(string format)
+    {
+        string result;
 
 //printf("replace: this = %p so = %d, eo = %d\n", this, pmatch[0].rm_so, pmatch[0].rm_eo);
 //printf("3input = '%.*s'\n", input);
-    result.length = format.length;
-    result.length = 0;
-    for (size_t i; i < format.length; i++)
-    {
-	char c = format[i];
-	switch (c)
-	{
-	    case '&':
+        result.length = format.length;
+        result.length = 0;
+        for (size_t i; i < format.length; i++)
+        {
+            char c = format[i];
+            switch (c)
+            {
+            case '&':
 //printf("match = '%.*s'\n", input[pmatch[0].rm_so .. pmatch[0].rm_eo]);
-		result ~= input[pmatch[0].rm_so .. pmatch[0].rm_eo];
-		break;
-
-	    case '\\':
-		if (i + 1 < format.length)
-		{
-		    c = format[++i];
-		    if (c >= '1' && c <= '9')
-		    {   uint j;
-
-			j = c - '0';
-			if (j <= re_nsub && pmatch[j].rm_so != pmatch[j].rm_eo)
-			    result ~= input[pmatch[j].rm_so .. pmatch[j].rm_eo];
-			break;
-		    }
-		}
-		result ~= c;
-		break;
-
-	    default:
-		result ~= c;
-		break;
-	}
+                result ~= input[pmatch[0].rm_so .. pmatch[0].rm_eo];
+                break;
+
+            case '\\':
+                if (i + 1 < format.length)
+                {
+                    c = format[++i];
+                    if (c >= '1' && c <= '9')
+                    {   uint j;
+
+                        j = c - '0';
+                        if (j <= re_nsub && pmatch[j].rm_so != pmatch[j].rm_eo)
+                            result ~= input[pmatch[j].rm_so .. pmatch[j].rm_eo];
+                        break;
+                    }
+                }
+                result ~= c;
+                break;
+
+            default:
+                result ~= c;
+                break;
+            }
+        }
+        return result;
     }
-    return result;
-}
 
 }
 
@@ -3345,3 +3300,92 @@
     m.replaceOld(`a&b\1c`);
     m.replace(`a$&b$'$1c`);
 }
+
+// Andrei
+//------------------------------------------------------------------------------
+
+struct Pattern(Char)
+{
+    immutable(Char)[] pattern;
+
+    this(immutable(Char)[] pattern)
+    {
+        this.pattern = pattern;
+    }
+}
+
+Pattern!(Char) pattern(Char)(immutable(Char)[] pat)
+{
+    return typeof(return)(pat);
+}
+
+struct Splitter(Range)
+{
+    Range _input;
+    size_t _chunkLength;
+    RegExp _rx;
+
+    private Range search()
+    {
+        //rx = std.regexp.search(_input, "(" ~ _separator.pattern ~ ")");
+        auto i = std.regexp.find(cast(string) _input, _rx);
+        return _input[i >= 0 ? i : _input.length .. _input.length];
+    }
+
+    private void advance()
+    {
+        //writeln("(" ~ _separator.pattern ~ ")");
+        //writeln(_input);
+        //assert(_rx[0].length > 0);
+        _chunkLength += _rx[0].length;
+    }
+
+    this(Range input, Pattern!(char) separator)
+    {
+        _input = input;
+        _rx = RegExp(separator.pattern);
+        _chunkLength = _input.length - search().length;
+    }
+
+    ref auto opSlice()
+    {
+        return this;
+    }
+
+    Range front()
+    {
+        return _input[0 .. _chunkLength];
+    }
+
+    bool empty()
+    {
+        return _input.empty;
+    }
+
+    void popFront()
+    {
+        if (_chunkLength == _input.length)
+        {
+            _input = _input[_chunkLength .. _input.length];
+            return;
+        }
+        advance;
+        _input = _input[_chunkLength .. _input.length];
+        _chunkLength = _input.length - search().length;
+    }
+}
+
+Splitter!(Range) splitter(Range)(Range r, Pattern!(char) pat)
+{
+    static assert(is(Unqual!(typeof(Range.init[0])) == char),
+        Unqual!(typeof(Range.init[0])).stringof);
+    return typeof(return)(cast(string) r, pat);
+}
+
+unittest
+{
+    auto s1 = ", abc, de,  fg, hi, ";
+    auto sp2 = splitter(s1, pattern(", *"));
+    //foreach (e; sp2) writeln("[", e, "]");
+    assert(equal(sp2, ["", "abc", "de", "fg", "hi"][]));
+}
diff -r f12bfe124807 d/phobos2/std/signals.d
--- a/d/phobos2/std/signals.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/signals.d	Thu Oct 14 14:12:53 2010 +0100
@@ -69,7 +69,6 @@
 alias void delegate(Object) DisposeEvt;
 extern (C) void  rt_attachDisposeEvent( Object obj, DisposeEvt evt );
 extern (C) void  rt_detachDisposeEvent( Object obj, DisposeEvt evt );
-
 //debug=signal;
 
 /************************
diff -r f12bfe124807 d/phobos2/std/socket.d
--- a/d/phobos2/std/socket.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/socket.d	Thu Oct 14 14:12:53 2010 +0100
@@ -2,15 +2,15 @@
 
 /*
 	Copyright (C) 2004-2005 Christopher E. Miller
-	
+
 	This software is provided 'as-is', without any express or implied
 	warranty.  In no event will the authors be held liable for any damages
 	arising from the use of this software.
-	
+
 	Permission is granted to anyone to use this software for any purpose,
 	including commercial applications, and to alter it and redistribute it
 	freely, subject to the following restrictions:
-	
+
 	1. The origin of this software must not be misrepresented; you must not
 	   claim that you wrote the original software. If you use this software
 	   in a product, an acknowledgment in the product documentation would be
@@ -19,30 +19,24 @@
 	   be misrepresented as being the original software.
 	3. This notice may not be removed or altered from any source
 	   distribution.
-	
+
 	socket.d 1.3
 	Jan 2005
-	
+
 	Thanks to Benjamin Herr for his assistance.
 */
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, April 2005
-*/
-
 /**
- * Notes: For Win32 systems, link with ws2_32.lib. 
+ * Notes: For Win32 systems, link with ws2_32.lib.
  * Example: See /dmd/samples/d/listener.d.
- * Authors: Christopher E. Miller 
+ * Authors: Christopher E. Miller
  * Macros:
  *	WIKI=Phobos/StdSocket
  */
 
 module std.socket;
 
-private import std.string, std.stdint, std.c.string, std.c.stdlib;
+import core.stdc.stdint, std.string, std.c.string, std.c.stdlib, std.conv;
 
 version(unittest)
 {
@@ -51,30 +45,21 @@
 
 version(Posix)
 {
-    version = BsdSockets;
+	version = BsdSockets;
 }
 
-version (skyos) { /* nothging */ }
-else
-{
-    version = have_getservbyport;
-    version = have_getprotobynumber;
-}
-
-    
 version(Win32)
 {
-
 	pragma (lib, "ws2_32.lib");
 	pragma (lib, "wsock32.lib");
 
 	private import std.c.windows.windows, std.c.windows.winsock;
 	private alias std.c.windows.winsock.timeval _ctimeval;
-	
+
 	typedef SOCKET socket_t = INVALID_SOCKET;
 	private const int _SOCKET_ERROR = SOCKET_ERROR;
-	
-	
+
+
 	private int _lasterr()
 	{
 		return WSAGetLastError();
@@ -82,19 +67,37 @@
 }
 else version(BsdSockets)
 {
-	version (Posix)
+	version(Posix)
 	{
-		private import std.c.unix.unix;
-		private alias std.c.unix.unix.timeval _ctimeval;
+	    version(linux)
+            import std.c.linux.socket : AF_IPX, AF_APPLETALK, SOCK_RDM,
+                IPPROTO_IGMP, IPPROTO_GGP, IPPROTO_PUP, IPPROTO_IDP,
+                protoent, servent, hostent, SD_RECEIVE, SD_SEND, SD_BOTH,
+                MSG_NOSIGNAL, INADDR_NONE, getprotobyname, getprotobynumber,
+                getservbyname, getservbyport, gethostbyname, gethostbyaddr;
+        else version(OSX)
+            private import std.c.osx.socket;
+        else
+            static assert(false);
+        private import core.sys.posix.fcntl;
+        private import core.sys.posix.unistd;
+        private import core.sys.posix.arpa.inet;
+        private import core.sys.posix.netinet.tcp;
+        private import core.sys.posix.netinet.in_;
+        private import core.sys.posix.sys.time;
+        //private import core.sys.posix.sys.select;
+        private import core.sys.posix.sys.socket;
+		private alias core.sys.posix.sys.time.timeval _ctimeval;
 	}
-	
+    private import core.stdc.errno;
+
 	typedef int32_t socket_t = -1;
 	private const int _SOCKET_ERROR = -1;
-	
-	
+
+
 	private int _lasterr()
 	{
-		return getErrno();
+		return errno;
 	}
 }
 else
@@ -117,14 +120,33 @@
 		if(errorCode > 0)
 		{
 		    char[80] buf;
-		    auto cs = _d_gnu_cbridge_strerror(errorCode, buf.ptr, buf.length);
+		    const(char)* cs;
+		    version (linux)
+		    {
+			cs = strerror_r(errorCode, buf.ptr, buf.length);
+		    }
+		    else version (OSX)
+		    {
+			auto errs = strerror_r(errorCode, buf.ptr, buf.length);
+			if (errs == 0)
+			    cs = buf.ptr;
+			else
+			{
+			    cs = "Unknown error";
+			}
+		    }
+		    else
+		    {
+			static assert(0);
+		    }
+
 		    auto len = strlen(cs);
 
 		    if(cs[len - 1] == '\n')
-			len--;
-			if(cs[len - 1] == '\r')
 			    len--;
-			msg = cast(string) (msg ~ ": " ~ cs[0 .. len]);
+		    if(cs[len - 1] == '\r')
+			    len--;
+		    msg = cast(string) (msg ~ ": " ~ cs[0 .. len]);
 		}
 	    }
 
@@ -138,7 +160,7 @@
 	version(Win32)
 	{
 		WSADATA wd;
-		
+
 		// Winsock will still load if an older version is present.
 		// The version is just a request.
 		int val;
@@ -209,27 +231,27 @@
 	ProtocolType type;	/// These members are populated when one of the following functions are called without failure:
 	string name;		/// ditto
 	string[] aliases;	/// ditto
-	
-	
+
+
 	void populate(protoent* proto)
 	{
 		type = cast(ProtocolType)proto.p_proto;
-		name = std.string.toString(proto.p_name).idup;
-		
+		name = to!string(proto.p_name).idup;
+
 		int i;
 		for(i = 0;; i++)
 		{
 			if(!proto.p_aliases[i])
 				break;
 		}
-		
+
 		if(i)
 		{
 			aliases = new string[i];
 			for(i = 0; i != aliases.length; i++)
 			{
-			    aliases[i] =
-				std.string.toString(proto.p_aliases[i]).idup;
+                aliases[i] =
+                    to!string(proto.p_aliases[i]).idup;
 			}
 		}
 		else
@@ -237,7 +259,7 @@
 			aliases = null;
 		}
 	}
-	
+
 	/** Returns false on failure */
 	bool getProtocolByName(string name)
 	{
@@ -248,23 +270,18 @@
 		populate(proto);
 		return true;
 	}
-	
-	
+
+
 	/** Returns false on failure */
 	// Same as getprotobynumber().
 	bool getProtocolByType(ProtocolType type)
 	{
-	    version (have_getprotobynumber)
-	    {
 		protoent* proto;
 		proto = getprotobynumber(type);
 		if(!proto)
 			return false;
 		populate(proto);
 		return true;
-	    }
-	    else
-		return false;
 	}
 }
 
@@ -273,12 +290,13 @@
 {
 	Protocol proto = new Protocol;
 	assert(proto.getProtocolByType(ProtocolType.TCP));
-	printf("About protocol TCP:\n\tName: %.*s\n",
-	    cast(int) proto.name.length, proto.name.ptr);
-	foreach(string s; proto.aliases)
-	{
-	        printf("\tAlias: %.*s\n", cast(int) s.length, s.ptr);
-	}
+	//printf("About protocol TCP:\n\tName: %.*s\n", proto.name);
+	// foreach(string s; proto.aliases)
+	// {
+	// 	printf("\tAlias: %.*s\n", s);
+	// }
+    assert(proto.name == "tcp");
+    assert(proto.aliases.length == 1 && proto.aliases[0] == "TCP");
 }
 
 
@@ -292,28 +310,28 @@
 	string[] aliases;	/// ditto
 	ushort port;		/// ditto
 	string protocolName;	/// ditto
-	
-	
+
+
 	void populate(servent* serv)
 	{
-		name = std.string.toString(serv.s_name).idup;
+		name = to!string(serv.s_name).idup;
 		port = ntohs(cast(ushort)serv.s_port);
-		protocolName = std.string.toString(serv.s_proto).idup;
-		
+		protocolName = to!string(serv.s_proto).idup;
+
 		int i;
 		for(i = 0;; i++)
 		{
 			if(!serv.s_aliases[i])
 				break;
 		}
-		
+
 		if(i)
 		{
 			aliases = new string[i];
 			for(i = 0; i != aliases.length; i++)
 			{
                             aliases[i] =
-                                std.string.toString(serv.s_aliases[i]).idup;
+                                to!string(serv.s_aliases[i]).idup;
 			}
 		}
 		else
@@ -321,7 +339,7 @@
 			aliases = null;
 		}
 	}
-	
+
 	/**
 	 * If a protocol name is omitted, any protocol will be matched.
 	 * Returns: false on failure.
@@ -335,8 +353,8 @@
 		populate(serv);
 		return true;
 	}
-	
-	
+
+
 	// Any protocol name will be matched.
 	/// ditto
 	bool getServiceByName(string name)
@@ -348,40 +366,30 @@
 		populate(serv);
 		return true;
 	}
-	
-	
+
+
 	/// ditto
 	bool getServiceByPort(ushort port, string protocolName)
 	{
-	    version (have_getservbyport)
-	    {
 		servent* serv;
 		serv = getservbyport(port, toStringz(protocolName));
 		if(!serv)
 			return false;
 		populate(serv);
 		return true;
-	    }
-	    else
-		return false;
 	}
-	
-	
+
+
 	// Any protocol name will be matched.
 	/// ditto
 	bool getServiceByPort(ushort port)
 	{
-	    version (have_getservbyport)
-	    {
 		servent* serv;
 		serv = getservbyport(port, null);
 		if(!serv)
 			return false;
 		populate(serv);
 		return true;
-	    }
-	    else
-		return false;
 	}
 }
 
@@ -391,13 +399,19 @@
 	Service serv = new Service;
 	if(serv.getServiceByName("epmap", "tcp"))
 	{
-		printf("About service epmap:\n\tService: %.*s\n\tPort: %d\n\tProtocol: %.*s\n",
-		        cast(int) serv.name.length, serv.name.ptr, serv.port,
-		        cast(int) serv.protocolName.length, serv.protocolName.ptr);
-		foreach(string s; serv.aliases)
-		{
-		        printf("\tAlias: %.*s\n", cast(int) s.length, s.ptr);
-		}
+		// printf("About service epmap:\n\tService: %.*s\n"
+        //         "\tPort: %d\n\tProtocol: %.*s\n",
+        //         serv.name, serv.port, serv.protocolName);
+		// foreach(string s; serv.aliases)
+		// {
+		// 	printf("\tAlias: %.*s\n", s);
+		// }
+	// For reasons unknown this is loc-srv on Wine and epmap on Windows
+        assert(serv.name == "loc-srv" || serv.name == "epmap", serv.name);
+        assert(serv.port == 135);
+        assert(serv.protocolName == "tcp");
+	// This assert used to pass, don't know why it fails now
+        //assert(serv.aliases.length == 1 && serv.aliases[0] == "epmap");
 	}
 	else
 	{
@@ -412,8 +426,8 @@
 class HostException: Exception
 {
 	int errorCode;	/// Platform-specific error code.
-	
-	
+
+
 	this(string msg, int err = 0)
 	{
 		errorCode = err;
@@ -430,50 +444,50 @@
 	string name;
 	string[] aliases;	/// ditto
 	uint32_t[] addrList;	/// ditto
-	
-	
+
+
 	void validHostent(hostent* he)
 	{
 		if(he.h_addrtype != cast(int)AddressFamily.INET || he.h_length != 4)
 			throw new HostException("Address family mismatch", _lasterr());
 	}
-	
-	
+
+
 	void populate(hostent* he)
 	{
 		int i;
 		char* p;
-		
-		name = std.string.toString(he.h_name).idup;
-		
+
+		name = to!string(he.h_name).idup;
+
 		for(i = 0;; i++)
 		{
 			p = he.h_aliases[i];
 			if(!p)
 				break;
 		}
-		
+
 		if(i)
 		{
 			aliases = new string[i];
 			for(i = 0; i != aliases.length; i++)
 			{
                             aliases[i] =
-                                std.string.toString(he.h_aliases[i]).idup;
+                                to!string(he.h_aliases[i]).idup;
 			}
 		}
 		else
 		{
 			aliases = null;
 		}
-		
+
 		for(i = 0;; i++)
 		{
 			p = he.h_addr_list[i];
 			if(!p)
 				break;
 		}
-		
+
 		if(i)
 		{
 			addrList = new uint32_t[i];
@@ -487,10 +501,10 @@
 			addrList = null;
 		}
 	}
-	
+
 	/**
 	 * Resolve host name. Returns false if unable to resolve.
-	 */	
+	 */
 	bool getHostByName(string name)
 	{
 		hostent* he;
@@ -501,11 +515,11 @@
 		populate(he);
 		return true;
 	}
-	
-	
+
+
 	/**
 	 * Resolve IPv4 address number. Returns false if unable to resolve.
-	 */	
+	 */
 	bool getHostByAddr(uint addr)
 	{
 		uint x = htonl(addr);
@@ -517,13 +531,13 @@
 		populate(he);
 		return true;
 	}
-	
-	
+
+
 	/**
 	 * Same as previous, but addr is an IPv4 address string in the
 	 * dotted-decimal form $(I a.b.c.d).
 	 * Returns false if unable to resolve.
-	 */	
+	 */
 	bool getHostByAddr(string addr)
 	{
 		uint x = inet_addr(std.string.toStringz(addr));
@@ -543,25 +557,23 @@
 	InternetHost ih = new InternetHost;
 	if (!ih.getHostByName("www.digitalmars.com"))
 	    return;		// don't fail if not connected to internet
-	printf("addrList.length = %d\n", ih.addrList.length);
+	//printf("addrList.length = %d\n", ih.addrList.length);
 	assert(ih.addrList.length);
 	InternetAddress ia = new InternetAddress(ih.addrList[0], InternetAddress.PORT_ANY);
-	string sia = ia.toAddrString();
-	printf("IPaddress = %.*s\nname = %.*s\n", cast(int) sia.length, sia.ptr,
-	    cast(int) ih.name.length, ih.name.ptr);
-	foreach(int i, string s; ih.aliases)
-	{
-	        printf("aliases[%d] = %.*s\n", i, cast(int) s.length, s.ptr);
-	}
-	
-	printf("---\n");
-	
+    assert(ih.name == "digitalmars.com");
+	// printf("IP address = %.*s\nname = %.*s\n", ia.toAddrString(), ih.name);
+	// foreach(int i, string s; ih.aliases)
+	// {
+	// 	printf("aliases[%d] = %.*s\n", i, s);
+	// }
+	// printf("---\n");
+
 	assert(ih.getHostByAddr(ih.addrList[0]));
-	printf("name = %.*s\n", cast(int) ih.name.length, ih.name.ptr);
-	foreach(int i, string s; ih.aliases)
-	{
-	        printf("aliases[%d] = %.*s\n", i, cast(int) s.length, s.ptr);
-	}
+	// printf("name = %.*s\n", ih.name);
+	// foreach(int i, string s; ih.aliases)
+	// {
+	// 	printf("aliases[%d] = %.*s\n", i, s);
+	// }
 }
 
 
@@ -595,27 +607,27 @@
 {
 	protected:
 	sockaddr sa;
-	
-	
+
+
 	override sockaddr* name()
 	{
 		return &sa;
 	}
-	
-	
+
+
 	override int nameLen()
 	{
 		return sa.sizeof;
 	}
-	
-	
+
+
 	public:
 	override AddressFamily addressFamily()
 	{
 		return cast(AddressFamily)sa.sa_family;
 	}
-	
-	
+
+
 	override string toString()
 	{
 		return "Unknown";
@@ -637,42 +649,42 @@
 	{
 		return cast(sockaddr*)&sin;
 	}
-	
-	
+
+
 	override int nameLen()
 	{
 		return sin.sizeof;
 	}
-	
-	
+
+
 	this()
 	{
 	}
-	
-	
+
+
 	public:
 	const uint ADDR_ANY = INADDR_ANY;	/// Any IPv4 address number.
 	const uint ADDR_NONE = INADDR_NONE;	/// An invalid IPv4 address number.
 	const ushort PORT_ANY = 0;		/// Any IPv4 port number.
-	
+
 	/// Overridden to return AddressFamily.INET.
 	override AddressFamily addressFamily()
 	{
 		return cast(AddressFamily)AddressFamily.INET;
 	}
-	
+
 	/// Returns the IPv4 port number.
 	ushort port()
 	{
 		return ntohs(sin.sin_port);
 	}
-	
+
 	/// Returns the IPv4 address number.
 	uint addr()
 	{
 		return ntohl(sin.sin_addr.s_addr);
 	}
-	
+
 	/**
 	 * Params:
 	 *   addr = an IPv4 address string in the dotted-decimal form a.b.c.d,
@@ -695,7 +707,7 @@
 		sin.sin_addr.s_addr = htonl(uiaddr);
 		sin.sin_port = htons(port);
 	}
-	
+
 	/**
 	 * Construct a new Address. addr may be ADDR_ANY (default) and port may
 	 * be PORT_ANY, and the actual numbers may not be known until a connection
@@ -706,32 +718,32 @@
 		sin.sin_addr.s_addr = htonl(addr);
 		sin.sin_port = htons(port);
 	}
-	
-	/// ditto	
+
+	/// ditto
 	this(ushort port)
 	{
 		sin.sin_addr.s_addr = 0; //any, "0.0.0.0"
 		sin.sin_port = htons(port);
 	}
-	
-	/// Human readable string representing the IPv4 address in dotted-decimal form.	
+
+	/// Human readable string representing the IPv4 address in dotted-decimal form.
 	string toAddrString()
 	{
-            return std.string.toString(inet_ntoa(sin.sin_addr)).idup;
+            return to!string(inet_ntoa(sin.sin_addr)).idup;
 	}
-	
+
 	/// Human readable string representing the IPv4 port.
 	string toPortString()
 	{
-		return std.string.toString(port());
+		return std.conv.to!string(port());
 	}
-	
+
 	/// Human readable string representing the IPv4 address and port in the form $(I a.b.c.d:e).
 	override string toString()
 	{
             return toAddrString() ~ ":" ~ toPortString();
 	}
-	
+
 	/**
 	 * Parse an IPv4 address string in the dotted-decimal form $(I a.b.c.d)
 	 * and return the number.
@@ -773,8 +785,8 @@
 /// Flags may be OR'ed together:
 enum SocketFlags: int
 {
-	NONE =       0,             /// no flags specified 
-	
+	NONE =       0,             /// no flags specified
+
 	OOB =        MSG_OOB,       /// out-of-band stream data
 	PEEK =       MSG_PEEK,      /// peek at incoming data without removing it from the queue, only for receiving
 	DONTROUTE =  MSG_DONTROUTE, /// data should not be subject to routing; this flag may be ignored. Only for sending
@@ -788,7 +800,7 @@
 	// D interface
 	int seconds;		/// Number of seconds.
 	int microseconds;	/// Number of additional microseconds.
-	
+
 	// C interface
 	deprecated
 	{
@@ -804,8 +816,8 @@
 	private:
 	uint maxsockets; /// max desired sockets, the fd_set might be capable of holding more
 	fd_set set;
-	
-	
+
+
 	version(Win32)
 	{
 		uint count()
@@ -818,8 +830,8 @@
 		int maxfd;
 		uint count;
 	}
-	
-	
+
+
 	public:
 
 	/// Set the maximum amount of sockets that may be added.
@@ -828,48 +840,36 @@
 		maxsockets = max;
 		reset();
 	}
-	
+
 	/// Uses the default maximum for the system.
 	this()
 	{
 		this(FD_SETSIZE);
 	}
-	
-	/// Reset the SocketSet so that there are 0 Sockets in the collection.	
+
+	/// Reset the SocketSet so that there are 0 Sockets in the collection.
 	void reset()
 	{
 		FD_ZERO(&set);
-		
+
 		version(BsdSockets)
- 		{
- 			maxfd = -1;
+		{
+			maxfd = -1;
 			count = 0;
- 		}
+		}
 	}
-	
-	
+
+
 	void add(socket_t s)
 	in
 	{
 		// Make sure too many sockets don't get added.
 		assert(count < maxsockets);
-		version(BsdSockets)
-		{
-			version(GNU)
-			{
-			    // Tries to account for little and big endian..er needs work
-			    // assert((s/NFDBITS+1)*NFDBITS/8 <= nbytes);
-			}
-			else
-			{
-				assert(FDELT(s) < (FD_SETSIZE / NFDBITS));
-			}
-		}
 	}
 	body
 	{
 		FD_SET(s, &set);
-		
+
 		version(BsdSockets)
 		{
 			++count;
@@ -877,13 +877,13 @@
 				maxfd = s;
 		}
 	}
-	
+
 	/// Add a Socket to the collection. Adding more than the maximum has dangerous side affects.
 	void add(Socket s)
 	{
 		add(s.sock);
 	}
-	
+
 	void remove(socket_t s)
 	{
 		FD_CLR(s, &set);
@@ -893,40 +893,40 @@
 			// note: adjusting maxfd would require scanning the set, not worth it
 		}
 	}
-	
-	
+
+
 	/// Remove this Socket from the collection.
 	void remove(Socket s)
 	{
 		remove(s.sock);
 	}
-	
+
 	int isSet(socket_t s)
 	{
 		return FD_ISSET(s, &set);
 	}
-	
-	
+
+
 	/// Returns nonzero if this Socket is in the collection.
 	int isSet(Socket s)
 	{
 		return isSet(s.sock);
 	}
-	
+
 
 	/// Return maximum amount of sockets that can be added, like FD_SETSIZE.
 	uint max()
 	{
 		return maxsockets;
 	}
-	
-	
+
+
 	fd_set* toFd_set()
 	{
 		return &set;
 	}
-	
-	
+
+
 	int selectn()
 	{
 		version(Win32)
@@ -956,16 +956,9 @@
 	IPV6 =    ProtocolType.IPV6,	/// internet protocol version 6 level
 }
 
-
 /// Linger information for use with SocketOption.LINGER.
 extern(C) struct linger
 {
-	version (BsdSockets)
-	    version (GNU)
-	    {
-		private alias std.c.unix.unix.linger __unix_linger;
-		static assert(linger.sizeof == __unix_linger.sizeof);
-	    }
 	// D interface
 	version(Win32)
 	{
@@ -974,20 +967,10 @@
 	}
 	else version(BsdSockets)
 	{
-		version (GNU)
-		{
-		    
-		    typeof(__unix_linger.l_onoff) on;
-		    typeof(__unix_linger.l_linger) time;
-		    
-		}
-		else
-		{
-		    int32_t on;
-		    int32_t time;
-		}
+		int32_t on;
+		int32_t time;
 	}
-	
+
 	// C interface
 	deprecated
 	{
@@ -1008,10 +991,10 @@
 	SNDBUF =               SO_SNDBUF,	/// send buffer size
 	RCVBUF =               SO_RCVBUF,	/// receive buffer size
 	DONTROUTE =            SO_DONTROUTE,	/// do not route
-	
+
 	// SocketOptionLevel.TCP:
 	TCP_NODELAY =          .TCP_NODELAY,	/// disable the Nagle algorithm for send coalescing
-	
+
 	// SocketOptionLevel.IPV6:
 	IPV6_UNICAST_HOPS =    .IPV6_UNICAST_HOPS,	///
 	IPV6_MULTICAST_IF =    .IPV6_MULTICAST_IF,	///
@@ -1030,17 +1013,17 @@
 	private:
 	socket_t sock;
 	AddressFamily _family;
-	
+
 	version(Win32)
 	    bool _blocking = false;	/// Property to get or set whether the socket is blocking or nonblocking.
-	
-	
+
+
 	// For use with accepting().
 	protected this()
 	{
 	}
-	
-	
+
+
 	public:
 
 	/**
@@ -1055,8 +1038,8 @@
 			throw new SocketException("Unable to create socket", _lasterr());
 		_family = af;
 	}
-	
-	
+
+
 	// A single protocol exists to support this socket type within the
 	// protocol family, so the ProtocolType is assumed.
 	/// ditto
@@ -1064,8 +1047,8 @@
 	{
 		this(af, type, cast(ProtocolType)0); // Pseudo protocol number.
 	}
-	
-	
+
+
 	/// ditto
 	this(AddressFamily af, SocketType type, string protocolName)
 	{
@@ -1075,14 +1058,14 @@
 			throw new SocketException("Unable to find the protocol", _lasterr());
 		this(af, type, cast(ProtocolType)proto.p_proto);
 	}
-	
-	
+
+
 	~this()
 	{
 		close();
 	}
-	
-	
+
+
 	/// Get underlying socket handle.
 	socket_t handle()
 	{
@@ -1094,7 +1077,7 @@
 	 *
 	 * When a socket is blocking, calls to receive(), accept(), and send()
 	 * will block and wait for data/action.
-	 * A non-blocking socket will immediately return instead of blocking. 
+	 * A non-blocking socket will immediately return instead of blocking.
 	 */
 	bool blocking()
 	{
@@ -1107,7 +1090,7 @@
 			return !(fcntl(handle, F_GETFL, 0) & O_NONBLOCK);
 		}
 	}
-	
+
 	/// ditto
 	void blocking(bool byes)
 	{
@@ -1131,32 +1114,33 @@
 				goto err;
 		}
 		return; // Success.
-		
+
 		err:
 		throw new SocketException("Unable to set socket blocking", _lasterr());
 	}
-	
 
-	/// Get the socket's address family.	
+
+	/// Get the socket's address family.
 	AddressFamily addressFamily() // getter
 	{
 		return _family;
 	}
-	
+
 	/// Property that indicates if this is a valid, alive socket.
 	bool isAlive() // getter
 	{
-		int type, typesize = type.sizeof;
+        int type;
+        socklen_t typesize = cast(socklen_t) type.sizeof;
 		return !getsockopt(sock, SOL_SOCKET, SO_TYPE, cast(char*)&type, &typesize);
 	}
-	
+
 	/// Associate a local address with this socket.
 	void bind(Address addr)
 	{
 		if(_SOCKET_ERROR == .bind(sock, addr.name(), addr.nameLen()))
 			throw new SocketException("Unable to bind socket", _lasterr());
 	}
-	
+
 	/**
 	 * Establish a connection. If the socket is blocking, connect waits for
 	 * the connection to be made. If the socket is nonblocking, connect
@@ -1168,7 +1152,7 @@
 		{
 			int err;
 			err = _lasterr();
-			
+
 			if(!blocking)
 			{
 				version(Win32)
@@ -1189,7 +1173,7 @@
 			throw new SocketException("Unable to connect socket", err);
 		}
 	}
-	
+
 	/**
 	 * Listen for an incoming connection. bind must be called before you can
 	 * listen. The backlog is a request of how many pending incoming
@@ -1200,7 +1184,7 @@
 		if(_SOCKET_ERROR == .listen(sock, backlog))
 			throw new SocketException("Unable to listen on socket", _lasterr());
 	}
-	
+
 	/**
 	 * Called by accept when a new Socket must be created for a new
 	 * connection. To use a derived class, override this method and return an
@@ -1213,7 +1197,7 @@
 	{
 		return new Socket;
 	}
-	
+
 	/**
 	 * Accept an incoming connection. If the socket is blocking, accept
 	 * waits for a connection request. Throws SocketAcceptException if unable
@@ -1227,13 +1211,13 @@
 		newsock = cast(socket_t)topaccept(sock, null, null);
 		if(socket_t.init == newsock)
 			throw new SocketAcceptException("Unable to accept socket connection", _lasterr());
-		
+
 		Socket newSocket;
 		try
 		{
 			newSocket = accepting();
 			assert(newSocket.sock == socket_t.init);
-			
+
 			newSocket.sock = newsock;
 			version(Win32)
 				newSocket._blocking = _blocking; //inherits blocking mode
@@ -1244,17 +1228,17 @@
 			_close(newsock);
 			throw o;
 		}
-		
+
 		return newSocket;
 	}
-	
+
 	/// Disables sends and/or receives.
 	void shutdown(SocketShutdown how)
 	{
 		.shutdown(sock, cast(int)how);
 	}
-	
-	
+
+
 	private static void _close(socket_t sock)
 	{
 		version(Win32)
@@ -1266,7 +1250,7 @@
 			.close(sock);
 		}
 	}
-	
+
 
 	/**
 	 * Immediately drop any connections and release socket resources.
@@ -1280,8 +1264,8 @@
 		_close(sock);
 		sock = socket_t.init;
 	}
-	
-	
+
+
 	private Address newFamilyObject()
 	{
 		Address result;
@@ -1290,48 +1274,48 @@
 			case cast(AddressFamily)AddressFamily.INET:
 				result = new InternetAddress;
 				break;
-			
+
 			default:
 				result = new UnknownAddress;
 		}
 		return result;
 	}
-	
-	
+
+
 	/// Returns the local machine's host name. Idea from mango.
 	static string hostName() // getter
 	{
 		char[256] result; // Host names are limited to 255 chars.
 		if(_SOCKET_ERROR == .gethostname(result.ptr, result.length))
 			throw new SocketException("Unable to obtain host name", _lasterr());
-		return std.string.toString(cast(char*)result).idup;
+		return to!string(cast(char*)result).idup;
 	}
-	
+
 	/// Remote endpoint Address.
 	Address remoteAddress()
 	{
 		Address addr = newFamilyObject();
-		int nameLen = addr.nameLen();
+		socklen_t nameLen = cast(socklen_t) addr.nameLen();
 		if(_SOCKET_ERROR == .getpeername(sock, addr.name(), &nameLen))
 			throw new SocketException("Unable to obtain remote socket address", _lasterr());
 		assert(addr.addressFamily() == _family);
 		return addr;
 	}
-	
+
 	/// Local endpoint Address.
 	Address localAddress()
 	{
 		Address addr = newFamilyObject();
-		int nameLen = addr.nameLen();
+		socklen_t nameLen = cast(socklen_t) addr.nameLen();
 		if(_SOCKET_ERROR == .getsockname(sock, addr.name(), &nameLen))
 			throw new SocketException("Unable to obtain local socket address", _lasterr());
 		assert(addr.addressFamily() == _family);
 		return addr;
 	}
-	
+
 	/// Send or receive error code.
 	const int ERROR = _SOCKET_ERROR;
-	
+
 	/**
 	 * Send data on the connection. Returns the number of bytes actually
 	 * sent, or ERROR on failure. If the socket is blocking and there is no
@@ -1344,13 +1328,13 @@
 		int sent = .send(sock, buf.ptr, buf.length, cast(int)flags);
 		return sent;
 	}
-	
+
 	/// ditto
 	int send(const(void)[] buf)
 	{
 		return send(buf, SocketFlags.NOSIGNAL);
 	}
-	
+
 	/**
 	 * Send data to a specific destination Address. If the destination address is not specified, a connection must have been made and that address is used. If the socket is blocking and there is no buffer space left, sendTo waits.
 	 */
@@ -1360,14 +1344,14 @@
 		int sent = .sendto(sock, buf.ptr, buf.length, cast(int)flags, to.name(), to.nameLen());
 		return sent;
 	}
-	
+
 	/// ditto
 	int sendTo(const(void)[] buf, Address to)
 	{
 		return sendTo(buf, SocketFlags.NONE, to);
 	}
-	
-	
+
+
 	//assumes you connect()ed
 	/// ditto
 	int sendTo(const(void)[] buf, SocketFlags flags)
@@ -1376,15 +1360,15 @@
 		int sent = .sendto(sock, buf.ptr, buf.length, cast(int)flags, null, 0);
 		return sent;
 	}
-	
-	
+
+
 	//assumes you connect()ed
 	/// ditto
 	int sendTo(const(void)[] buf)
 	{
 		return sendTo(buf, SocketFlags.NONE);
 	}
-	
+
 
 	/**
 	 * Receive data on the connection. Returns the number of bytes actually
@@ -1401,13 +1385,13 @@
 		// if(!read) //connection closed
 		return read;
 	}
-	
+
 	/// ditto
 	int receive(void[] buf)
 	{
 		return receive(buf, SocketFlags.NONE);
 	}
-	
+
 	/**
 	 * Receive data and get the remote endpoint Address.
 	 * If the socket is blocking, receiveFrom waits until there is data to
@@ -1420,21 +1404,21 @@
 		if(!buf.length) //return 0 and don't think the connection closed
 			return 0;
 		from = newFamilyObject();
-		int nameLen = from.nameLen();
+		socklen_t nameLen = cast(socklen_t) from.nameLen();
 		int read = .recvfrom(sock, buf.ptr, buf.length, cast(int)flags, from.name(), &nameLen);
 		assert(from.addressFamily() == _family);
 		// if(!read) //connection closed
 		return read;
 	}
-	
-	
+
+
 	/// ditto
 	int receiveFrom(void[] buf, out Address from)
 	{
 		return receiveFrom(buf, SocketFlags.NONE, from);
 	}
-	
-	
+
+
 	//assumes you connect()ed
 	/// ditto
 	int receiveFrom(void[] buf, SocketFlags flags)
@@ -1445,49 +1429,49 @@
 		// if(!read) //connection closed
 		return read;
 	}
-	
-	
+
+
 	//assumes you connect()ed
 	/// ditto
 	int receiveFrom(void[] buf)
 	{
 		return receiveFrom(buf, SocketFlags.NONE);
 	}
-	
 
-	/// Get a socket option. Returns the number of bytes written to result.	
+
+	/// Get a socket option. Returns the number of bytes written to result.
 	//returns the length, in bytes, of the actual result - very different from getsockopt()
 	int getOption(SocketOptionLevel level, SocketOption option, void[] result)
 	{
-		int len = result.length;
+		socklen_t len = cast(socklen_t) result.length;
 		if(_SOCKET_ERROR == .getsockopt(sock, cast(int)level, cast(int)option, result.ptr, &len))
 			throw new SocketException("Unable to get socket option", _lasterr());
 		return len;
 	}
-	
 
-	/// Common case of getting integer and boolean options.	
+
+	/// Common case of getting integer and boolean options.
 	int getOption(SocketOptionLevel level, SocketOption option, out int32_t result)
 	{
 		return getOption(level, option, (&result)[0 .. 1]);
 	}
 
 
-	/// Get the linger option.	
+	/// Get the linger option.
 	int getOption(SocketOptionLevel level, SocketOption option, out linger result)
 	{
 		//return getOption(cast(SocketOptionLevel)SocketOptionLevel.SOCKET, SocketOption.LINGER, (&result)[0 .. 1]);
-		return getOption(level, option, (&result)[0 .. 1]); 
+		return getOption(level, option, (&result)[0 .. 1]);
 	}
-	
+
 	// Set a socket option.
 	void setOption(SocketOptionLevel level, SocketOption option, void[] value)
 	{
 		if(_SOCKET_ERROR == .setsockopt(sock, cast(int)level, cast(int)option, value.ptr, value.length))
 			throw new SocketException("Unable to set socket option", _lasterr());
 	}
-	
-	
+
+
 	/// Common case for setting integer and boolean options.
 	void setOption(SocketOptionLevel level, SocketOption option, int32_t value)
 	{
@@ -1501,7 +1485,7 @@
 		//setOption(cast(SocketOptionLevel)SocketOptionLevel.SOCKET, SocketOption.LINGER, (&value)[0 .. 1]);
 		setOption(level, option, (&value)[0 .. 1]);
 	}
-	
+
 
 	/**
 	 * Wait for a socket to change status. A wait timeout timeval or int microseconds may be specified; if a timeout is not specified or the timeval is null, the maximum timeout is used. The timeval timeout has an unspecified value when select returns. Returns the number of sockets with status changes, 0 on timeout, or -1 on interruption. If the return value is greater than 0, the SocketSets are updated to only contain the sockets having status changes. For a connecting socket, a write status change means the connection is established and it's able to send. For a listening socket, a read status change means there is an incoming connection request and it's able to accept.
@@ -1529,7 +1513,7 @@
 	{
 		fd_set* fr, fw, fe;
 		int n = 0;
-		
+
 		version(Win32)
 		{
 			// Windows has a problem with empty fd_set`s that aren't null.
@@ -1548,7 +1532,7 @@
 			{
 				fr = null;
 			}
-			
+
 			if(checkWrite)
 			{
 				fw = checkWrite.toFd_set();
@@ -1561,7 +1545,7 @@
 			{
 				fw = null;
 			}
-			
+
 			if(checkError)
 			{
 				fe = checkError.toFd_set();
@@ -1575,9 +1559,9 @@
 				fe = null;
 			}
 		}
-		
+
 		int result = .select(n, fr, fw, fe, cast(_ctimeval*)tv);
-		
+
 		version(Win32)
 		{
 			if(_SOCKET_ERROR == result && WSAGetLastError() == WSAEINTR)
@@ -1585,17 +1569,17 @@
 		}
 		else version(Posix)
 		{
-			if(_SOCKET_ERROR == result && getErrno() == EINTR)
+			if(_SOCKET_ERROR == result && errno == EINTR)
 				return -1;
 		}
 		else
 		{
 			static assert(0);
 		}
-		
+
 		if(_SOCKET_ERROR == result)
 			throw new SocketException("Socket select error", _lasterr());
-		
+
 		return result;
 	}
 
@@ -1603,21 +1587,21 @@
 	/// ditto
 	static int select(SocketSet checkRead, SocketSet checkWrite, SocketSet checkError, int microseconds)
 	{
-		timeval tv;
-		tv.seconds = microseconds / 1_000_000;
-		tv.microseconds = microseconds % 1_000_000;
-		return select(checkRead, checkWrite, checkError, &tv);
+	    timeval tv;
+	    tv.seconds = microseconds / 1_000_000;
+	    tv.microseconds = microseconds % 1_000_000;
+	    return select(checkRead, checkWrite, checkError, &tv);
 	}
-	
-	
+
+
 	/// ditto
 	//maximum timeout
 	static int select(SocketSet checkRead, SocketSet checkWrite, SocketSet checkError)
 	{
 		return select(checkRead, checkWrite, checkError, null);
 	}
-	
-	
+
+
 	/+
 	bool poll(events)
 	{
@@ -1636,14 +1620,14 @@
 	{
 		super(family, SocketType.STREAM, ProtocolType.TCP);
 	}
-	
+
 	/// Constructs a blocking TCP Socket.
 	this()
 	{
 		this(cast(AddressFamily)AddressFamily.INET);
 	}
-	
-	
+
+
 	//shortcut
 	/// Constructs a blocking TCP Socket and connects to an InternetAddress.
 	this(Address connectTo)
@@ -1662,8 +1646,8 @@
 	{
 		super(family, SocketType.DGRAM, ProtocolType.UDP);
 	}
-	
-	
+
+
 	/// Constructs a blocking UDP Socket.
 	this()
 	{
diff -r f12bfe124807 d/phobos2/std/stdarg.d
--- a/d/phobos2/std/stdarg.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/stdarg.d	Thu Oct 14 14:12:53 2010 +0100
@@ -9,36 +9,27 @@
 
 /* NOTE: This file has been patched from the original DMD distribution to
    work with the GDC compiler.
-
-   Modified by David Friedman, September 2004
-*/
+ */
 
 module std.stdarg;
 
-version (GNU) {
+version (GNU)
+{
     // va_list might be a pointer, but assuming so is not portable.
     private import gcc.builtins;
     alias __builtin_va_list va_list;
-    
-    // va_arg is handled magically by the compiler
-} else {
+}
+else
+{
     alias void* va_list;
 }
-
+    
+// va_arg is handled magically by the compiler
 template va_arg(T)
 {
     T va_arg(inout va_list _argptr)
     {
-	/*
-	T arg = *cast(T*)_argptr;
-	_argptr = _argptr + ((T.sizeof + int.sizeof - 1) & ~(int.sizeof - 1));
-	return arg;
-	*/
-	T t; return t;
+	T t;
+	return t;
     }
 }
-
-private import std.c.stdarg;
-/* The existence of std.stdarg.va_copy isn't standard.  Prevent
-   conflicts by using '__'. */
-alias std.c.stdarg.va_copy __va_copy;
diff -r f12bfe124807 d/phobos2/std/stdint.d
--- a/d/phobos2/std/stdint.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/stdint.d	Thu Oct 14 14:12:53 2010 +0100
@@ -119,87 +119,6 @@
  *	WIKI=Phobos/StdStdint
  */
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, February 2007
-*/
-
 module std.stdint;
 
-version(GNU)
-    import gcc.builtins;
-
-/* Exact sizes */
-
-alias  byte   int8_t;
-alias ubyte  uint8_t;
-alias  short  int16_t;
-alias ushort uint16_t;
-alias  int    int32_t;
-alias uint   uint32_t;
-alias  long   int64_t;
-alias ulong  uint64_t;
-
-/* At least sizes */
-
-alias  byte   int_least8_t;
-alias ubyte  uint_least8_t;
-alias  short  int_least16_t;
-alias ushort uint_least16_t;
-alias  int    int_least32_t;
-alias uint   uint_least32_t;
-alias  long   int_least64_t;
-alias ulong  uint_least64_t;
-
-/* Fastest minimum width sizes */
-
-alias  byte  int_fast8_t;
-alias ubyte uint_fast8_t;
-alias  int   int_fast16_t;
-alias uint  uint_fast16_t;
-alias  int   int_fast32_t;
-alias uint  uint_fast32_t;
-alias  long  int_fast64_t;
-alias ulong uint_fast64_t;
-
-/* Integer pointer holders */
-
-version(GNU)
-{
-    alias __builtin_pointer_int  intptr_t;
-    alias __builtin_pointer_uint uintptr_t;
-}
-else version(X86_64)
-{
-    alias long   intptr_t;
-    alias ulong  uintptr_t;
-}
-else
-{
-    alias int   intptr_t;
-    alias uint uintptr_t;
-}
-
-/* Greatest width integer types */
-
-alias  long  intmax_t;
-alias ulong uintmax_t;
-
-/* C long types */
-
-version(GNU)
-{
-    alias __builtin_Clong Clong_t;
-    alias __builtin_Culong Culong_t;
-}
-else version(X86_64)
-{
-    alias long Clong_t;
-    alias ulong Culong_t;
-}
-else
-{
-    alias int Clong_t;
-    alias uint Culong_t;
-}
+public import core.stdc.stdint;
diff -r f12bfe124807 d/phobos2/std/stdio.d
--- a/d/phobos2/std/stdio.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/stdio.d	Thu Oct 14 14:12:53 2010 +0100
@@ -1,4 +1,3 @@
-
 // Written in the D programming language.
 
 /* Written by Walter Bright and Andrei Alexandrescu
@@ -6,337 +5,1099 @@
  * Placed in the Public Domain.
  */
 
+/********************************
+Standard I/O functions that extend $(B std.c.stdio).  $(B std.c.stdio)
+is $(D_PARAM public)ally imported when importing $(B std.stdio).
+
+Authors: $(WEB digitalmars.com, Walter Bright), $(WEB erdani.org,
+Andrei Alexandrescu)
+  
+Macros:
+WIKI=Phobos/StdStdio
+ */
+
 /* NOTE: This file has been patched from the original DMD distribution to
    work with the GDC compiler.
-
-   Modified by David Friedman, April 2007
-*/
-
-/********************************
- * Standard I/O functions that extend $(B std.c.stdio).
- * $(B std.c.stdio) is $(D_PARAM public)ally imported when importing
- * $(B std.stdio).
- *
- * Authors:
- *
- * $(WEB digitalmars.com, Walter Bright), $(WEB erdani.org, Andrei
-Alexandrescu)
- * 
- * Macros:
- *	WIKI=Phobos/StdStdio
  */
 
 module std.stdio;
 
-public import std.c.stdio;
-
-import core.memory;
-import std.format;
-import std.utf;
-import std.string;
-import std.c.stdlib;
-import std.c.string;
-import std.c.stddef;
-import std.conv;
-import std.traits;
-import std.contracts;
-import std.file;
-import std.typetuple;
-
-import std.stdarg;
+public import core.stdc.stdio;
+import core.memory, core.stdc.errno, core.stdc.stddef,
+    core.stdc.stdlib, core.stdc.string, core.stdc.wchar_;
+import std.stdiobase;
+import std.algorithm, std.array, std.contracts, std.conv, std.file, std.format,
+    std.metastrings, std.range, std.string, std.traits, std.typecons,
+    std.typetuple, std.utf;
 
 version (GNU)
+    import std.stdarg;
+
+version (DigitalMars) version (Windows)
 {
-    static import gcc.config.config;
-    import gcc.config.config : Have_getdelim, Have_Unlocked_Stdio,
-	Have_Unlocked_Wide_Stdio, Have_fwide, Have_fgetln,
-	Have_fgetline;
+    // Specific to the way Digital Mars C does stdio
+    version = DIGITAL_MARS_STDIO;
+    import std.c.stdio : __fhnd_info, FHND_WCHAR;
+}
 
-    extern(C)
+version (linux)
+{
+    // Specific to the way Gnu C does stdio
+    version = GCC_IO;
+    extern(C) FILE* fopen64(const char*, const char*);
+}
+
+version (OSX)
+{
+    version = GENERIC_IO;
+    alias core.stdc.stdio.fopen fopen64;
+}
+
+version(Windows)
+{
+    alias core.stdc.stdio.fopen fopen64;
+}
+
+version (DIGITAL_MARS_STDIO)
+{
+    extern (C)
     {
-	char * fgetln(FILE *stream, size_t *len);
-	char * fgetline(FILE *stream, size_t *len);
-	int putc_unlocked(int, FILE*);
-	int putwc_unlocked(wchar_t, FILE*);
-	int getc_unlocked(FILE*);
-	int getwc_unlocked(FILE*);
-	void flockfile(FILE*);
-	void funlockfile(FILE*);
+        /* **
+         * Digital Mars under-the-hood C I/O functions
+         */
+        int _fputc_nlock(int, FILE*);
+        int _fputwc_nlock(int, FILE*);
+        int _fgetc_nlock(FILE*);
+        int _fgetwc_nlock(FILE*);
+        int __fp_lock(FILE*);
+        void __fp_unlock(FILE*);
+    }
+    alias _fputc_nlock FPUTC;
+    alias _fputwc_nlock FPUTWC;
+    alias _fgetc_nlock FGETC;
+    alias _fgetwc_nlock FGETWC;
+    
+    alias __fp_lock FLOCK;
+    alias __fp_unlock FUNLOCK;
+}
+else version (GCC_IO)
+{
+    /* **
+     * Gnu under-the-hood C I/O functions; see
+     * http://www.gnu.org/software/libc/manual/html_node/I_002fO-on-Streams.html#I_002fO-on-Streams
+     */
+    //private import std.c.linux.linux;
+    private import core.sys.posix.stdio;
+    extern (C)
+    {
+        int fputc_unlocked(int, FILE*);
+        int fputwc_unlocked(wchar_t, FILE*);
+        int fgetc_unlocked(FILE*);
+        int fgetwc_unlocked(FILE*);
+        void flockfile(FILE*);
+        void funlockfile(FILE*);
+        ssize_t getline(char**, size_t*, FILE*);
+        ssize_t getdelim (char**, size_t*, int, FILE*);
+        
+        private size_t fwrite_unlocked(const(void)* ptr,
+                size_t size, size_t n, FILE *stream);
+    }
 
-	private size_t fwrite_unlocked(const(void)* ptr,
-	    size_t size, size_t n, FILE *stream);
+    version (linux)
+    {
+        // declare fopen64 if not already
+        static if (!is(typeof(fopen64)))
+            extern (C) FILE* fopen64(in char*, in char*);
+    }
+
+    alias fputc_unlocked FPUTC;
+    alias fputwc_unlocked FPUTWC;
+    alias fgetc_unlocked FGETC;
+    alias fgetwc_unlocked FGETWC;
+
+    alias flockfile FLOCK;
+    alias funlockfile FUNLOCK;
+}
+else version (GENERIC_IO)
+{
+    extern (C)
+    {
+        void flockfile(FILE*);
+        void funlockfile(FILE*);
+    }
+
+    alias fputc FPUTC;
+    alias fputwc FPUTWC;
+    alias fgetc FGETC;
+    alias fgetwc FGETWC;
+
+    alias flockfile FLOCK;
+    alias funlockfile FUNLOCK;
+}
+else
+{
+    static assert(0, "unsupported C I/O system");
+}
+/**
+Encapsulates a $(D FILE*). Generally D does not attempt to provide
+thin wrappers over equivalent functions in the C standard library, but
+manipulating $(D FILE*) values directly is unsafe and error-prone in
+many ways. The $(D File) type ensures safe manipulation, automatic
+file closing, and a lot of convenience.
+
+The underlying $(D FILE*) handle is maintained in a reference-counted
+manner, such that as soon as the last $(D File) variable bound to a
+given $(D FILE*) goes out of scope, the underlying $(D FILE*) is
+automatically closed.
+
+Example:
+----
+// test.d
+void main(string args[])
+{
+    auto f = File("test.txt", "w"); // open for writing
+    f.write("Hello");
+    if (args.length > 1)
+    {
+        auto g = f; // now g and f write to the same file
+                    // internal reference count is 2
+        g.write(", ", args[1]);
+        // g exits scope, reference count decreases to 1
+    }
+    f.writeln("!");
+    // f exits scope, reference count falls to zero,
+    // underlying $(D FILE*) is closed.
+}
+----
+<pre class=console>
+% rdmd test.d Jimmy
+% cat test.txt
+Hello, Jimmy!
+% __
+</pre>
+ */
+struct File
+{
+    /*private*/ struct Impl
+    {
+        FILE * handle;
+        uint refs;
+        string name;
+        this(FILE* h, uint r, string n)
+        {
+            handle = h;
+            refs = r;
+            name = n;
+        }
+    }
+    /*private*/ Impl * p;
+
+/**
+Constructor taking the name of the file to open and the open mode
+(with the same semantics as in the C standard library $(WEB
+cplusplus.com/reference/clibrary/cstdio/fopen.html, fopen)
+function). Throws an exception if the file could not be opened.
+
+Copying one $(D File) object to another results in the two $(D File)
+objects referring to the same underlying file. 
+
+The destructor automatically closes the file as soon as no $(D File)
+object refers to it anymore.
+ */
+
+    this(string name, in char[] stdioOpenmode = "rb")
+    {
+        p = new Impl(errnoEnforce(.fopen(name, stdioOpenmode),
+                        "Cannot open file `"~name
+                        ~"' in mode `"~stdioOpenmode.idup~"'"),
+                1, name);
+    }
+
+    // ~this()
+    // {
+    //     if (!p) return;
+    //     // @@@BUG@@@ These lines prematurely close the file
+    //     if (p.refs == 1) close;
+    //     else --p.refs;
+    // }
+
+    // this(this)
+    // {
+    //     //printf("Copying file with %d refs\n", _refs ? *_refs : 9999);
+    //     if (!p) return;
+    //     enforce(p.refs);
+    //     ++p.refs;
+    // }
+
+/**
+Assigns a file to another. The target of the assignment gets detached
+from whatever file it was attached to, and attaches itself to the new
+file.
+ */
+    void opAssign(File rhs)
+    {
+        // @@@BUG@@@
+        //swap(p, rhs.p);
+        p = rhs.p;
     }
     
-    static if (Have_getdelim)
+/**
+First calls $(D detach) (throwing on failure), and then attempts to
+_open file $(D name) with mode $(D stdioOpenmode). The mode has the
+same semantics as in the C standard library $(WEB
+cplusplus.com/reference/clibrary/cstdio/fopen.html, fopen) function.
+Throws exception in case of error.
+ */
+    void open(string name, string stdioOpenmode = "rb")
     {
-	import gcc.config.unix;
-	extern(C) ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream);
+        detach;
+        auto another = File(name, stdioOpenmode);
+        swap(this, another);
     }
 
-    static if (Have_Unlocked_Stdio)
+/**
+First calls $(D detach) (throwing on failure), and then runs a command
+by calling the C standard library function $(WEB
+opengroup.org/onlinepubs/007908799/xsh/_popen.html, _popen).
+ */
+    version(linux) void popen(string command, string stdioOpenmode = "r")
     {
-	alias flockfile FLOCK;
-	alias funlockfile FUNLOCK;
-	alias putc_unlocked FPUTC;
-	alias getc_unlocked FGETC;
-	static if (Have_Unlocked_Wide_Stdio)
-	{
-	    alias putwc_unlocked FPUTWC;
-	    alias getwc_unlocked FGETWC;
-	}
-	else
-	{
-	    alias fputwc FPUTWC;
-	    alias fgetwc FGETWC;
-	}
-    }
-    else
-    {
-	private void fnop(FILE *) { }
-	alias fnop FLOCK;
-	alias fnop FUNLOCK;
-	alias fputc FPUTC;
-	alias fgetc FGETC;
-	alias fputwc FPUTWC;
-	alias fgetwc FGETWC;
-    }
-}
-else
-    static assert(0);
-
-
-/*********************
- * Thrown if I/O errors happen.
- */
-class StdioException : Exception
-{
-    uint errno;			// operating system error code
-
-    this(string msg)
-    {
-	super(msg);
+        detach;
+        p = new Impl(errnoEnforce(.popen(command, stdioOpenmode),
+                        "Cannot run command `"~command~"'"),
+                1, command);
     }
 
-    this(uint errno)
+/** Returns $(D true) if the file is opened. */
+    bool isOpen() const
     {
-	version (Posix)
-	{   char[80] buf = void;
-	    auto s = std.c.string._d_gnu_cbridge_strerror(errno, buf.ptr, buf.length);
-	}
-	else
-	{
-	    auto s = std.c.string.strerror(errno);
-	}
-	super(std.string.toString(s).idup);
+        return p !is null && p.handle;
     }
 
-    static void opCall(string msg)
+/**
+Returns $(D true) if the file is at end (see $(WEB
+cplusplus.com/reference/clibrary/cstdio/feof.html, feof)). The file
+must be opened, otherwise an exception is thrown.
+ */
+    bool eof() const
     {
-	throw new StdioException(msg);
+        enforce(p && p.handle, "Calling eof() against an unopened file.");
+        return .feof(cast(FILE*) p.handle) != 0;
     }
 
-    static void opCall()
+/** Returns the name of the file, if any. */
+    string name() const
     {
-	throw new StdioException(getErrno());
+        return p.name;
+    }
+
+/**
+If the file is not opened, returns $(D false). Otherwise, returns
+$(WEB cplusplus.com/reference/clibrary/cstdio/ferror.html, ferror) for
+the file handle.
+ */
+    bool error() const
+    {
+        return !p.handle || .ferror(cast(FILE*) p.handle);
+    }
+    
+/**
+Detaches from the underlying file. If the sole owner, calls $(D close)
+and throws if that fails.
+  */
+    void detach()
+    {
+        if (!p) return;
+        // @@@BUG
+        //if (p.refs == 1) close;
+        p = null;
+    }
+    
+/**
+If the file was unopened, succeeds vacuously. Otherwise closes the
+file (by calling $(WEB
+cplusplus.com/reference/clibrary/cstdio/fclose.html, fclose)),
+throwing on error. Even if an exception is thrown, afterwards the $(D
+File) object is empty. This is different from $(D detach) in that it
+always closes the file; consequently, all other $(D File) objects
+referring to the same handle will see a closed file henceforth.
+ */
+    void close()
+    {
+        if (!p) return; // succeed vacuously
+        if (!p.handle)
+        {
+            p = null; // start a new life
+            return;
+        }
+        scope(exit)
+        {
+            p.handle = null; // nullify the handle anyway
+            p.name = null;
+            --p.refs;
+            p = null;
+        }
+        //fprintf(std.c.stdio.stderr, ("Closing file `"~name~"`.\n\0").ptr);
+        errnoEnforce(.fclose(p.handle) == 0,
+                    "Could not close file `"~p.name~"'");
+    }
+
+/**
+If the file is not opened, succeeds vacuously. Otherwise, returns
+$(WEB cplusplus.com/reference/clibrary/cstdio/_clearerr.html,
+_clearerr) for the file handle.
+ */
+    void clearerr()
+    {
+        p is null || p.handle is null ||
+        .clearerr(p.handle);
+    }
+
+/**
+If the file is not opened, throws an exception. Otherwise, calls $(WEB
+cplusplus.com/reference/clibrary/cstdio/_fflush.html, _fflush) for the
+file handle and throws on error.
+ */
+    void flush()
+    {
+        errnoEnforce
+        (.fflush(enforce(p.handle, "Calling fflush() on an unopened file"))
+                == 0);
+    }
+
+/**
+If the file is not opened, throws an exception. Otherwise, calls $(WEB
+cplusplus.com/reference/clibrary/cstdio/fread.html, fread) for the
+file handle and throws on error.
+ */
+    T[] rawRead(T)(T[] buffer)
+    {
+        enforce(buffer.length);
+        invariant result =
+            .fread(buffer.ptr, T.sizeof, buffer.length, p.handle);
+        errnoEnforce(!error);
+        return result ? buffer[0 .. result] : null;
+    }
+
+/**
+If the file is not opened, throws an exception. Otherwise, calls $(WEB
+cplusplus.com/reference/clibrary/cstdio/fwrite.html, fwrite) for the
+file handle and throws on error.
+ */
+    void rawWrite(T)(in T[] buffer)
+    {
+        auto result =
+            .fwrite(buffer.ptr, T.sizeof, buffer.length, p.handle);
+        if (result == result.max) result = 0;
+        errnoEnforce(result == buffer.length,
+                text("Wrote ", result, " instead of ", buffer.length,
+                        " objects of type ", T.stringof, " to file `",
+                        p.name, "'"));
+    }
+
+/**
+If the file is not opened, throws an exception. Otherwise, calls $(WEB
+cplusplus.com/reference/clibrary/cstdio/fseek.html, fseek) for the
+file handle. Throws on error.
+ */
+    void seek(long offset, int origin = SEEK_SET)
+    {
+        enforce(p && p.handle,
+                "Attempting to seek() in an unopened file");
+        // @@@ Dubious: why is fseek in std.c.stdio taking an int???
+        errnoEnforce(core.stdc.stdio.fseek(
+                    p.handle, to!int(offset), origin) == 0,
+                "Could not seek in file `"~p.name~"'");
+    }
+
+/**
+If the file is not opened, throws an exception. Otherwise, calls $(WEB
+cplusplus.com/reference/clibrary/cstdio/ftell.html, ftell) for the
+managed file handle. Throws on error.
+ */
+    ulong tell() const
+    {
+        enforce(p && p.handle,
+                "Attempting to tell() in an unopened file");
+        immutable result = .ftell(cast(FILE*) p.handle);
+        errnoEnforce(result != -1,
+                "Query ftell() failed for file `"~p.name~"'");
+        return result;
+    }
+
+/**
+If the file is not opened, throws an exception. Otherwise, calls $(WEB
+cplusplus.com/reference/clibrary/cstdio/_rewind.html, _rewind) for the
+file handle. Throws on error.
+ */
+    void rewind()
+    {
+        enforce(p && p.handle,
+                "Attempting to rewind() an unopened file");
+        .rewind(p.handle);
+    }
+
+/**
+If the file is not opened, throws an exception. Otherwise, calls $(WEB
+cplusplus.com/reference/clibrary/cstdio/_setvbuf.html, _setvbuf) for
+the file handle.
+ */
+    void setvbuf(size_t size, int mode = _IOFBF)
+    {
+        errnoEnforce(
+            .setvbuf(enforce(p.handle,
+                            "Attempting to call setvbuf() on an unopened file"),
+                    null, mode, size) == 0,
+            "Could not set buffering for file `"~p.name~"'");
+    }
+
+/**
+If the file is not opened, throws an exception. Otherwise, calls
+$(WEB cplusplus.com/reference/clibrary/cstdio/_setvbuf.html,
+_setvbuf) for the file handle. */
+    void setvbuf(void[] buf, int mode = _IOFBF)
+    {
+        errnoEnforce(
+            .setvbuf(enforce(p.handle,
+                            "Attempting to call setvbuf() on an unopened file"),
+                    cast(char*) buf.ptr, mode, buf.length) == 0,
+            "Could not set buffering for file `"~p.name~"'");
+    }
+
+/**
+If the file is not opened, throws an exception. Otherwise, writes its
+arguments in text format to the file. */
+    void write(S...)(S args)
+    {
+        //writef("", args[0 .. $]);
+        auto w = lockingTextWriter;
+        foreach (arg; args)
+        {
+            static if (isSomeString!(typeof(arg)))
+            {
+                w.put(arg);
+            }
+            else
+            {
+                std.format.formattedWrite(w, "%s", arg);
+            }
+        }
+    }
+        
+/**
+If the file is not opened, throws an exception. Otherwise, writes its
+arguments in text format to the file, followed by a newline. */
+    void writeln(S...)(S args)
+    {
+        write(args, '\n');
+        .fflush(p.handle);
+    }
+
+/**
+If the file is not opened, throws an exception. Otherwise, writes its
+arguments in text format to the file, according to the format in the
+first argument. */
+    void writef(S...)(S args) if (isSomeString!(S[0]))
+    {
+        assert(p);
+        assert(p.handle);
+        enum errorMessage =
+        "You must pass a formatting string as the first"
+        " argument to writef. If no formatting is needed,"
+        " you may want to use write.";
+        static assert(isSomeString!(S[0]), errorMessage);
+        auto w = lockingTextWriter;
+        std.format.formattedWrite(w, args);
+    }
+
+/**
+Same as writef, plus adds a newline. */
+    void writefln(S...)(S args)
+    {
+        auto w = lockingTextWriter;
+        std.format.formattedWrite(w, args);
+        w.put('\n');
+        .fflush(p.handle);
+    }
+
+/**********************************
+Read line from stream $(D fp) and write it to $(D buf[]), including
+terminating character.
+
+This is often faster than $(D File.readln(dchar)) because the buffer
+is reused each call. Note that reusing the buffer means that the
+previous contents of it has to be copied if needed.
+
+Params:
+fp = input stream
+buf = buffer used to store the resulting line data. buf is
+resized as necessary.
+
+Returns:
+0 for end of file, otherwise number of characters read
+
+Throws: $(D StdioException) on error
+
+Example:
+---
+// Reads $(D stdin) and writes it to $(D stdout).
+import std.stdio;
+
+int main()
+{
+    char[] buf;
+    while (readln(stdin, buf))
+        write(buf);
+    return 0;
+}
+---
+    This method is more efficient than the one in the previous example
+because $(D readln(stdin, buf)) reuses (if possible) memory
+allocated by $(D buf), whereas $(D buf = readln()) makes a
+new memory allocation with every line.
+*/
+    size_t readln(ref char[] buf, dchar terminator = '\n')
+    {
+        enforce(p && p.handle, "Attempt to read from an unopened file.");
+        return readlnImpl(p.handle, buf, terminator);
+    }
+    
+/** ditto */
+    string readln(dchar terminator = '\n')
+    {
+        char[] buf;
+        readln(buf, terminator);
+        return assumeUnique(buf);
+    }
+    
+/** ditto */
+    // TODO: optimize this
+    size_t readln(inout wchar[] buf, dchar terminator = '\n')
+    {
+        string s = readln(terminator);
+        if (!s.length) return 0;
+        buf.length = 0;
+        foreach (wchar c; s)
+        {
+            buf ~= c;
+        }
+        return buf.length;
+    }
+
+/** ditto */
+// TODO: fold this together with wchar
+    size_t readln(inout dchar[] buf, dchar terminator = '\n')
+    {
+        string s = readln(terminator);
+        if (!s.length) return 0;
+        buf.length = 0;
+        foreach (dchar c; s)
+        {
+            buf ~= c;
+        }
+        return buf.length;
+    }
+
+/**
+ Returns a temporary file by calling $(WEB
+ cplusplus.com/reference/clibrary/cstdio/_tmpfile.html, _tmpfile). */
+    static File tmpfile()
+    {
+        auto h = errnoEnforce(core.stdc.stdio.tmpfile,
+                "Could not create temporary file with tmpfile()");
+        File result = void;
+        result.p = new Impl(h, 1, null);
+        return result;
+    }
+
+/**
+Unsafe function that wraps an existing $(D FILE*). The resulting $(D
+File) never takes the initiative in closing the file. */
+    /*private*/ static File wrapFile(FILE* f)
+    {
+        File result = void;
+        //result.p = new Impl(f, uint.max / 2, null);
+        result.p = new Impl(f, 9999, null);
+        return result;
+    }
+    
+/**
+Returns the $(D FILE*) corresponding to this object.
+ */
+    FILE* getFP()
+    {
+        enforce(p && p.handle,
+                "Attempting to call getFP() on an unopened file");
+        return p.handle;
+    }
+
+    unittest
+    {
+        assert(stdout.getFP == std.c.stdio.stdout);
+    }
+    
+/**
+Returns the file number corresponding to this object.
+ */
+    version(Posix) int fileno() const
+    {
+        enforce(p && p.handle,
+                "Attempting to call fileno() on an unopened file");
+        return core.stdc.stdio.fileno(cast(FILE*) p.handle);
+    }
+    
+/**
+Range that reads one line at a time. */ 
+    enum KeepTerminator : bool { no, yes }
+    /// ditto
+    struct ByLine(Char, Terminator)
+    {
+        File file;
+        Char[] line;
+        Terminator terminator;
+        KeepTerminator keepTerminator;
+        
+        this(File f, KeepTerminator kt = KeepTerminator.no,
+                Terminator terminator = '\n')
+        {
+            file = f;
+            this.terminator = terminator;
+            keepTerminator = kt;
+            popFront; // prime the range
+            // @@@BUG@@@ line below should not exist
+            //if (file.p) ++file.p.refs;
+        }
+
+        /// Range primitive implementations.
+        ByLine!(Char, Terminator) opSlice()
+        {
+            return this;
+        }
+
+        /// Ditto
+        bool empty() const
+        {
+            return !file.isOpen;
+        }
+
+        /// Ditto
+        Char[] front()
+        {
+            return line;
+        }
+
+        /// Ditto
+        void popFront()
+        {
+            enforce(file.isOpen);
+            file.readln(line, terminator);
+            if (!line.length)
+                file.detach;
+            else if (keepTerminator == KeepTerminator.no
+                    && std.algorithm.endsWith(line, terminator))
+                line.length = line.length - 1;
+        }
+    }
+
+/**
+Convenience function that returns the $(D LinesReader) corresponding
+to this file. */ 
+    ByLine!(Char, Terminator) byLine(Terminator = char, Char = char)
+    (KeepTerminator keepTerminator = KeepTerminator.no,
+            Terminator terminator = '\n')
+    {
+        return typeof(return)(this, keepTerminator, terminator);
+    }
+
+    unittest
+    {
+        //printf("Entering test at line %d\n", __LINE__);
+        scope(failure) printf("Failed test at line %d\n", __LINE__);
+        std.file.write("testingByLine", "asd\ndef\nasdf");
+        auto witness = [ "asd", "def", "asdf" ];
+        uint i;
+        auto f = File("testingByLine");
+        scope(exit)
+        {
+            f.close;
+            assert(!f.isOpen);
+            //std.file.remove("testingByLine");
+        }
+        foreach (line; f.byLine())
+        {
+            assert(line == witness[i++]);
+        }
+        assert(i == witness.length);
+        i = 0;
+        f.rewind;
+        foreach (line; f.byLine(KeepTerminator.yes))
+        {
+            assert(line == witness[i++] ~ '\n' || i == witness.length);
+        }
+        assert(i == witness.length);
+    }
+
+    template byRecord(Fields...)
+    {
+        ByRecord!(Fields) byRecord(string format)
+        {
+            return typeof(return)(this, format);
+        }
+    }
+
+    unittest
+    {
+        scope(failure) printf("Failed test at line %d\n", __LINE__);
+        std.file.write("deleteme", "1 2\n4 1\n5 100");
+        scope(exit) std.file.remove("deleteme");
+        File f = File("deleteme");
+        scope(exit) f.close;
+        auto t = [ tuple(1, 2), tuple(4, 1), tuple(5, 100) ];
+        uint i;
+        foreach (e; f.byRecord!(int, int)("%s %s"))
+        {
+            //.writeln(e);
+            assert(e == t[i++]);
+        }
+    }
+
+/**
+$(D Range) that locks the file and allows fast writing to it.
+ */ 
+    struct LockingTextWriter {
+        //@@@ Hacky implementation due to bugs, see the correct
+        //implementation at the end of this struct
+        FILE * handle;
+        int orientation;
+
+        this(ref File f)
+        {
+            enforce(f.p && f.p.handle);
+            handle = f.p.handle;
+            orientation = fwide(handle, 0);
+            FLOCK(handle);
+        }
+
+        ~this()
+        {
+            FUNLOCK(handle);
+            handle = null;
+        }
+        
+        /// Range primitive implementations.
+        void put(A)(A writeme) if (is(ElementType!A : dchar))
+        {
+            alias ElementType!A C;
+            static assert(!is(C == void));
+            // writeln("typeof(A.init[0]) = ", typeof(A.init[0]),
+            //         ", ElementType!A = ", ElementType!A);
+            if (writeme[0].sizeof == 1 && orientation <= 0)
+            {
+                //file.write(writeme); causes infinite recursion!!!
+                //file.rawWrite(writeme);
+                auto result =
+                .fwrite(writeme.ptr, C.sizeof, writeme.length, handle);
+                //if (result == result.max) result = 0;
+                if (result != writeme.length) errnoEnforce(0);
+            }
+            else
+            {
+                // put each character in turn
+                foreach (dchar c; writeme)
+                {
+                    put(c);
+                }
+            }
+        }
+        
+        // @@@BUG@@@ 2340
+        //void front(C)(C c) if (is(C : dchar)) {
+        /// ditto
+        void put(C)(C c) if (is(C : dchar))
+        {
+            static if (c.sizeof == 1)
+            {
+                // simple char
+                if (orientation <= 0) FPUTC(c, handle);
+                else FPUTWC(c, handle);
+            }
+            else static if (c.sizeof == 2)
+            {
+                if (orientation <= 0)
+                {
+                    if (c <= 0x7F)
+                    {
+                        FPUTC(c, backend);
+                    }
+                    else
+                    {
+                        char[4] buf;
+                        auto b = std.utf.toUTF8(buf, c);
+                        foreach (i ; 0 .. b.length)
+                            FPUTC(b[i], backend);
+                    }
+                }
+                else
+                {
+                    FPUTWC(c, backend);
+                }
+            }
+            else // 32-bit characters
+            {
+                if (orientation <= 0)
+                {
+                    if (c <= 0x7F)
+                    {
+                        FPUTC(c, handle);
+                    }
+                    else
+                        {
+                            char[4] buf;
+                            auto b = std.utf.toUTF8(buf, c);
+                            foreach (i ; 0 .. b.length)
+                                FPUTC(b[i], handle);
+                        }
+                }
+                else
+                {
+                    version (Windows)
+                    {
+                        assert(isValidDchar(c));
+                        if (c <= 0xFFFF)
+                        {
+                                FPUTWC(c, handle);
+                        }
+                        else
+                        {
+                            FPUTWC(cast(wchar)
+                                    ((((c - 0x10000) >> 10) & 0x3FF)
+                                            + 0xD800), handle);
+                            FPUTWC(cast(wchar)
+                                    (((c - 0x10000) & 0x3FF) + 0xDC00),
+                                    handle);
+                        }
+                    }
+                    else version (Posix)
+                    {
+                                 FPUTWC(c, handle);
+                    }
+                    else
+                    {
+                        static assert(0);
+                    }
+                }
+            }
+        }
+        
+        //@@@BUG correct implementation is below:
+        
+        // File file;
+        // int orientation;
+
+        // this(File f)
+        // {
+        //     enforce(f.isOpen);
+        //     swap(file, f);
+        //     // @@@BUG@@@ This line should NOT be there!
+        //     file.p.refs++;
+        //     orientation = fwide(file.p.handle, 0);
+        //     //FLOCK(file.p.handle);
+        // }
+
+        // // @@@BUG@@@ uncomment and you get a linker error
+        // // this(this)
+        // // {
+        // //     //FLOCK(file.p.handle);
+        // // }
+        
+        // ~this()
+        // {
+        //     if (!file.p.handle) return;
+        //     //FUNLOCK(file.p.handle);
+        // }
+
+        // void opAssign(LockingTextWriter rhs)
+        // {
+        //     swap(this, rhs);
+        // }
+    }
+
+/// Convenience function.
+    LockingTextWriter lockingTextWriter()
+    {
+        // @@@BUG2341@@@
+        //return LockingTextWriter(this);
+        // The code below avoids bug 2341
+        //printf("Entering fn with %d refs\n", *_refs);
+        auto result = LockingTextWriter(this);
+        return result;
     }
 }
 
 private
 void writefx(FILE* fp, TypeInfo[] arguments, va_list argptr, int newline=false)
-{   int orientation;
+{
+    int orientation = fwide(fp, 0);
 
-    static if (Have_fwide)
-	orientation = fwide(fp, 0);
+    /* Do the file stream locking at the outermost level
+     * rather than character by character.
+     */
+    FLOCK(fp);
+    scope(exit) FUNLOCK(fp);
 
-    if (orientation <= 0)		// byte orientation or no orientation
+    if (orientation <= 0)                // byte orientation or no orientation
     {
-	static if (Have_Unlocked_Stdio)
-	{
-	    /* Do the file stream locking at the outermost level
-	     * rather than character by character.
-	     */
-	    FLOCK(fp);
-	    scope(exit) FUNLOCK(fp);
-	}
-	
-	void putc(dchar c)
-	{
-	    if (c <= 0x7F)
-	    {
-		FPUTC(c, fp);
-	    }
-	    else
-	    {   char[4] buf;
-		auto b = std.utf.toUTF8(buf, c);
-		for (size_t i = 0; i < b.length; i++)
-		    FPUTC(b[i], fp);
-	    }
-	}
+        void putc(dchar c)
+        {
+            if (c <= 0x7F)
+            {
+                FPUTC(c, fp);
+            }
+            else
+            {
+                char[4] buf = void;
+                foreach (i; 0 .. std.utf.toUTF8(buf, c).length)
+                    FPUTC(buf[i], fp);
+            }
+        }
 
-	std.format.doFormat(&putc, arguments, argptr);
-	if (newline)
-	    FPUTC('\n', fp);
+        std.format.doFormat(&putc, arguments, argptr);
+        if (newline)
+            FPUTC('\n', fp);
     }
-    else if (orientation > 0)		// wide orientation
+    else if (orientation > 0)                // wide orientation
     {
-	static if (Have_fwide)
-	{
-	    
-	static if (Have_Unlocked_Wide_Stdio)
-	{
-	    /* Do the file stream locking at the outermost level
-	     * rather than character by character.
-	     */
-	    FLOCK(fp);
-	    scope(exit) FUNLOCK(fp);
-	}
+        version (Windows)
+        {
+            void putcw(dchar c)
+            {
+                assert(isValidDchar(c));
+                if (c <= 0xFFFF)
+                {
+                    FPUTWC(c, fp);
+                }
+                else
+                {
+                    FPUTWC(cast(wchar) ((((c - 0x10000) >> 10) & 0x3FF) +
+                                    0xD800), fp);
+                    FPUTWC(cast(wchar) (((c - 0x10000) & 0x3FF) + 0xDC00), fp);
+                }
+            }
+        }
+        else version (Posix)
+        {
+            void putcw(dchar c)
+            {
+                FPUTWC(c, fp);
+            }
+        }
+        else
+        {
+            static assert(0);
+        }
 
-	static if (wchar_t.sizeof == 2)
-	{
-	    void putcw(dchar c)
-	    {
-		assert(isValidDchar(c));
-		if (c <= 0xFFFF)
-		{
-		    FPUTWC(c, fp);
-		}
-		else
-		{   wchar[2] buf;
-
-		    buf[0] = cast(wchar) ((((c - 0x10000) >> 10) & 0x3FF) + 0xD800);
-		    buf[1] = cast(wchar) (((c - 0x10000) & 0x3FF) + 0xDC00);
-		    FPUTWC(buf[0], fp);
-		    FPUTWC(buf[1], fp);
-		}
-	    }
-	}
-	else static if (wchar_t.sizeof == 4)
-	{
-	    void putcw(dchar c)
-	    {
-		FPUTWC(c, fp);
-	    }
-	}
-	else
-	{
-	    static assert(0);
-	}
-
-	std.format.doFormat(&putcw, arguments, argptr);
-	if (newline)
-	    FPUTWC('\n', fp);
-
-	}
+        std.format.doFormat(&putcw, arguments, argptr);
+        if (newline)
+            FPUTWC('\n', fp);
     }
 }
 
+template isStreamingDevice(T)
+{
+    enum isStreamingDevice = is(T : FILE*) ||
+        is(T : File);
+}
 
 /***********************************
- * If the first argument $(D_PARAM args[0]) is a $(D_PARAM FILE*), for
- * each argument $(D_PARAM arg) in $(D_PARAM args[1..$]), format the
- * argument (as per $(LINK2 std_conv.html, to!(string)(arg))) and
- * write the resulting string to $(D_PARAM args[0]). If $(D_PARAM
- * args[0]) is not a $(D_PARAM FILE*), the call is equivalent to
- * $(D_PARAM write(stdout, args)).
- *
- * A call without any arguments will fail to compile. In the
- * exceedingly rare case you'd want to print a $(D_PARAM FILE*) to
- * $(D_PARAM stdout) as a hex pointer, $(D_PARAM write("", myFilePtr))
- * will do the trick.
- *
- * In case of an I/O error, throws an StdioException.
+For each argument $(D arg) in $(D args), format the argument (as per
+$(LINK2 std_conv.html, to!(string)(arg))) and write the resulting
+string to $(D args[0]). A call without any arguments will fail to
+compile.
+
+Throws: In case of an I/O error, throws an $(D StdioException).
  */
-void write(T...)(T args)
+void write(T...)(T args) if (!is(T[0] : File))
 {
-    static if (is(typeof(args[0]) : FILE*))
-    {
-        alias args[0] target;
-        enum first = 1;
-    }
-    else
-    {
-        alias stdout target;
-        enum first = 0;
-    }
-    writef(target, "", args[first .. $]);
-    static if (args.length && is(typeof(args[$ - 1]) : dchar)) {
-        if (args[$ - 1] == '\n') fflush(target);
-    }
+    stdout.write(args);
 }
 
 unittest
 {
+    //printf("Entering test at line %d\n", __LINE__);
+    scope(failure) printf("Failed test at line %d\n", __LINE__);
     void[] buf;
     write(buf);
-    // test write
+    // // test write
     string file = "dmd-build-test.deleteme.txt";
-    FILE* f = fopen(file, "w");
-    assert(f, getcwd());
+    auto f = File(file, "w");
     scope(exit) { std.file.remove(file); }
-    write(f, "Hello, ",  "world number ", 42, "!");
-    fclose(f) == 0 || assert(false);
+    f.write("Hello, ",  "world number ", 42, "!");
+    f.close;
     assert(cast(char[]) std.file.read(file) == "Hello, world number 42!");
-    // test write on stdout
+    // // test write on stdout
     auto saveStdout = stdout;
     scope(exit) stdout = saveStdout;
-    stdout = fopen(file, "w");
-    assert(stdout);
+    //stdout.open(file, "w");
     Object obj;
-    write("Hello, ",  "world number ", 42, "! ", obj);
-    fclose(stdout) == 0 || assert(false);
-    auto result = cast(char[]) std.file.read(file);
-    assert(result == "Hello, world number 42! null", result);
+    //write("Hello, ",  "world number ", 42, "! ", obj);
+    //stdout.close;
+    // auto result = cast(char[]) std.file.read(file);
+    // assert(result == "Hello, world number 42! null", result);
 }
 
 /***********************************
- * Equivalent to $(D_PARAM write(args, '\n')).  Calling $(D_PARAM
- * writeln) without arguments is valid and just prints a newline to
- * the standard output.
+ * Equivalent to $(D write(args, '\n')).  Calling $(D writeln) without
+ * arguments is valid and just prints a newline to the standard
+ * output.
  */
 void writeln(T...)(T args)
 {
-    write(args, '\n');
+    stdout.write(args, '\n');
 }
 
 unittest
 {
+        //printf("Entering test at line %d\n", __LINE__);
+    scope(failure) printf("Failed test at line %d\n", __LINE__);
     // test writeln
     string file = "dmd-build-test.deleteme.txt";
-    FILE* f = fopen(file, "w");
-    assert(f);
+    auto f = File(file, "w");
     scope(exit) { std.file.remove(file); }
-    writeln(f, "Hello, ",  "world number ", 42, "!");
-    fclose(f) == 0 || assert(false);
-  version (Windows)
-    assert(cast(char[]) std.file.read(file) == "Hello, world number 42!\r\n");
-  else
-    assert(cast(char[]) std.file.read(file) == "Hello, world number 42!\n");
+    f.writeln("Hello, ",  "world number ", 42, "!");
+    f.close;
+    version (Windows)
+        assert(cast(char[]) std.file.read(file) ==
+                "Hello, world number 42!\r\n");
+    else
+        assert(cast(char[]) std.file.read(file) ==
+                "Hello, world number 42!\n");
     // test writeln on stdout
     auto saveStdout = stdout;
     scope(exit) stdout = saveStdout;
-    stdout = fopen(file, "w");
-    assert(stdout);
+    stdout.open(file, "w");
     writeln("Hello, ",  "world number ", 42, "!");
-    fclose(stdout) == 0 || assert(false);
-  version (Windows)
-    assert(cast(char[]) std.file.read(file) == "Hello, world number 42!\r\n");
-  else
-    assert(cast(char[]) std.file.read(file) == "Hello, world number 42!\n");
+    stdout.close;
+    version (Windows)
+        assert(cast(char[]) std.file.read(file) ==
+                "Hello, world number 42!\r\n");
+    else
+        assert(cast(char[]) std.file.read(file) ==
+                "Hello, world number 42!\n");
 }
 
 /***********************************
- * If the first argument $(D_PARAM args[0]) is a $(D_PARAM FILE*), use
+ * If the first argument $(D args[0]) is a $(D FILE*), use
  * $(LINK2 std_format.html#format-string, the format specifier) in
- * $(D_PARAM args[1]) to control the formatting of $(D_PARAM
- * args[2..$]), and write the resulting string to $(D_PARAM args[0]).
- * If $(D_PARAM arg[0]) is not a $(D_PARAM FILE*), the call is
- * equivalent to $(D_PARAM writef(stdout, args)).
+ * $(D args[1]) to control the formatting of $(D
+ * args[2..$]), and write the resulting string to $(D args[0]).
+ * If $(D arg[0]) is not a $(D FILE*), the call is
+ * equivalent to $(D writef(stdout, args)).
  *
 
 IMPORTANT:
 
 New behavior starting with D 2.006: unlike previous versions,
-$(D_PARAM writef) (and also $(D_PARAM writefln)) only scans its first
+$(D writef) (and also $(D writefln)) only scans its first
 string argument for format specifiers, but not subsequent string
 arguments. This decision was made because the old behavior made it
 unduly hard to simply print string variables that occasionally
@@ -355,137 +1116,99 @@
 
 The positional and non-positional styles can be mixed in the same
 format string. (POSIX leaves this behavior undefined.) The internal
-counter for non-positional parameters tracks the next parameter after
+counter for non-positional parameters tracks the popFront parameter after
 the largest positional parameter already used.
 
 New starting with 2.008: raw format specifiers. Using the "%r"
-specifier makes $(D_PARAM writef) simply write the binary
+specifier makes $(D writef) simply write the binary
 representation of the argument. Use "%-r" to write numbers in little
 endian format, "%+r" to write numbers in big endian format, and "%r"
 to write numbers in platform-native format.
- 
+
 */
 
 void writef(T...)(T args)
 {
-    PrivateFileWriter!(char) w;
-    enum errorMessage =
-        "You must pass a formatting string as the first"
-        " argument to writef. If no formatting is needed,"
-        " you may want to use write.";
-    static if (is(typeof(args[0]) : FILE*))
-    {
-        alias args[0] target;
-        enum first = 1;
-    }
-    else
-    {
-        alias stdout target;
-        enum first = 0;
-    }
-    w.backend = target;
-    FLOCK(w.backend);
-    scope(exit) FUNLOCK(w.backend);
-    static if (!isSomeString!(T[first]))
-    {
-        // bacward compatibility hack
-        std.format.formattedWrite(w, "", args[first .. $]);
-    }
-    else
-    {
-        std.format.formattedWrite(w, args[first .. $]);
-    }
+    stdout.writef(args);
 }
 
 unittest
 {
+        //printf("Entering test at line %d\n", __LINE__);
+    scope(failure) printf("Failed test at line %d\n", __LINE__);
     // test writef
     string file = "dmd-build-test.deleteme.txt";
-    auto f = fopen(file, "w");
-    assert(f);
+    auto f = File(file, "w");
     scope(exit) { std.file.remove(file); }
-    writef(f, "Hello, %s world number %s!", "nice", 42);
-    fclose(f) == 0 || assert(false);
+    f.writef("Hello, %s world number %s!", "nice", 42);
+    f.close;
     assert(cast(char[]) std.file.read(file) ==  "Hello, nice world number 42!");
     // test write on stdout
     auto saveStdout = stdout;
     scope(exit) stdout = saveStdout;
-    stdout = fopen(file, "w");
-    assert(stdout);
+    stdout.open(file, "w");
     writef("Hello, %s world number %s!", "nice", 42);
-    fclose(stdout) == 0 || assert(false);
+    stdout.close;
     assert(cast(char[]) std.file.read(file) == "Hello, nice world number 42!");
 }
 
 /***********************************
- * Equivalent to $(D_PARAM writef(args, '\n')).
+ * Equivalent to $(D writef(args, '\n')).
  */
 void writefln(T...)(T args)
 {
-    writef(args, '\n');
+    stdout.writefln(args);
 }
 
 unittest
 {
+        //printf("Entering test at line %d\n", __LINE__);
+    scope(failure) printf("Failed test at line %d\n", __LINE__);
     // test writefln
     string file = "dmd-build-test.deleteme.txt";
-    FILE* f = fopen(file, "w");
-    assert(f);
+    auto f = File(file, "w");
     scope(exit) { std.file.remove(file); }
-    writefln(f, "Hello, %s world number %s!", "nice", 42);
-    fclose(f) == 0 || assert(false);
-  version (Windows)
-    assert(cast(char[]) std.file.read(file) == "Hello, nice world number 42!\r\n");
-  else
-    assert(cast(char[]) std.file.read(file) == "Hello, nice world number 42!\n");
+    f.writefln("Hello, %s world number %s!", "nice", 42);
+    f.close;
+    version (Windows)
+        assert(cast(char[]) std.file.read(file) ==
+                "Hello, nice world number 42!\r\n");
+    else
+        assert(cast(char[]) std.file.read(file) ==
+                "Hello, nice world number 42!\n",
+                cast(char[]) std.file.read(file));
     // test write on stdout
     auto saveStdout = stdout;
     scope(exit) stdout = saveStdout;
-    stdout = fopen(file, "w");
-    assert(stdout);
+    stdout.open(file, "w");
+    assert(stdout.isOpen);
     writefln("Hello, %s world number %s!", "nice", 42);
     foreach (F ; TypeTuple!(ifloat, idouble, ireal))
     {
         F a = 5i;
         F b = a % 2;
-        writefln(b);
+        writeln(b);
     }
-    fclose(stdout) == 0 || assert(false);
+    stdout.close;
     auto read = cast(char[]) std.file.read(file);
-  version (Windows)
-    assert(read == "Hello, nice world number 42!\r\n1\r\n1\r\n1\r\n", read);
-  else
-    assert(read == "Hello, nice world number 42!\n1\n1\n1\n", read);
-}
-
-/***********************************
- * Kept for backward compatibility. Use $(D_PARAM writef) instead.
- */
-void fwritef(FILE* fp, ...)
-{
-    writefx(fp, _arguments, _argptr, 0);
-}
-
-/***********************************
- * Kept for backward compatibility. Use $(D_PARAM writefln) instead.
- */
-void fwritefln(FILE* fp, ...)
-{
-    writefx(fp, _arguments, _argptr, 1);    
+    version (Windows)
+        assert(read == "Hello, nice world number 42!\r\n1\r\n1\r\n1\r\n", read);
+    else
+        assert(read == "Hello, nice world number 42!\n1\n1\n1\n", "["~read~"]");
 }
 
 /**********************************
- * Read line from stream $(D_PARAM fp).
+ * Read line from stream $(D fp).
  * Returns:
- *	$(D_PARAM null) for end of file,
- *	$(D_PARAM char[]) for line read from $(D_PARAM fp), including terminating character
+ *        $(D null) for end of file,
+ *        $(D char[]) for line read from $(D fp), including terminating character
  * Params:
- *	$(D_PARAM fp) = input stream
- *	$(D_PARAM terminator) = line terminator, '\n' by default
+ *        $(D fp) = input stream
+ *        $(D terminator) = line terminator, '\n' by default
  * Throws:
- *	$(D_PARAM StdioException) on error
+ *        $(D StdioException) on error
  * Example:
- *	Reads $(D_PARAM stdin) and writes it to $(D_PARAM stdout).
+ *        Reads $(D stdin) and writes it to $(D stdout).
 ---
 import std.stdio;
 
@@ -493,247 +1216,30 @@
 {
     char[] buf;
     while ((buf = readln()) != null)
-	write(buf);
+        write(buf);
     return 0;
 }
 ---
 */
-string readln(FILE* fp = stdin, dchar terminator = '\n')
+string readln(dchar terminator = '\n')
 {
-    char[] buf;
-    readln(fp, buf, terminator);
-    return assumeUnique(buf);
-}
-
-/**********************************
- * Read line from stream $(D_PARAM fp) and write it to $(D_PARAM
- * buf[]), including terminating character.
- *
- * This is often faster than $(D_PARAM readln(FILE*)) because the buffer
- * is reused each call. Note that reusing the buffer means that
- * the previous contents of it need to be copied if needed.
- * Params:
- *	$(D_PARAM fp) = input stream
- *	$(D_PARAM buf) = buffer used to store the resulting line data. buf
- *		is resized as necessary.
- * Returns:
- *	0 for end of file, otherwise
- *	number of characters read
- * Throws:
- *	$(D_PARAM StdioException) on error
- * Example:
- *	Reads $(D_PARAM stdin) and writes it to $(D_PARAM stdout).
----
-import std.stdio;
-
-int main()
-{
-    char[] buf;
-    while (readln(stdin, buf))
-	write(buf);
-    return 0;
-}
----
-This method is more efficient than the one in the previous example
-because $(D_PARAM readln(stdin, buf)) reuses (if possible) memory
-allocated by $(D_PARAM buf), whereas $(D_PARAM buf = readln()) makes a
-new memory allocation with every line.
-*/
-size_t readln(FILE* fp, inout char[] buf, dchar terminator = '\n')
-{
-    version (GNU)
-    {
-	int orientation;
-	static if (Have_fwide)
-	    orientation = fwide(fp, 0);
-
-	if (orientation > 0)
-	{   /* Stream is in wide characters.
-	     * Read them and convert to chars.
-	     */
-	    static if (Have_fwide)
-	    {
-
-	    static if (Have_Unlocked_Wide_Stdio)
-	    {
-		FLOCK(fp);
-		scope(exit) FUNLOCK(fp);
-	    }
-
-	    static if (wchar_t.sizeof == 2)
-	    {
-		buf.length = 0;
-		int c2;
-		for (int c = void; (c = FGETWC(fp)) != -1; )
-		{
-		    if ((c & ~0x7F) == 0)
-		    {   buf ~= c;
-			if (c == terminator)
-			    break;
-		    }
-		    else
-		    {
-			if (c >= 0xD800 && c <= 0xDBFF)
-			{
-			    if ((c2 = FGETWC(fp)) != -1 ||
-				c2 < 0xDC00 && c2 > 0xDFFF)
-			    {
-				StdioException("unpaired UTF-16 surrogate");
-			    }
-			    c = ((c - 0xD7C0) << 10) + (c2 - 0xDC00);
-			}
-			std.utf.encode(buf, c);
-		    }
-		}
-		if (ferror(fp))
-		    StdioException();
-		return buf.length;
-	    }
-	    else static if (wchar_t.sizeof == 4)
-	    {
-		buf.length = 0;
-		for (int c = void; (c = FGETWC(fp)) != -1; )
-		{
-		    if ((c & ~0x7F) == 0)
-			buf ~= c;
-		    else
-			std.utf.encode(buf, cast(dchar)c);
-		    if (c == terminator)
-			break;
-		}
-		if (ferror(fp))
-		    StdioException();
-		return buf.length;
-	    }
-	    else
-	    {
-		static assert(0);
-	    }
-
-	    }
-	}
-
-	char *lineptr = null;
-	size_t s;
-	static if (Have_getdelim)
-	{
-	    size_t n = 0;
-	    s = getdelim(&lineptr, &n, terminator, fp);
-	    scope(exit) free(lineptr);
-	    if (cast(ssize_t) s == -1)
-	    {
-		if (ferror(fp))
-		    StdioException();
-		buf.length = 0;		// end of file
-		return 0;
-	    }
-	}
-	else static if (Have_fgetln || Have_fgetline)
-	{
-	    static if (Have_fgetln)
-		lineptr = fgetln(fp, & s);
-	    else
-		lineptr = fgetline(fp, & s);
-	    if (lineptr is null)
-	    {
-		if (ferror(fp))
-		    StdioException();
-		buf.length = 0;		// end of file
-		return 0;
-	    }
-	}
-	else
-	{
-	    {
-		static if (Have_Unlocked_Stdio)
-		{
-		    FLOCK(fp);
-		    scope(exit) FUNLOCK(fp);
-		}
-
-		buf.length = 0;
-		for (int c = void; (c = FGETC(fp)) != -1; )
-		{
-		    buf ~= cast(char)c;
-		    if (cast(char)c == terminator)
-			break;
-		}
-	    }
-	    if (ferror(fp))
-		StdioException();
-	    return buf.length;
-	}
-	buf = buf.ptr[0 .. GC.sizeOf(buf.ptr)];
-	if (s <= buf.length)
-	{
-	    buf.length = s;
-	    buf[] = lineptr[0 .. s];
-	}
-	else
-	{
-	    buf = lineptr[0 .. s].dup;
-	}
-	return s;
-    }
-    else
-    {
-	static assert(0);
-    }
+    return stdin.readln(terminator);
 }
 
 /** ditto */
 size_t readln(inout char[] buf, dchar terminator = '\n')
 {
-    return readln(stdin, buf, terminator);
+    return stdin.readln(buf, terminator);
 }
 
-/** ditto */
-// TODO: optimize this
-size_t readln(FILE* f, inout wchar[] buf, dchar terminator = '\n')
-{
-    string s = readln(f, terminator);
-    if (!s.length) return 0;
-    buf.length = 0;
-    foreach (wchar c; s)
-    {
-        buf ~= c;
-    }
-    return buf.length;
-}
-
-/** ditto */
-// TODO: fold this together with wchar
-size_t readln(FILE* f, inout dchar[] buf, dchar terminator = '\n')
-{
-    string s = readln(f, terminator);
-    if (!s.length) return 0;
-    buf.length = 0;
-    foreach (dchar c; s)
-    {
-        buf ~= c;
-    }
-    return buf.length;
-}
-
-/***********************************
- * Convenience function that forwards to $(D_PARAM std.c.stdio.fopen)
+/*
+ * Convenience function that forwards to $(D std.c.stdio.fopen)
  * with appropriately-constructed C-style strings.
  */
-FILE* fopen(in char[] name, in char[] mode = "r")
+private FILE* fopen(in char[] name, in char[] mode = "r")
 {
     const namez = toStringz(name), modez = toStringz(mode);
-    auto result = std.c.stdio.fopen(namez, modez);
-    version(linux)
-    {
-        enum int EOVERFLOW = 75; // taken from my Ubuntu's
-                                 // /usr/include/asm-generic/errno.h
-        if (!result && getErrno == EOVERFLOW)
-        {
-            // attempt fopen64, maybe the file was very large
-            result = std.c.stdio.fopen64(namez, modez);
-        }
-    }
-    return result;
+    return fopen64(namez, modez);
 }
 
 version (Posix)
@@ -741,7 +1247,7 @@
     extern(C) FILE* popen(const char*, const char*);
 
 /***********************************
- * Convenience function that forwards to $(D_PARAM std.c.stdio.popen)
+ * Convenience function that forwards to $(D std.c.stdio.popen)
  * with appropriately-constructed C-style strings.
  */
     FILE* popen(in char[] name, in char[] mode = "r")
@@ -751,134 +1257,17 @@
 }
 
 /*
- * Convenience function that forwards to $(D_PARAM std.c.stdio.fwrite)
+ * Convenience function that forwards to $(D std.c.stdio.fwrite)
  * and throws an exception upon error
  */
 private void binaryWrite(T)(FILE* f, T obj)
 {
-    invariant result = fwrite(obj.ptr, obj[0].sizeof, obj.length, f);
+    immutable result = fwrite(obj.ptr, obj[0].sizeof, obj.length, f);
     if (result != obj.length) StdioException();
 }
 
-/*
- * Implements the static Writer interface for a FILE*. Instantiate it
- * with the character type, e.g. PrivateFileWriter!(char),
- * PrivateFileWriter!(wchar), or PrivateFileWriter!(dchar). Regardless of
- * instantiation, PrivateFileWriter supports all character widths; it only is
- * the most efficient at accepting the character type it was
- * instantiated with.
- *
- * */
-private struct PrivateFileWriter(Char)
-{
-    alias Char NativeChar;
-    FILE* backend;
-    int orientation;
-
-    void write(C)(in C[] s)
-    {
-	static if (Have_fwide)
-	    if (!orientation) orientation = fwide(backend, 0);
-
-        if (orientation <= 0 && C.sizeof == 1)
-        {
-            // lucky case: narrow chars on narrow stream
-            if (std.c.stdio.fwrite(s.ptr, C.sizeof, s.length, backend)
-                != s.length)
-            {
-                StdioException();
-            }
-        }
-        else
-        {
-            // put each character in turn
-            foreach (C c; s)
-            {
-                putchar(c);
-            }
-        }
-    }
-
-    void putchar(C)(in C c)
-    {
-	static if (Have_fwide)
-	    if (!orientation) orientation = fwide(backend, 0);
-
-        static if (c.sizeof == 1)
-        {
-            // simple char
-            if (orientation <= 0) FPUTC(c, backend);
-            else FPUTWC(c, backend);
-        }
-        else static if (c.sizeof == 2)
-        {
-            if (orientation <= 0)
-            {
-                if (c <= 0x7F)
-                {
-                    FPUTC(c, backend);
-                }
-                else
-                {
-                    char[4] buf;
-                    auto b = std.utf.toUTF8(buf, c);
-                    foreach (i ; 0 .. b.length)
-                        FPUTC(b[i], backend);
-                }
-            }
-            else
-            {
-                FPUTWC(c, backend);
-            }
-        }
-        else // 32-bit characters
-        {
-            if (orientation <= 0)
-            {
-                if (c <= 0x7F)
-                {
-                    FPUTC(c, backend);
-                }
-                else
-                {
-                    char[4] buf;
-                    auto b = std.utf.toUTF8(buf, c);
-                    foreach (i ; 0 .. b.length)
-                        FPUTC(b[i], backend);
-                }
-            }
-            else
-            {
-                static if (wchar_t.sizeof == 2)
-                {
-                    assert(isValidDchar(c));
-                    if (c <= 0xFFFF)
-                    {
-                        FPUTWC(c, backend);
-                    }
-                    else
-                    {
-                        FPUTWC(cast(wchar) ((((c - 0x10000) >> 10) & 0x3FF)
-                                            + 0xD800), backend);
-                        FPUTWC(cast(wchar) (((c - 0x10000) & 0x3FF) + 0xDC00),
-                               backend);
-                    }
-                }
-                else static if (wchar_t.sizeof == 4)
-                {
-                    FPUTWC(c, backend);
-                }
-                else
-                {
-                    static assert(0);
-                }
-            }
-        }
-    }
-}
-
 /**
- * Iterates through the lines of a file by using $(D_PARAM foreach).
+ * Iterates through the lines of a file by using $(D foreach).
  *
  * Example:
  *
@@ -893,22 +1282,22 @@
 ---------
  The line terminator ('\n' by default) is part of the string read (it
 could be missing in the last line of the file). Several types are
-supported for $(D_PARAM line), and the behavior of $(D_PARAM lines)
+supported for $(D line), and the behavior of $(D lines)
 changes accordingly:
 
-$(OL $(LI If $(D_PARAM line) has type $(D_PARAM string), $(D_PARAM
-wstring), or $(D_PARAM dstring), a new string of the respective type
-is allocated every read.) $(LI If $(D_PARAM line) has type $(D_PARAM
-char[]), $(D_PARAM wchar[]), $(D_PARAM dchar[]), the line's content
-will be reused (overwritten) across reads.) $(LI If $(D_PARAM line)
-has type $(D_PARAM invariant(ubyte)[]), the behavior is similar to
+$(OL $(LI If $(D line) has type $(D string), $(D
+wstring), or $(D dstring), a new string of the respective type
+is allocated every read.) $(LI If $(D line) has type $(D
+char[]), $(D wchar[]), $(D dchar[]), the line's content
+will be reused (overwritten) across reads.) $(LI If $(D line)
+has type $(D immutable(ubyte)[]), the behavior is similar to
 case (1), except that no UTF checking is attempted upon input.) $(LI
-If $(D_PARAM line) has type $(D_PARAM ubyte[]), the behavior is
+If $(D line) has type $(D ubyte[]), the behavior is
 similar to case (2), except that no UTF checking is attempted upon
 input.))
 
 In all cases, a two-symbols versions is also accepted, in which case
-the first symbol (of integral type, e.g. $(D_PARAM ulong) or $(D_PARAM
+the first symbol (of integral type, e.g. $(D ulong) or $(D
 uint)) tracks the zero-based number of the current line.
 
 Example:
@@ -919,29 +1308,29 @@
   }
 ----
 
- In case of an I/O error, an $(D_PARAM StdioException) is thrown. 
+ In case of an I/O error, an $(D StdioException) is thrown. 
  */
 
 struct lines
 {
-    private FILE * f;
+    private File f;
     private dchar terminator = '\n';
     private string fileName;
 
-  /*static lines opCall(FILE* f, dchar terminator = '\n')
+    static lines opCall(File f, dchar terminator = '\n')
     {
         lines result;
         result.f = f;
         result.terminator = terminator;
         return result;
-    }*/
+    }
 
     // Keep these commented lines for later, when Walter fixes the
     // exception model.
-    
+
 //     static lines opCall(string fName, dchar terminator = '\n')
 //     {
-//         auto f = enforce(fopen(fName), 
+//         auto f = enforce(fopen(fName),
 //             new StdioException("Cannot open file `"~fName~"' for reading"));
 //         auto result = lines(f, terminator);
 //         result.fileName = fName;
@@ -971,7 +1360,7 @@
                 Parms[0] i = 0;
             for (;;)
             {
-                if (!readln(f, line, terminator)) break;
+                if (!f.readln(line, terminator)) break;
                 auto copy = to!(Parms[$ - 1])(line);
                 static if (Parms.length == 2)
                 {
@@ -996,15 +1385,15 @@
     int opApplyRaw(D)(D dg)
     {
         alias ParameterTypeTuple!(dg) Parms;
-        enum duplicate = is(Parms[$ - 1] : invariant(ubyte)[]);
+        enum duplicate = is(Parms[$ - 1] : immutable(ubyte)[]);
         int result = 1;
         int c = void;
-        FLOCK(f);
-	scope(exit) FUNLOCK(f);
+        FLOCK(f.p.handle);
+        scope(exit) FUNLOCK(f.p.handle);
         ubyte[] buffer;
         static if (Parms.length == 2)
             Parms[0] line = 0;
-        while ((c = FGETC(f)) != -1)
+        while ((c = FGETC(f.p.handle)) != -1)
         {
             buffer ~= to!(ubyte)(c);
             if (c == terminator)
@@ -1014,8 +1403,8 @@
                 else
                     alias buffer arg;
                 // unlock the file while calling the delegate
-                FUNLOCK(f);
-                scope(exit) FLOCK(f);
+                FUNLOCK(f.p.handle);
+                scope(exit) FLOCK(f.p.handle);
                 static if (Parms.length == 1)
                 {
                     result = dg(arg);
@@ -1031,13 +1420,15 @@
             }
         }
         // can only reach when FGETC returned -1
-        if (!feof(f)) throw new StdioException(ferror(f)); // error occured
+        if (!f.eof) throw new StdioException("Error in reading file"); // error occured
         return result;
     }
 }
 
 unittest
 {
+        //printf("Entering test at line %d\n", __LINE__);
+    scope(failure) printf("Failed test at line %d\n", __LINE__);
     string file = "dmd-build-test.deleteme.txt";
     scope(exit) { std.file.remove(file); }
     alias TypeTuple!(string, wstring, dstring,
@@ -1046,16 +1437,16 @@
     foreach (T; TestedWith) {
         // test looping with an empty file
         std.file.write(file, "");
-        auto f = fopen(file, "r");
+        auto f = File(file, "r");
         foreach (T line; lines(f))
         {
             assert(false);
         }
-        fclose(f) == 0 || assert(false);
+        f.close;
 
         // test looping with a file with three lines
         std.file.write(file, "Line one\nline two\nline three\n");
-        f = fopen(file, "r");
+        f.open(file, "r");
         uint i = 0;
         foreach (T line; lines(f))
         {
@@ -1065,11 +1456,11 @@
             else assert(false);
             ++i;
         }
-        fclose(f) == 0 || assert(false);
-    
+        f.close;
+
         // test looping with a file with three lines, last without a newline
         std.file.write(file, "Line one\nline two\nline three");
-        f = fopen(file, "r");
+        f.open(file, "r");
         i = 0;
         foreach (T line; lines(f))
         {
@@ -1079,25 +1470,26 @@
             else assert(false);
             ++i;
         }
-        fclose(f) == 0 || assert(false);
+        f.close;
     }
 
     // test with ubyte[] inputs
-    alias TypeTuple!(invariant(ubyte)[], ubyte[])
-        TestedWith2;
+    //@@@BUG 2612@@@
+    //alias TypeTuple!(immutable(ubyte)[], ubyte[]) TestedWith2;
+    alias TypeTuple!(invariant(ubyte)[], ubyte[]) TestedWith2;
     foreach (T; TestedWith2) {
         // test looping with an empty file
         std.file.write(file, "");
-        auto f = fopen(file, "r");
+        auto f = File(file, "r");
         foreach (T line; lines(f))
         {
             assert(false);
         }
-        fclose(f) == 0 || assert(false);
+        f.close;
 
         // test looping with a file with three lines
         std.file.write(file, "Line one\nline two\nline three\n");
-        f = fopen(file, "r");
+        f.open(file, "r");
         uint i = 0;
         foreach (T line; lines(f))
         {
@@ -1108,11 +1500,11 @@
             else assert(false);
             ++i;
         }
-        fclose(f) == 0 || assert(false);
-    
+        f.close;
+
         // test looping with a file with three lines, last without a newline
         std.file.write(file, "Line one\nline two\nline three");
-        f = fopen(file, "r");
+        f.open(file, "r");
         i = 0;
         foreach (T line; lines(f))
         {
@@ -1122,7 +1514,7 @@
             else assert(false);
             ++i;
         }
-        fclose(f) == 0 || assert(false);
+        f.close;
 
     }
 
@@ -1131,7 +1523,7 @@
         // test looping with a file with three lines, last without a newline
         // using a counter too this time
         std.file.write(file, "Line one\nline two\nline three");
-        auto f = fopen(file, "r");
+        auto f = File(file, "r");
         uint i = 0;
         foreach (ulong j, T line; lines(f))
         {
@@ -1141,12 +1533,12 @@
             else assert(false);
             ++i;
         }
-        fclose(f) == 0 || assert(false);
+        f.close;
     }
 }
 
 /**
-Iterates through a file a chunk at a time by using $(D_PARAM
+Iterates through a file a chunk at a time by using $(D
 foreach).
 
 Example:
@@ -1161,23 +1553,23 @@
 }
 ---------
 
-The content of $(D_PARAM buffer) is reused across calls. In the
- example above, $(D_PARAM buffer.length) is 4096 for all iterations,
- except for the last one, in which case $(D_PARAM buffer.length) may
+The content of $(D buffer) is reused across calls. In the
+ example above, $(D buffer.length) is 4096 for all iterations,
+ except for the last one, in which case $(D buffer.length) may
  be less than 4096 (but always greater than zero).
 
- In case of an I/O error, an $(D_PARAM StdioException) is thrown. 
+ In case of an I/O error, an $(D StdioException) is thrown. 
 */
 
 struct chunks
 {
-    private FILE* f;
+    private File f;
     private size_t size;
     private string fileName;
 
-    static chunks opCall(FILE* f, size_t size)
+    static chunks opCall(File f, size_t size)
     {
-        assert(f && size);
+        assert(size);
         chunks result;
         result.f = f;
         result.size = size;
@@ -1186,7 +1578,7 @@
 
 //     static chunks opCall(string fName, size_t size)
 //     {
-//         auto f = enforce(fopen(fName), 
+//         auto f = enforce(fopen(fName),
 //             new StdioException("Cannot open file `"~fName~"' for reading"));
 //         auto result = chunks(f, size);
 //         result.fileName  = fName;
@@ -1204,14 +1596,14 @@
         size_t r = void;
         int result = 1;
         uint tally = 0;
-        while ((r = std.c.stdio.fread(buffer.ptr,
-                                      buffer[0].sizeof, size, f)) > 0)
+        while ((r = core.stdc.stdio.fread(buffer.ptr,
+                                buffer[0].sizeof, size, f.p.handle)) > 0)
         {
             assert(r <= size);
             if (r != size)
             {
                 // error occured
-                if (!feof(f)) throw new StdioException(ferror(f));
+                if (!f.eof) throw new StdioException(null);
                 buffer.length = r;
             }
             static if (is(typeof(dg(tally, buffer)))) {
@@ -1227,20 +1619,22 @@
 
 unittest
 {
+        //printf("Entering test at line %d\n", __LINE__);
+    scope(failure) printf("Failed test at line %d\n", __LINE__);
     string file = "dmd-build-test.deleteme.txt";
     scope(exit) { std.file.remove(file); }
     // test looping with an empty file
     std.file.write(file, "");
-    auto f = fopen(file, "r");
+    auto f = File(file, "r");
     foreach (ubyte[] line; chunks(f, 4))
     {
         assert(false);
     }
-    fclose(f) == 0 || assert(false);
-    
+    f.close;
+
     // test looping with a file with three lines
     std.file.write(file, "Line one\nline two\nline three\n");
-    f = fopen(file, "r");
+    f = File(file, "r");
     uint i = 0;
     foreach (ubyte[] line; chunks(f, 3))
     {
@@ -1250,5 +1644,470 @@
         else break;
         ++i;
     }
-    fclose(f) == 0 || assert(false);
+    f.close;
 }
+
+/*********************
+ * Thrown if I/O errors happen.
+ */
+class StdioException : Exception
+{
+    /// Operating system error code.
+    uint errno;
+
+/**
+Initialize with a message and an error code. */
+    this(string message, uint e = .getErrno)
+    {
+        errno = e;
+        version (linux)
+        {
+            char[256] buf = void;
+            assert(false);
+            auto s = std.c.string.strerror_r(errno, buf.ptr, buf.length);
+        }
+        else
+        {
+            auto s = std.c.string.strerror(errno);
+        }
+        auto sysmsg = to!string(s);
+        super(message ? message ~ "(" ~ sysmsg ~ ")" : sysmsg);
+    }
+
+/** Convenience functions that throw an $(D StdioException). */
+    static void opCall(string msg)
+    {
+        throw new StdioException(msg);
+    }
+    
+/// ditto
+    static void opCall()
+    {
+        throw new StdioException(null, .getErrno);
+    }
+}
+
+extern(C) void std_stdio_static_this()
+{
+    //Bind stdin, stdout, stderr
+    static File.Impl stdinImpl = { null, uint.max / 2, null };
+    stdinImpl.handle = core.stdc.stdio.stdin;
+    .stdin.p = &stdinImpl;
+    // stdout
+    static File.Impl stdoutImpl = { null, uint.max / 2, null };
+    stdoutImpl.handle = core.stdc.stdio.stdout;
+    .stdout.p = &stdoutImpl;
+    // stderr
+    static File.Impl stderrImpl = { null, uint.max / 2, null };
+    stderrImpl.handle = core.stdc.stdio.stderr;
+    .stderr.p = &stderrImpl;
+}
+
+//---------
+File stdin;
+File stdout;
+File stderr;
+
+//------------------------------------------------------------------------------
+struct ByRecord(Fields...)
+{
+    File file;
+    char[] line;
+    Tuple!(Fields) current;
+    string format;
+        
+    this(File f, string format)
+    {
+        assert(f.isOpen);
+        file = f;
+        this.format = format;
+        popFront; // prime the range
+    }
+
+    /// Range primitive implementations.
+    ref auto opSlice()
+    {
+        return this;
+    }
+
+    /// Ditto
+    bool empty() const
+    {
+        return !file.isOpen;
+    }
+
+    /// Ditto
+    ref Tuple!(Fields) front()
+    {
+        return current;
+    }
+
+    /// Ditto
+    void popFront()
+    {
+        enforce(file.isOpen);
+        file.readln(line);
+        if (!line.length)
+        {
+            file.detach;
+        }
+        else
+        {
+            auto slack = formattedRead(chomp(line), format, &current);
+            enforce(slack.empty, text("Leftover characters in record: `",
+                            slack, "'"));
+        }
+    }
+}
+
+template byRecord(Fields...)
+{
+    ByRecord!(Fields) byRecord(File f, string format)
+    {
+        return typeof(return)(f, format);
+    }
+}
+
+unittest
+{
+    scope(failure) printf("Failed test at line %d\n", __LINE__);
+    std.file.write("deleteme", "1 2\n4 1\n5 100");
+    scope(exit) std.file.remove("deleteme");
+    {
+        File f = File("deleteme");
+        scope(exit) f.close;
+        auto t = [ tuple(1, 2), tuple(4, 1), tuple(5, 100) ];
+        uint i;
+        foreach (e; f.byRecord!(int, int)("%s %s"))
+        {
+            //writeln(e);
+            assert(e == t[i++]);
+        }
+        assert(i == 3);
+    }
+    {
+        std.file.write("deleteme", "1:2 3\n4:1 5\n5:100");
+        File f = File("deleteme");
+        scope(exit) f.close;
+        auto t = [ tuple(1, [2,3][]), tuple(4, [1,5][]), tuple(5, [100][]) ];
+        uint i;
+        foreach (e; f.byRecord!(int, int[])("%s:%(s )"))
+        {
+            //writeln(e);
+            assert(e == t[i++]);
+        }
+        assert(i == 3);
+    }
+}
+
+// Private implementation of readln
+private size_t readlnImpl(FILE* fp, ref char[] buf, dchar terminator = '\n')
+{
+    version (DIGITAL_MARS_STDIO)
+    {
+        FLOCK(fp);
+        scope(exit) FUNLOCK(fp);
+
+        if (__fhnd_info[fp._file] & FHND_WCHAR)
+        {   /* Stream is in wide characters.
+             * Read them and convert to chars.
+             */
+            static assert(wchar_t.sizeof == 2);
+            buf.length = 0;
+            int c2;
+            for (int c = void; (c = FGETWC(fp)) != -1; )
+            {
+                if ((c & ~0x7F) == 0)
+                {   buf ~= c;
+                    if (c == terminator)
+                        break;
+                }
+                else
+                {
+                    if (c >= 0xD800 && c <= 0xDBFF)
+                    {
+                        if ((c2 = FGETWC(fp)) != -1 ||
+                                c2 < 0xDC00 && c2 > 0xDFFF)
+                        {
+                            StdioException("unpaired UTF-16 surrogate");
+                        }
+                        c = ((c - 0xD7C0) << 10) + (c2 - 0xDC00);
+                    }
+                    std.utf.encode(buf, c);
+                }
+            }
+            if (ferror(fp))
+                StdioException();
+            return buf.length;
+        }
+
+        auto sz = GC.sizeOf(buf.ptr);
+        //auto sz = buf.length;
+        buf = buf.ptr[0 .. sz];
+        if (fp._flag & _IONBF)
+        {
+            /* Use this for unbuffered I/O, when running
+             * across buffer boundaries, or for any but the common
+             * cases.
+             */
+          L1:
+            char *p;
+
+            if (sz)
+            {
+                p = buf.ptr;
+            }
+            else
+            {
+                sz = 64;
+                p = cast(char*) GC.malloc(sz, GC.BlkAttr.NO_SCAN);
+                buf = p[0 .. sz];
+            }
+            size_t i = 0;
+            for (int c = void; (c = FGETC(fp)) != -1; )
+            {
+                if ((p[i] = cast(char)c) != terminator)
+                {
+                    i++;
+                    if (i < sz)
+                        continue;
+                    buf = p[0 .. i];
+                    {
+                        char[] buf2;
+                        readlnImpl(fp, buf2, terminator);
+                        buf ~= buf2;
+                    }
+                    return buf.length;
+                }
+                else
+                {
+                    buf = p[0 .. i + 1];
+                    return i + 1;
+                }
+            }
+            if (ferror(fp))
+                StdioException();
+            buf = p[0 .. i];
+            return i;
+        }
+        else
+        {
+            int u = fp._cnt;
+            char* p = fp._ptr;
+            int i;
+            if (fp._flag & _IOTRAN)
+            {   /* Translated mode ignores \r and treats ^Z as end-of-file
+                 */
+                char c;
+                while (1)
+                {
+                    if (i == u)                // if end of buffer
+                        goto L1;        // give up
+                    c = p[i];
+                    i++;
+                    if (c != '\r')
+                    {
+                        if (c == terminator)
+                            break;
+                        if (c != 0x1A)
+                            continue;
+                        goto L1;
+                    }
+                    else
+                    {   if (i != u && p[i] == terminator)
+                            break;
+                        goto L1;
+                    }
+                }
+                if (i > sz)
+                {
+                    buf = cast(char[])GC.malloc(i, GC.BlkAttr.NO_SCAN)[0 .. i];
+                }
+                if (i - 1)
+                    memcpy(buf.ptr, p, i - 1);
+                buf[i - 1] = terminator;
+                buf = buf[0 .. i];
+                if (terminator == '\n' && c == '\r')
+                    i++;
+            }
+            else
+            {
+                while (1)
+                {
+                    if (i == u)                // if end of buffer
+                        goto L1;        // give up
+                    auto c = p[i];
+                    i++;
+                    if (c == terminator)
+                        break;
+                }
+                if (i > sz)
+                {
+                    buf = cast(char[])GC.malloc(i, GC.BlkAttr.NO_SCAN)[0 .. i];
+                }
+                memcpy(buf.ptr, p, i);
+                buf = buf[0 .. i];
+            }
+            fp._cnt -= i;
+            fp._ptr += i;
+            return i;
+        }
+    }
+    else version (GCC_IO)
+    {
+        if (fwide(fp, 0) > 0)
+        {   /* Stream is in wide characters.
+             * Read them and convert to chars.
+             */
+            FLOCK(fp);
+            scope(exit) FUNLOCK(fp);
+            version (Windows)
+            {
+                buf.length = 0;
+                int c2;
+                for (int c = void; (c = FGETWC(fp)) != -1; )
+                {
+                    if ((c & ~0x7F) == 0)
+                    {   buf ~= c;
+                        if (c == terminator)
+                            break;
+                    }
+                    else
+                    {
+                        if (c >= 0xD800 && c <= 0xDBFF)
+                        {
+                            if ((c2 = FGETWC(fp)) != -1 ||
+                                    c2 < 0xDC00 && c2 > 0xDFFF)
+                            {
+                                StdioException("unpaired UTF-16 surrogate");
+                            }
+                            c = ((c - 0xD7C0) << 10) + (c2 - 0xDC00);
+                        }
+                        std.utf.encode(buf, c);
+                    }
+                }
+                if (ferror(fp))
+                    StdioException();
+                return buf.length;
+            }
+            else version (Posix)
+            {
+                buf.length = 0;
+                for (int c; (c = FGETWC(fp)) != -1; )
+                {
+                    if ((c & ~0x7F) == 0)
+                        buf ~= c;
+                    else
+                        std.utf.encode(buf, cast(dchar)c);
+                    if (c == terminator)
+                        break;
+                }
+                if (ferror(fp))
+                    StdioException();
+                return buf.length;
+            }
+            else
+            {
+                static assert(0);
+            }
+        }
+
+        char *lineptr = null;
+        size_t n = 0;
+        auto s = getdelim(&lineptr, &n, terminator, fp);
+        scope(exit) free(lineptr);
+        if (s < 0)
+        {
+            if (ferror(fp))
+                StdioException();
+            buf.length = 0;                // end of file
+            return 0;
+        }
+        buf = buf.ptr[0 .. GC.sizeOf(buf.ptr)];
+        if (s <= buf.length)
+        {
+            buf.length = s;
+            buf[] = lineptr[0 .. s];
+        }
+        else
+        {
+            buf = lineptr[0 .. s].dup;
+        }
+        return s;
+    }
+    else version (GENERIC_IO)
+    {
+        FLOCK(fp);
+        scope(exit) FUNLOCK(fp);
+        if (fwide(fp, 0) > 0)
+        {   /* Stream is in wide characters.
+             * Read them and convert to chars.
+             */
+            version (Windows)
+            {
+                buf.length = 0;
+                int c2;
+                for (int c; (c = FGETWC(fp)) != -1; )
+                {
+                    if ((c & ~0x7F) == 0)
+                    {   buf ~= c;
+                        if (c == terminator)
+                            break;
+                    }
+                    else
+                    {
+                        if (c >= 0xD800 && c <= 0xDBFF)
+                        {
+                            if ((c2 = FGETWC(fp)) != -1 ||
+                                    c2 < 0xDC00 && c2 > 0xDFFF)
+                            {
+                                StdioException("unpaired UTF-16 surrogate");
+                            }
+                            c = ((c - 0xD7C0) << 10) + (c2 - 0xDC00);
+                        }
+                        std.utf.encode(buf, c);
+                    }
+                }
+                if (ferror(fp))
+                    StdioException();
+                return buf.length;
+            }
+            else version (Posix)
+            {
+                buf.length = 0;
+                for (int c; (c = FGETWC(fp)) != -1; )
+                {
+                    if ((c & ~0x7F) == 0)
+                        buf ~= c;
+                    else
+                        std.utf.encode(buf, cast(dchar)c);
+                    if (c == terminator)
+                        break;
+                }
+                if (ferror(fp))
+                    StdioException();
+                return buf.length;
+            }
+            else
+            {
+                static assert(0);
+            }
+        }
+
+        buf.length = 0;
+        for (int c; (c = FGETC(fp)) != -1; )
+        {
+            buf ~= c;
+            if (c == terminator)
+                break;
+        }
+        if (ferror(fp))
+            StdioException();
+        return buf.length;
+    }
+    else
+    {
+        static assert(0);
+    }
+}
+
diff -r f12bfe124807 d/phobos2/std/stream.d
--- a/d/phobos2/std/stream.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/stream.d	Thu Oct 14 14:12:53 2010 +0100
@@ -24,9 +24,7 @@
 
 /* NOTE: This file has been patched from the original DMD distribution to
    work with the GDC compiler.
-
-   Modified by David Friedman, April 2005
-*/
+ */
 
 module std.stream;
 
@@ -82,7 +80,7 @@
   import std.system;    // for Endian enumeration
   import std.intrinsic; // for bswap
   import std.utf;
-  import std.c.stdarg;
+  import std.stdarg;
 }
 
 version (Windows) {
@@ -193,6 +191,7 @@
 
   wchar[] readStringW(size_t length);
 
+
   /***
    * Read and return the next character in the stream.
    *
@@ -201,8 +200,6 @@
    * If EOF is reached then getc returns char.init and getcw returns wchar.init.
    */
 
-  // pushes back character c into the stream; only has
-  // effect on further calls to getc() and getcw()
   char getc();
   wchar getcw(); /// ditto
 
@@ -361,6 +358,7 @@
   bool isOpen(); /// Return true if the stream is currently open.
 }
 
+
 /***
  * Stream is the base abstract class from which the other stream classes derive.
  * 
@@ -1136,17 +1134,15 @@
     auto f = toStringz(format);
     size_t psize = buffer.length;
     size_t count;
-    va_list args_copy;
     while (true) {
-      va_copy(args_copy, args);
       version (Win32) {
-	count = _vsnprintf(p, psize, f, args_copy);
+	count = _vsnprintf(p, psize, f, args);
 	if (count != -1)
 	  break;
 	psize *= 2;
 	p = cast(char*) alloca(psize);
       } else version (Posix) {
-	count = vsnprintf(p, psize, f, args_copy);
+	count = vsnprintf(p, psize, f, args);
 	if (count == -1)
 	  psize *= 2;
 	else if (count >= psize)
@@ -1164,9 +1160,9 @@
   // writes data to stream using printf() syntax,
   // returns number of bytes written
   size_t printf(char[] format, ...) {
-    version (GNU)
-	return vprintf(format, _argptr);
-    else {
+    version (GNU) {
+      return vprintf(format, _argptr);
+    } else {
       va_list ap;
       ap = cast(va_list) &format;
       ap += format.sizeof;
@@ -1641,51 +1637,50 @@
   // reusing the memory in buffer if result will fit, otherwise
   // will reallocate (using concatenation)
   template TreadLine(T) {
-    T[] readLine(T[] inBuffer)
+      T[] readLine(T[] inBuffer)
       {
-	size_t    lineSize = 0;
-	bool    haveCR = false;
-	T       c = '\0';
-	size_t    idx = 0;
-	ubyte*  pc = cast(ubyte*)&c;
+          size_t    lineSize = 0;
+          bool    haveCR = false;
+          T       c = '\0';
+          size_t    idx = 0;
+          ubyte*  pc = cast(ubyte*)&c;
 
-      L0:
-	for(;;) {
-	  uint start = bufferCurPos;
-	L1:
-	  foreach(ubyte b; buffer[start .. bufferLen]) {
-	    bufferCurPos++;
-	    pc[idx] = b;
-	    if(idx < T.sizeof - 1) {
-	      idx++;
-	      continue L1;
-	    } else {
-	      idx = 0;
-	    }
-	    if(c == '\n' || haveCR) {
-	      if(haveCR && c != '\n') bufferCurPos--;
-	      break L0;
-	    } else {
-	      if(c == '\r') {
-		haveCR = true;
-	      } else {
-		if(lineSize < inBuffer.length) {
-		  inBuffer[lineSize] = c;
-		} else {
-		  inBuffer ~= c;
-		}
-		lineSize++;
-	      }
-	    }
-	  }
-	  flush();
-	  size_t res = super.readBlock(buffer.ptr, buffer.length);
-	  if(!res) break L0; // EOF
-	  bufferSourcePos = bufferLen = res;
-	  streamPos += res;
-	}
-
-	return inBuffer[0 .. lineSize];
+        L0:
+          for(;;) {
+              uint start = bufferCurPos;
+            L1:
+              foreach(ubyte b; buffer[start .. bufferLen]) {
+                  bufferCurPos++;
+                  pc[idx] = b;
+                  if(idx < T.sizeof - 1) {
+                      idx++;
+                      continue L1;
+                  } else {
+                      idx = 0;
+                  }
+                  if(c == '\n' || haveCR) {
+                      if(haveCR && c != '\n') bufferCurPos--;
+                      break L0;
+                  } else {
+                      if(c == '\r') {
+                          haveCR = true;
+                      } else {
+                          if(lineSize < inBuffer.length) {
+                              inBuffer[lineSize] = c;
+                          } else {
+                              inBuffer ~= c;
+                          }
+                          lineSize++;
+                      }
+                  }
+              }
+              flush();
+              size_t res = super.readBlock(buffer.ptr, buffer.length);
+              if(!res) break L0; // EOF
+              bufferSourcePos = bufferLen = res;
+              streamPos += res;
+          }
+          return inBuffer[0 .. lineSize];
       }
   } // template TreadLine(T)
 
@@ -1791,11 +1786,10 @@
   }
 }
 version (Posix) {
-  private import std.c.unix.unix;
+  private import core.sys.posix.fcntl;
+  private import core.sys.posix.unistd;
   alias int HANDLE;
 }
-version (NoSystem)
-  alias int HANDLE;
 
 /// This subclass is for unbuffered file system streams.
 class File: Stream {
@@ -1803,11 +1797,9 @@
   version (Win32) {
     private HANDLE hFile;
   }
-  else version (Posix) {
+  version (Posix) {
     private HANDLE hFile = -1;
   }
-  else version (NoSystem)
-    private HANDLE hFile;
 
   this() {
     super();
@@ -1828,8 +1820,8 @@
     writeable = cast(bool)(mode & FileMode.Out);
     version(Windows) {
       seekable = GetFileType(hFile) == 1; // FILE_TYPE_DISK
-    } else version (Posix) {
-      ulong result = lseek(hFile, 0, 0);
+    } else {
+      auto result = lseek(hFile, 0, 0);
       seekable = (result != ~0);
     }
   }
@@ -1876,11 +1868,9 @@
       isopen = hFile != INVALID_HANDLE_VALUE;
     }
     version (Posix) {
-      hFile = std.c.unix.unix.open(toStringz(filename), access | createMode, share);
+      hFile = core.sys.posix.fcntl.open(toStringz(filename), access | createMode, share);
       isopen = hFile != -1;
     }
-    version (NoSystem)
-      throw new OpenException("Files not supported on this target");
     if (!isopen)
       throw new OpenException(cast(string) ("Cannot open or create file '"
                                             ~ filename ~ "'"));
@@ -1946,7 +1936,7 @@
 	  CloseHandle(hFile);
 	  hFile = null;
 	} else version (Posix) {
-	  std.c.unix.unix.close(hFile);
+	  core.sys.posix.unistd.close(hFile);
 	  hFile = -1;
 	}
       }
@@ -1971,7 +1961,7 @@
     version (Win32) {
       ReadFile(hFile, buffer, size, &size, null);
     } else version (Posix) {
-      size = std.c.unix.unix.read(hFile, buffer, size);
+      size = core.sys.posix.unistd.read(hFile, buffer, size);
       if (size == -1)
 	size = 0;
     }
@@ -1984,7 +1974,7 @@
     version (Win32) {
       WriteFile(hFile, buffer, size, &size, null);
     } else version (Posix) {
-      size = std.c.unix.unix.write(hFile, buffer, size);
+      size = core.sys.posix.unistd.write(hFile, buffer, size);
       if (size == -1)
 	size = 0;
     }
@@ -2000,15 +1990,12 @@
 	throw new SeekException("unable to move file pointer");
       ulong result = (cast(ulong)hi << 32) + low;
     } else version (Posix) {
-       ulong result = lseek(hFile, cast(off_t)offset, rel);
-      if (result == 0xFFFFFFFF)
-	throw new SeekException("unable to move file pointer");
-    } else version (NoSystem) {
-	int result;
+      auto result = lseek(hFile, cast(int)offset, rel);
+      if (result == cast(typeof(result))-1)
 	throw new SeekException("unable to move file pointer");
     }
     readEOF = false;
-    return result;
+    return cast(ulong)result;
   }
 
   /***
@@ -2655,7 +2642,7 @@
   /// Ensure the stream can hold count bytes.
   void reserve(size_t count) {
     if (cur + count > buf.length)
-      buf.length = cast(size_t)((cur + count) * 2);
+      buf.length = cast(uint)((cur + count) * 2);
   }
 
   override size_t writeBlock(const void* buffer, size_t size) {
diff -r f12bfe124807 d/phobos2/std/string.d
--- a/d/phobos2/std/string.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/string.d	Thu Oct 14 14:12:53 2010 +0100
@@ -2,22 +2,23 @@
 // Written in the D programming language.
 
 /**
- * String handling functions. Objects of types $(D string), $(D
- * wstring), and $(D dstring) are value types and cannot be mutated
- * element-by-element. For using mutation during building strings, use
- * $(D char[]), $(D wchar[]), or $(D dchar[]). The $(D *string) types
- * are preferable because they don't exhibit undesired aliasing, thus
- * making code more robust.
- *
- * Authors:
- *
- * $(WEB digitalmars.com, Walter Bright), $(WEB erdani.org, Andrei
+String handling functions. Objects of types $(D _string), $(D
+wstring), and $(D dstring) are value types and cannot be mutated
+element-by-element. For using mutation during building strings, use
+$(D char[]), $(D wchar[]), or $(D dchar[]). The $(D *_string) types
+are preferable because they don't exhibit undesired aliasing, thus
+making code more robust.
+
+Authors:
+
+$(WEB digitalmars.com, Walter Bright), $(WEB erdani.org, Andrei
 Alexandrescu)
- *
- * Macros:
- *  WIKI = Phobos/StdString
- * Copyright:
- *  Public Domain
+
+Macros:
+ WIKI = Phobos/StdString
+
+Copyright:
+ Public Domain
  */
 
 /* Author:
@@ -27,34 +28,18 @@
 // The code is not optimized for speed, that will have to wait
 // until the design is solidified.
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, September 2004
-*/
-
 module std.string;
 
 //debug=string;     // uncomment to turn on debugging printf's
 
-private import std.algorithm;
-private import std.stdio;
-private import std.c.stdio;
-private import std.c.stdlib;
-private import std.c.string;
-private import std.utf;
-private import std.encoding;
-private import std.uni;
-private import std.format;
-private import std.ctype;
-private import std.stdarg;
-private import std.contracts;
-private import std.typetuple;
-private import std.conv;
-private import std.traits;
 private import core.exception : onRangeError;
-
-extern (C)
+import core.stdc.stdio, core.stdc.stdlib,
+    core.stdc.string, std.algorithm, std.array, 
+    std.contracts, std.conv, std.ctype, std.encoding, std.format,
+    std.metastrings, std.stdarg, std.stdio, std.traits,
+    std.typetuple, std.uni, std.utf;
+
+version(Windows) extern (C)
 {
     size_t wcslen(in wchar *);
     int wcscmp(in wchar *, in wchar *);
@@ -63,7 +48,7 @@
 /* ************* Exceptions *************** */
 
 /// Thrown on errors in string functions.
-typedef object.Exception StringException;
+typedef Exception StringException;
 
 /* ************* Constants *************** */
 
@@ -73,7 +58,7 @@
 invariant char[26] lowercase = "abcdefghijklmnopqrstuvwxyz";    /// a..z
 invariant char[26] uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";    /// A..Z
 invariant char[52] letters   = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
-                   "abcdefghijklmnopqrstuvwxyz";    /// A..Za..z
+    "abcdefghijklmnopqrstuvwxyz";    /// A..Za..z
 invariant char[6] whitespace = " \t\v\r\n\f";           /// ASCII whitespace
 
 enum dchar LS = '\u2028';   /// UTF line separator
@@ -91,54 +76,20 @@
 
 bool iswhite(dchar c)
 {
-    return (c <= 0x7F)
+    return c <= 0x7F
         ? find(whitespace, c) != -1
         : (c == PS || c == LS);
 }
 
-/*********************************
-Convert string $(D s) to integer. $(RED Scheduled for deprecation. Use
-the $(D to!(int)(s)) or $(D parse!(int)(s)) routines in $(WEB
-std_conv, std.conv)).
- */
-
-long atoi(C)(in C[] s)
-{
-    return to!(long)(s);//std.c.stdlib.atoi(toStringz(s));
-}
-
-/*************************************
-Convert string to real. $(RED Scheduled for deprecation. Use the $(D
-to!(real)(s)) or $(D parse!(real)(s)) routines in $(WEB std_conv,
-std.conv)).
- */
-
-real atof(C)(in C[] s)
-{
-    return parse!(real)(s);
-}
-
-unittest
-{
-    alias TypeTuple!(char, wchar, dchar,
-            const char, const wchar, const dchar,
-            invariant char, invariant wchar, invariant dchar)
-        AllChars;
-    foreach (Char; AllChars)
-    {
-        auto s = to!(Char[])("123");
-        assert(atoi(s) == 123);
-    }
-}
-
 /**********************************
- * Compare two strings. cmp is case sensitive, icmp is case insensitive.
- * Returns:
- *  <table border=1 cellpadding=4 cellspacing=0>
- *  $(TR $(TD < 0)  $(TD s1 < s2))
- *  $(TR $(TD = 0)  $(TD s1 == s2))
- *  $(TR $(TD > 0)  $(TD s1 > s2))
- *  </table>
+Compare two strings. $(D _cmp) is case sensitive, $(D icmp) is case
+insensitive.
+
+$(BOOKTABLE Returns:,
+$(TR $(TD < 0)  $(TD $(D s1 < s2)))
+$(TR $(TD = 0)  $(TD $(D s1 == s2)))
+$(TR $(TD > 0)  $(TD $(D s1 > s2)))
+)
  */
 
 int cmp(C1, C2)(in C1[] s1, in C2[] s2)
@@ -160,7 +111,6 @@
                 c2 = std.utf.decode(s2, i2);
             if (c1 != c2) return cast(int) c1 - cast(int) c2;
         }
-	assert(0);
     }
 }
 
@@ -204,7 +154,6 @@
             c2 += cast(int)'a' - cast(int)'A';
         if (c1 != c2) return cast(int) c1 - cast(int) c2;
     }
-    assert(0);
 }
 
 unittest
@@ -230,30 +179,20 @@
     assert(result > 0);
 }
 
-/* ********************************
- * Converts a D array of chars to a C-style 0 terminated string.
- * Deprecated: replaced with toStringz().
+/*********************************
+ * Convert array of chars $(D s[]) to a C-style 0-terminated string.
+ * $(D s[]) must not contain embedded 0's.
  */
 
-deprecated const(char)* toCharz(string s)
+const(char)* toStringz(const(char)[] s)
+in
 {
-    return toStringz(s);
-}
-
-/*********************************
- * Convert array of chars s[] to a C-style 0 terminated string.
- * s[] must not contain embedded 0's.
- */
-
-const(char)* toStringz(const(char)[] s)
-    in
-    {
-        // The assert below contradicts the unittests!
+    // The assert below contradicts the unittests!
     //assert(memchr(s.ptr, 0, s.length) == null,
     //text(s.length, ": `", s, "'"));
-    }
-    out (result)
-    {
+}
+out (result)
+{
     if (result)
     {
         auto slen = s.length;
@@ -261,32 +200,32 @@
         assert(strlen(result) == slen);
         assert(memcmp(result, s.ptr, slen) == 0);
     }
-    }
-    body
-    {
+}
+body
+{
     char[] copy;
-
+    
     /+ Unfortunately, this isn't reliable.
-       We could make this work if string literals are put
-       in read-only memory and we test if s[] is pointing into
-       that.
-
-        /* Peek past end of s[], if it's 0, no conversion necessary.
-         * Note that the compiler will put a 0 past the end of static
-         * strings, and the storage allocator will put a 0 past the end
-         * of newly allocated char[]'s.
-         */
-        char* p = &s[0] + s.length;
-        if (*p == 0)
-        return s;
-    +/
+     We could make this work if string literals are put
+     in read-only memory and we test if s[] is pointing into
+     that.
+     
+     /* Peek past end of s[], if it's 0, no conversion necessary.
+     * Note that the compiler will put a 0 past the end of static
+     * strings, and the storage allocator will put a 0 past the end
+     * of newly allocated char[]'s.
+     */
+     char* p = &s[0] + s.length;
+     if (*p == 0)
+     return s;
+     +/
 
     // Need to make a copy
     copy = new char[s.length + 1];
     copy[0..s.length] = s;
     copy[s.length] = 0;
     return copy.ptr;
-    }
+}
 
 // /// Ditto
 // const(char)* toStringz(invariant(char)[] s)
@@ -334,22 +273,22 @@
  *  Index in s where c is found, -1 if not found.
  */
 
-ptrdiff_t find(in char[] s, dchar c)
+int find(in char[] s, dchar c)
 {
     if (c <= 0x7F)
     {   // Plain old ASCII
-    auto p = cast(char*)memchr(s.ptr, c, s.length);
-    if (p)
-        return p - cast(char *)s;
-    else
-        return -1;
+        auto p = cast(char*)memchr(s.ptr, c, s.length);
+        if (p)
+            return p - cast(char *)s;
+        else
+            return -1;
     }
 
     // c is a universal character
-    foreach (ptrdiff_t i, dchar c2; s)
+    foreach (int i, dchar c2; s)
     {
-    if (c == c2)
-        return i;
+        if (c == c2)
+            return i;
     }
     return -1;
 }
@@ -375,29 +314,29 @@
  * ditto
  */
 
-ptrdiff_t ifind(in char[] s, dchar c)
+int ifind(in char[] s, dchar c)
 {
     if (c <= 0x7F)
     {   // Plain old ASCII
-	char c1 = cast(char) std.ctype.tolower(c);
-
-	foreach (ptrdiff_t i, char c2; s)
-	{
-	    auto c3 = cast(char)std.ctype.tolower(c2);
-	    if (c1 == c3)
-		return i;
-	}
+        char c1 = cast(char) std.ctype.tolower(c);
+
+        foreach (int i, char c2; s)
+        {
+            auto c3 = cast(char)std.ctype.tolower(c2);
+            if (c1 == c3)
+                return i;
+        }
     }
     else
-    {	// c is a universal character
-	dchar c1 = std.uni.toUniLower(c);
-
-	foreach (ptrdiff_t i, dchar c2; s)
-	{
-	    auto c3 = std.uni.toUniLower(c2);
-	    if (c1 == c3)
-		return i;
-	}
+    {   // c is a universal character
+        dchar c1 = std.uni.toUniLower(c);
+
+        foreach (int i, dchar c2; s)
+        {
+            auto c3 = std.uni.toUniLower(c2);
+            if (c1 == c3)
+                return i;
+        }
     }
     return -1;
 }
@@ -433,7 +372,7 @@
  * ditto
  */
 
-ptrdiff_t rfind(in char[] s, dchar c)
+int rfind(in char[] s, dchar c)
 {
     size_t i;
 
@@ -473,7 +412,7 @@
  * ditto
  */
 
-ptrdiff_t irfind(in char[] s, dchar c)
+int irfind(in char[] s, dchar c)
 {
     size_t i;
 
@@ -547,9 +486,9 @@
  *  Index in s where c is found, -1 if not found.
  */
 
-ptrdiff_t find(in char[] s, in char[] sub)
-    out (result)
-    {
+int find(in char[] s, in char[] sub)
+out (result)
+{
     if (result == -1)
     {
     }
@@ -558,9 +497,9 @@
         assert(0 <= result && result < s.length - sub.length + 1);
         assert(memcmp(&s[result], sub.ptr, sub.length) == 0);
     }
-    }
-    body
-    {
+}
+body
+{
     auto sublength = sub.length;
 
     if (sublength == 0)
@@ -571,31 +510,31 @@
         auto c = sub[0];
         if (sublength == 1)
         {
-        auto p = cast(const char*)memchr(s.ptr, c, s.length);
-        if (p)
-            return p - &s[0];
+            auto p = cast(const char*)memchr(s.ptr, c, s.length);
+            if (p)
+                return p - &s[0];
         }
         else
         {
-        size_t imax = s.length - sublength + 1;
-
-        // Remainder of sub[]
-        auto q = &sub[1];
-        sublength--;
-
-        for (size_t i = 0; i < imax; i++)
-        {
-            auto p = cast(const char*)memchr(&s[i], c, imax - i);
-            if (!p)
-            break;
-            i = p - &s[0];
-            if (memcmp(p + 1, q, sublength) == 0)
-            return i;
-        }
+            size_t imax = s.length - sublength + 1;
+
+            // Remainder of sub[]
+            auto q = &sub[1];
+            sublength--;
+
+            for (size_t i = 0; i < imax; i++)
+            {
+                auto p = cast(const char*)memchr(&s[i], c, imax - i);
+                if (!p)
+                    break;
+                i = p - &s[0];
+                if (memcmp(p + 1, q, sublength) == 0)
+                    return i;
+            }
         }
     }
     return -1;
-    }
+}
 
 
 unittest
@@ -622,9 +561,9 @@
  * ditto
  */
 
-ptrdiff_t ifind(in char[] s, in char[] sub)
-    out (result)
-    {
+int ifind(in char[] s, in char[] sub)
+out (result)
+{
     if (result == -1)
     {
     }
@@ -633,11 +572,11 @@
         assert(0 <= result && result < s.length - sub.length + 1);
         assert(icmp(s[result .. result + sub.length], sub) == 0);
     }
-    }
-    body
-    {
+}
+body
+{
     auto sublength = sub.length;
-    ptrdiff_t i;
+    int i;
 
     if (sublength == 0)
         return 0;
@@ -659,12 +598,12 @@
 
         for (i = 0; i < imax; i++)
         {
-        auto j = ifind(s[i .. imax], c);
-        if (j == -1)
-            return -1;
-        i += j;
-        if (icmp(s[i + 1 .. i + sublength], subn) == 0)
-            return i;
+            auto j = ifind(s[i .. imax], c);
+            if (j == -1)
+                return -1;
+            i += j;
+            if (icmp(s[i + 1 .. i + sublength], subn) == 0)
+                return i;
         }
         i = -1;
     }
@@ -674,13 +613,13 @@
 
         for (i = 0; i <= imax; i++)
         {
-        if (icmp(s[i .. i + sublength], sub) == 0)
-            return i;
+            if (icmp(s[i .. i + sublength], sub) == 0)
+                return i;
         }
         i = -1;
     }
     return i;
-    }
+}
 
 
 unittest
@@ -731,9 +670,9 @@
  * ditto
  */
 
-ptrdiff_t rfind(in char[] s, in char[] sub)
-    out (result)
-    {
+int rfind(in char[] s, in char[] sub)
+out (result)
+{
     if (result == -1)
     {
     }
@@ -742,9 +681,9 @@
         assert(0 <= result && result < s.length - sub.length + 1);
         assert(memcmp(&s[0] + result, sub.ptr, sub.length) == 0);
     }
-    }
-    body
-    {
+}
+body
+{
     char c;
 
     if (sub.length == 0)
@@ -752,16 +691,16 @@
     c = sub[0];
     if (sub.length == 1)
         return rfind(s, c);
-    for (ptrdiff_t i = s.length - sub.length; i >= 0; i--)
+    for (int i = s.length - sub.length; i >= 0; i--)
     {
         if (s[i] == c)
         {
-        if (memcmp(&s[i + 1], &sub[1], sub.length - 1) == 0)
-            return i;
+            if (memcmp(&s[i + 1], &sub[1], sub.length - 1) == 0)
+                return i;
         }
     }
     return -1;
-    }
+}
 
 unittest
 {
@@ -785,9 +724,9 @@
  * ditto
  */
 
-ptrdiff_t irfind(in char[] s, in char[] sub)
-    out (result)
-    {
+int irfind(in char[] s, in char[] sub)
+out (result)
+{
     if (result == -1)
     {
     }
@@ -796,9 +735,9 @@
         assert(0 <= result && result < s.length - sub.length + 1);
         assert(icmp(s[result .. result + sub.length], sub) == 0);
     }
-    }
-    body
-    {
+}
+body
+{
     dchar c;
 
     if (sub.length == 0)
@@ -809,25 +748,25 @@
     if (c <= 0x7F)
     {
         c = std.ctype.tolower(c);
-        for (ptrdiff_t i = s.length - sub.length; i >= 0; i--)
+        for (int i = s.length - sub.length; i >= 0; i--)
         {
-        if (std.ctype.tolower(s[i]) == c)
-        {
-            if (icmp(s[i + 1 .. i + sub.length], sub[1 .. sub.length]) == 0)
-            return i;
-        }
+            if (std.ctype.tolower(s[i]) == c)
+            {
+                if (icmp(s[i + 1 .. i + sub.length], sub[1 .. sub.length]) == 0)
+                    return i;
+            }
         }
     }
     else
     {
-        for (ptrdiff_t i = s.length - sub.length; i >= 0; i--)
+        for (int i = s.length - sub.length; i >= 0; i--)
         {
-        if (icmp(s[i .. i + sub.length], sub) == 0)
-            return i;
+            if (icmp(s[i .. i + sub.length], sub) == 0)
+                return i;
         }
     }
     return -1;
-    }
+}
 
 unittest
 {
@@ -923,13 +862,13 @@
 {
     for (size_t i = 0; i < s.length; )
     {
-    invariant c = s[i];
-    if ('A' <= c && c <= 'Z')
-    {
+        invariant c = s[i];
+        if ('A' <= c && c <= 'Z')
+        {
             s[i++] = cast(C) (c + (cast(C)'a' - 'A'));
-    }
-    else if (c > 0x7F)
-    {
+        }
+        else if (c > 0x7F)
+        {
             // wide character
             size_t j = i;
             dchar dc = decode(s, j);
@@ -942,7 +881,7 @@
             auto toAdd = to!(C[])(std.uni.toUniLower(dc));
             s = s[0 .. i] ~ toAdd  ~ s[j .. $];
             i += toAdd.length;
-    }
+        }
         else
         {
             ++i;
@@ -1047,13 +986,13 @@
 {
     for (size_t i = 0; i < s.length; )
     {
-    invariant c = s[i];
-    if ('a' <= c && c <= 'z')
-    {
+        invariant c = s[i];
+        if ('a' <= c && c <= 'z')
+        {
             s[i++] = cast(C) (c - (cast(C)'a' - 'A'));
-    }
-    else if (c > 0x7F)
-    {
+        }
+        else if (c > 0x7F)
+        {
             // wide character
             size_t j = i;
             dchar dc = decode(s, j);
@@ -1066,7 +1005,7 @@
             auto toAdd = to!(C[])(std.uni.toUniUpper(dc));
             s = s[0 .. i] ~ toAdd  ~ s[j .. $];
             i += toAdd.length;
-    }
+        }
         else
         {
             ++i;
@@ -1112,6 +1051,7 @@
 string capitalize(string s)
 {
     int changed;
+    int i;
     char[] r;
 
     changed = 0;
@@ -1237,19 +1177,19 @@
 string repeat(string s, size_t n)
 {
     if (n == 0)
-    return null;
+        return null;
     if (n == 1)
-    return s;
+        return s;
     char[] r = new char[n * s.length];
     if (s.length == 1)
-    r[] = s[0];
+        r[] = s[0];
     else
     {   auto len = s.length;
 
-    for (size_t i = 0; i < n * len; i += len)
-    {
-        r[i .. i + len] = s[];
-    }
+        for (size_t i = 0; i < n * len; i += len)
+        {
+            r[i .. i + len] = s[];
+        }
     }
     return assumeUnique(r);
 }
@@ -1281,37 +1221,28 @@
 
 string join(in string[] words, string sep)
 {
-    char[] result;
-
-    if (words.length)
+    if (!words.length) return null;
+    immutable seplen = sep.length;
+    size_t len = (words.length - 1) * seplen;
+    
+    foreach (i; 0 .. words.length)
+        len += words[i].length;
+    
+    auto result = new char[len];
+    
+    size_t j;
+    foreach (i; 0 .. words.length)
     {
-    size_t len = 0;
-    size_t i;
-
-    for (i = 0; i < words.length; i++)
-        len += words[i].length;
-
-    auto seplen = sep.length;
-    len += (words.length - 1) * seplen;
-
-    result = new char[len];
-
-    size_t j;
-    i = 0;
-    while (true)
-    {
-        size_t wlen = words[i].length;
-
+        if (i > 0)
+        {
+            result[j .. j + seplen] = sep;
+            j += seplen;
+        }
+        immutable wlen = words[i].length;
         result[j .. j + wlen] = words[i];
         j += wlen;
-        i++;
-        if (i >= words.length)
-        break;
-        result[j .. j + seplen] = sep;
-        j += seplen;
     }
     assert(j == len);
-    }
     return assumeUnique(result);
 }
 
@@ -1402,12 +1333,12 @@
  */
 
 string[] split(string s, string delim)
-    in
-    {
+in
+{
     assert(delim.length > 0);
-    }
-    body
-    {
+}
+body
+{
     size_t i;
     size_t j;
     string[] words;
@@ -1417,89 +1348,89 @@
     {
         if (delim.length == 1)
         {   char c = delim[0];
-        size_t nwords = 0;
-        auto p = s.ptr;
-        auto pend = p + s.length;
-
-        while (true)
-        {
-            nwords++;
-            p = cast(typeof(p))memchr(p, c, pend - p);
-            if (!p)
-            break;
-            p++;
-            if (p == pend)
-            {   nwords++;
-            break;
+            size_t nwords = 0;
+            auto p = s.ptr;
+            auto pend = p + s.length;
+
+            while (true)
+            {
+                nwords++;
+                p = cast(typeof(p))memchr(p, c, pend - p);
+                if (!p)
+                    break;
+                p++;
+                if (p == pend)
+                {   nwords++;
+                    break;
+                }
             }
-        }
-        words.length = nwords;
-
-        size_t wordi = 0;
-        i = 0;
-        while (true)
-        {
-            p = cast(typeof(p))memchr(&s[i], c, s.length - i);
-            if (!p)
+            words.length = nwords;
+
+            int wordi = 0;
+            i = 0;
+            while (true)
             {
-            words[wordi] = s[i .. s.length];
-            break;
+                p = cast(typeof(p))memchr(&s[i], c, s.length - i);
+                if (!p)
+                {
+                    words[wordi] = s[i .. s.length];
+                    break;
+                }
+                j = p - &s[0];
+                words[wordi] = s[i .. j];
+                wordi++;
+                i = j + 1;
+                if (i == s.length)
+                {
+                    words[wordi] = "";
+                    break;
+                }
             }
-            j = p - &s[0];
-            words[wordi] = s[i .. j];
-            wordi++;
-            i = j + 1;
-            if (i == s.length)
-            {
-            words[wordi] = "";
-            break;
-            }
-        }
-        assert(wordi + 1 == nwords);
+            assert(wordi + 1 == nwords);
         }
         else
         {   size_t nwords = 0;
 
-        while (true)
-        {
-            nwords++;
-            j = find(s[i .. s.length], delim);
-            if (j == -1)
-            break;
-            i += j + delim.length;
-            if (i == s.length)
-            {   nwords++;
-            break;
+            while (true)
+            {
+                nwords++;
+                j = find(s[i .. s.length], delim);
+                if (j == -1)
+                    break;
+                i += j + delim.length;
+                if (i == s.length)
+                {   nwords++;
+                    break;
+                }
+                assert(i < s.length);
             }
-            assert(i < s.length);
-        }
-        words.length = nwords;
-
-        size_t wordi = 0;
-        i = 0;
-        while (true)
-        {
-            j = find(s[i .. s.length], delim);
-            if (j == -1)
+            words.length = nwords;
+
+            int wordi = 0;
+            i = 0;
+            while (true)
             {
-            words[wordi] = s[i .. s.length];
-            break;
+                j = find(s[i .. s.length], delim);
+                if (j == -1)
+                {
+                    words[wordi] = s[i .. s.length];
+                    break;
+                }
+                words[wordi] = s[i .. i + j];
+                wordi++;
+                i += j + delim.length;
+                if (i == s.length)
+                {
+                    words[wordi] = "";
+                    break;
+                }
+                assert(i < s.length);
             }
-            words[wordi] = s[i .. i + j];
-            wordi++;
-            i += j + delim.length;
-            if (i == s.length)
-            {
-            words[wordi] = "";
-            break;
-            }
-            assert(i < s.length);
-        }
-        assert(wordi + 1 == nwords);
+            assert(wordi + 1 == nwords);
         }
     }
     return words;
-    }
+}
 
 unittest
 {
@@ -1572,28 +1503,28 @@
 
 string[] splitlines(string s)
 {
-    size_t i;
-    size_t istart;
-    size_t nlines;
+    uint i;
+    uint istart;
+    uint nlines;
 
     nlines = 0;
     for (i = 0; i < s.length; i++)
     {   char c;
 
-    c = s[i];
-    if (c == '\r' || c == '\n')
-    {
-        nlines++;
-        istart = i + 1;
-        if (c == '\r' && i + 1 < s.length && s[i + 1] == '\n')
+        c = s[i];
+        if (c == '\r' || c == '\n')
         {
-        i++;
-        istart++;
+            nlines++;
+            istart = i + 1;
+            if (c == '\r' && i + 1 < s.length && s[i + 1] == '\n')
+            {
+                i++;
+                istart++;
+            }
         }
     }
-    }
     if (istart != i)
-    nlines++;
+        nlines++;
 
     auto lines = new string[nlines];
     nlines = 0;
@@ -1601,22 +1532,22 @@
     for (i = 0; i < s.length; i++)
     {   char c;
 
-    c = s[i];
-    if (c == '\r' || c == '\n')
-    {
-        lines[nlines] = s[istart .. i];
-        nlines++;
-        istart = i + 1;
-        if (c == '\r' && i + 1 < s.length && s[i + 1] == '\n')
+        c = s[i];
+        if (c == '\r' || c == '\n')
         {
-        i++;
-        istart++;
+            lines[nlines] = s[istart .. i];
+            nlines++;
+            istart = i + 1;
+            if (c == '\r' && i + 1 < s.length && s[i + 1] == '\n')
+            {
+                i++;
+                istart++;
+            }
         }
     }
-    }
     if (istart != i)
     {   lines[nlines] = s[istart .. i];
-    nlines++;
+        nlines++;
     }
 
     assert(nlines == lines.length);
@@ -1657,44 +1588,37 @@
  * Strips leading or trailing whitespace, or both.
  */
 
-string stripl(string s)
+String stripl(String)(String s)
 {
-    size_t i;
-
+    uint i;
     for (i = 0; i < s.length; i++)
     {
-    if (!std.ctype.isspace(s[i]))
-        break;
+        if (!std.ctype.isspace(s[i]))
+            break;
     }
     return s[i .. s.length];
 }
 
-string stripr(string s) /// ditto
+String stripr(String)(String s) /// ditto
 {
-    size_t i;
-
-    for (i = s.length; i > 0; i--)
+    for (auto i = s.length;;)
     {
-    if (!std.ctype.isspace(s[i - 1]))
-        break;
+        if (i == 0) return null;
+        --i;
+        if (!std.ctype.isspace(s[i]))
+            return s[0 .. i + 1];
     }
-    return s[0 .. i];
 }
 
-string strip(string s) /// ditto
+String strip(String)(String s) /// ditto
 {
     return stripr(stripl(s));
 }
 
 unittest
 {
-    debug(string) printf("string.strip.unittest\n");
-    string s;
-    int i;
-
-    s = strip("  foo\t ");
-    i = cmp(s, "foo");
-    assert(i == 0);
+    assert(strip("  foo\t ") == "foo");
+    assert(strip("1") == "1");
 }
 
 /**
@@ -1703,59 +1627,46 @@
  */
 bool startsWith(A1, A2)(A1 longer, A2 shorter)
 {
-    static if (is(typeof(longer[0 .. shorter.length] == shorter)))
+    static if (isSomeString!(A1) && isSomeString!(A2))
     {
-        // the easy way: arrays, directly comparable
-        return longer.length >= shorter.length &&
-            longer[0 .. shorter.length] == shorter;
+        // UTF-informed comparison
+        // find the largest character of the two
+        static if (longer[0].sizeof > shorter[0].sizeof)
+        {
+            alias typeof(longer[0]) Char;
+            foreach (Char c; shorter)
+            {
+                if (longer.empty || longer.front != c) return false;
+                longer.popFront;
+            }
+            return true;
+        }
+        else static if (longer[0].sizeof < shorter[0].sizeof)
+        {
+            alias typeof(shorter[0]) Char;
+            foreach (Char c; longer)
+            {
+                if (shorter.empty) return true;
+                if (shorter.front != c) return false;
+                shorter.popFront;
+            }
+            return shorter.empty;
+        }
+        else
+        {
+            return longer.length >= shorter.length
+                && longer[0 .. shorter.length] == shorter;
+        }
     }
     else
     {
-        // different element types, etc.
-        static if (isSomeString!(A1) && isSomeString!(A2))
-        {
-            // UTF-informed comparison
-            // find the largest character of the two
-            static if (longer[0].sizeof > shorter[0].sizeof)
-            {
-                alias typeof(longer[0]) Char;
-                if (shorter.length / Char.sizeof > longer.length) return false;
-                size_t i = 0;
-                foreach (Char c; shorter)
-                {
-                    if (i == longer.length || longer[i] != c) return false;
-                    ++i;
-                }
-            }
-            else
-            {
-                static assert(longer[0].sizeof < shorter[0].sizeof,
-                    "Looks like there's a bug in the compiler");
-                alias typeof(shorter[0]) Char;
-                if (shorter.length > longer.length) return false;
-                size_t i = 0;
-                foreach (Char c; longer)
-                {
-                    if (i == shorter.length) return true;
-                    if (shorter[i] != c) return false;
-                    ++i;
-                }
-            }
-        }
-        else
-        {
-            // raw element-by-element comparison
-            if (longer.length < shorter.length) return false;
-            foreach (i, e; shorter)
-            {
-                if (longer[i] != e) return false;
-            }
-        }
-        return true;
+        // raw element-by-element comparison
+        return std.algorithm.startsWith(longer, shorter) == 1;
     }
 }
 
-unittest
+// Too slow for release mode
+debug unittest
 {
 version(none) // fails to compile with: Error: array equality comparison type mismatch, immutable(char)[] vs ubyte[]
 {
@@ -1795,60 +1706,48 @@
  */
 bool endsWith(A1, A2)(A1 longer, A2 shorter)
 {
-    static if (is(typeof(longer[$ - shorter.length .. $] == shorter)))
+    // different element types, etc.
+    static if (isSomeString!(A1) && isSomeString!(A2))
     {
-        // the easy way: arrays, directly comparable
-        return longer.length >= shorter.length &&
-            longer[$ - shorter.length .. $] == shorter;
+        // UTF-informed comparison
+        // find the largest character of the two
+        static if (longer[0].sizeof > shorter[0].sizeof)
+        {
+            alias typeof(longer[0]) Char;
+            foreach_reverse (Char c; shorter)
+            {
+                if (longer.empty) return false;
+                if (longer.back != c) return false;
+                longer.popBack;
+            }
+            return true;
+        }
+        else static if (longer[0].sizeof < shorter[0].sizeof)
+        {
+            alias typeof(shorter[0]) Char;
+            foreach_reverse (Char c; longer)
+            {
+                if (shorter.empty) return true;
+                if (shorter.back != c) return false;
+                shorter.popBack;
+            }
+            return shorter.empty;
+        }
+        else
+        {
+            return longer.length >= shorter.length
+                && longer[$ - shorter.length .. $] == shorter;
+        }
     }
     else
     {
-        // different element types, etc.
-        static if (isSomeString!(A1) && isSomeString!(A2))
-        {
-            // UTF-informed comparison
-            // find the largest character of the two
-            static if (longer[0].sizeof > shorter[0].sizeof)
-            {
-                alias typeof(longer[0]) Char;
-                if (shorter.length > longer.length * Char.sizeof) return false;
-                size_t i = longer.length - 1;
-                foreach_reverse (Char c; shorter)
-                {
-                    if (i == 0 || longer[i] != c) return false;
-                    --i;
-                }
-            }
-            else
-            {
-                static assert(longer[0].sizeof < shorter[0].sizeof,
-                    "Looks like there's a bug in the compiler");
-                alias typeof(shorter[0]) Char;
-                if (shorter.length > longer.length) return false;
-                if (!shorter.length) return true;
-                size_t i = shorter.length - 1;
-                foreach_reverse (Char c; longer)
-                {
-                    if (i == 0) return true;
-                    if (shorter[i] != c) return false;
-                    --i;
-                }
-            }
-        }
-        else
-        {
-            // raw element-by-element comparison
-            if (longer.length < shorter.length) return false;
-            foreach (i, e; longer[$ - shorter.length .. $])
-            {
-                if (shorter[i] != e) return false;
-            }
-        }
-        return true;
+        //assert(0);
+        return std.algorithm.endsWith(longer, shorter) == 1;
     }
 }
 
-unittest
+// Too slow for release mode
+debug unittest
 {
     alias TypeTuple!(string, wstring, dstring, char[], wchar[], dchar[])
         TestTypes;
@@ -1863,6 +1762,10 @@
             {
                 auto a = to!(T1)("efgh"), b = to!(T2)("abcdefgh"),
                     c = to!(T2)(""), d = to!(T3)([1, 2]);
+                assert(endsWith(a, a));
+                assert(endsWith(b, b));
+                // writeln(T2.stringof);
+                // writeln(T1.stringof);
                 assert(endsWith(b, a));
                 assert(!endsWith(a, b));
                 assert(endsWith(b, c));
@@ -1884,8 +1787,8 @@
         {
             auto a = to!(T1)([1, 2]);
             auto b = to!(T2)([0, 1, 2]);
-            assert(!endsWith(a, b));
-            assert(endsWith(b, a));
+            //assert(!std.string.endsWith(a, b));
+            // assert(endsWith(b, a));
         }
     }
 }
@@ -1901,24 +1804,24 @@
     if (delimiter is null)
     {   auto len = s.length;
 
-    if (len)
-    {   auto c = s[len - 1];
-
-        if (c == '\r')          // if ends in CR
-        len--;
-        else if (c == '\n')         // if ends in LF
-        {
-        len--;
-        if (len && s[len - 1] == '\r')
-            len--;          // remove CR-LF
+        if (len)
+        {   auto c = s[len - 1];
+
+            if (c == '\r')          // if ends in CR
+                len--;
+            else if (c == '\n')         // if ends in LF
+            {
+                len--;
+                if (len && s[len - 1] == '\r')
+                    len--;          // remove CR-LF
+            }
         }
-    }
-    return s[0 .. len];
+        return s[0 .. len];
     }
     else if (s.length >= delimiter.length)
     {
-    if (s[length - delimiter.length .. length] == delimiter)
-        return s[0 .. length - delimiter.length];
+        if (s[length - delimiter.length .. length] == delimiter)
+            return s[0 .. length - delimiter.length];
     }
     return s;
 }
@@ -1984,24 +1887,21 @@
  */
 
 string chop(string s)
-{   auto len = s.length;
-
-    if (len)
-    {
+{
+    auto len = s.length;
+    if (!len) return s;
     if (len >= 2 && s[len - 1] == '\n' && s[len - 2] == '\r')
         return s[0 .. len - 2];
-
+    
     // If we're in a tail of a UTF-8 sequence, back up
     while ((s[len - 1] & 0xC0) == 0x80)
     {
         len--;
         if (len == 0)
-        throw new std.utf.UtfException("invalid UTF sequence", 0);
+            throw new std.utf.UtfException("invalid UTF sequence", 0);
     }
-
+    
     return s[0 .. len - 1];
-    }
-    return s;
 }
 
 
@@ -2026,7 +1926,7 @@
  * in field width chars wide.
  */
 
-string ljustify(string s, ptrdiff_t width)
+string ljustify(string s, int width)
 {
     if (s.length >= width)
     return s;
@@ -2037,7 +1937,7 @@
 }
 
 /// ditto
-string rjustify(string s, ptrdiff_t width)
+string rjustify(string s, int width)
 {
     if (s.length >= width)
     return s;
@@ -2048,12 +1948,12 @@
 }
 
 /// ditto
-string center(string s, ptrdiff_t width)
+string center(string s, int width)
 {
     if (s.length >= width)
     return s;
     char[] r = new char[width];
-    ptrdiff_t left = (width - s.length) / 2;
+    int left = (width - s.length) / 2;
     r[0 .. left] = cast(char)' ';
     r[left .. left + s.length] = s;
     r[left + s.length .. width] = cast(char)' ';
@@ -2090,7 +1990,7 @@
  * Same as rjustify(), but fill with '0's.
  */
 
-string zfill(string s, ptrdiff_t width)
+string zfill(string s, int width)
 {
     if (s.length >= width)
     return s;
@@ -2107,7 +2007,7 @@
 string replace(string s, string from, string to)
 {
     char[] p;
-    ptrdiff_t i;
+    int i;
     size_t istart;
 
     //printf("replace('%.*s','%.*s','%.*s')\n", s, from, to);
@@ -2156,21 +2056,23 @@
 in
 {
     // Verify that slice[] really is a slice of s[]
-    ptrdiff_t so = cast(char*)slice - cast(char*)s;
+    int so = cast(char*)slice - cast(char*)s;
     assert(so >= 0);
-    //printf("s.length = %d, so = %d, slice.length = %d\n", s.length, so, slice.length);
+    //printf("s.length = %d, so = %d, slice.length = %d\n", s.length,
+    //so, slice.length);
     assert(s.length >= so + slice.length);
 }
 body
 {
     char[] result;
-    ptrdiff_t so = cast(char*)slice - cast(char*)s;
+    int so = cast(char*)slice - cast(char*)s;
 
     result.length = s.length - slice.length + replacement.length;
 
     result[0 .. so] = s[0 .. so];
     result[so .. so + replacement.length] = replacement;
-    result[so + replacement.length .. result.length] = s[so + slice.length .. s.length];
+    result[so + replacement.length .. result.length] =
+        s[so + slice.length .. s.length];
 
     return assumeUnique(result);
 }
@@ -2205,7 +2107,7 @@
     if (s.length == 0)
     return sub;
 
-    ptrdiff_t newlength = s.length + sub.length;
+    int newlength = s.length + sub.length;
     char[] result = new char[newlength];
 
     result[0 .. index] = s[0 .. index];
@@ -2249,7 +2151,7 @@
 size_t count(string s, string sub)
 {
     size_t i;
-    ptrdiff_t j;
+    int j;
     int count = 0;
 
     for (i = 0; i < s.length; i += j + sub.length)
@@ -2284,8 +2186,8 @@
 {
     bool changes = false;
     char[] result;
-    size_t column;
-    size_t nspaces;
+    int column;
+    int nspaces;
 
     foreach (size_t i, dchar c; str)
     {
@@ -2303,7 +2205,7 @@
             result[i .. i + nspaces] = ' ';
         }
         else
-        {   size_t j = result.length;
+        {   int j = result.length;
             result.length = j + nspaces;
             result[j .. j + nspaces] = ' ';
         }
@@ -2369,99 +2271,99 @@
  *  tabsize = Tab columns are tabsize spaces apart. tabsize defaults to 8.
  */
 
-string entab(string s, ptrdiff_t tabsize = 8)
+string entab(string s, int tabsize = 8)
 {
     bool changes = false;
     char[] result;
 
-    ptrdiff_t nspaces = 0;
-    ptrdiff_t nwhite = 0;
-    ptrdiff_t column = 0;			// column number
+    int nspaces = 0;
+    int nwhite = 0;
+    int column = 0;         // column number
 
     foreach (size_t i, dchar c; s)
-    {   
-
-	void change()
-	{
-	    changes = true;
-	    result = null;
-	    result.length = s.length;
-	    result.length = i;
-	    result[0 .. i] = s[0 .. i];
-	}
-
-	switch (c)
-	{   
-	    case '\t':
-		nwhite++;
-		if (nspaces)
-		{
-		    if (!changes)
-			change();
-
-		    ptrdiff_t j = result.length - nspaces;
-		    ptrdiff_t ntabs = (((column - nspaces) % tabsize) + nspaces) / tabsize;
-		    result.length = j + ntabs;
-		    result[j .. j + ntabs] = '\t';
-		    nwhite += ntabs - nspaces;
-		    nspaces = 0;
-		}
-		column = (column + tabsize) / tabsize * tabsize;
-		break;
-
-	    case '\r':
-	    case '\n':
-	    case PS:
-	    case LS:
-		// Truncate any trailing spaces or tabs
-		if (nwhite)
-		{
-		    if (!changes)
-			change();
-		    result = result[0 .. result.length - nwhite];
-		}
-		break;
-
-	    default:
-		if (nspaces >= 2 && (column % tabsize) == 0)
-		{
-		    if (!changes)
-			change();
-
-		    ptrdiff_t j = result.length - nspaces;
-		    ptrdiff_t ntabs = (nspaces + tabsize - 1) / tabsize;
-		    result.length = j + ntabs;
-		    result[j .. j + ntabs] = '\t';
-		    nwhite += ntabs - nspaces;
-		    nspaces = 0;
-		}
-		if (c == ' ')
-		{   nwhite++;
-		    nspaces++;
-		}
-		else
-		{   nwhite = 0;
-		    nspaces = 0;
-		}
-		column++;
-		break;
-	}
-	if (changes)
-	{
-	    if (c <= 0x7F)
-		result ~= cast(char)c;
-	    else
-		std.utf.encode(result, c);
-	}
+    {
+
+    void change()
+    {
+        changes = true;
+        result = null;
+        result.length = s.length;
+        result.length = i;
+        result[0 .. i] = s[0 .. i];
+    }
+
+    switch (c)
+    {
+        case '\t':
+        nwhite++;
+        if (nspaces)
+        {
+            if (!changes)
+            change();
+
+            int j = result.length - nspaces;
+            int ntabs = (((column - nspaces) % tabsize) + nspaces) / tabsize;
+            result.length = j + ntabs;
+            result[j .. j + ntabs] = '\t';
+            nwhite += ntabs - nspaces;
+            nspaces = 0;
+        }
+        column = (column + tabsize) / tabsize * tabsize;
+        break;
+
+        case '\r':
+        case '\n':
+        case PS:
+        case LS:
+        // Truncate any trailing spaces or tabs
+        if (nwhite)
+        {
+            if (!changes)
+            change();
+            result = result[0 .. result.length - nwhite];
+        }
+        break;
+
+        default:
+        if (nspaces >= 2 && (column % tabsize) == 0)
+        {
+            if (!changes)
+            change();
+
+            int j = result.length - nspaces;
+            int ntabs = (nspaces + tabsize - 1) / tabsize;
+            result.length = j + ntabs;
+            result[j .. j + ntabs] = '\t';
+            nwhite += ntabs - nspaces;
+            nspaces = 0;
+        }
+        if (c == ' ')
+        {   nwhite++;
+            nspaces++;
+        }
+        else
+        {   nwhite = 0;
+            nspaces = 0;
+        }
+        column++;
+        break;
+    }
+    if (changes)
+    {
+        if (c <= 0x7F)
+        result ~= cast(char)c;
+        else
+        std.utf.encode(result, c);
+    }
     }
 
     // Truncate any trailing spaces or tabs
     if (nwhite)
     {
-	if (changes)
-	    result = result[0 .. result.length - nwhite];
-	else
-	    s = s[0 .. s.length - nwhite];
+    if (changes)
+        result = result[0 .. result.length - nwhite];
+    else
+        s = s[0 .. s.length - nwhite];
     }
     return changes ? assumeUnique(result) : s;
 }
@@ -2519,29 +2421,29 @@
 string maketrans(in string from, in string to)
     in
     {
-	assert(from.length == to.length);
-	assert(from.length <= 128);
-	foreach (char c; from)
-	{
-	    assert(c <= 0x7F);
-	}
-	foreach (char c; to)
-	{
-	    assert(c <= 0x7F);
-	}
+    assert(from.length == to.length);
+    assert(from.length <= 128);
+    foreach (char c; from)
+    {
+        assert(c <= 0x7F);
+    }
+    foreach (char c; to)
+    {
+        assert(c <= 0x7F);
+    }
     }
     body
     {
-	char[] t = new char[256];
-	ptrdiff_t i;
-
-	for (i = 0; i < t.length; i++)
-	    t[i] = cast(char)i;
-
-	for (i = 0; i < from.length; i++)
-	    t[from[i]] = to[i];
-
-	return assumeUnique(t);
+    char[] t = new char[256];
+    int i;
+
+    for (i = 0; i < t.length; i++)
+        t[i] = cast(char)i;
+
+    for (i = 0; i < from.length; i++)
+        t[from[i]] = to[i];
+
+    return assumeUnique(t);
     }
 
 /******************************************
@@ -2553,40 +2455,40 @@
 string translate(string s, in string transtab, in string delchars)
     in
     {
-	assert(transtab.length == 256);
+    assert(transtab.length == 256);
     }
     body
     {
-	char[] r;
-	ptrdiff_t count;
-	bool[256] deltab;
-
-	deltab[] = false;
-	foreach (char c; delchars)
-	{
-	    deltab[c] = true;
-	}
-
-	count = 0;
-	foreach (char c; s)
-	{
-	    if (!deltab[c])
-		count++;
-	    //printf("s[%d] = '%c', count = %d\n", i, s[i], count);
-	}
-
-	r = new char[count];
-	count = 0;
-	foreach (char c; s)
-	{
-	    if (!deltab[c])
-	    {
-		r[count] = transtab[c];
-		count++;
-	    }
-	}
-
-	return assumeUnique(r);
+    char[] r;
+    int count;
+    bool[256] deltab;
+
+    deltab[] = false;
+    foreach (char c; delchars)
+    {
+        deltab[c] = true;
+    }
+
+    count = 0;
+    foreach (char c; s)
+    {
+        if (!deltab[c])
+        count++;
+        //printf("s[%d] = '%c', count = %d\n", i, s[i], count);
+    }
+
+    r = new char[count];
+    count = 0;
+    foreach (char c; s)
+    {
+        if (!deltab[c])
+        {
+        r[count] = transtab[c];
+        count++;
+        }
+    }
+
+    return assumeUnique(r);
     }
 
 unittest
@@ -2607,421 +2509,167 @@
     assert(i == 0);
 }
 
-/***********************************************
- * Convert to string.
+/**
+Convert to string. WARNING! This function has been deprecated. Instead
+ of $(D toString(x)), you may want to import $(D std.conv) and use $(D
+ to!string(x)) instead.
  */
-
-string toString(bool b)
+deprecated auto toString(T, string f = __FILE__, uint line = __LINE__)(T obj)
+    if (is(typeof(to!string(T.init))))
 {
-    return b ? "true" : "false";
+    pragma(msg, "toString("~T.stringof~") called from "~f~"("~ToString!(line)
+            ~") is deprecated."
+            " Instead you may want to"
+            " import std.conv and use to!string(x) instead of toString(x).");
+    return to!string(obj);
 }
 
-/// ditto
-string toString(char c)
+/**
+Convert string to integer. WARNING. This function has been
+ deprecated. Instead of $(D atoi(s)), you may want to import $(D
+ std.conv) and use $(D to!int(s)) instead.
+ */
+deprecated auto atoi(T, string f = __FILE__, uint line = __LINE__)(T obj)
+    if (isSomeString!T)
 {
-    char[] result = new char[2];
-    result[0] = c;
-    result[1] = 0;
-    return cast(string) result[0 .. 1];
-}
-
-/// ditto
-string toString(wchar c)
-{
-    char[] result;
-    encode(result, c);
-    return assumeUnique(result);
-}
-
-/// ditto
-string toString(dchar c)
-{
-    char[] result;
-    encode(result, c);
-    return assumeUnique(result);
+    pragma(msg, "atoi("~T.stringof~") called from "~f~"("~ToString!(line)
+            ~") is deprecated."
+            " Instead you may want to"
+            " import std.conv and use to!int(x) instead of atoi(x).");
+    return to!int(obj);
 }
 
 unittest
 {
-    debug(string) printf("string.toString(char).unittest\n");
-
     string s = "foo";
     string s2;
     foreach (char c; s)
     {
-    s2 ~= std.string.toString(c);
+        s2 ~= to!string(c);
     }
     //printf("%.*s", s2);
     assert(s2 == "foo");
 }
 
-string toString(ubyte ub)  { return toString(cast(uint) ub); } /// ditto
-string toString(ushort us) { return toString(cast(uint) us); } /// ditto
-
-/// ditto
-string toString(uint u)
-{   char[uint.sizeof * 3] buffer = void;
-    int ndigits;
-    char[] result;
-
-    ndigits = 0;
-    if (u < 10)
-    // Avoid storage allocation for simple stuff
-    return digits[u .. u + 1];
-    else
-    {
-    while (u)
-    {
-        uint c = (u % 10) + '0';
-        u /= 10;
-        ndigits++;
-        buffer[buffer.length - ndigits] = cast(char)c;
-    }
-    result = new char[ndigits];
-    result[] = buffer[buffer.length - ndigits .. buffer.length];
-    }
-    return assumeUnique(result);
-}
-
 unittest
 {
-    debug(string) printf("string.toString(uint).unittest\n");
+    debug(string) printf("string.to!string(uint).unittest\n");
 
     string r;
     int i;
 
-    r = toString(0u);
+    r = to!string(0u);
     i = cmp(r, "0");
     assert(i == 0);
 
-    r = toString(9u);
+    r = to!string(9u);
     i = cmp(r, "9");
     assert(i == 0);
 
-    r = toString(123u);
+    r = to!string(123u);
     i = cmp(r, "123");
     assert(i == 0);
 }
 
-/// ditto
-string toString(ulong u)
-{   char[ulong.sizeof * 3] buffer;
-    int ndigits;
-    char[] result;
-
-    if (u < 0x1_0000_0000)
-    return toString(cast(uint)u);
-    ndigits = 0;
-    while (u)
-    {
-    char c = cast(char)((u % 10) + '0');
-    u /= 10;
-    ndigits++;
-    buffer[buffer.length - ndigits] = c;
-    }
-    result = new char[ndigits];
-    result[] = buffer[buffer.length - ndigits .. buffer.length];
-    return assumeUnique(result);
-}
-
 unittest
 {
-    debug(string) printf("string.toString(ulong).unittest\n");
+    debug(string) printf("string.to!string(ulong).unittest\n");
 
     string r;
     int i;
 
-    r = toString(0uL);
+    r = to!string(0uL);
     i = cmp(r, "0");
     assert(i == 0);
 
-    r = toString(9uL);
+    r = to!string(9uL);
     i = cmp(r, "9");
     assert(i == 0);
 
-    r = toString(123uL);
+    r = to!string(123uL);
     i = cmp(r, "123");
     assert(i == 0);
 }
 
-string toString(byte b)  { return toString(cast(int) b); } /// ditto
-string toString(short s) { return toString(cast(int) s); } /// ditto
-
-/// ditto
-string toString(int i)
-{   char[1 + int.sizeof * 3] buffer;
-    char[] result;
-
-    if (i >= 0)
-    return toString(cast(uint)i);
-
-    uint u = -i;
-    int ndigits = 1;
-    while (u)
-    {
-    char c = cast(char)((u % 10) + '0');
-    u /= 10;
-    buffer[buffer.length - ndigits] = c;
-    ndigits++;
-    }
-    buffer[buffer.length - ndigits] = '-';
-    result = new char[ndigits];
-    result[] = buffer[buffer.length - ndigits .. buffer.length];
-    return assumeUnique(result);
-}
-
 unittest
 {
-    debug(string) printf("string.toString(int).unittest\n");
+    debug(string) printf("string.to!string(int).unittest\n");
 
     string r;
     int i;
 
-    r = toString(0);
+    r = to!string(0);
     i = cmp(r, "0");
     assert(i == 0);
 
-    r = toString(9);
+    r = to!string(9);
     i = cmp(r, "9");
     assert(i == 0);
 
-    r = toString(123);
+    r = to!string(123);
     i = cmp(r, "123");
     assert(i == 0);
 
-    r = toString(-0);
+    r = to!string(-0);
     i = cmp(r, "0");
     assert(i == 0);
 
-    r = toString(-9);
+    r = to!string(-9);
     i = cmp(r, "-9");
     assert(i == 0);
 
-    r = toString(-123);
+    r = to!string(-123);
     i = cmp(r, "-123");
     assert(i == 0);
 }
 
-/// ditto
-string toString(long i)
-{   char[1 + long.sizeof * 3] buffer;
-    char[] result;
-
-    if (i >= 0)
-    return toString(cast(ulong)i);
-    if (cast(int)i == i)
-    return toString(cast(int)i);
-
-    ulong u = cast(ulong)(-i);
-    int ndigits = 1;
-    while (u)
-    {
-    char c = cast(char)((u % 10) + '0');
-    u /= 10;
-    buffer[buffer.length - ndigits] = c;
-    ndigits++;
-    }
-    buffer[buffer.length - ndigits] = '-';
-    result = new char[ndigits];
-    result[] = buffer[buffer.length - ndigits .. buffer.length];
-    return assumeUnique(result);
-}
-
 unittest
 {
-    debug(string) printf("string.toString(long).unittest\n");
+    debug(string) printf("string.to!string(long).unittest\n");
 
     string r;
     int i;
 
-    r = toString(0L);
+    r = to!string(0L);
     i = cmp(r, "0");
     assert(i == 0);
 
-    r = toString(9L);
+    r = to!string(9L);
     i = cmp(r, "9");
     assert(i == 0);
 
-    r = toString(123L);
+    r = to!string(123L);
     i = cmp(r, "123");
     assert(i == 0);
 
-    r = toString(-0L);
+    r = to!string(-0L);
     i = cmp(r, "0");
     assert(i == 0);
 
-    r = toString(-9L);
+    r = to!string(-9L);
     i = cmp(r, "-9");
     assert(i == 0);
 
-    r = toString(-123L);
+    r = to!string(-123L);
     i = cmp(r, "-123");
     assert(i == 0);
 }
 
-/// ditto
-string toString(float f) { return toString(cast(double) f); }
-
-/// ditto
-string toString(double d)
-{
-    char[20] buffer;
-
-    int len = sprintf(buffer.ptr, "%g", d);
-    return buffer[0 .. len].idup;
-}
-
-/// ditto
-static if (real.sizeof != double.sizeof)
-    private static const char[] _longDoubleFormat = "L";
-else
-    private static const char[] _longDoubleFormat = "";
-    
-string toString(real r)
-{
-    char[20] buffer;
-
-    int len = sprintf(buffer.ptr, ("%"~_longDoubleFormat~"g").ptr, r);
-    return buffer[0 .. len].idup;
-}
-
-/// ditto
-string toString(ifloat f) { return toString(cast(idouble) f); }
-
-/// ditto
-string toString(idouble d)
-{
-    char[21] buffer;
-
-    int len = sprintf(buffer.ptr, "%gi", d);
-    return buffer[0 .. len].idup;
-}
-
-/// ditto
-string toString(ireal r)
-{
-    char[21] buffer;
-
-    int len = sprintf(buffer.ptr, ("%"~_longDoubleFormat~"gi").ptr, r);
-    return buffer[0 .. len].idup;
-}
-
-/// ditto
-string toString(cfloat f) { return toString(cast(cdouble) f); }
-
-/// ditto
-string toString(cdouble d)
-{
-    char[20 + 1 + 20 + 1] buffer;
-
-    int len = sprintf(buffer.ptr, "%g+%gi", d.re, d.im);
-    return buffer[0 .. len].idup;
-}
-
-/// ditto
-string toString(creal r)
-{
-    char[20 + 1 + 20 + 1] buffer;
-
-    int len = sprintf(buffer.ptr, ("%"~_longDoubleFormat~"g+%"~_longDoubleFormat~"gi").ptr, r.re, r.im);
-    return buffer[0 .. len].idup;
-}
-
-/******************************************
- * Convert value to string in _radix radix.
- *
- * radix must be a value from 2 to 36.
- * value is treated as a signed value only if radix is 10.
- * The characters A through Z are used to represent values 10 through 36.
- */
-string toString(long value, uint radix)
-in
-{
-    assert(radix >= 2 && radix <= 36);
-}
-body
-{
-    if (radix == 10)
-    return toString(value);     // handle signed cases only for radix 10
-    return toString(cast(ulong)value, radix);
-}
-
-/// ditto
-string toString(ulong value, uint radix)
-in
-{
-    assert(radix >= 2 && radix <= 36);
-}
-body
-{
-    char[value.sizeof * 8] buffer;
-    size_t i = buffer.length;
-
-    if (value < radix && value < hexdigits.length)
-    return hexdigits[cast(size_t)value .. cast(size_t)value + 1];
-
-    do
-    {   ubyte c;
-
-    c = cast(ubyte)(value % radix);
-    value = value / radix;
-    i--;
-    buffer[i] = cast(char)((c < 10) ? c + '0' : c + 'A' - 10);
-    } while (value);
-    return buffer[i .. length].idup;
-}
-
 unittest
 {
-    debug(string) printf("string.toString(ulong, uint).unittest\n");
+    debug(string) printf("string.to!string(char*).unittest\n");
 
     string r;
     int i;
 
-    r = toString(-10L, 10u);
-    assert(r == "-10");
-
-    r = toString(15L, 2u);
-    //writefln("r = '%s'", r);
-    assert(r == "1111");
-
-    r = toString(1L, 2u);
-    //writefln("r = '%s'", r);
-    assert(r == "1");
-
-    r = toString(0x1234AFL, 16u);
-    //writefln("r = '%s'", r);
-    assert(r == "1234AF");
-}
-
-/*************************************************
- * Convert C-style 0 terminated string s to string string.
- */
-
-// string toString(invariant char *s)
-// {
-//     return s ? cast(string) s[0 .. strlen(s)] : cast(string)null;
-// }
-
-string toString(const char *s)
-{
-    return s ? s[0 .. strlen(s)].idup : cast(string)null;
-}
-
-unittest
-{
-    debug(string) printf("string.toString(char*).unittest\n");
-
-    string r;
-    int i;
-
-    r = toString(null);
+    r = to!string(cast(char*) null);
     i = cmp(r, "");
     assert(i == 0);
 
-    r = toString("foo\0");
-    i = cmp(r, "foo");
-    assert(i == 0);
+    r = to!string("foo\0".ptr);
+    assert(r == "foo");
+    // i = cmp(r, "foo");
+    // assert(i == 0);
 }
 
 
@@ -3029,14 +2677,13 @@
  * Format arguments into a string.
  */
 
-
 string format(...)
 {
     char[] s;
 
     void putc(dchar c)
     {
-    std.utf.encode(s, c);
+        std.utf.encode(s, c);
     }
 
     std.format.doFormat(&putc, _arguments, _argptr);
@@ -3075,7 +2722,6 @@
     return s[0 .. i];
 }
 
-
 unittest
 {
     debug(string) printf("std.string.format.unittest\n");
@@ -3244,7 +2890,7 @@
 
     foreach (dchar c; s)
     {
-    count += inPattern(c, pattern);
+        count += inPattern(c, pattern);
     }
     return count;
 }
@@ -3275,22 +2921,19 @@
     //writefln("removechars(%s, %s)", s, pattern);
     foreach (size_t i, dchar c; s)
     {
-    if (!inPattern(c, pattern))
-    {
+        if (inPattern(c, pattern)) continue;
         if (!changed)
         {   changed = true;
-        r = s[0 .. i].dup;
+            r = s[0 .. i].dup;
         }
         if (changed)
         {
-        std.utf.encode(r, c);
+            std.utf.encode(r, c);
         }
     }
-    }
     return assumeUnique(r);
 }
 
-
 unittest
 {
     debug(string) printf("std.string.removechars.unittest\n");
@@ -3543,87 +3186,87 @@
     dchar lastc;
 
     foreach (dchar c; str)
-    {	dchar lastf;
-	dchar lastt;
-	dchar newc;
-	ptrdiff_t n = 0;
-
-	for (size_t i = 0; i < from.length; )
-	{
-	    dchar f = std.utf.decode(from, i);
-	    //writefln("\tf = '%s', c = '%s', lastf = '%x', '%x', i = %d, %d", f, c, lastf, dchar.init, i, from.length);
-	    if (f == '-' && lastf != dchar.init && i < from.length)
-	    {
-		dchar nextf = std.utf.decode(from, i);
-		//writefln("\tlastf = '%s', c = '%s', nextf = '%s'", lastf, c, nextf);
-		if (lastf <= c && c <= nextf)
-		{
-		    n += c - lastf - 1;
-		    if (mod_c)
-			goto Lnotfound;
-		    goto Lfound;
-		}
-		n += nextf - lastf;
-		lastf = lastf.init;
-		continue;
-	    }
-
-	    if (c == f)
-	    {	if (mod_c)
-		    goto Lnotfound;
-		goto Lfound;
-	    }
-	    lastf = f;
-	    n++;
-	}
-	if (!mod_c)
-	    goto Lnotfound;
-	n = 0;			// consider it 'found' at position 0
+    {   dchar lastf;
+    dchar lastt;
+    dchar newc;
+    int n = 0;
+
+    for (size_t i = 0; i < from.length; )
+    {
+        dchar f = std.utf.decode(from, i);
+        //writefln("\tf = '%s', c = '%s', lastf = '%x', '%x', i = %d, %d", f, c, lastf, dchar.init, i, from.length);
+        if (f == '-' && lastf != dchar.init && i < from.length)
+        {
+        dchar nextf = std.utf.decode(from, i);
+        //writefln("\tlastf = '%s', c = '%s', nextf = '%s'", lastf, c, nextf);
+        if (lastf <= c && c <= nextf)
+        {
+            n += c - lastf - 1;
+            if (mod_c)
+            goto Lnotfound;
+            goto Lfound;
+        }
+        n += nextf - lastf;
+        lastf = lastf.init;
+        continue;
+        }
+
+        if (c == f)
+        {   if (mod_c)
+            goto Lnotfound;
+        goto Lfound;
+        }
+        lastf = f;
+        n++;
+    }
+    if (!mod_c)
+        goto Lnotfound;
+    n = 0;          // consider it 'found' at position 0
 
     Lfound:
 
-	// Find the nth character in to[]
-	//writefln("\tc = '%s', n = %d", c, n);
-	dchar nextt;
-	for (size_t i = 0; i < to.length; )
-	{   dchar t = std.utf.decode(to, i);
-	    if (t == '-' && lastt != dchar.init && i < to.length)
-	    {
-		nextt = std.utf.decode(to, i);
-		//writefln("\tlastt = '%s', c = '%s', nextt = '%s', n = %d", lastt, c, nextt, n);
-		n -= nextt - lastt;
-		if (n < 0)
-		{
-		    newc = nextt + n + 1;
-		    goto Lnewc;
-		}
-		lastt = dchar.init;
-		continue;
-	    }
-	    if (n == 0)
-	    {	newc = t;
-		goto Lnewc;
-	    }
-	    lastt = t;
-	    nextt = t;
-	    n--;
-	}
-	if (mod_d)
-	    continue;
-	newc = nextt;
+    // Find the nth character in to[]
+    //writefln("\tc = '%s', n = %d", c, n);
+    dchar nextt;
+    for (size_t i = 0; i < to.length; )
+    {   dchar t = std.utf.decode(to, i);
+        if (t == '-' && lastt != dchar.init && i < to.length)
+        {
+        nextt = std.utf.decode(to, i);
+        //writefln("\tlastt = '%s', c = '%s', nextt = '%s', n = %d", lastt, c, nextt, n);
+        n -= nextt - lastt;
+        if (n < 0)
+        {
+            newc = nextt + n + 1;
+            goto Lnewc;
+        }
+        lastt = dchar.init;
+        continue;
+        }
+        if (n == 0)
+        {   newc = t;
+        goto Lnewc;
+        }
+        lastt = t;
+        nextt = t;
+        n--;
+    }
+    if (mod_d)
+        continue;
+    newc = nextt;
 
       Lnewc:
-	if (mod_s && m && newc == lastc)
-	    continue;
-	std.utf.encode(result, newc);
-	m = 1;
-	lastc = newc;
-	continue;
+    if (mod_s && m && newc == lastc)
+        continue;
+    std.utf.encode(result, newc);
+    m = 1;
+    lastc = newc;
+    continue;
 
       Lnotfound:
-	std.utf.encode(result, c);
-	lastc = c;
-	m = 0;
+    std.utf.encode(result, c);
+    lastc = c;
+    m = 0;
     }
     return assumeUnique(result);
 }
@@ -3719,7 +3362,7 @@
 
 final bool isNumeric(string s, in bool bAllowSep = false)
 {
-    ptrdiff_t iLen = s.length;
+    int    iLen = s.length;
     bool   bDecimalPoint = false;
     bool   bExponent = false;
     bool   bComplex = false;
@@ -3731,32 +3374,32 @@
     // Empty string, return false
     if (iLen == 0)
         return false;
-    
+
     // Check for NaN (Not a Number)
     if (sx == "nan" || sx == "nani" || sx == "nan+nani")
         return true;
-        
+
     // Check for Infinity
     if (sx == "inf" || sx == "-inf")
         return true;
-     
-    // A sign is allowed only in the 1st character   
+
+    // A sign is allowed only in the 1st character
     if (sx[0] == '-' || sx[0] == '+')
         j++;
-            
-    for (ptrdiff_t i = j; i < iLen; i++)
+
+    for (int i = j; i < iLen; i++)
     {
         c = sx[i];
-    
-        // Digits are good, continue checking 
-        // with the next character... ;)
-        if (c >= '0' && c <= '9') 
+
+        // Digits are good, continue checking
+        // with the popFront character... ;)
+        if (c >= '0' && c <= '9')
             continue;
 
-        // Check for the complex type, and if found 
-        // reset the flags for checking the 2nd number.  
+        // Check for the complex type, and if found
+        // reset the flags for checking the 2nd number.
         else if (c == '+')
-            if (i > 0) 
+            if (i > 0)
             {
                 bDecimalPoint = false;
                 bExponent = false;
@@ -3981,9 +3624,9 @@
     assert(isNumeric("123f") == true);
     assert(isNumeric("123.u") == false);
 
-    assert(isNumeric(std.string.toString(real.nan)) == true);
-    assert(isNumeric(std.string.toString(-real.infinity)) == true);
-    assert(isNumeric(std.string.toString(123e+2+1234.78Li)) == true);
+    assert(isNumeric(to!string(real.nan)) == true);
+    assert(isNumeric(to!string(-real.infinity)) == true);
+    assert(isNumeric(to!string(123e+2+1234.78Li)) == true);
 
     s = "$250.99-";
     assert(isNumeric(s[1..s.length - 2]) == true);
@@ -4252,29 +3895,29 @@
  * leftmost column, which is numbered starting from 0.
  */
 
-size_t column(string str, ptrdiff_t tabsize = 8)
+size_t column(string str, int tabsize = 8)
 {
     size_t column;
 
     foreach (dchar c; str)
     {
-    switch (c)
-    {
+        switch (c)
+        {
         case '\t':
-        column = (column + tabsize) / tabsize * tabsize;
-        break;
+            column = (column + tabsize) / tabsize * tabsize;
+            break;
 
         case '\r':
         case '\n':
         case PS:
         case LS:
-        column = 0;
-        break;
+            column = 0;
+            break;
 
         default:
-        column++;
-        break;
-    }
+            column++;
+            break;
+        }
     }
     return column;
 }
@@ -4308,12 +3951,12 @@
  *  The resulting paragraph.
  */
 
-string wrap(string s, ptrdiff_t columns = 80, string firstindent = null,
-	string indent = null, ptrdiff_t tabsize = 8)
+string wrap(string s, int columns = 80, string firstindent = null,
+    string indent = null, int tabsize = 8)
 {
     char[] result;
-    ptrdiff_t col;
-    ptrdiff_t spaces;
+    int col;
+    int spaces;
     bool inword;
     bool first = true;
     size_t wordstart;
@@ -4388,138 +4031,3 @@
     assert(wrap("x") == "x\n");
     assert(wrap("u u") == "u u\n");
 }
-
-
-/***************************
- * Does string s[] start with an email address?
- *
- * Deprecated: use std.uri.emailLength
- */
-deprecated string isEmail(string s)
-{   size_t i;
-
-    if (!isalpha(s[0]))
-    goto Lno;
-
-    for (i = 1; 1; i++)
-    {
-    if (i == s.length)
-        goto Lno;
-    auto c = s[i];
-    if (isalnum(c))
-        continue;
-    if (c == '-' || c == '_' || c == '.')
-        continue;
-    if (c != '@')
-        goto Lno;
-    i++;
-    break;
-    }
-    //writefln("test1 '%s'", s[0 .. i]);
-
-    /* Now do the part past the '@'
-     */
-    size_t lastdot;
-    for (; i < s.length; i++)
-    {
-    auto c = s[i];
-    if (isalnum(c))
-        continue;
-    if (c == '-' || c == '_')
-        continue;
-    if (c == '.')
-    {
-        lastdot = i;
-        continue;
-    }
-    break;
-    }
-    if (!lastdot || (i - lastdot != 3 && i - lastdot != 4))
-    goto Lno;
-
-    return s[0 .. i];
-
-Lno:
-    return null;
-}
-
-
-/***************************
- * Does string s[] start with a URL?
- *
- * Deprecated: use std.uri.uriLength
- */
-
-deprecated string isURL(string s)
-{
-    /* Must start with one of:
-     *  http://
-     *  https://
-     *  www.
-     */
-
-    size_t i;
-
-    if (s.length <= 4)
-    goto Lno;
-
-    //writefln("isURL(%s)", s);
-    if (s.length > 7 && std.string.icmp(s[0 .. 7], "http://") == 0)
-    i = 7;
-    else if (s.length > 8 && std.string.icmp(s[0 .. 8], "https://") == 0)
-    i = 8;
-//    if (icmp(s[0 .. 4], "www.") == 0)
-//  i = 4;
-    else
-    goto Lno;
-
-    size_t lastdot;
-    for (; i < s.length; i++)
-    {
-    auto c = s[i];
-    if (isalnum(c))
-        continue;
-    if (c == '-' || c == '_' || c == '?' ||
-        c == '=' || c == '%' || c == '&' ||
-        c == '/' || c == '+' || c == '#' ||
-        c == '~' || c == '$')
-        continue;
-    if (c == '.')
-    {
-        lastdot = i;
-        continue;
-    }
-    break;
-    }
-    //if (!lastdot || (i - lastdot != 3 && i - lastdot != 4))
-    if (!lastdot)
-    goto Lno;
-
-    return s[0 .. i];
-
-Lno:
-    return null;
-}
-
-// Undocumented yet
-
-private S textImpl(S, T...)(T args)
-{
-    S result;
-    foreach (arg; args)
-    {
-        result ~= to!(S)(arg);
-    }
-    return result;
-}
-
-string text(T...)(T args) { return textImpl!(string, T)(args); }
-wstring wtext(T...)(T args) { return textImpl!(wstring, T)(args); }
-dstring dtext(T...)(T args) { return textImpl!(dstring, T)(args); }
-
-unittest
-{
-    assert(text(42, ' ', 1.5, ": xyz") == "42 1.5: xyz");
-    assert(wtext(42, ' ', 1.5, ": xyz") == "42 1.5: xyz"w);
-    assert(dtext(42, ' ', 1.5, ": xyz") == "42 1.5: xyz"d);
-}
diff -r f12bfe124807 d/phobos2/std/system.d
--- a/d/phobos2/std/system.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/system.d	Thu Oct 14 14:12:53 2010 +0100
@@ -8,13 +8,6 @@
  *	WIKI = Phobos/StdSystem
  */
 
-/* NOTE: This file has been patched from the original DMD distribution to
-   work with the GDC compiler.
-
-   Modified by David Friedman, September 2007
-*/
-
-// Information about the target operating system, environment, and CPU
 
 module std.system;
 
@@ -26,8 +19,6 @@
     {
 	Win32 = 1,		// Microsoft 32 bit Windows systems
 	linux,			// all linux systems
-	Unix,			// Unix-like
-	NoSystem,		// No operating system
 	OSX,
     }
 
@@ -35,7 +26,7 @@
     {
 	Family family = Family.Win32;
     }
-    else version (linux)
+    else version (Posix)
     {
 	Family family = Family.linux;
     }
@@ -43,14 +34,6 @@
     {
 	Family family = Family.OSX;
     }
-    else version (Unix)
-    {
-	Family family = Family.Unix;
-    }	     
-    else version (NoSystem)
-    {
-	Family family = Family.NoSystem;
-    }
     else
     {
 	static assert(0);
diff -r f12bfe124807 d/phobos2/std/traits.d
--- a/d/phobos2/std/traits.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/traits.d	Thu Oct 14 14:12:53 2010 +0100
@@ -120,9 +120,9 @@
 template FieldTypeTuple(S)
 {
     static if (is(S == struct) || is(S == class) || is(S == union))
-	alias typeof(S.tupleof) FieldTypeTuple;
+        alias typeof(S.tupleof) FieldTypeTuple;
     else
-        alias S FieldTypeTuple;
+        alias TypeTuple!(S) FieldTypeTuple;
 	//static assert(0, "argument is not struct or class");
 }
 
@@ -771,42 +771,117 @@
 }
 
 /**
- * Detect whether T is a built-in integral type
+ * Detect whether T is a built-in integral type. Types $(D bool), $(D
+ * char), $(D wchar), and $(D dchar) are not considered integral.
  */
 
 template isIntegral(T)
 {
-    static const isIntegral = is(T == byte) || is(T == ubyte) || is(T == short)
-        || is(T == ushort) || is(T == int) || is(T == uint)
-        || is(T == long) || is(T == ulong);
+    enum bool isIntegral = indexOf!(Unqual!(T), byte,
+            ubyte, short, ushort, int, uint, long, ulong) >= 0;
+}
+
+unittest
+{
+    assert(isIntegral!(byte));
+    assert(isIntegral!(const(byte)));
+    assert(isIntegral!(immutable(byte)));
+    //assert(isIntegral!(shared(byte)));
+    //assert(isIntegral!(shared(const(byte))));
+
+    //assert(isIntegral!(ubyte));
+    //assert(isIntegral!(const(ubyte)));
+    //assert(isIntegral!(immutable(ubyte)));
+    //assert(isIntegral!(shared(ubyte)));
+    //assert(isIntegral!(shared(const(ubyte))));
+
+    //assert(isIntegral!(short));
+    //assert(isIntegral!(const(short)));
+    assert(isIntegral!(immutable(short)));
+    //assert(isIntegral!(shared(short)));
+    //assert(isIntegral!(shared(const(short))));
+
+    assert(isIntegral!(ushort));
+    assert(isIntegral!(const(ushort)));
+    assert(isIntegral!(immutable(ushort)));
+    //assert(isIntegral!(shared(ushort)));
+    //assert(isIntegral!(shared(const(ushort))));
+
+    assert(isIntegral!(int));
+    assert(isIntegral!(const(int)));
+    assert(isIntegral!(immutable(int)));
+    //assert(isIntegral!(shared(int)));
+    //assert(isIntegral!(shared(const(int))));
+
+    assert(isIntegral!(uint));
+    assert(isIntegral!(const(uint)));
+    assert(isIntegral!(immutable(uint)));
+    //assert(isIntegral!(shared(uint)));
+    //assert(isIntegral!(shared(const(uint))));
+
+    assert(isIntegral!(long));
+    assert(isIntegral!(const(long)));
+    assert(isIntegral!(immutable(long)));
+    //assert(isIntegral!(shared(long)));
+    //assert(isIntegral!(shared(const(long))));
+
+    assert(isIntegral!(ulong));
+    assert(isIntegral!(const(ulong)));
+    assert(isIntegral!(immutable(ulong)));
+    //assert(isIntegral!(shared(ulong)));
+    //assert(isIntegral!(shared(const(ulong))));
+
+    assert(!isIntegral!(float));
 }
 
 /**
- * Detect whether T is a built-in floating point type
+ * Detect whether T is a built-in floating point type.
  */
 
 template isFloatingPoint(T)
 {
-    static const isFloatingPoint = is(T == float)
-        || is(T == double) || is(T == real);
+    enum bool isFloatingPoint = indexOf!(Unqual!(T), float, double, real) >= 0;
+}
+
+unittest
+{
+    foreach (F; TypeTuple!(float, double, real))
+    {
+        F a = 5.5;
+        static assert(isFloatingPoint!(typeof(a)));
+        const F b = 5.5;
+        static assert(isFloatingPoint!(typeof(b)));
+        immutable F c = 5.5;
+        static assert(isFloatingPoint!(typeof(c)));
+    }
+    foreach (T; TypeTuple!(int, long, char))
+    {
+        T a;
+        static assert(!isFloatingPoint!(typeof(a)));
+        const T b = 0;
+        static assert(!isFloatingPoint!(typeof(b)));
+        immutable T c = 0;
+        static assert(!isFloatingPoint!(typeof(c)));
+    }
 }
 
 /**
- * Detect whether T is a built-in numeric type
+Detect whether T is a built-in numeric type (integral or floating
+point).
  */
 
 template isNumeric(T)
 {
-    static const isNumeric = isIntegral!(T) || isFloatingPoint!(T);
+    enum bool isNumeric = isIntegral!(T) || isFloatingPoint!(T);
 }
 
 /**
- * Detect whether T is one of the built-in string types
+Detect whether T is one of the built-in string types
  */
 
 template isSomeString(T)
 {
-    static const isSomeString = is(T : const(char[]))
+    enum isSomeString = is(T : const(char[]))
         || is(T : const(wchar[])) || is(T : const(dchar[]));
 }
 
@@ -826,7 +901,7 @@
 
 template isAssociativeArray(T)
 {
-    static const bool isAssociativeArray =
+    enum bool isAssociativeArray =
         is(typeof(T.keys)) && is(typeof(T.values));
 }
 
@@ -841,12 +916,12 @@
  */
 template isStaticArray(T : U[N], U, size_t N)
 {
-    const bool isStaticArray = true;
+    enum bool isStaticArray = true;
 }
 
 template isStaticArray(T)
 {
-    const bool isStaticArray = false;
+    enum bool isStaticArray = false;
 }
 
 static assert (isStaticArray!(int[51]));
@@ -871,12 +946,12 @@
  */
 template isDynamicArray(T, U = void)
 {
-    static const isDynamicArray = false;
+    enum bool isDynamicArray = false;
 }
 
 template isDynamicArray(T : U[], U)
 {
-  static const isDynamicArray = !isStaticArray!(T);
+  enum bool isDynamicArray = !isStaticArray!(T);
 }
 
 static assert(isDynamicArray!(int[]));
@@ -887,7 +962,7 @@
  */
 template isArray(T)
 {
-    static const isArray = isStaticArray!(T) || isDynamicArray!(T);
+    enum bool isArray = isStaticArray!(T) || isDynamicArray!(T);
 }
 
 static assert(isArray!(int[]));
@@ -903,9 +978,9 @@
 template isExpressionTuple(T ...)
 {
     static if (is(void function(T)))
-	const bool isExpressionTuple = false;
+	enum bool isExpressionTuple = false;
     else
-	const bool isExpressionTuple = true;
+	enum bool isExpressionTuple = true;
 }
 
 /**
@@ -913,50 +988,36 @@
  * integral type, otherwise a compile-time error occurs.
  */
 
-template unsigned(T) {
-    static if (is(T == byte)) alias ubyte unsigned;
-    else static if (is(T == short)) alias ushort unsigned;
-    else static if (is(T == int)) alias uint unsigned;
-    else static if (is(T == long)) alias ulong unsigned;
-    else static if (is(T == ubyte)) alias ubyte unsigned;
-    else static if (is(T == ushort)) alias ushort unsigned;
-    else static if (is(T == uint)) alias uint unsigned;
-    else static if (is(T == ulong)) alias ulong unsigned;
-    else static if (is(T == char)) alias char unsigned;
-    else static if (is(T == wchar)) alias wchar unsigned;
-    else static if (is(T == dchar)) alias dchar unsigned;
+template Unsigned(T) {
+    static if (is(T == byte)) alias ubyte Unsigned;
+    else static if (is(T == short)) alias ushort Unsigned;
+    else static if (is(T == int)) alias uint Unsigned;
+    else static if (is(T == long)) alias ulong Unsigned;
+    else static if (is(T == ubyte)) alias ubyte Unsigned;
+    else static if (is(T == ushort)) alias ushort Unsigned;
+    else static if (is(T == uint)) alias uint Unsigned;
+    else static if (is(T == ulong)) alias ulong Unsigned;
+    else static if (is(T == char)) alias char Unsigned;
+    else static if (is(T == wchar)) alias wchar Unsigned;
+    else static if (is(T == dchar)) alias dchar Unsigned;
     else static if(is(T == enum)) {
-        static if (T.sizeof == 1) alias ubyte unsigned;
-        else static if (T.sizeof == 2) alias ushort unsigned;
-        else static if (T.sizeof == 4) alias uint unsigned;
-        else static if (T.sizeof == 8) alias ulong unsigned;
+        static if (T.sizeof == 1) alias ubyte Unsigned;
+        else static if (T.sizeof == 2) alias ushort Unsigned;
+        else static if (T.sizeof == 4) alias uint Unsigned;
+        else static if (T.sizeof == 8) alias ulong Unsigned;
         else static assert(false, "Type " ~ T.stringof
-                           ~ " does not have an unsigned counterpart");
+                           ~ " does not have an Unsigned counterpart");
     }
     else static assert(false, "Type " ~ T.stringof
-                       ~ " does not have an unsigned counterpart");
+                       ~ " does not have an Unsigned counterpart");
 }
 
 unittest
 {
-    alias unsigned!(int) U;
+    alias Unsigned!(int) U;
     assert(is(U == uint));
 }
 
-/******
- * Returns the mutable version of the type T.
- */
-
-template Mutable(T)
-{
-    static if (is(T U == const(U)))
-	alias U Mutable;
-    else static if (is(T U == invariant(U)))
-	alias U Mutable;
-    else
-	alias T Mutable;
-}
-
 /**
 Returns the most negative value of the numeric type T.
 */
@@ -974,3 +1035,113 @@
     static assert(mostNegative!(uint) == 0);
     static assert(mostNegative!(long) == long.min);
 }
+
+/**
+Removes all qualifiers, if any, from type $(D T).
+
+Example:
+----
+static assert(is(Unqual!(int) == int));
+static assert(is(Unqual!(const int) == int));
+static assert(is(Unqual!(immutable int) == int));
+----
+ */
+template Unqual(T) { alias T Unqual; }
+/// Ditto
+template Unqual(T : const(U), U) { alias U Unqual; }
+/// Ditto
+template Unqual(T : immutable(U), U) { alias U Unqual; }
+/// Ditto
+//template Unqual(T : shared(U), U) { alias U Unqual; }
+
+unittest
+{
+    static assert(is(Unqual!(int) == int));
+    static assert(is(Unqual!(const int) == int));
+    static assert(is(Unqual!(immutable int) == int));
+    alias immutable(int[]) ImmIntArr;
+    static assert(is(Unqual!(ImmIntArr) == immutable(int)[]));
+}
+
+/**
+Evaluates to $(D TypeTuple!(F[T[0]], F[T[1]], ..., F[T[$ - 1]])).
+
+Example:
+----
+alias staticMap!(Unqual, int, const int, immutable int) T;
+static assert(is(T == TypeTuple!(int, int, int)));
+----
+ */
+template staticMap(alias F, T...)
+{
+    static if (T.length == 1)
+    {
+        alias F!(T[0]) staticMap;
+    }
+    else
+    {
+        alias TypeTuple!(F!(T[0]), staticMap!(F, T[1 .. $])) staticMap;
+    }
+}
+
+unittest
+{
+    alias staticMap!(Unqual, int, const int, immutable int) T;
+    static assert(is(T == TypeTuple!(int, int, int)));
+}
+
+/**
+Evaluates to $(D F[T[0]] && F[T[1]] && ... && F[T[$ - 1]]).
+
+Example:
+----
+static assert(!allSatisfy!(isIntegral, int, double));
+static assert(allSatisfy!(isIntegral, int, long));
+----
+ */
+template allSatisfy(alias F, T...)
+{
+    static if (T.length == 1)
+    {
+        alias F!(T[0]) allSatisfy;
+    }
+    else
+    {
+        enum bool allSatisfy = F!(T[0]) && allSatisfy!(F, T[1 .. $]);
+    }
+}
+
+unittest
+{
+    static assert(!allSatisfy!(isIntegral, int, double));
+    static assert(allSatisfy!(isIntegral, int, long));
+}
+
+/**
+Aliases itself to $(D T) if the boolean $(D condition) is $(D true)
+and to $(D F) otherwise.
+
+Example:
+----
+alias Select!(size_t.sizeof == 4, int, long) Int;
+----
+ */
+template Select(bool condition, T, F)
+{
+    static if (condition) alias T Select;
+    else alias F Select;
+}
+
+unittest
+{
+    static assert(is(Select!(true, int, long) == int));
+    static assert(is(Select!(false, int, long) == long));
+}
+
+/**
+If $(D cond) is $(D true), returns $(D a) without evaluating $(D
+b). Otherwise, returns $(D b) without evaluating $(D a).
+ */
+A select(bool cond : true, A, B)(A a, lazy B b) { return a; }
+/// Ditto
+B select(bool cond : false, A, B)(lazy A a, B b) { return b; }
diff -r f12bfe124807 d/phobos2/std/typecons.d
--- a/d/phobos2/std/typecons.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/typecons.d	Thu Oct 14 14:12:53 2010 +0100
@@ -14,8 +14,7 @@
 // value tuples
 alias Tuple!(float, "x", float, "y", float, "z") Coord;
 Coord c;
-c._0 = 1;         // access by index-based name
-c.field!(1) = 1;  // access by index
+c.field[1] = 1;   // access by index
 c.z = 1;          // access by given name
 alias Tuple!(string, string) DicEntry; // names can be omitted
 
@@ -73,12 +72,7 @@
  */
 
 module std.typecons;
-private import std.stdio;
-private import std.metastrings;
-private import std.contracts;
-private import std.typetuple;
-private import std.conv;
-private import std.traits;
+import std.array, std.contracts, std.conv, std.metastrings, std.traits;
 
 /**
 Encapsulates unique ownership of a resource. 
@@ -245,41 +239,49 @@
     assert(uf.isEmpty);
     assert(!uf2.isEmpty);
 }
-++/
++/
 
-private template tupleImpl(uint index, T...)
+private template tupleFields(uint index, T...)
 {
     static if (!T.length)
     {
-        enum string result = "";
+        enum string tupleFields = "";
     }
     else
     {
-        enum string indexStr = ToString!(index);
-        enum string decl = T[0].stringof~" _"~indexStr~";"
-            ~"\ntemplate field(int i : "~indexStr~") { alias _"~indexStr
-            ~" field; }\n";
         static if (is(typeof(T[1]) : string))
         {
-            enum string result = decl ~ "alias _" ~ ToString!(index) ~ " "
-                ~ T[1] ~ ";\n" ~ tupleImpl!(index + 1, T[2 .. $]).result;
+            enum string tupleFields = "Types["~ToString!(index)~"] "~T[1]~"; "
+                ~ tupleFields!(index + 1, T[2 .. $]);
         }
         else
         {
-            enum string result = decl ~ tupleImpl!(index + 1, T[1 .. $]).result;
+            enum string tupleFields = "Types["~ToString!(index)~"] _"
+                ~ToString!(index)~"; "
+                ~ tupleFields!(index + 1, T[1 .. $]);
         }
     }
 }
 
+// Tuple
+private template noStrings(T...)
+{
+    template A(U...) { alias U A; }
+    static if (T.length == 0)
+        alias A!() Result;
+    else static if (is(typeof(T[0]) : string))
+        alias noStrings!(T[1 .. $]).Result Result;
+    else
+        alias A!(T[0], noStrings!(T[1 .. $]).Result) Result;
+}
+
 /**
-Tuple of values, for example $(D_PARAM Tuple!(int, string)) is a
-record that stores an $(D_PARAM int) and a $(D_PARAM
-string). $(D_PARAM Tuple) can be used to bundle values together,
-notably when returning multiple values from a function. If $(D_PARAM
-obj) is a tuple, the individual members are accessible with the syntax
-$(D_PARAM obj.field!(0)) for the first field, $(D_PARAM obj.field!(1))
-for the second, and so on. A shortcut notation is $(D_PARAM
-obj.)&#95;$(D_PARAM 0), $(D_PARAM obj.)&#95;$(D_PARAM 1) etc.
+Tuple of values, for example $(D Tuple!(int, string)) is a record that
+stores an $(D int) and a $(D string). $(D Tuple) can be used to bundle
+values together, notably when returning multiple values from a
+function. If $(D obj) is a tuple, the individual members are
+accessible with the syntax $(D obj.field[0]) for the first field, $(D
+obj.field[1]) for the second, and so on.
 
 The choice of zero-based indexing instead of one-base indexing was
 motivated by the ability to use value tuples with various compile-time
@@ -291,11 +293,11 @@
 ----
 Tuple!(int, int) point;
 // assign coordinates
-point._0 = 5;
-point.field!(1) = 6;
+point.field[0] = 5;
+point.field[1] = 6;
 // read coordinates
-auto x = point.field!(0);
-auto y = point._1;
+auto x = point.field[0];
+auto y = point.[1];
 ----
 
 Tuple members can be named. It is legal to mix named and unnamed
@@ -308,8 +310,8 @@
 Entry e;
 e.index = 4;
 e.value = "Hello";
-assert(e._1 == "Hello");
-assert(e.field!(0) == 4);
+assert(e.field[1] == "Hello");
+assert(e.field[0] == 4);
 ----
 
 Tuples with named fields are distinct types from tuples with unnamed
@@ -327,34 +329,162 @@
 */
 struct Tuple(T...)
 {
-    mixin(tupleImpl!(0, T).result);
+public:
+/**
+   The type of the tuple's components.
+*/
+    alias noStrings!(T).Result Types;
+    union
+    {
+        Types field;
+        mixin(tupleFields!(0, T));
+    }
+    // @@@BUG 2800
+    //alias field this;
+/**
+   Constructor taking one value for each field. Each argument must be
+   implicitly assignable to the respective element of the target.
+ */
+    this(U...)(U values) if (U.length == Types.length)
+    {
+        foreach (i, Unused; Types)
+        {
+            field[i] = values[i];
+        }
+    }
+
+/**
+   Constructor taking a compatible tuple. Each element of the source
+   must be implicitly assignable to the respective element of the
+   target.
+ */
+    // @@@BUG@@@
+    //this(U)(Tuple!(U) another)
+    this(U)(U another)
+    {
+        static assert(U.Types.length == Types.length);
+        foreach (i, Unused; Types)
+        {
+            field[i] = another.field[i];
+        }
+    }
+
+/**
+   Comparison for equality.
+ */
+    bool opEquals(T)(T rhs)
+    {
+        static assert(field.length == rhs.field.length,
+                "Length mismatch in attempting to compare a "
+                ~typeof(this).stringof
+                ~" with a "~typeof(rhs).stringof);
+        foreach (i, f; field)
+        {
+            if (f != rhs.field[i]) return false;
+        }
+        return true;
+    }
+
+/**
+   Assignment from another tuple. Each element of the source must be
+   implicitly assignable to the respective element of the target.
+ */
+    void opAssign(U)(U rhs)
+    {
+        foreach (i, Unused; noStrings!(T).Result)
+        {
+            field[i] = rhs.field[i];
+        }
+    }
+/**
+   Takes a slice of the tuple.
+
+   Example:
+
+----
+Tuple!(int, string, float, double) a;
+a.field[1] = "abc";
+a.field[2] = 4.5;
+auto s = a.slice!(1, 3);
+static assert(is(typeof(s) == Tuple!(string, float)));
+assert(s.field[0] == "abc" && s.field[1] == 4.5);
+----
+ */
+    ref Tuple!(Types[from .. to]) slice(uint from, uint to)()
+    {
+        return *cast(typeof(return) *) &(field[from]);
+    }
+
+    unittest
+    {
+        .Tuple!(int, string, float, double) a;
+        a.field[1] = "abc";
+        a.field[2] = 4.5;
+        auto s = a.slice!(1, 3);
+        static assert(is(typeof(s) == Tuple!(string, float)));
+        assert(s.field[0] == "abc" && s.field[1] == 4.5);
+    }
+
+    static string toStringHeader = Tuple.stringof ~ "(";
+    static string toStringFooter = ")";
+    static string toStringSeparator = ", ";
+
+/**
+   Converts to string.
+ */
     string toString()
     {
-        string result;
-        foreach (i, Type; FieldTypeTuple!(Tuple))
+        char[] result;
+        auto app = appender(&result);
+        app.put(toStringHeader);
+        foreach (i, Unused; noStrings!(T).Result)
         {
-            static if (i > 0) result ~= " ";
-            static if (is(typeof(to!(string)(*new Type))))
-            {
-                result ~= mixin("to!(string)(field!("~ToString!(i)~"))");
-            }
+            static if (i > 0) result ~= toStringSeparator;
+            static if (is(typeof(to!string(field[i]))))
+                app.put(to!string(field[i]));
             else
-            {
-                result ~= "unprintable("~Type.stringof~")";
-            }
+                app.put(typeof(field[i]).stringof); 
         }
-        return result;
+        app.put(toStringFooter);
+        return assumeUnique(result);
     }
 }
 
 unittest
 {
-    Tuple!(int, "a", int, "b") nosh;
-    nosh.a = 5;
-    assert(nosh._0 == 5);
-    assert(nosh.field!(0) == 5);
-    Tuple!(int, int, "b") nosh1;
-    assert(!is(typeof(nosh) == typeof(nosh1)));
+    {
+        Tuple!(int, "a", int, "b") nosh;
+        nosh.a = 5;
+        nosh.b = 6;
+        assert(nosh.a == 5);
+        assert(nosh.b == 6);
+    }
+    {
+        Tuple!(short, double) b;
+        b.field[1] = 5;
+        auto a = Tuple!(int, float)(b);
+        assert(a.field[0] == 0 && a.field[1] == 5);
+        a = Tuple!(int, float)(1, 2);
+        assert(a.field[0] == 1 && a.field[1] == 2);
+        auto c = Tuple!(int, "a", double, "b")(a);
+        assert(c.field[0] == 1 && c.field[1] == 2);
+    }
+    Tuple!(int, int) nosh;
+    nosh.field[0] = 5;
+    assert(nosh.field[0] == 5);
+    // Tuple!(int, int) nosh1;
+    // assert(!is(typeof(nosh) == typeof(nosh1)));
+    assert(nosh.toString == "Tuple!(int,int)(5, 0)", nosh.toString);
+    Tuple!(int, short) yessh;
+    nosh = yessh;
+
+    Tuple!(int, "a", float, "b") x;
+    static assert(x.a.offsetof == x.field[0].offsetof);
+    static assert(x.b.offsetof == x.field[1].offsetof);
+    x.b = 4.5;
+    x.a = 5;
+    assert(x.field[0] == 5 && x.field[1] == 4.5);
+    assert(x.a == 5 && x.b == 4.5);
 }
 
 /**
@@ -364,21 +494,16 @@
 Example:
 ----
 auto value = tuple(5, 6.7, "hello");
-assert(value._0 == 5);
-assert(value._1 == 6.7);
-assert(value._2 == "hello");
+assert(value.field[0] == 5);
+assert(value.field[1] == 6.7);
+assert(value.field[2] == "hello");
 ----
 */
 
 Tuple!(T) tuple(T...)(T args)
 {
     typeof(return) result;
-    foreach (i, U; T)
-    {
-        // @@@BUG@@@ in the compiler
-        // This should work: result.field!(i) = args[i];
-        mixin("result.field!("~ToString!(i)~") = args[i];");
-    }
+    static if (T.length > 0) result.field = args;
     return result;
 }
 
@@ -487,8 +612,8 @@
 Abc enumFromString(string s) { ... }
 ----
 
-The $(D_PARAM enumToString) function generates the unqualified names
-of the enumerated values, i.e. "A", "B", and "C". The $(D_PARAM
+The $(D enumToString) function generates the unqualified names
+of the enumerated values, i.e. "A", "B", and "C". The $(D
 enumFromString) function expects one of "A", "B", and "C", and throws
 an exception in any other case.
 
@@ -498,9 +623,8 @@
 mixin(defineEnum!("Abc", ubyte, "A", "B", "C", 255));
 ----
 
-In this case the generated $(D_PARAM enum) will have a $(D_PARAM
-ubyte) representation.
-*/
+In this case the generated $(D enum) will have a $(D ubyte)
+representation.  */
 
 template defineEnum(string name, T...)
 {
@@ -558,12 +682,16 @@
 risks usually associated with $(D cast).
 
  */
-template Rebindable(T : Object)
+template Rebindable(T) if (is(T : Object) || isArray!(T))
 {
     static if (!is(T X == const(U), U) && !is(T X == invariant(U), U))
     {
         alias T Rebindable;
     }
+    else static if (isArray!(T))
+    {
+        alias const(ElementType!(T))[] Rebindable;
+    }
     else
     {
         struct Rebindable
@@ -615,7 +743,6 @@
     assert(obj2.foo == 42);
 }
 
-
 /**
   Order the provided members to minimize size while preserving alignment.
   Returns a declaration to be mixed in.
@@ -665,3 +792,35 @@
     struct Foo{ int x; }
     assert(alignForSize!(ubyte, Foo, cdouble)(["x", "y","z"]) =="cdouble z;\nFoo y;\nubyte x;\n");    
 }
+
+/*--*
+First-class reference type
+*/
+struct Ref(T)
+{
+    private T * _p;
+    this(ref T value) { _p = &value; }
+    ref T opDot() { return *_p; }
+    /*ref*/ T opImplicitCastTo() { return *_p; }
+    ref T value() { return *_p; }
+    
+    void opAssign(T value)
+    {
+        *_p = value;
+    }
+    void opAssign(T * value)
+    {
+        _p = value;
+    }
+}
+
+unittest
+{
+    Ref!(int) x;
+    int y = 42;
+    x = &y;
+    assert(x.value == 42);
+    x = 5;
+    assert(x.value == 5);
+    assert(y == 5);
+}
diff -r f12bfe124807 d/phobos2/std/typetuple.d
--- a/d/phobos2/std/typetuple.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/typetuple.d	Thu Oct 14 14:12:53 2010 +0100
@@ -71,14 +71,14 @@
 template indexOf(T, TList...)
 {
     static if (TList.length == 0)
-	const int indexOf = -1;
+        enum int indexOf = -1;
     else static if (is(T == TList[0]))
-	const int indexOf = 0;
+        enum int indexOf = 0;
     else
-	const int indexOf =
-		(indexOf!(T, TList[1 .. length]) == -1)
-			? -1
-			: 1 + indexOf!(T, TList[1 .. length]);
+        enum int indexOf =
+            (indexOf!(T, TList[1 .. length]) == -1)
+            ? -1
+            : 1 + indexOf!(T, TList[1 .. length]);
 }
 
 /// Kept for backwards compatibility
@@ -257,3 +257,4 @@
 						    TList[0],
 						    TList[1 .. length]))) DerivedToFront;
 }
+
diff -r f12bfe124807 d/phobos2/std/uni.d
--- a/d/phobos2/std/uni.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/uni.d	Thu Oct 14 14:12:53 2010 +0100
@@ -29,7 +29,7 @@
 int isUniLower(dchar c)
 {
     if (c <= 0x7F)
-	return (c >= 'a' && c <= 'z');
+        return (c >= 'a' && c <= 'z');
 
     return isUniAlpha(c) && c == toUniLower(c);
 }
@@ -550,29 +550,29 @@
 
     debug
     {
-	for (int i = 0; i < table.length; i++)
-	{
-	    assert(table[i][0] <= table[i][1]);
-	    if (i < table.length - 1)
-	    {
-		if (table[i][1] >= table[i + 1][0])
-		    printf("table[%d][1] = x%x, table[%d][0] = x%x\n", i, table[i][1], i + 1, table[i + 1][0]);
-		assert(table[i][1] < table[i + 1][0]);
-	    }
-	}
+        for (int i = 0; i < table.length; i++)
+        {
+            assert(table[i][0] <= table[i][1]);
+            if (i < table.length - 1)
+            {
+                //if (table[i][1] >= table[i + 1][0])
+                //printf("table[%d][1] = x%x, table[%d][0] = x%x\n", i, table[i][1], i + 1, table[i + 1][0]);
+                assert(table[i][1] < table[i + 1][0]);
+            }
+        }
     }
-
+    
     if (u < 0xAA)
     {
-	if (u < 'A')
-	    goto Lisnot;
-	if (u <= 'Z')
-	    goto Lis;
-	if (u < 'a')
-	    goto Lisnot;
-	if (u <= 'z')
-	    goto Lis;
-	goto Lisnot;
+        if (u < 'A')
+            goto Lisnot;
+        if (u <= 'Z')
+            goto Lis;
+        if (u < 'a')
+            goto Lisnot;
+        if (u <= 'z')
+            goto Lis;
+        goto Lisnot;
     }
 
     // Binary search
diff -r f12bfe124807 d/phobos2/std/uri.d
--- a/d/phobos2/std/uri.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/uri.d	Thu Oct 14 14:12:53 2010 +0100
@@ -76,16 +76,17 @@
     // Initialize uri_flags[]
 
     static void helper(invariant char[] p, uint flags)
-    {
-	foreach (c; p)
-	    uri_flags[c] |= flags;
+    {   int i;
+
+    for (i = 0; i < p.length; i++)
+        uri_flags[p[i]] |= flags;
     }
 
     uri_flags['#'] |= URI_Hash;
 
     for (int i = 'A'; i <= 'Z'; i++)
     {   uri_flags[i] |= URI_Alpha;
-        uri_flags[i + 0x20] |= URI_Alpha;   // lowercase letters
+    uri_flags[i + 0x20] |= URI_Alpha;   // lowercase letters
     }
     helper("0123456789", URI_Digit);
     helper(";/?:@&=+$,", URI_Reserved);
@@ -94,17 +95,17 @@
 
 
 private string URI_Encode(dstring string, uint unescapedSet)
-{   size_t len;
-    size_t j;
-    size_t k;
+{   uint len;
+    uint j;
+    uint k;
     dchar V;
     dchar C;
 
     // result buffer
     char[50] buffer = void;
     char* R;
-    size_t Rlen;
-    size_t Rsize; // alloc'd size
+    uint Rlen;
+    uint Rsize; // alloc'd size
 
     len = string.length;
 
@@ -233,9 +234,9 @@
 }
 
 private dstring URI_Decode(string string, uint reservedSet)
-{   size_t len;
+{   uint len;
     uint j;
-    size_t k;
+    uint k;
     uint V;
     dchar C;
 
@@ -243,8 +244,8 @@
 
     // Result array, allocated on stack
     dchar* R;
-    size_t Rlen;
-    size_t Rsize;	// alloc'd size
+    uint Rlen;
+    uint Rsize; // alloc'd size
 
     len = string.length;
     auto s = string.ptr;
@@ -252,87 +253,87 @@
     // Preallocate result buffer R guaranteed to be large enough for result
     Rsize = len;
     if (Rsize > 1024 / dchar.sizeof)
-	R = (new dchar[Rsize]).ptr;
+    R = (new dchar[Rsize]).ptr;
     else
-    {	R = cast(dchar *)alloca(Rsize * dchar.sizeof);
-	if (!R)
-	    goto LthrowURIerror;
+    {   R = cast(dchar *)alloca(Rsize * dchar.sizeof);
+    if (!R)
+        goto LthrowURIerror;
     }
     Rlen = 0;
 
     for (k = 0; k != len; k++)
-    {	char B;
-	size_t start;
+    {   char B;
+    uint start;
 
-	C = s[k];
-	if (C != '%')
-	{   R[Rlen] = C;
-	    Rlen++;
-	    continue;
-	}
-	start = k;
-	if (k + 2 >= len)
-	    goto LthrowURIerror;
-	if (!isxdigit(s[k + 1]) || !isxdigit(s[k + 2]))
-	    goto LthrowURIerror;
-	B = cast(char)((ascii2hex(s[k + 1]) << 4) + ascii2hex(s[k + 2]));
-	k += 2;
-	if ((B & 0x80) == 0)
-	{
-	    C = B;
-	}
-	else
-	{   uint n;
+    C = s[k];
+    if (C != '%')
+    {   R[Rlen] = C;
+        Rlen++;
+        continue;
+    }
+    start = k;
+    if (k + 2 >= len)
+        goto LthrowURIerror;
+    if (!isxdigit(s[k + 1]) || !isxdigit(s[k + 2]))
+        goto LthrowURIerror;
+    B = cast(char)((ascii2hex(s[k + 1]) << 4) + ascii2hex(s[k + 2]));
+    k += 2;
+    if ((B & 0x80) == 0)
+    {
+        C = B;
+    }
+    else
+    {   uint n;
 
-	    for (n = 1; ; n++)
-	    {
-		if (n > 4)
-		    goto LthrowURIerror;
-		if (((B << n) & 0x80) == 0)
-		{
-		    if (n == 1)
-			goto LthrowURIerror;
-		    break;
-		}
-	    }
+        for (n = 1; ; n++)
+        {
+        if (n > 4)
+            goto LthrowURIerror;
+        if (((B << n) & 0x80) == 0)
+        {
+            if (n == 1)
+            goto LthrowURIerror;
+            break;
+        }
+        }
 
-	    // Pick off (7 - n) significant bits of B from first byte of octet
-	    V = B & ((1 << (7 - n)) - 1);	// (!!!)
+        // Pick off (7 - n) significant bits of B from first byte of octet
+        V = B & ((1 << (7 - n)) - 1);   // (!!!)
 
-	    if (k + (3 * (n - 1)) >= len)
-		goto LthrowURIerror;
-	    for (j = 1; j != n; j++)
-	    {
-		k++;
-		if (s[k] != '%')
-		    goto LthrowURIerror;
-		if (!isxdigit(s[k + 1]) || !isxdigit(s[k + 2]))
-		    goto LthrowURIerror;
-		B = cast(char)((ascii2hex(s[k + 1]) << 4) + ascii2hex(s[k + 2]));
-		if ((B & 0xC0) != 0x80)
-		    goto LthrowURIerror;
-		k += 2;
-		V = (V << 6) | (B & 0x3F);
-	    }
-	    if (V > 0x10FFFF)
-		goto LthrowURIerror;
-	    C = V;
-	}
-	if (C < uri_flags.length && uri_flags[C] & reservedSet)
-	{
-	    // R ~= s[start .. k + 1];
-	    int width = (k + 1) - start;
-	    for (int ii = 0; ii < width; ii++)
-		R[Rlen + ii] = s[start + ii];
-	    Rlen += width;
-	}
-	else
-	{
-	    R[Rlen] = C;
-	    Rlen++;
-	}
+        if (k + (3 * (n - 1)) >= len)
+        goto LthrowURIerror;
+        for (j = 1; j != n; j++)
+        {
+        k++;
+        if (s[k] != '%')
+            goto LthrowURIerror;
+        if (!isxdigit(s[k + 1]) || !isxdigit(s[k + 2]))
+            goto LthrowURIerror;
+        B = cast(char)((ascii2hex(s[k + 1]) << 4) + ascii2hex(s[k + 2]));
+        if ((B & 0xC0) != 0x80)
+            goto LthrowURIerror;
+        k += 2;
+        V = (V << 6) | (B & 0x3F);
+        }
+        if (V > 0x10FFFF)
+        goto LthrowURIerror;
+        C = V;
     }
-    assert(Rlen <= Rsize);	// enforce our preallocation size guarantee
+    if (C < uri_flags.length && uri_flags[C] & reservedSet)
+    {
+        // R ~= s[start .. k + 1];
+        int width = (k + 1) - start;
+        for (int ii = 0; ii < width; ii++)
+        R[Rlen + ii] = s[start + ii];
+        Rlen += width;
+    }
+    else
+    {
+        R[Rlen] = C;
+        Rlen++;
+    }
+    }
+    assert(Rlen <= Rsize);  // enforce our preallocation size guarantee
 
     // Copy array on stack to array in memory
     return R[0..Rlen].idup;
@@ -510,10 +511,10 @@
     string t = "http://www.digitalmars.com/~fred/fred's%20RX.html#foo";
 
     auto r = encode(s);
-    debug(uri) printf("r = '%.*s'\n", cast(int) r.length, r.ptr);
+    debug(uri) printf("r = '%.*s'\n", r);
     assert(r == t);
     r = decode(t);
-    debug(uri) printf("r = '%.*s'\n", cast(int) r.length, r.ptr);
+    debug(uri) printf("r = '%.*s'\n", r);
     assert(r == s);
 
     r = encode( decode("%E3%81%82%E3%81%82") );
@@ -523,8 +524,7 @@
     //printf("r = '%.*s'\n", r);
     assert(r == "c%2B%2B");
 
-    // char[] str = new char[10_000_000]; // Belongs in testgc.d? 8-\
-    auto str = new char[10_000];
+    auto str = new char[10_000_000];
     str[] = 'A';
     r = encodeComponent(assumeUnique(str));
     foreach (char c; r)
diff -r f12bfe124807 d/phobos2/std/utf.d
--- a/d/phobos2/std/utf.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/utf.d	Thu Oct 14 14:12:53 2010 +0100
@@ -68,8 +68,8 @@
 
     this(string s, size_t i)
     {
-	idx = i;
-	super(s);
+        idx = i;
+        super(s);
     }
 }
 
@@ -672,13 +672,13 @@
 
 string toUTF8(string s)
     in
-    {
+{
 	validate(s);
-    }
-    body
-    {
+}
+body
+{
 	return s;
-    }
+}
 
 /** ditto */
 
@@ -773,24 +773,24 @@
     r.length = 0;
     for (size_t i = 0; i < slen; )
     {
-	dchar c = s[i];
-	if (c <= 0x7F)
-	{
-	    i++;
-	    r ~= cast(wchar)c;
-	}
-	else
-	{
-	    c = decode(s, i);
-	    encode(r, c);
-	}
+        dchar c = s[i];
+        if (c <= 0x7F)
+        {
+            i++;
+            r ~= cast(wchar)c;
+        }
+        else
+        {
+            c = decode(s, i);
+            encode(r, c);
+        }
     }
     return cast(wstring) r; // ok because r is unique
 }
 
 /** ditto */
 
-const(wchar*) toUTF16z(string s)
+const(wchar*) toUTF16z(in char[] s)
 {
     wchar[] r;
     size_t slen = s.length;
diff -r f12bfe124807 d/phobos2/std/variant.d
--- a/d/phobos2/std/variant.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/variant.d	Thu Oct 14 14:12:53 2010 +0100
@@ -83,7 +83,7 @@
 
 module std.variant;
 
-import std.traits, std.conv, std.c.string, std.typetuple;
+import std.traits, std.c.string, std.typetuple, std.conv;
 import std.stdio; // for testing only
 import std.contracts; // for testing only
 
@@ -91,15 +91,54 @@
 {
     static if (T.length == 1)
     {
-        static const size_t maxSize = T[0].sizeof;
+        enum size_t maxSize = T[0].sizeof;
     }
     else
     {
-        static const size_t maxSize = T[0].sizeof >= maxSize!(T[1 .. $])
+        enum size_t maxSize = T[0].sizeof >= maxSize!(T[1 .. $])
             ? T[0].sizeof : maxSize!(T[1 .. $]);
     }
 }
 
+struct This;
+
+template AssociativeArray(T)
+{
+    enum bool valid = false;
+    alias void Key;
+    alias void Value;
+}
+
+template AssociativeArray(T : V[K], K, V)
+{
+    enum bool valid = true;
+    alias K Key;
+    alias V Value;
+}
+
+template This2Variant(V, T...)
+{
+    static if (T.length == 0) alias TypeTuple!() This2Variant;
+    else static if (is(AssociativeArray!(T[0]).Key == This))
+    {
+        static if (is(AssociativeArray!(T[0]).Value == This))
+            alias TypeTuple!(V[V],
+                    This2Variant!(V, T[1 .. $])) This2Variant;
+        else
+            alias TypeTuple!(AssociativeArray!(T[0]).Value[V],
+                    This2Variant!(V, T[1 .. $])) This2Variant;
+    }
+    else static if (is(AssociativeArray!(T[0]).Value == This))
+        alias TypeTuple!(V[AssociativeArray!(T[0]).Key],
+                This2Variant!(V, T[1 .. $])) This2Variant;
+    else static if (is(T[0] == This[]))
+        alias TypeTuple!(V[], This2Variant!(V, T[1 .. $])) This2Variant;
+    else static if (is(T[0] == This*))
+        alias TypeTuple!(V*, This2Variant!(V, T[1 .. $])) This2Variant;
+    else
+       alias TypeTuple!(T[0], This2Variant!(V, T[1 .. $])) This2Variant;
+}
+
 /**
  * $(D_PARAM VariantN) is a back-end type seldom used directly by user
  * code. Two commonly-used types using $(D_PARAM VariantN) as
@@ -126,16 +165,18 @@
  *
  */
 
-struct VariantN(size_t maxDataSize, AllowedTypes...)
+struct VariantN(size_t maxDataSize, AllowedTypesX...)
 {
 private:
+    alias This2Variant!(VariantN, AllowedTypesX) AllowedTypes;
+    
     // Compute the largest practical size from maxDataSize
     struct SizeChecker
     {
         int function() fptr;
         ubyte[maxDataSize] data;
     }
-    const size_t size = SizeChecker.sizeof - (int function()).sizeof;
+    enum size = SizeChecker.sizeof - (int function()).sizeof;
 
     /** Tells whether a type $(D_PARAM T) is statically allowed for
      * storage inside a $(D_PARAM VariantN) object by looking
@@ -145,8 +186,7 @@
      */
     public template allowed(T)
     {
-        static const bool allowed =
-            (T.sizeof <= size || is(T == VariantN))
+        enum bool allowed = is(T == VariantN) || T.sizeof <= size
             && (!AllowedTypes.length || indexOf!(T, AllowedTypes) >= 0);
     }
 
@@ -167,7 +207,7 @@
     }
 
     // internals
-    // Handler for an initialized value
+    // Handler for an uninitialized value
     static int handler(A : void)(OpID selector, ubyte[size]*, void* parm)
     {
         switch (selector)
@@ -209,21 +249,25 @@
         // Output: target points to a copy of *me, if me was not null
         // Returns: true iff the A can be converted to the type represented
         // by the incoming TypeInfo 
-        static bool tryPutting(A* me, TypeInfo targetType, void* target)
+        static bool tryPutting(A* src, TypeInfo targetType, void* target)
         {
             alias TypeTuple!(A, ImplicitConversionTargets!(A)) AllTypes;
             foreach (T ; AllTypes)
             {
                 if (targetType != typeid(T)) continue;
                 // found!!!
-                static if (is(typeof(*cast(T*) target = *me)))
+                static if (is(typeof(*cast(T*) target = *src)))
                 {
-                    if (me) *cast(T*) target = *me;
+                    if (src)
+                    {
+                        assert(target);
+                        *cast(T*) target = *src;
+                    }
                 }
                 else
                 {
                     // type is not assignable
-                    if (me) assert(false, A.stringof);
+                    if (src) assert(false, A.stringof);
                 }
                 return true;
             }
@@ -237,7 +281,9 @@
             break;
         case OpID.copyOut:
             auto target = cast(VariantN *) parm;
-            memcpy(&target.store, pStore, A.sizeof);
+            assert(target);
+            tryPutting(cast(A*) pStore, typeid(A), &target.store)
+                || assert(false);
             target.fptr = &handler!(A);
             break;
         case OpID.get:
@@ -306,6 +352,11 @@
                 *target = to!(string)(*me);
                 break;
             }
+            else static if (is(typeof((*me).toString)))
+            {
+                *target = (*me).toString;
+                break;
+            }
             else
             {
                 throw new VariantException(typeid(A), typeid(string));
@@ -313,20 +364,23 @@
 
         case OpID.index:
             auto me = cast(A*) pStore;
-            static if (isArray!(A))
+            // Added allowed!(...) prompted by a bug report by Chris
+            // Nicholson-Sauls.
+            static if (isArray!(A) && allowed!(typeof(A.init[0])))
             {
                 // array type; input and output are the same VariantN 
                 auto result = cast(VariantN*) parm;
                 size_t index = result.convertsTo!(int)
                     ? result.get!(int) : result.get!(size_t);
                 *result = (*me)[index];
-		break;
+                break;
             }
-            else static if (isAssociativeArray!(A))
+            else static if (isAssociativeArray!(A)
+                    && allowed!(typeof(A.init.values[0])))
             {
                 auto result = cast(VariantN*) parm;
                 *result = (*me)[result.get!(typeof(A.keys[0]))];
-		break;
+                break;
             }
             else
             {
@@ -405,7 +459,7 @@
     {
         static assert(allowed!(T), "Cannot store a " ~ T.stringof
             ~ " in a " ~ VariantN.stringof);
-        VariantN result = void;
+        VariantN result;
         result.opAssign(value);
         return result;
     }
@@ -415,8 +469,10 @@
 
     VariantN opAssign(T)(T rhs)
     {
+        assert(&this !is null); // weird bug in hashtables
         static assert(allowed!(T), "Cannot store a " ~ T.stringof
-            ~ " in a " ~ VariantN.stringof);
+            ~ " in a " ~ VariantN.stringof ~ ". Valid types are "
+                ~ AllowedTypes.stringof);
         static if (isStaticArray!(T))
         {
             // Fix for Brad's bug
@@ -431,13 +487,19 @@
             }
             else
             {
-                static assert(T.sizeof <= size, "Cannot store type "
-                    ~ T.stringof ~ " in a " ~ VariantN.stringof
-                    ~ "; it's too large. Try storing a pointer, or using"
-                    " VariantN with a larger size.");
-                //*cast(U*) &store = rhs;
-                memcpy(&store, &rhs, rhs.sizeof);
-                fptr = &handler!(T);
+                static if (T.sizeof <= size)
+                {
+                    //*cast(U*) &store = rhs;
+                    memcpy(&store, &rhs, rhs.sizeof);
+                    fptr = &handler!(T);
+                }
+                else
+                {
+                    static assert(false, "Cannot store type "
+                            ~ T.stringof ~ " in a " ~ VariantN.stringof
+                            ~ "; it's too large. Try storing a pointer"
+                            ", or using VariantN with a larger size.");
+                }
             }
             return this;
         }
@@ -481,8 +543,9 @@
      */
     T * peek(T)()
     {
-        static assert(allowed!(T), "Cannot store a " ~ T.stringof
-            ~ " in a " ~ VariantN.stringof);
+        static if (!is(T == void))
+            static assert(allowed!(T), "Cannot store a " ~ T.stringof
+                    ~ " in a " ~ VariantN.stringof);
         return type == typeid(T) ? cast(T*) &store : null;
     }
 
@@ -917,13 +980,13 @@
 }
 
 /**
- * $(D_PARAM Variant) is an alias for $(D_PARAM VariantN) instantiated
- * with the largest of $(D_PARAM creal), $(D_PARAM char[]), and
- * $(D_PARAM void delegate()). This ensures that $(D_PARAM Variant) is
- * large enough to hold all of D's predefined types, including all
- * numeric types, pointers, delegates, and class references.  You may
- * want to use $(D_PARAM VariantN) directly with a different maximum
- * size either for storing larger types, or for saving memory.
+$(D_PARAM Variant) is an alias for $(D_PARAM VariantN) instantiated
+with the largest of $(D_PARAM creal), $(D_PARAM char[]), and $(D_PARAM
+void delegate()). This ensures that $(D_PARAM Variant) is large enough
+to hold all of D's predefined types, including all numeric types,
+pointers, delegates, and class references.  You may want to use
+$(D_PARAM VariantN) directly with a different maximum size either for
+storing larger types, or for saving memory.
  */
 
 alias VariantN!(maxSize!(creal, char[], void delegate())) Variant;
@@ -1005,6 +1068,31 @@
 
 unittest
 {
+    // alias This2Variant!(char, int, This[int]) W1;
+    // alias TypeTuple!(int, char[int]) W2;
+    // static assert(is(W1 == W2));
+
+    // alias Algebraic!(void, string) var_t;
+    // var_t foo = "quux";
+}
+
+unittest
+{
+    // alias Algebraic!(real, This[], This[int], This[This]) A;
+    // A v1, v2, v3;
+    // v2 = 5.0L;
+    // v3 = 42.0L;
+    // //v1 = [ v2 ][];
+    //  auto v = v1.peek!(A[]);
+    //writeln(v[0]);
+    //v1 = [ 9 : v3 ];
+    // //writeln(v1);
+    // v1 = [ v3 : v3 ];
+    //writeln(v1);
+}
+
+version(none) unittest
+{
     // try it with an oddly small size
     VariantN!(1) test;
     assert(test.size > 1);
@@ -1090,7 +1178,7 @@
     assert( v.get!(int) == 42 );
     assert( v.get!(long) == 42L );
     assert( v.get!(ulong) == 42uL );
- 	
+
     // should be string... @@@BUG IN COMPILER
     v = "Hello, World!"c;
     assert( v.peek!(string) );
@@ -1103,14 +1191,14 @@
     v = [1,2,3,4,5];
     assert( v.peek!(int[]) );
     assert( v.get!(int[]) == [1,2,3,4,5] );
- 	
+
     v = 3.1413;
     assert( v.peek!(double) );
     assert( v.convertsTo!(real) );
     //@@@ BUG IN COMPILER: DOUBLE SHOULD NOT IMPLICITLY CONVERT TO FLOAT
     assert( !v.convertsTo!(float) );
     assert( *v.peek!(double) == 3.1413 );
-
+    
     auto u = Variant(v);
     assert( u.peek!(double) );
     assert( *u.peek!(double) == 3.1413 ); 	
diff -r f12bfe124807 d/phobos2/std/windows/charset.d
--- a/d/phobos2/std/windows/charset.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/windows/charset.d	Thu Oct 14 14:12:53 2010 +0100
@@ -13,7 +13,6 @@
 private import std.utf;
 private import std.string;
 
-
 /******************************************
  * Converts the UTF-8 string s into a null-terminated string in a Windows
  * 8-bit character set.
@@ -29,33 +28,33 @@
  *	yaneurao, Walter Bright, Stewart Gordon
  */
 
-const(char)* toMBSz(string s, uint codePage = 0)
+const(char)* toMBSz(in char[] s, uint codePage = 0)
 {
     // Only need to do this if any chars have the high bit set
     foreach (char c; s)
     {
-	if (c >= 0x80)
-	{
-	    char[] result;
-	    int readLen;
-	    auto ws = std.utf.toUTF16z(s);
-	    result.length = WideCharToMultiByte(codePage, 0, ws, -1, null, 0,
-		null, null);
+        if (c >= 0x80)
+        {
+            char[] result;
+            int readLen;
+            auto ws = std.utf.toUTF16z(s);
+            result.length = WideCharToMultiByte(codePage, 0, ws, -1, null, 0,
+                    null, null);
 
-	    if (result.length)
-	    {
-		readLen = WideCharToMultiByte(codePage, 0, ws, -1, result.ptr,
-			result.length, null, null);
-	    }
+            if (result.length)
+            {
+                readLen = WideCharToMultiByte(codePage, 0, ws, -1, result.ptr,
+                        result.length, null, null);
+            }
 
-	    if (!readLen || readLen != result.length)
-	    {
-		throw new Exception("Couldn't convert string: " ~
-			sysErrorString(GetLastError()));
-	    }
+            if (!readLen || readLen != result.length)
+            {
+                throw new Exception("Couldn't convert string: " ~
+                        sysErrorString(GetLastError()));
+            }
 
-	    return result.ptr;
-	}
+            return result.ptr;
+        }
     }
     return std.string.toStringz(s);
 }
diff -r f12bfe124807 d/phobos2/std/windows/registry.d
--- a/d/phobos2/std/windows/registry.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/windows/registry.d	Thu Oct 14 14:12:53 2010 +0100
@@ -53,7 +53,9 @@
 //import std.windows.types;
 private import std.string;
 private import std.c.windows.windows;
+import std.c.stdio;
 //private import std.windows.exceptions;
+import std.conv;
 
 //import synsoft.types;
 /+ + These are borrowed from synsoft.types, until such time as something similar is in Phobos ++
@@ -680,30 +682,30 @@
 
             case    REG_VALUE_TYPE.REG_SZ:
             case    REG_VALUE_TYPE.REG_EXPAND_SZ:
-                value = std.string.toString(cast(char*)data);
+                value = to!string(cast(char*)data);
 		if (value.ptr == cast(char*)&u.qw)
 		    value = value.idup;		// don't point into the stack
                 break;
 version(LittleEndian)
 {
             case    REG_VALUE_TYPE.REG_DWORD_LITTLE_ENDIAN:
-                value = std.string.toString(u.dw);
+                value = to!string(u.dw);
                 break;
             case    REG_VALUE_TYPE.REG_DWORD_BIG_ENDIAN:
-                value = std.string.toString(swap(u.dw));
+                value = to!string(swap(u.dw));
                 break;
 }
 version(BigEndian)
 {
             case    REG_VALUE_TYPE.REG_DWORD_LITTLE_ENDIAN:
-                value = std.string.toString(swap(u.dw));
+                value = to!string(swap(u.dw));
                 break;
             case    REG_VALUE_TYPE.REG_DWORD_BIG_ENDIAN:
-                value = std.string.toString(u.dw);
+                value = to!string(u.dw);
                 break;
 }
             case    REG_VALUE_TYPE.REG_QWORD_LITTLE_ENDIAN:
-                value = std.string.toString(u.qw);
+                value = to!string(u.qw);
                 break;
         }
     }
@@ -1456,7 +1458,7 @@
             throw new Win32Exception("Failed to expand environment variables");
         }
 
-        return std.string.toString(newValue.ptr);	// remove trailing 0
+        return to!string(newValue.ptr);	// remove trailing 0
     }
 
     /// Obtains the current value as an array of strings
diff -r f12bfe124807 d/phobos2/std/xml.d
--- a/d/phobos2/std/xml.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/xml.d	Thu Oct 14 14:12:53 2010 +0100
@@ -121,6 +121,8 @@
 import std.string;
 import std.encoding;
 
+immutable cdata = "<![CDATA[";
+
 /**
  * Returns true if the character is a character according to the XML standard
  *
@@ -772,7 +774,6 @@
             if (items[i] != element.items[i])
                 return items[i].opCmp(element.items[i]);
         }
-        assert(false);
     }
 
     /**
@@ -1266,7 +1267,7 @@
     /**
      * Returns a string representation of this CData section
      */
-    override const string toString() { return "<[CDATA[" ~ content ~ "]]>"; }
+    override const string toString() { return cdata ~ content ~ "]]>"; }
 
     override const bool isEmptyXML() { return false; } /// Returns false always
 }
@@ -2150,7 +2151,7 @@
 
         try
         {
-            checkLiteral("<[CDATA[",s);
+            checkLiteral(cdata,s);
             checkEnd("]]>",s);
         }
         catch(Err e) { fail(e); }
@@ -2344,7 +2345,7 @@
                      if (s.startsWith("&"))        { checkReference(s); }
                 else if (s.startsWith("<!--"))     { checkComment(s); }
                 else if (s.startsWith("<?"))       { checkPI(s); }
-                else if (s.startsWith("<[CDATA[")) { checkCDSect(s); }
+                else if (s.startsWith(cdata)) { checkCDSect(s); }
                 else if (s.startsWith("</"))       { break; }
                 else if (s.startsWith("<"))        { checkElement(s); }
                 else                               { checkCharData(s); }
diff -r f12bfe124807 d/phobos2/std/zip.d
--- a/d/phobos2/std/zip.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/zip.d	Thu Oct 14 14:12:53 2010 +0100
@@ -73,8 +73,8 @@
     {
     void print()
     {
-	printf("name = '%.*s'\n", cast(int) name.length, name.ptr);
-	printf("\tcomment = '%.*s'\n", cast(int) comment.length, comment.ptr);
+	printf("name = '%.*s'\n", name);
+	printf("\tcomment = '%.*s'\n", comment);
 	printf("\tmadeVersion = x%04x\n", madeVersion);
 	printf("\textractVersion = x%04x\n", extractVersion);
 	printf("\tflags = x%04x\n", flags);
@@ -126,7 +126,7 @@
 	printf("\tdiskStartDir = %u\n", diskStartDir);
 	printf("\tnumEntries = %u\n", numEntries);
 	printf("\ttotalEntries = %u\n", totalEntries);
-	printf("\tcomment = '%.*s'\n", cast(int) comment.length, comment.ptr);
+	printf("\tcomment = '%.*s'\n", comment);
     }
     }
 
diff -r f12bfe124807 d/phobos2/std/zlib.d
--- a/d/phobos2/std/zlib.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/std/zlib.d	Thu Oct 14 14:12:53 2010 +0100
@@ -14,15 +14,14 @@
 
 /* NOTE: This file has been patched from the original DMD distribution to
    work with the GDC compiler.
+ */
 
-   Modified by David Friedman, February 2007
-*/
 
 module std.zlib;
 
 //debug=zlib;		// uncomment to turn on debugging printf's
 
-private import etc.c.zlib, std.stdint;
+private import etc.c.zlib;
 
 // Values for 'mode'
 
@@ -120,9 +119,8 @@
 {
     int err;
     ubyte[] destbuf;
-    Culong_t destlen;
 
-    destlen = srcbuf.length + ((srcbuf.length + 1023) / 1024) + 12;
+    auto destlen = srcbuf.length + ((srcbuf.length + 1023) / 1024) + 12;
     destbuf = new ubyte[destlen];
     err = etc.c.zlib.compress2(destbuf.ptr, &destlen, cast(ubyte *)srcbuf, srcbuf.length, level);
     if (err)
@@ -151,7 +149,7 @@
  * Returns: the decompressed data.
  */
 
-const(void)[] uncompress(const(void)[] srcbuf, size_t destlen = 0u, int winbits = 15)
+const(void)[] uncompress(const(void)[] srcbuf, uint destlen = 0u, int winbits = 15)
 {
     int err;
     ubyte[] destbuf;
@@ -570,10 +568,11 @@
 
     // smallish buffers
     for(int idx = 0; idx < 25; idx++) {
-        char[] buf = new char[rand() % 100];
+        char[] buf = new char[uniform(0, 100)];
 
         // Alternate between more & less compressible
-        foreach(inout char c; buf) c = ' ' + (rand() % (idx % 2 ? 91 : 2));
+        foreach(ref char c; buf)
+            c = cast(char) (' ' + (uniform(0, idx % 2 ? 91 : 2)));
 
         if(CompressThenUncompress(cast(ubyte[])buf)) {
             debug(zlib) printf("; Success.\n");
@@ -584,10 +583,11 @@
 
     // larger buffers
     for(int idx = 0; idx < 25; idx++) {
-        char[] buf = new char[rand() % 1000/*0000*/];
+        char[] buf = new char[uniform(0, 1000/*0000*/)];
 
         // Alternate between more & less compressible
-        foreach(inout char c; buf) c = ' ' + (rand() % (idx % 2 ? 91 : 10));
+        foreach(inout char c; buf)
+            c = cast(char) (' ' + (uniform(0, idx % 2 ? 91 : 10)));
 
         if(CompressThenUncompress(cast(ubyte[])buf)) {
             debug(zlib) printf("; Success.\n");
diff -r f12bfe124807 d/phobos2/unittest.d
--- a/d/phobos2/unittest.d	Thu Oct 14 08:09:22 2010 +0100
+++ b/d/phobos2/unittest.d	Thu Oct 14 14:12:53 2010 +0100
@@ -27,7 +27,6 @@
 
 public import std.base64;
 public import std.bind;
-public import std.bitarray;
 public import std.boxer;
 public import std.compiler;
 public import std.contracts;
@@ -75,16 +74,19 @@
 
 int main(char[][] args)
 {
+
+version (all)
+{
     // Bring in unit test for module by referencing function in it
 
     cmp("foo", "bar");			// string
     fncharmatch('a', 'b');		// path
-    isnan(1.0);				// math
-    std.conv.toDouble("1.0");		// std.conv
+    isNaN(1.0);				// math
+    std.conv.to!double("1.0");		// std.conv
     OutBuffer b = new OutBuffer();	// outbuffer
     std.ctype.tolower('A');		// ctype
     RegExp r = new RegExp(null, null);	// regexp
-    std.random.rand();
+    uint ranseed = std.random.unpredictableSeed();
     int a[];
     a.reverse;				// adi
     a.sort;				// qsort
@@ -123,10 +125,6 @@
 
     std.demangle.demangle("hello");
 
-    BitArray ba;			// std.bitarray
-    ba.length = 3;
-    ba[0] = true;
-
     std.uni.isUniAlpha('A');
 
     std.file.exists("foo");
@@ -137,7 +135,7 @@
     std.signals.linkin();
 
     writefln(std.cpuid.toString());
-
+}
     printf("Success!\n");
     return 0;
 }
