diff -r 6a92bcae44c5 d/phobos/configure
--- a/d/phobos/configure	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/configure	Sat Jun 26 21:05:08 2010 +0100
@@ -5099,9 +5099,14 @@
 # AC_SUBST(DCFG_EXPM1)
 # also erf, erfc
 
-# use version(Posix)/version(Unix) instead.
-#AC_CHECK_FUNC(execvpe,DCFG_EXECVPE="",DCFG_EXECVPE="GNU_Need_execvpe")
-#AC_SUBST(DCFG_EXECVPE)
+ac_fn_c_check_func "$LINENO" "execvpe" "ac_cv_func_execvpe"
+if test "x$ac_cv_func_execvpe" = x""yes; then :
+  DCFG_EXECVPE=""
+else
+  DCFG_EXECVPE="GNU_Need_execvpe"
+fi
+
+
 
 ac_fn_c_check_func "$LINENO" "spawnvp" "ac_cv_func_spawnvp"
 if test "x$ac_cv_func_spawnvp" = x""yes; then :
diff -r 6a92bcae44c5 d/phobos/configure.in
--- a/d/phobos/configure.in	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/configure.in	Sat Jun 26 21:05:08 2010 +0100
@@ -440,9 +440,8 @@
 # AC_SUBST(DCFG_EXPM1)
 # also erf, erfc
 
-# use version(Posix)/version(Unix) instead.
-#AC_CHECK_FUNC(execvpe,DCFG_EXECVPE="",DCFG_EXECVPE="GNU_Need_execvpe")
-#AC_SUBST(DCFG_EXECVPE)
+AC_CHECK_FUNC(execvpe,DCFG_EXECVPE="",DCFG_EXECVPE="GNU_Need_execvpe")
+AC_SUBST(DCFG_EXECVPE)
 
 AC_CHECK_FUNC(spawnvp,DCFG_SPAWNVP="",DCFG_SPAWNVP="GNU_Need_spawnvp")
 AC_SUBST(DCFG_SPAWNVP)
diff -r 6a92bcae44c5 d/phobos/etc/c/zlib.d
--- a/d/phobos/etc/c/zlib.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/etc/c/zlib.d	Sat Jun 26 21:05:08 2010 +0100
@@ -1,16 +1,17 @@
 /* zlib.d: modified from zlib.h by Walter Bright */
+/* updated from 1.2.1 to 1.2.3 by Thomas Kuehne */
 /* NOTE: This file has been patched from the original DMD distribution to
    work with the GDC compiler.
 
    Modified by David Friedman, February 2007
-*/
+ */
 
 module etc.c.zlib;
 
 /* zlib.h -- interface of the 'zlib' general purpose compression library
-  version 1.2.1, November 17th, 2003
+   version 1.2.3, July 18th, 2005
 
-  Copyright (C) 1995-2003 Jean-loup Gailly and Mark Adler
+  Copyright (C) 1995-2005 Jean-loup Gailly and Mark Adler
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
@@ -41,7 +42,8 @@
 
 extern (C):
 
-char[] ZLIB_VERSION = "1.2.1";
+char[] ZLIB_VERSION = "1.2.3";
+const ZLIB_VERNUM = 0x1230;
 
 /*
      The 'zlib' compression library provides in-memory compression and
@@ -56,24 +58,22 @@
   application must provide more input and/or consume the output
   (providing more output space) before each call.
 
-     The compressed data format used by the in-memory functions is the zlib
-  format, which is a zlib wrapper documented in RFC 1950, wrapped around a
-  deflate stream, which is itself documented in RFC 1951.
+     The compressed data format used by default by the in-memory functions is
+  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
+  around a deflate stream, which is itself documented in RFC 1951.
 
      The library also supports reading and writing files in gzip (.gz) format
   with an interface similar to that of stdio using the functions that start
   with "gz".  The gzip format is different from the zlib format.  gzip is a
   gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
 
+     This library can optionally read and write gzip streams in memory as well.
+
      The zlib format was designed to be compact and fast for use in memory
   and on communications channels.  The gzip format was designed for single-
   file compression on file systems, has a larger header than zlib to maintain
   directory information, and uses a different, slower check method than zlib.
 
-     This library does not provide any functions to write gzip files in memory.
-  However such functions could be easily written using zlib's deflate function,
-  the documentation in the gzip RFC, and the examples in gzio.c.
-
      The library does not install any signal handler. The decoder checks
   the consistency of the compressed data, so the library should never
   crash even in case of corrupted input.
@@ -107,7 +107,30 @@
 alias z_stream* z_streamp;
 
 /*
-   The application must update next_in and avail_in when avail_in has
+     gzip header information passed to and from zlib routines.  See RFC 1952
+  for more details on the meanings of these fields.
+*/
+struct gz_header {
+    int     text;       /* true if compressed data believed to be text */
+    ulong   time;       /* modification time */
+    int     xflags;     /* extra flags (not used when writing a gzip file) */
+    int     os;         /* operating system */
+    byte    *extra;     /* pointer to extra field or Z_NULL if none */
+    uint    extra_len;  /* extra field length (valid if extra != Z_NULL) */
+    uint    extra_max;  /* space at extra (only when reading header) */
+    byte    *name;      /* pointer to zero-terminated file name or Z_NULL */
+    uint    name_max;   /* space at name (only when reading header) */
+    byte    *comment;   /* pointer to zero-terminated comment or Z_NULL */
+    uint    comm_max;   /* space at comment (only when reading header) */
+    int     hcrc;       /* true if there was or will be a header crc */
+    int     done;       /* true when done reading gzip header (not used
+                           when writing a gzip file) */
+}
+
+alias gz_header* gz_headerp;
+
+/*
+  The application must update next_in and avail_in when avail_in has
    dropped to zero. It must update next_out and avail_out when avail_out
    has dropped to zero. The application must initialize zalloc, zfree and
    opaque before calling the init function. All other fields are set by the
@@ -181,6 +204,7 @@
 	Z_FILTERED            = 1,
 	Z_HUFFMAN_ONLY        = 2,
 	Z_RLE                 = 3,
+	Z_FIXED               = 4,
 	Z_DEFAULT_STRATEGY    = 0,
 }
 /* compression strategy; see deflateInit2() below for details */
@@ -188,8 +212,10 @@
 enum
 {
 	Z_BINARY   = 0,
-	Z_ASCII    = 1,
+	Z_TEXT     = 1,
 	Z_UNKNOWN  = 2,
+
+	Z_ASCII    = Z_TEXT
 }
 /* Possible values of the data_type field (though see inflate()) */
 
@@ -265,6 +291,10 @@
   and with zero avail_out, it must be called again after making room in the
   output buffer because there might be more output pending.
 
+    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
+  decide how much data to accumualte before producing output, in order to
+  maximize compression.
+
     If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
   flushed to the output buffer and the output is aligned on a byte boundary, so
   that the decompressor can get all input data available so far. (In particular
@@ -276,7 +306,7 @@
   Z_SYNC_FLUSH, and the compression state is reset so that decompression can
   restart from this point if previous compressed data has been damaged or if
   random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
-  the compression.
+  compression.
 
     If deflate returns with avail_out == 0, this function must be called again
   with the same value of the flush parameter and more output space (updated
@@ -301,8 +331,8 @@
     deflate() sets strm->adler to the adler32 checksum of all input read
   so far (that is, total_in bytes).
 
-    deflate() may update data_type if it can make a good guess about
-  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
+    deflate() may update strm->data_type if it can make a good guess about
+  the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered
   binary. This field is only for information purposes and does not affect
   the compression algorithm in any manner.
 
@@ -386,11 +416,11 @@
     The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
   Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much
   output as possible to the output buffer. Z_BLOCK requests that inflate() stop
-  if and when it get to the next deflate block boundary. When decoding the zlib
-  or gzip format, this will cause inflate() to return immediately after the
-  header and before the first block. When doing a raw inflate, inflate() will
-  go ahead and process the first block, and will return when it gets to the end
-  of that block, or when it runs out of data.
+  if and when it gets to the next deflate block boundary. When decoding the
+  zlib or gzip format, this will cause inflate() to return immediately after
+  the header and before the first block. When doing a raw inflate, inflate()
+  will go ahead and process the first block, and will return when it gets to
+  the end of that block, or when it runs out of data.
 
     The Z_BLOCK option assists in appending to or combining deflate streams.
   Also to assist in this, on return inflate() will set strm->data_type to the
@@ -422,7 +452,7 @@
   because Z_BLOCK is used.
 
      If a preset dictionary is needed after this call (see inflateSetDictionary
-  below), inflate sets strm-adler to the adler32 checksum of the dictionary
+  below), inflate sets strm->adler to the adler32 checksum of the dictionary
   chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
   strm->adler to the adler32 checksum of all output produced so far (that is,
   total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
@@ -502,7 +532,8 @@
    16 to windowBits to write a simple gzip header and trailer around the
    compressed data instead of a zlib wrapper. The gzip header will have no
    file name, no extra data, no comment, no modification time (set to zero),
-   no header crc, and the operating system will be set to 255 (unknown).
+   no header crc, and the operating system will be set to 255 (unknown).  If a
+   gzip stream is being written, strm->adler is a crc32 instead of an adler32.
 
      The memLevel parameter specifies how much memory should be allocated
    for the internal compression state. memLevel=1 uses minimum memory but
@@ -521,7 +552,9 @@
    Z_DEFAULT and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as
    Z_HUFFMAN_ONLY, but give better compression for PNG image data. The strategy
    parameter only affects the compression ratio but not the correctness of the
-   compressed output even if it is not set appropriately.
+   compressed output even if it is not set appropriately.  Z_FIXED prevents the
+   use of dynamic Huffman codes, allowing for a simpler decoder for special
+   applications.
 
       deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
    memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
@@ -548,7 +581,9 @@
    deflateInit or deflateInit2, a part of the dictionary may in effect be
    discarded, for example if the dictionary is larger than the window size in
    deflate or deflate2. Thus the strings most likely to be useful should be
-   put at the end of the dictionary, not at the front.
+   put at the end of the dictionary, not at the front. In addition, the
+   current implementation of deflate will use at most the window size minus
+   262 bytes of the provided dictionary.
 
      Upon return of this function, strm->adler is set to the adler32 value
    of the dictionary; the decompressor may later use this value to determine
@@ -592,6 +627,59 @@
    stream state was inconsistent (such as zalloc or state being NULL).
 */
 
+int inflatePrime(z_streamp strm, int bits, int value);
+/*
+     This function inserts bits in the inflate input stream.  The intent is
+  that this function is used to start inflating at a bit position in the
+  middle of a byte.  The provided bits will be used before any bytes are used
+  from next_in.  This function should only be used with raw inflate, and
+  should be used before the first inflate() call after inflateInit2() or
+  inflateReset().  bits must be less than or equal to 16, and that many of the
+  least significant bits of value will be inserted in the input.
+
+      inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+int inflateGetHeader(z_streamp strm, gz_headerp head);
+/*
+      inflateGetHeader() requests that gzip header information be stored in the
+   provided gz_header structure.  inflateGetHeader() may be called after
+   inflateInit2() or inflateReset(), and before the first call of inflate().
+   As inflate() processes the gzip stream, head->done is zero until the header
+   is completed, at which time head->done is set to one.  If a zlib stream is
+   being decoded, then head->done is set to -1 to indicate that there will be
+   no gzip header information forthcoming.  Note that Z_BLOCK can be used to
+   force inflate() to return immediately after header processing is complete
+   and before any actual data is decompressed.
+
+      The text, time, xflags, and os fields are filled in with the gzip header
+   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
+   was valid if done is set to one.)  If extra is not Z_NULL, then extra_max
+   contains the maximum number of bytes to write to extra.  Once done is true,
+   extra_len contains the actual extra field length, and extra contains the
+   extra field, or that field truncated if extra_max is less than extra_len.
+   If name is not Z_NULL, then up to name_max characters are written there,
+   terminated with a zero unless the length is greater than name_max.  If
+   comment is not Z_NULL, then up to comm_max characters are written there,
+   terminated with a zero unless the length is greater than comm_max.  When
+   any of extra, name, or comment are not Z_NULL and the respective field is
+   not present in the header, then that field is set to Z_NULL to signal its
+   absence.  This allows the use of deflateSetHeader() with the returned
+   structure to duplicate the header.  However if those fields are set to
+   allocated memory, then the application will need to save those pointers
+   elsewhere so that they can be eventually freed.
+
+      If inflateGetHeader is not used, then the header information is simply
+   discarded.  The header is always checked for validity, including the header
+   CRC if present.  inflateReset() will reset the process to discard the header
+   information.  The application would need to call inflateGetHeader() again to
+   retrieve the header from the next gzip stream.
+
+      inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
 int deflateParams(z_streamp strm, int level, int strategy);
 /*
      Dynamically update the compression level and compression strategy.  The
@@ -611,7 +699,21 @@
    if strm->avail_out was zero.
 */
 
-uint deflateBound(z_streamp strm, uint Culong_t);
+int deflateTune(z_streamp strm, int good_length, int max_lazy, int nice_length,
+	int max_chain);
+/*
+     Fine tune deflate's internal compression parameters.  This should only be
+   used by someone who understands the algorithm used by zlib's deflate for
+   searching for the best matching string, and even then only by the most
+   fanatic optimizer trying to squeeze out the last compressed bit for their
+   specific input data.  Read the deflate.c source code for the meaning of the
+   max_lazy, good_length, nice_length, and max_chain parameters.
+
+     deflateTune() can be called after deflateInit() or deflateInit2(), and
+   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
+ */
+
+int deflateBound(z_streamp strm, Culong_t sourceLen);
 /*
      deflateBound() returns an upper bound on the compressed size after
    deflation of sourceLen bytes.  It must be called after deflateInit()
@@ -633,6 +735,29 @@
    stream state was inconsistent.
 */
 
+int deflateSetHeader(z_streamp strm, gz_headerp head);
+/*
+      deflateSetHeader() provides gzip header information for when a gzip
+   stream is requested by deflateInit2().  deflateSetHeader() may be called
+   after deflateInit2() or deflateReset() and before the first call of
+   deflate().  The text, time, os, extra field, name, and comment information
+   in the provided gz_header structure are written to the gzip header (xflag is
+   ignored -- the extra flags are set according to the compression level).  The
+   caller must assure that, if not Z_NULL, name and comment are terminated with
+   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
+   available there.  If hcrc is true, a gzip header crc is included.  Note that
+   the current versions of the command-line version of gzip (up through version
+   1.3.x) do not support header crc's, and will report that it is a "multi-part
+   gzip file" and give up.
+
+      If deflateSetHeader is not used, the default gzip header has text false,
+   the time set to zero, and os set to 255, with no extra, name, or comment
+   fields.  The gzip header is returned to the default state by deflateReset().
+
+      deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
 int inflateInit2(z_streamp strm, int windowBits)
 {
     return inflateInit2_(strm, windowBits, ZLIB_VERSION.ptr, z_stream.sizeof);
@@ -666,24 +791,28 @@
      windowBits can also be greater than 15 for optional gzip decoding. Add
    32 to windowBits to enable zlib and gzip decoding with automatic header
    detection, or add 16 to decode only the gzip format (the zlib format will
-   return a Z_DATA_ERROR).
+   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is
+   a crc32 instead of an adler32.
 
      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
-   memLevel). msg is set to null if there is no error message.  inflateInit2
-   does not perform any decompression apart from reading the zlib header if
-   present: this will be done by inflate(). (So next_in and avail_in may be
-   modified, but next_out and avail_out are unchanged.)
-*/
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as a null strm). msg
+   is set to null if there is no error message.  inflateInit2 does not perform
+   any decompression apart from reading the zlib header if present: this will
+   be done by inflate(). (So next_in and avail_in may be modified, but next_out
+   and avail_out are unchanged.)
+/
 
 int inflateSetDictionary(z_streamp strm, ubyte* dictionary, uint  dictLength);
 /*
      Initializes the decompression dictionary from the given uncompressed byte
-   sequence. This function must be called immediately after a call of inflate
-   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
-   can be determined from the adler32 value returned by this call of
-   inflate. The compressor and decompressor must use exactly the same
-   dictionary (see deflateSetDictionary).
+   sequence. This function must be called immediately after a call of inflate,
+   if that call returned Z_NEED_DICT. The dictionary chosen by the compressor
+   can be determined from the adler32 value returned by that call of inflate.
+   The compressor and decompressor must use exactly the same dictionary (see
+   deflateSetDictionary).  For raw inflate, this function can be called
+   immediately after inflateInit2() or inflateReset() and before any call of
+   inflate() to set the dictionary.  The application must insure that the
+   dictionary that was used for compression is provided.
 
      inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
    parameter is invalid (such as NULL dictionary) or the stream state is
@@ -1109,6 +1238,12 @@
    input stream, otherwise zero.
 */
 
+int gzdirect(gzFile file);
+/*
+     Returns 1 if file is being read directly without decompression, otherwise
+   zero.
+*/
+
 int gzclose(gzFile file);
 /*
      Flushes all pending output if necessary, closes the compressed file
@@ -1157,12 +1292,20 @@
      if (adler != original_adler) error();
 */
 
+uint adler32_combine(uint adler1, uint adler2, z_off_t len2);
+/*
+     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
+   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
+   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
+   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.
+*/
+
 Culong_t crc32(Culong_t crc, ubyte *buf, uint len);
 /*
-     Update a running crc with the bytes buf[0..len-1] and return the updated
-   crc. If buf is NULL, this function returns the required initial value
-   for the crc. Pre- and post-conditioning (one's complement) is performed
-   within this function so it shouldn't be done by the application.
+     Update a running CRC-32 with the bytes buf[0..len-1] and return the
+   updated CRC-32. If buf is NULL, this function returns the required initial
+   value for the for the crc. Pre- and post-conditioning (one's complement) is
+   performed within this function so it shouldn't be done by the application.
    Usage example:
 
      uint crc = crc32(0L, Z_NULL, 0);
@@ -1173,6 +1316,16 @@
      if (crc != original_crc) error();
 */
 
+uint crc32_combine (uint crc1, uint crc2, z_off_t len2);
+
+/*
+     Combine two CRC-32 check values into one.  For two sequences of bytes,
+   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
+   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
+   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
+   len2.
+*/
+ 
 
                         /* various hacks, don't look :) */
 
diff -r 6a92bcae44c5 d/phobos/etc/c/zlib/linux.mak
--- a/d/phobos/etc/c/zlib/linux.mak	Tue Jun 22 15:17:14 2010 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,78 +0,0 @@
-# Makefile for zlib
-
-CC=gcc
-LD=link
-CFLAGS=-O -m32
-LDFLAGS=
-O=.o
-
-.c.o:
-	$(CC) -c $(CFLAGS) $*
-
-.d.o:
-	$(DMD) -c $(DFLAGS) $*
-
-# variables
-OBJS = adler32$(O) compress$(O) crc32$(O) gzio$(O) uncompr$(O) deflate$(O) \
-       trees$(O) zutil$(O) inflate$(O) infback$(O) inftrees$(O) inffast$(O)
-
-all:  zlib.a example minigzip
-
-adler32.o: adler32.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-compress.o: compress.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-crc32.o: crc32.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-deflate.o: deflate.c deflate.h zutil.h zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-gzio.o: gzio.c zutil.h zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-infback.o: infback.c zlib.h zconf.h inftrees.h inflate.h inffast.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-inflate.o: inflate.c zlib.h zconf.h inftrees.h inflate.h inffast.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-inftrees.o: inftrees.c zlib.h zconf.h inftrees.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-inffast.o: inffast.c zlib.h zconf.h inftrees.h inflate.h inffast.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-trees.o: trees.c deflate.h zutil.h zlib.h zconf.h trees.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-uncompr.o: uncompr.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-zutil.o: zutil.c zutil.h zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-example.o: example.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-minigzip.o: minigzip.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-zlib.a: $(OBJS)
-	ar -r $@ $(OBJS)
-
-example: example.o zlib.a
-	$(CC) $(CFLAGS) -o $@ example.o zlib.a -g
-
-minigzip: minigzip.o zlib.a
-	$(CC) $(CFLAGS) -o $@ minigzip.o zlib.a -g
-
-test: example minigzip
-	./example
-	echo hello world | minigzip | minigzip -d 
-
-clean:
-	$(RM) $(OBJS) zlib.a example.o example minigzip minigzip.o test foo.gz
-
diff -r 6a92bcae44c5 d/phobos/etc/c/zlib/osx.mak
--- a/d/phobos/etc/c/zlib/osx.mak	Tue Jun 22 15:17:14 2010 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,78 +0,0 @@
-# Makefile for zlib
-
-CC=gcc
-LD=link
-CFLAGS=-O -m32
-LDFLAGS=
-O=.o
-
-.c.o:
-	$(CC) -c $(CFLAGS) $*
-
-.d.o:
-	$(DMD) -c $(DFLAGS) $*
-
-# variables
-OBJS = adler32$(O) compress$(O) crc32$(O) gzio$(O) uncompr$(O) deflate$(O) \
-       trees$(O) zutil$(O) inflate$(O) infback$(O) inftrees$(O) inffast$(O)
-
-all:  zlib.a example minigzip
-
-adler32.o: adler32.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-compress.o: compress.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-crc32.o: crc32.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-deflate.o: deflate.c deflate.h zutil.h zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-gzio.o: gzio.c zutil.h zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-infback.o: infback.c zlib.h zconf.h inftrees.h inflate.h inffast.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-inflate.o: inflate.c zlib.h zconf.h inftrees.h inflate.h inffast.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-inftrees.o: inftrees.c zlib.h zconf.h inftrees.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-inffast.o: inffast.c zlib.h zconf.h inftrees.h inflate.h inffast.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-trees.o: trees.c deflate.h zutil.h zlib.h zconf.h trees.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-uncompr.o: uncompr.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-zutil.o: zutil.c zutil.h zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-example.o: example.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-minigzip.o: minigzip.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-zlib.a: $(OBJS)
-	ar -r $@ $(OBJS)
-
-example: example.o zlib.a
-	$(CC) -o $@ example.o zlib.a -g
-
-minigzip: minigzip.o zlib.a
-	$(CC) -o $@ minigzip.o zlib.a -g
-
-test: example minigzip
-	./example
-	echo hello world | minigzip | minigzip -d 
-
-clean:
-	$(RM) $(OBJS) zlib.a example.o example minigzip minigzip.o test foo.gz
-
diff -r 6a92bcae44c5 d/phobos/etc/c/zlib/win32.mak
--- a/d/phobos/etc/c/zlib/win32.mak	Tue Jun 22 15:17:14 2010 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,76 +0,0 @@
-# Makefile for zlib
-
-CC=dmc
-LD=link
-CFLAGS=-o
-LDFLAGS=
-O=.obj
-
-# variables
-OBJS = adler32$(O) compress$(O) crc32$(O) gzio$(O) uncompr$(O) deflate$(O) \
-       trees$(O) zutil$(O) inflate$(O) infback$(O) inftrees$(O) inffast$(O)
-
-all:  zlib.lib example.exe minigzip.exe
-
-adler32.obj: adler32.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-compress.obj: compress.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-crc32.obj: crc32.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-gzio.obj: gzio.c zutil.h zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-infback.obj: infback.c zlib.h zconf.h inftrees.h inflate.h inffast.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-inflate.obj: inflate.c zlib.h zconf.h inftrees.h inflate.h inffast.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-inftrees.obj: inftrees.c zlib.h zconf.h inftrees.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-inffast.obj: inffast.c zlib.h zconf.h inftrees.h inflate.h inffast.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-trees.obj: trees.c deflate.h zutil.h zlib.h zconf.h trees.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-example.obj: example.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-minigzip.obj: minigzip.c zlib.h zconf.h
-	$(CC) -c $(cvarsdll) $(CFLAGS) $*.c
-
-zlib.lib: $(OBJS)
-	lib -c zlib.lib $(OBJS)
-
-example.exe: example.obj zlib.lib
-	$(LD) $(LDFLAGS) example.obj zlib.lib
-
-minigzip.exe: minigzip.obj zlib.lib
-	$(LD) $(LDFLAGS) minigzip.obj zlib.lib
-
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d 
-
-clean:
-	del *.obj
-	del *.exe
-	del *.dll
-	del *.lib
-	del *.lst
-	del foo.gz
diff -r 6a92bcae44c5 d/phobos/etc/gamma.d
--- a/d/phobos/etc/gamma.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/etc/gamma.d	Sat Jun 26 21:05:08 2010 +0100
@@ -1,3 +1,8 @@
+/*
+ * Cephes code Copyright 1994 by Stephen L. Moshier
+ * Converted to D by Don Clugston.
+ */
+
 /**
 Macros:
  GAMMA =  &#915;
@@ -5,93 +10,71 @@
 */
 module etc.gamma;
 
-private import std.math;
+import std.math;
 private import std.stdio;
+//import etc.realtest;
 
 //------------------------------------------------------------------
 const real SQRT2PI = 2.50662827463100050242E0L; // sqrt(2pi)
-// exp(tgamma(x)) == inf if x>MAXGAMMA
-const real MAXGAMMA = 1755.455L;
+const real MAXGAMMA = 1755.455L;	// exp(tgamma(x)) == inf if x>MAXGAMMA
 
 // Polynomial approximations for gamma and loggamma.
 
 static real GammaNumeratorCoeffs[] = [
-   0x1p+0,					 // 1
-   0x1.acf42d903366539ep-1,	 // 0.83780043015731267283
-   0x1.73a991c8475f1aeap-2,	 // 0.36295154366402391688
-   0x1.c7e918751d6b2a92p-4,	 // 0.1113062816019361559
-   0x1.86d162cca32cfe86p-6,	 // 0.023853632434611082525
-   0x1.0c378e2e6eaf7cd8p-8,	 // 0.0040926668283940355009
-   0x1.dc5c66b7d05feb54p-12, // 0.00045429319606080091555
-   0x1.616457b47e448694p-15  // 4.2127604874716220134e-05
+   0x1p+0,			// 1
+   0x1.acf42d903366539ep-1,	// 0.83780043015731267283
+   0x1.73a991c8475f1aeap-2,	// 0.36295154366402391688
+   0x1.c7e918751d6b2a92p-4,	// 0.1113062816019361559
+   0x1.86d162cca32cfe86p-6,	// 0.023853632434611082525
+   0x1.0c378e2e6eaf7cd8p-8,	// 0.0040926668283940355009
+   0x1.dc5c66b7d05feb54p-12,	// 0.00045429319606080091555
+   0x1.616457b47e448694p-15	// 4.2127604874716220134e-05
 ];
 
 static real GammaDenominatorCoeffs[] = [
-   0x1p+0,                    // 1
-   0x1.a8f9faae5d8fc8bp-2,    // 0.41501609505884554346
-   -0x1.cb7895a6756eebdep-3,  // -0.22435109056703291645
-   -0x1.7b9bab006d30652ap-5,  // -0.046338876712445342138
-   0x1.c671af78f312082ep-6,	  // 0.027737065658400729792
-   -0x1.a11ebbfaf96252dcp-11, // -0.00079559336824947383209
-   -0x1.447b4d2230a77ddap-10, // -0.0012377992466531522311
-   0x1.ec1d45bb85e06696p-13,  // 0.00023465840591606352443
-   -0x1.d4ce24d05bd0a8e6p-17  // -1.3971485174761704409e-05
-];
-
-static real SmallStirlingCoeffs[] = [
-   0x1.55555555555543aap-4,	  // 0.083333333333333318004
-   0x1.c71c71c720dd8792p-9,	  // 0.0034722222222300753277
-   -0x1.5f7268f0b5907438p-9,  // -0.0026813271618763044182
-   -0x1.e13cd410e0477de6p-13, // -0.00022947197478731854057
-   0x1.9b0f31643442616ep-11,  // 0.00078403348427447530038
-   0x1.2527623a3472ae08p-14,  // 6.9893322606231931717e-05
-   -0x1.37f6bc8ef8b374dep-11, // -0.00059502375540563301557
-   -0x1.8c968886052b872ap-16, // -2.3638488095017590616e-05
-   0x1.76baa9c6d3eeddbcp-11   // 0.0007147391378143610789
-];
-
-static real LargeStirlingCoeffs[] = [
-	1.0L,
-	8.33333333333333333333E-2L,
-	3.47222222222222222222E-3L,
-	-2.68132716049382716049E-3L,
-	-2.29472093621399176955E-4L,
-	7.84039221720066627474E-4L,
-    6.97281375836585777429E-5L
+    0x1p+0,			//  1
+    0x1.a8f9faae5d8fc8b0p-2,	//  0.41501609505884554346
+   -0x1.cb7895a6756eebdep-3,	// -0.22435109056703291645
+   -0x1.7b9bab006d30652ap-5,	// -0.046338876712445342138
+    0x1.c671af78f312082ep-6,	//  0.027737065658400729792
+   -0x1.a11ebbfaf96252dcp-11,	// -0.00079559336824947383209
+   -0x1.447b4d2230a77ddap-10,	// -0.0012377992466531522311
+    0x1.ec1d45bb85e06696p-13,	//  0.00023465840591606352443
+   -0x1.d4ce24d05bd0a8e6p-17	// -1.3971485174761704409e-05
 ];
 
 static real GammaSmallCoeffs[] = [
-   0x1p+0,	// 1
-   0x1.2788cfc6fb618f52p-1,	// 0.57721566490153286082
+    0x1p+0,			//  1
+    0x1.2788cfc6fb618f52p-1,	//  0.57721566490153286082
    -0x1.4fcf4026afa2f7ecp-1,	// -0.65587807152025406846
    -0x1.5815e8fa24d7e306p-5,	// -0.042002635034033440541
-   0x1.5512320aea2ad71ap-3,	// 0.16653861137208052067
-   -0x1.59af0fb9d82e216p-5,	// -0.042197733607059154702
+    0x1.5512320aea2ad71ap-3,	//  0.16653861137208052067
+   -0x1.59af0fb9d82e2160p-5,	// -0.042197733607059154702
    -0x1.3b4b61d3bfdf244ap-7,	// -0.0096220233604062716456
-   0x1.d9358e9d9d69fd34p-8,	// 0.0072205994780369096722
+    0x1.d9358e9d9d69fd34p-8,	//  0.0072205994780369096722
    -0x1.38fc4bcbada775d6p-10 	// -0.0011939450513815100956
 ];
 
 static real GammaSmallNegCoeffs[] = [
-   -0x1p+0,	// -1
-   0x1.2788cfc6fb618f54p-1,	// 0.57721566490153286086
-   0x1.4fcf4026afa2bc4cp-1,	// 0.65587807152025365473
+   -0x1p+0,			// -1
+    0x1.2788cfc6fb618f54p-1,	//  0.57721566490153286086
+    0x1.4fcf4026afa2bc4cp-1,	//  0.65587807152025365473
    -0x1.5815e8fa2468fec8p-5,	// -0.042002635034021129105
    -0x1.5512320baedaf4b6p-3,	// -0.16653861139444135193
    -0x1.59af0fa283baf07ep-5,	// -0.042197733437311917216
-   0x1.3b4a70de31e05942p-7,	// 0.0096219111550359767339
-   0x1.d9398be3bad13136p-8,	// 0.0072208372618931703258
-   0x1.291b73ee05bcbba2p-10 	// 0.001133374167243894382
+    0x1.3b4a70de31e05942p-7,	//  0.0096219111550359767339
+    0x1.d9398be3bad13136p-8,	//  0.0072208372618931703258
+    0x1.291b73ee05bcbba2p-10 	//  0.001133374167243894382
 ];
 
 static real logGammaStirlingCoeffs[] = [
-   0x1.5555555555553f98p-4,	// 0.083333333333333314473
-   -0x1.6c16c16c07509b1p-9,	// -0.0027777777777503496034
-   0x1.a01a012461cbf1e4p-11,	// 0.00079365077958550707556
-   -0x1.3813089d3f9d164p-11,	// -0.00059523458517656885149
-   0x1.b911a92555a277b8p-11,	// 0.00084127232973224980805
+    0x1.5555555555553f98p-4,	//  0.083333333333333314473
+   -0x1.6c16c16c07509b10p-9,	// -0.0027777777777503496034
+    0x1.a01a012461cbf1e4p-11,	//  0.00079365077958550707556
+   -0x1.3813089d3f9d1640p-11,	// -0.00059523458517656885149
+    0x1.b911a92555a277b8p-11,	//  0.00084127232973224980805
    -0x1.ed0a7b4206087b22p-10,	// -0.0018808019381193769072
-   0x1.402523859811b308p-8 	// 0.0048850261424322707812
+    0x1.402523859811b308p-8 	//  0.0048850261424322707812
 ];
 
 static real logGammaNumerator[] = [
@@ -112,34 +95,58 @@
    -0x1.301303b99a614a0ap+19,	// -622744.11640662195015
    -0x1.09e76ab41ae965p+15,	// -34035.708405343046707
    -0x1.00f95ced9e5f54eep+9,	// -513.94814844353701437
-   0x1p+0 	// 1
+    0x1p+0 			// 1
 ];
 
-/*
-Helper function: Gamma function computed by Stirling's formula.
+/* ****************************************************
+ * Helper function: Gamma function computed by Stirling's formula.
+ *
+ * Stirling's formula for the gamma function is:
+ *
+ * $(GAMMA)(x) = sqrt(2 &pi;) x<sup>x-0.5</sup> exp(-x) (1 + 1/x P(1/x))
+ *
+ */
+private real gammaStirling(real x)
+{
+    static real SmallStirlingCoeffs[] = [
+        0x1.55555555555543aap-4,   //  0.083333333333333318004
+        0x1.c71c71c720dd8792p-9,   //  0.0034722222222300753277
+       -0x1.5f7268f0b5907438p-9,   // -0.0026813271618763044182
+       -0x1.e13cd410e0477de6p-13,  // -0.00022947197478731854057
+        0x1.9b0f31643442616ep-11,  //  0.00078403348427447530038
+        0x1.2527623a3472ae08p-14,  //  6.9893322606231931717e-05
+       -0x1.37f6bc8ef8b374dep-11,  // -0.00059502375540563301557
+       -0x1.8c968886052b872ap-16,  // -2.3638488095017590616e-05
+        0x1.76baa9c6d3eeddbcp-11   //  0.0007147391378143610789
+    ];
 
-Stirling's formula for the gamma function is:
+    static real LargeStirlingCoeffs[] = [
+	 1.0L,
+	 8.33333333333333333333E-2L,
+	 3.47222222222222222222E-3L,
+	-2.68132716049382716049E-3L,
+	-2.29472093621399176955E-4L,
+	 7.84039221720066627474E-4L,
+	 6.97281375836585777429E-5L
+    ];
 
-$(GAMMA)(x) = sqrt(2 &pi;) x<sup>x-0.5</sup> exp(-x) (1 + 1/x P(1/x))
-
-*/
-real gammaStirling(real x)
-{
-	real w = 1.0L/x;
-	real y = exp(x);
-	if ( x > 1024.0L ) {
-		// For large x, use rational coefficients from the analytical expansion.
-		w = poly(w, LargeStirlingCoeffs);
-		// Avoid overflow in pow()
-		real v = pow( x, 0.5L * x - 0.25L );
-		y = v * (v / y);
-	}
-	else {
-		w = 1.0L + w * poly( w, SmallStirlingCoeffs);
-		y = pow( x, x - 0.5L ) / y;
-	}
-	y = SQRT2PI * y * w;
-	return  y;
+    real w = 1.0L / x;
+    real y = exp(x);
+    if (x > 1024.0L)
+    {
+	// For large x, use rational coefficients from the analytical expansion.
+	w = poly(w, LargeStirlingCoeffs);
+	// Avoid overflow in pow()
+	real v = pow( x, 0.5L * x - 0.25L );
+	y = v * (v / y);
+    }
+    else
+    {
+	w = 1.0L + w * poly(w, SmallStirlingCoeffs);
+	y = pow( x, x - 0.5L ) / y;
+    }
+    y = SQRT2PI * y * w;
+    return  y;
 }
 
 /*****************************************************
@@ -170,106 +177,126 @@
  */
 real tgamma(real x)
 {
-/* Author: Don Clugston. Based on code from the CEPHES library.
- *
- * Arguments |x| <= 13 are reduced by recurrence and the function
- * approximated by a rational function of degree 7/8 in the
- * interval (2,3).  Large arguments are handled by Stirling's
- * formula. Large negative arguments are made positive using
- * a reflection formula. 
- */ 
+    /* Author: Don Clugston. Based on code from the CEPHES library.
+     *
+     * Arguments |x| <= 13 are reduced by recurrence and the function
+     * approximated by a rational function of degree 7/8 in the
+     * interval (2,3).  Large arguments are handled by Stirling's
+     * formula. Large negative arguments are made positive using
+     * a reflection formula. 
+     */ 
 
-	real q, z;
-	if (isnan(x)) return x;
-	if (x==-x.infinity) return real.nan;
-	if ( fabs(x) > MAXGAMMA ) return real.infinity;
-	if (x==0) return 1.0/x; // +- infinity depending on sign of x, create an exception.
-	
-	q = fabs(x);
-		
-	if ( q > 13.0L )	{
-		// Large arguments are handled by Stirling's
-		// formula. Large negative arguments are made positive using
-		// the reflection formula.  
-	
-		if ( x < 0.0L )	{
-			int sgngam = 1; // sign of gamma.
-			real p  = floor(q);
-			if ( p == q ) return real.nan; // poles for all integers <0.
-			int intpart = cast(int)(p);
-			if ( (intpart & 1) == 0 )
-				sgngam = -1;
-			z = q - p;
-			if ( z > 0.5L )	{
-				p += 1.0L;
-				z = q - p;
-			}
-			z = q * sin( PI * z );
-			z = fabs(z) * gammaStirling(q);
-			if ( z <= PI/real.max ) return sgngam * real.infinity;
-			return sgngam * PI/z;
-		} else {
-			return gammaStirling(x);
-		}
+    real q, z;
+
+    if (isnan(x))
+	return x;
+    if (x == -x.infinity)
+	return real.nan;
+    if ( fabs(x) > MAXGAMMA )
+	return real.infinity;
+    if (x == 0)
+	return 1.0 / x; // +- infinity depending on sign of x, create an exception.
+    
+    q = fabs(x);
+	    
+    if ( q > 13.0L )
+    {
+	// Large arguments are handled by Stirling's
+	// formula. Large negative arguments are made positive using
+	// the reflection formula.  
+
+	if ( x < 0.0L )
+	{
+	    int sgngam = 1;	// sign of gamma.
+	    real p  = floor(q);
+	    if ( p == q )
+		return real.nan; // poles for all integers <0.
+	    int intpart = cast(int)(p);
+	    if ( (intpart & 1) == 0 )
+		    sgngam = -1;
+	    z = q - p;
+	    if ( z > 0.5L )
+	    {
+		p += 1.0L;
+		z = q - p;
+	    }
+	    z = q * sin( PI * z );
+	    z = fabs(z) * gammaStirling(q);
+	    if ( z <= PI / real.max )
+		return sgngam * real.infinity;
+	    return sgngam * PI / z;
 	}
-	
-	// Arguments |x| <= 13 are reduced by recurrence and the function
-	// approximated by a rational function of degree 7/8 in the
-	// interval (2,3).
+	else
+	    return gammaStirling(x);
+    }
+    
+    // Arguments |x| <= 13 are reduced by recurrence and the function
+    // approximated by a rational function of degree 7/8 in the
+    // interval (2,3).
 
-	z = 1.0L;
-	while ( x >= 3.0L )	{
-		x -= 1.0L;
-		z *= x;
+    z = 1.0L;
+    while ( x >= 3.0L )
+    {
+	x -= 1.0L;
+	z *= x;
+    }
+    
+    while ( x < -0.03125L )
+    {
+	z /= x;
+	x += 1.0L;
+    }
+    
+    if ( x <= 0.03125L )
+    {
+	if ( x == 0.0L )
+	    return real.nan;
+	else if ( x < 0.0L )
+	{
+	    x = -x;
+	    return z / (x * poly( x, GammaSmallNegCoeffs ));
 	}
-	
-	while ( x < -0.03125L ) {
-		z /= x;
-		x += 1.0L;
+	else
+	{
+	    return z / (x * poly( x, GammaSmallCoeffs ));
 	}
-	
-	if ( x <= 0.03125L ) {
-		if ( x == 0.0L ) return real.nan;
-		else {
-			if ( x < 0.0L )	{
-				x = -x;
-				return z / (x * poly( x, GammaSmallNegCoeffs ));
-			} else {
-				return z / (x * poly( x, GammaSmallCoeffs ));
-			}
-		}
-	}
-	
-	while ( x < 2.0L ) {
-		z /= x;
-		x += 1.0L;
-	}
-	if ( x == 2.0L ) return z;
-	
-	x -= 2.0L;
-	return z * poly( x, GammaNumeratorCoeffs ) / poly( x, GammaDenominatorCoeffs );
+    }
+    
+    while ( x < 2.0L )
+    {
+	z /= x;
+	x += 1.0L;
+    }
+    if ( x == 2.0L )
+	return z;
+    
+    x -= 2.0L;
+    return z * poly( x, GammaNumeratorCoeffs ) / poly( x, GammaDenominatorCoeffs );
 }
 
 version(X86) // requires feqrel
-unittest {
-	// gamma(n) = factorial(n-1) if n is an integer.
-	double fact=1.0L;
-	for (int i=1; fact<real.max; ++i) {
-	  // Require exact equality for small factorials
-	  if (i<14) assert(tgamma(i*1.0L)==fact);
-	  assert(feqrel(tgamma(i * 1.0L), cast(real)fact) > real.mant_dig - 15);
-	  //writefln(i, " %a ---> %a   %a ", i*1.0L, tgamma(i*1.0L), fact, feqrel(tgamma(i*1.0L), fact));
-	  fact*=(i*1.0L);
-	}
-	assert(tgamma(0.0)==real.infinity);
-	assert(tgamma(-0.0)==-real.infinity);
-	assert(isnan(tgamma(-1.0)));
-	assert(isnan(tgamma(real.nan)));
-	assert(tgamma(real.infinity)==real.infinity);
-	assert(isnan(tgamma(-real.infinity)));
-	assert(tgamma(real.min*real.epsilon)==real.infinity);
-	
-	assert(feqrel(tgamma(0.5),sqrt(PI))>real.mant_dig-3);
+unittest
+{
+    // gamma(n) = factorial(n-1) if n is an integer.
+    double fact = 1.0L;
+    for (int i = 1; fact < real.max; ++i)
+    {
+	// Require exact equality for small factorials
+	if (i < 14)
+	    assert(tgamma(i * 1.0L)==fact);
+	assert(feqrel(tgamma(i * 1.0L), cast(real)fact) > real.mant_dig - 15);
+	//writefln(i, " %a ---> %a   %a ", i*1.0L, tgamma(i * 1.0L), fact, feqrel(tgamma(i*1.0L), fact));
+	fact *= (i * 1.0L);
+    }
+    assert(tgamma(0.0) == real.infinity);
+    assert(tgamma(-0.0) == -real.infinity);
+    assert(isnan(tgamma(-1.0)));
+    assert(isnan(tgamma(real.nan)));
+    assert(tgamma(real.infinity) == real.infinity);
+    assert(isnan(tgamma(-real.infinity)));
+    assert(tgamma(real.min * real.epsilon) == real.infinity);
+
+    assert(feqrel(tgamma(0.5), sqrt(PI)) > real.mant_dig - 3);
 }
 
 /*****************************************************
@@ -292,227 +319,167 @@
  */
 real lgamma(real x)
 {
-	/* Author: Don Clugston. Based on code from the CEPHES library.
-	 *
-	 * For arguments greater than 33, the logarithm of the gamma
-	 * function is approximated by the logarithmic version of
-	 * Stirling's formula using a polynomial approximation of
-	 * degree 4. Arguments between -33 and +33 are reduced by
-	 * recurrence to the interval [2,3] of a rational approximation.
-	 * The cosecant reflection formula is employed for arguments
-	 * less than -33.
-	 */
-	real p, q, w, z, f, nx;
-	
-	if (isnan(x)) return x;
-	if (fabs(x)==x.infinity) return x.infinity;
-	
-	if( x < -34.0L ) {
-		q = -x;
-		w = lgamma(q);
-		real p = floor(q);
-		if ( p == q ) return real.infinity;
-		int intpart = cast(int)(p);
-		real sgngam = 1;
-		if ( (intpart & 1) == 0 )
-			sgngam = -1;
-		z = q - p;
-		if ( z > 0.5L ) {
-			p += 1.0L;
-			z = p - q;
+    /* Author: Don Clugston. Based on code from the CEPHES library.
+     *
+     * For arguments greater than 33, the logarithm of the gamma
+     * function is approximated by the logarithmic version of
+     * Stirling's formula using a polynomial approximation of
+     * degree 4. Arguments between -33 and +33 are reduced by
+     * recurrence to the interval [2,3] of a rational approximation.
+     * The cosecant reflection formula is employed for arguments
+     * less than -33.
+     */
+    real q, w, z, f, nx;
+    
+    if (isnan(x))
+	return x;
+    if (fabs(x) == x.infinity)
+	return x.infinity;
+    
+    if ( x < -34.0L )
+    {
+	q = -x;
+	w = lgamma(q);
+	real p = floor(q);
+	if ( p == q )
+	    return real.infinity;
+	int intpart = cast(int)(p);
+	real sgngam = 1;
+	if ( (intpart & 1) == 0 )
+	    sgngam = -1;
+	z = q - p;
+	if ( z > 0.5L )
+	{
+	    p += 1.0L;
+	    z = p - q;
+	}
+	z = q * sin( PI * z );
+	if ( z == 0.0L )
+	    return sgngam * real.infinity;
+	/* z = LOGPI - logl( z ) - w; */
+	z = log( PI / z ) - w;
+	return z;
+    }
+
+    if ( x < 13.0L )
+    {
+	z = 1.0L;
+	nx = floor( x +  0.5L );
+	f = x - nx;
+	while ( x >= 3.0L )
+	{
+	    nx -= 1.0L;
+	    x = nx + f;
+	    z *= x;
+	}
+	while ( x < 2.0L )
+	{
+	    if( fabs(x) <= 0.03125 )
+	    {
+		if ( x == 0.0L )
+		    return real.infinity;
+		if ( x < 0.0L )
+		{
+		    x = -x;
+		    q = z / (x * poly( x, GammaSmallNegCoeffs));
 		}
-		z = q * sin( PI * z );
-		if ( z == 0.0L ) return sgngam * real.infinity;
-	/*	z = LOGPI - logl( z ) - w; */
-		z = log( PI/z ) - w;
-		return( z );
+		else
+		    q = z / (x * poly( x, GammaSmallCoeffs));
+		return log( fabs(q) );
+	    }			
+	    z /= nx +  f;
+	    nx += 1.0L;
+	    x = nx + f;
 	}
+	z = fabs(z);
+	if ( x == 2.0L )
+	    return log(z);
+	x = (nx - 2.0L) + f;
+	real p = x * poly( x, logGammaNumerator ) / poly( x, logGammaDenominator);
+	return ( log(z) + p );
+    }
+    
+    //const real MAXLGM = 1.04848146839019521116e+4928L;
+    //if ( x > MAXLGM ) return sgngaml * real.infinity;
 
-	if( x < 13.0L )	{
-		z = 1.0L;
-		nx = floor( x +  0.5L );
-		f = x - nx;
-		while ( x >= 3.0L ) {
-			nx -= 1.0L;
-			x = nx + f;
-			z *= x;
-		}
-		while ( x < 2.0L ) {
-			if( fabs(x) <= 0.03125 ) {
-					if ( x == 0.0L ) return real.infinity;
-					if ( x < 0.0L ) {
-						x = -x;
-						q = z / (x * poly( x, GammaSmallNegCoeffs));
-					} else
-						q = z / (x * poly( x, GammaSmallCoeffs));
-					return log( fabs(q) );
-			}			
-			z /= nx +  f;
-			nx += 1.0L;
-			x = nx + f;
-			}
-		z = fabs(z);
-		if ( x == 2.0L )
-			return log(z);
-		x = (nx - 2.0L) + f;
-		p = x * poly( x, logGammaNumerator ) / poly( x, logGammaDenominator);
-		return ( log(z) + p );
-	}
-	
-    //const real MAXLGM = 1.04848146839019521116e+4928L;
-    //	if( x > MAXLGM ) return sgngaml * real.infinity;
-
-	/* log( sqrt( 2*pi ) ) */
-	const real LOGSQRT2PI  =  0.91893853320467274178L;
-	
-	q = ( x - 0.5L ) * log(x) - x + LOGSQRT2PI;
-	if (x > 1.0e10L) return q;
-	p = 1.0L/(x*x);
-	q += poly( p, logGammaStirlingCoeffs ) / x;
-	return q ;
+    /* log( sqrt( 2*pi ) ) */
+    const real LOGSQRT2PI  =  0.91893853320467274178L;
+    
+    q = ( x - 0.5L ) * log(x) - x + LOGSQRT2PI;
+    if (x > 1.0e10L) return q;
+    real p = 1.0L/(x*x);
+    q += poly( p, logGammaStirlingCoeffs ) / x;
+    return q ;
 }
 
 version(X86) // requires feqrel
-unittest {
+unittest
+{
     // return true if x is +0.0
     bit isPosZero(real x)
     {
        return (x==0) && (signbit(x)==0);
     }
 
-  assert(isnan(lgamma(real.nan)));
-  assert(lgamma(real.infinity)==real.infinity);
-  assert(lgamma(-1.0)==real.infinity);
-  assert(lgamma(0.0)==real.infinity);
-  assert(isPosZero(lgamma(1.0L)));
-  assert(isPosZero(lgamma(2.0L)));
+    assert(isnan(lgamma(real.nan)));
+    assert(lgamma(real.infinity) == real.infinity);
+    assert(lgamma(-1.0) == real.infinity);
+    assert(lgamma(0.0) == real.infinity);
+    assert(isPosZero(lgamma(1.0L)));
+    assert(isPosZero(lgamma(2.0L)));
  
-  // x, correct loggamma(x), correct d/dx loggamma(x).
-  static real[] testpoints = [ 
-    8.0L,                    8.525146484375L      + 1.48766904143001655310E-5,   2.01564147795560999654E0L,
-	8.99993896484375e-1L,    6.6375732421875e-2L  + 5.11505711292524166220E-6L, -7.54938684259372234258E-1,
-    7.31597900390625e-1L,    2.2369384765625e-1   + 5.21506341809849792422E-6L, -1.13355566660398608343E0L,
-    2.31639862060546875e-1L, 1.3686676025390625L  + 1.12609441752996145670E-5L, -4.56670961813812679012E0,
-    1.73162841796875L,      -8.88214111328125e-2L + 3.36207740803753034508E-6L, 2.33339034686200586920E-1L,
-    1.23162841796875L,      -9.3902587890625e-2L  + 1.28765089229009648104E-5L, -2.49677345775751390414E-1L,
-    7.3786976294838206464e19L,   3.301798506038663053312e21L - 1.656137564136932662487046269677E5L,
+    // x, correct loggamma(x), correct d/dx loggamma(x).
+    static real[] testpoints =
+    [ 
+	 8.0L,                    8.525146484375L      + 1.48766904143001655310E-5,   2.01564147795560999654E0L,
+	 8.99993896484375e-1L,    6.6375732421875e-2L  + 5.11505711292524166220E-6L, -7.54938684259372234258E-1,
+	 7.31597900390625e-1L,    2.2369384765625e-1   + 5.21506341809849792422E-6L, -1.13355566660398608343E0L,
+	 2.31639862060546875e-1L, 1.3686676025390625L  + 1.12609441752996145670E-5L, -4.56670961813812679012E0,
+	 1.73162841796875L,      -8.88214111328125e-2L + 3.36207740803753034508E-6L, 2.33339034686200586920E-1L,
+	 1.23162841796875L,      -9.3902587890625e-2L  + 1.28765089229009648104E-5L, -2.49677345775751390414E-1L,
+	 7.3786976294838206464e19L,   3.301798506038663053312e21L - 1.656137564136932662487046269677E5L,
                           4.57477139169563904215E1L,
-    1.08420217248550443401E-19L, 4.36682586669921875e1L + 1.37082843669932230418E-5L,
+	 1.08420217248550443401E-19L, 4.36682586669921875e1L + 1.37082843669932230418E-5L,
                          -9.22337203685477580858E18L,
-//    1.0L, 0.0L, -5.77215664901532860607E-1L,
-//    2.0L, 0.0L, 4.22784335098467139393E-1L,
-    -0.5L,  1.2655029296875L    + 9.19379714539648894580E-6L, 3.64899739785765205590E-2L,
-    -1.5L,  8.6004638671875e-1L + 6.28657731014510932682E-7L, 7.03156640645243187226E-1L,
-    -2.5L, -5.6243896484375E-2L + 1.79986700949327405470E-7,  1.10315664064524318723E0L,
-    -3.5L,  -1.30902099609375L  + 1.43111007079536392848E-5L, 1.38887092635952890151E0L
-   ];
-   // TODO: test derivatives as well.
-	for (int i=0; i<testpoints.length; i+=3) {
-	//   writefln("%a  %a  ", lgamma(testpoints[i]), testpoints[i+1], feqrel(lgamma(testpoints[i]), testpoints[i+1]));
-		 assert( feqrel(lgamma(testpoints[i]), testpoints[i+1]) > real.mant_dig-5);
-	 }
+//	 1.0L, 0.0L, -5.77215664901532860607E-1L,
+//	 2.0L, 0.0L, 4.22784335098467139393E-1L,
+	-0.5L,  1.2655029296875L    + 9.19379714539648894580E-6L, 3.64899739785765205590E-2L,
+	-1.5L,  8.6004638671875e-1L + 6.28657731014510932682E-7L, 7.03156640645243187226E-1L,
+	-2.5L, -5.6243896484375E-2L + 1.79986700949327405470E-7,  1.10315664064524318723E0L,
+	-3.5L,  -1.30902099609375L  + 1.43111007079536392848E-5L, 1.38887092635952890151E0L
+    ];
 
-	static real logabsgamma(real x)
-	{
-	 // For poles, tgamma(x) returns nan, but lgamma() returns infinity.
-	  if (x<0 && x==floor(x)) return real.infinity;
-	  return log(fabs(tgamma(x)));
-	}
-	static real exploggamma(real x)
-	{
-	  return exp(lgamma(x));
-	}
-	static real absgamma(real x)
-	{
-	  if (x<0 && x==floor(x)) return real.infinity;
-	  return fabs(tgamma(x));
-	}
+    // TODO: test derivatives as well.
 
-  // Check that loggamma(x) = log(gamma(x)) provided x is not -1, -2, -3, ...
-  //assert(consistencyTwoFuncs(&lgamma, &logabsgamma, -1000, 1700) > real.mant_dig-7);
-  //assert(consistencyTwoFuncs(&exploggamma, &absgamma, -2000, real.infinity) > real.mant_dig-16);
+    for (int i=0; i<testpoints.length; i+=3)
+    {
+	//writefln("%a  %a  ", lgamma(testpoints[i]), testpoints[i+1], feqrel(lgamma(testpoints[i]), testpoints[i+1]));
+	 assert( feqrel(lgamma(testpoints[i]), testpoints[i+1]) > real.mant_dig-5);
+    }
+
+    static real logabsgamma(real x)
+    {
+	// For poles, tgamma(x) returns nan, but lgamma() returns infinity.
+	if (x < 0 && x == floor(x))
+	    return real.infinity;
+	return log(fabs(tgamma(x)));
+    }
+
+    static real exploggamma(real x)
+    {
+	return exp(lgamma(x));
+    }
+
+    static real absgamma(real x)
+    {
+	if (x < 0 && x == floor(x))
+	    return real.infinity;
+	return fabs(tgamma(x));
+    }
+
+    // Check that loggamma(x) = log(gamma(x)) provided x is not -1, -2, -3, ...
+    //assert(consistencyTwoFuncs(&lgamma, &logabsgamma, -1000, 1700) > real.mant_dig-7);
+    //assert(consistencyTwoFuncs(&exploggamma, &absgamma, -2000, real.infinity) > real.mant_dig-16);
 }
 
-/**
-  Test the consistency of a real function which can be calculated in two ways.
   
-  Returns the worst (minimum) value of feqrel(firstfunc(x), secondfunc(x)) 
-  for all x in the domain.
-  
-Params:
-        firstfunc, secondfunc   Functions to be compared
-        domain        A sequence of pairs of numbers giving the first and last
-points which are valid for the function.
-eg. (-real.infinity, real.infinity) ==> valid everywhere
-    (-real.infinity, -real.min, real.min, real.infinity) ==> valid for x!=0.
- Returns:
-    number of bits for which firstfunc(x) and secondfunc(x) are equal for
-    every point x in the domain.
-    -1 = at least one point is wrong by a factor of 2 or more.
-*/
-version(X86) // requires feqrel
-int consistencyTwoFuncs(real function (real) firstfunc, 
-                    real function (real) secondfunc, real [] domain ...)
-{
-   /*  Author: Don Clugston. License: Public Domain
-   */
-      assert(domain.length>=2); // must have at least one valid range
-      assert((domain.length & 1) == 0); // must have even number of endpoints.
-                                      
-      int worsterror=real.mant_dig+1;
-      real worstx=domain[0]; // where does the biggest discrepancy occur?
-      
-      void testPoint(real x) {
-         for (int i=0; i<domain.length; i+=2) {
-            if (x>=domain[i] && x<=domain[i+1]) {
-				int u=feqrel(secondfunc(x), firstfunc(x));
-				if (u<worsterror) { worsterror=u;  worstx=x; }
-				return;
-		     }
-		 }
-      }
-      // test the edges of the domains
-      foreach(real y; domain) testPoint(y);
-      real x = 1.01;
-	  // first, go from 1 to infinity
-	  for (x=1.01; x!=x.infinity; x*=2.83) testPoint(x);
-	  // then from 1 to +0
-	  for (x=0.98; x!=0; x*=0.401) testPoint(x);
-	  // from -1 to -0
-	  for (x=-0.93; x!=0; x*=0.403) testPoint(x);
-	  // from -1 to -infinity
-	  for (x=-1.09; x!=-x.infinity; x*=2.97) testPoint(x);
-//    writefln("Worst error is ", worsterror, " at x= ", worstx, " Func1=%a, Func2=%a", firstfunc(worstx), secondfunc(worstx));
-	  return worsterror;
-}
-
-/**
- Test the consistency of a real function which has an inverse.
- Returns: the worst (minimum) value of feqrel(x, inversefunc(forwardfunc(x))) 
- for all x in the domain.
-*/
-version(X86) // requires feqrel
-int consistencyRealInverse(real function (real) forwardfunc, 
-                    real function (real) inversefunc, real [] domain ...)
-{
- // HACK: should use proper function composition instead
-  static real function (real) fwd;
-  static real function (real) inv;
-  static real unity(real x) { return x; }
-  static real inverter(real x){ return inv(fwd(x)); }
-  fwd = forwardfunc;
-  inv=inversefunc;
-  return consistencyTwoFuncs(&unity, &inverter, domain);
-}
-
-// return true if x is -0.0
-bit isNegZero(real x)
-{
-   return (x==0) && (signbit(x)==1);
-}
-
-// return true if x is +0.0
-bit isPosZero(real x)
-{
-   return (x==0) && (signbit(x)==0);
-}
diff -r 6a92bcae44c5 d/phobos/gcstats.d
--- a/d/phobos/gcstats.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/gcstats.d	Sat Jun 26 21:05:08 2010 +0100
@@ -8,7 +8,7 @@
     size_t poolsize;		// total size of pool
     size_t usedsize;		// bytes allocated
     size_t freeblocks;		// number of blocks marked FREE
-    size_t freelistsize;		// total of memory on free lists
+    size_t freelistsize;	// total of memory on free lists
     size_t pageblocks;		// number of blocks marked PAGE
 }
 
diff -r 6a92bcae44c5 d/phobos/internal/aaA.d
--- a/d/phobos/internal/aaA.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/aaA.d	Sat Jun 26 21:05:08 2010 +0100
@@ -6,7 +6,7 @@
  */
 
 /*
- *  Copyright (C) 2000-2007 by Digital Mars, www.digitalmars.com
+ *  Copyright (C) 2000-2008 by Digital Mars, http://www.digitalmars.com
  *  Written by Walter Bright
  *
  *  This software is provided 'as-is', without any express or implied
@@ -47,13 +47,14 @@
 // Auto-rehash and pre-allocate - Dave Fladebo
 
 static size_t[] prime_list = [
-    97UL,         389UL,
-    1543UL,       6151UL,
-    24593UL,      98317UL,
-    393241UL,     1572869UL,
-    6291469UL,    25165843UL,
-    100663319UL,  402653189UL,
-    1610612741UL, 4294967291UL
+               97UL,            389UL,
+            1_543UL,          6_151UL,
+           24_593UL,         98_317UL,
+          393_241UL,      1_572_869UL,
+        6_291_469UL,     25_165_843UL,
+      100_663_319UL,    402_653_189UL,
+    1_610_612_741UL,  4_294_967_291UL,
+//    8_589_934_513UL, 17_179_869_143UL
 ];
 
 /* This is the type of the return value for dynamic arrays.
@@ -280,7 +281,7 @@
 	//printf("create new one\n");
 	std.gc.disable();
 	e = cast(aaA *) cast(void*) new void[aaA.sizeof + keysize + valuesize];
-	std.gc.enable;
+	std.gc.enable();
 	memcpy(e + 1, pkey, keysize);
 	e.hash = key_hash;
 	*pe = e;
@@ -588,59 +589,59 @@
 	}
 	return *paa;
     }
-    
+
 /********************************************
  * Balance an array.
  */
- 
+
  /+void _aaBalance(AA* paa)
- {
-     //printf("_aaBalance()\n");
-     if (paa.a)
-     {
- 	aaA*[16] tmp;
- 	aaA*[] array = tmp;
- 
- 	auto aa = paa.a;
- 	foreach (j, e; aa.b)
- 	{
- 	    /* Temporarily store contents of bucket in array[]
+{
+    //printf("_aaBalance()\n");
+    if (paa.a)
+    {
+	aaA*[16] tmp;
+	aaA*[] array = tmp;
+
+	auto aa = paa.a;
+	foreach (j, e; aa.b)
+	{
+	    /* Temporarily store contents of bucket in array[]
 	     */
- 	    size_t k = 0;
- 
- 	    void addToArray(aaA* e)
- 	    {
- 		while (e)
- 		{   addToArray(e.left);
- 		    if (k == array.length)
- 			array.length = array.length * 2;
- 		    array[k++] = e;
- 		    e = e.right;
- 		}
- 	    }
- 
- 	    addToArray(e);
- 
+	    size_t k = 0;
+
+	    void addToArray(aaA* e)
+	    {
+		while (e)
+		{   addToArray(e.left);
+		    if (k == array.length)
+			array.length = array.length * 2;
+		    array[k++] = e;
+		    e = e.right;
+		}
+	    }
+
+	    addToArray(e);
+
 	    /* The contents of the bucket are now sorted into array[].
 	     * Rebuild the tree.
 	     */
- 
- 	    void buildTree(aaA** p, size_t x1, size_t x2)
- 	    {
- 		if (x1 >= x2)
- 		    *p = null;
- 		else
- 		{   auto mid = (x1 + x2) >> 1;
- 		    *p = array[mid];
- 		    buildTree(&(*p).left, x1, mid);
- 		    buildTree(&(*p).right, mid + 1, x2);
- 		}
- 	    }
- 
- 	    auto p = &aa.b[j];
- 	    buildTree(p, 0, k);
- 	}
-     }
+
+	    void buildTree(aaA** p, size_t x1, size_t x2)
+	    {
+		if (x1 >= x2)
+		    *p = null;
+		else
+		{   auto mid = (x1 + x2) >> 1;
+		    *p = array[mid];
+		    buildTree(&(*p).left, x1, mid);
+		    buildTree(&(*p).right, mid + 1, x2);
+		}
+	    }
+
+	    auto p = &aa.b[j];
+	    buildTree(p, 0, k);
+	}
+    }
  }+/
 
 
@@ -815,15 +816,13 @@
     BB* result;
 
     //printf("_d_assocarrayliteralT(keysize = %d, valuesize = %d, length = %d)\n", keysize, valuesize, length);
-    //writefln("tivalue = %s", ti.next.classinfo.name);
+    //printf("tivalue = %.*s\n", ti.next.classinfo.name);
     if (length == 0 || valuesize == 0 || keysize == 0)
     {
 	;
     }
     else
     {
-	//va_list q;
-	//va_start!(size_t)(q, length);
 	void * qkey = keys;
 	void * qval = values;
 
@@ -845,10 +844,8 @@
 
 	for (size_t j = 0; j < length; j++)
 	{   void* pkey = qkey;
-	    //q += keystacksize;
 	    qkey += keysize;
 	    void* pvalue = qval;
-	    //q += valuestacksize;
 	    qval += valuesize;
 	    aaA* e;
 
diff -r 6a92bcae44c5 d/phobos/internal/adi.d
--- a/d/phobos/internal/adi.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/adi.d	Sat Jun 26 21:05:08 2010 +0100
@@ -650,14 +650,14 @@
 }
 
 extern (C) int _adEq2(Array a1, Array a2, TypeInfo ti)
- {
-     //printf("_adEq2(a1.length = %d, a2.length = %d)\n", a1.length, a2.length);
-     if (a1.length != a2.length)
- 	return 0;		// not equal
-     if (!ti.equals(&a1, &a2))
- 	return 0;
-     return 1;
- }
+{
+    //printf("_adEq2(a1.length = %d, a2.length = %d)\n", a1.length, a2.length);
+    if (a1.length != a2.length)
+	return 0;		// not equal
+    if (!ti.equals(&a1, &a2))
+	return 0;
+    return 1;
+}
 
 unittest
 {
@@ -752,10 +752,10 @@
 }
 
 extern (C) int _adCmp2(Array a1, Array a2, TypeInfo ti)
- {
-     //printf("_adCmp2(a1.length = %d, a2.length = %d)\n", a1.length, a2.length);
-     return ti.compare(&a1, &a2);
- }
+{
+    //printf("_adCmp2(a1.length = %d, a2.length = %d)\n", a1.length, a2.length);
+    return ti.compare(&a1, &a2);
+}
 
 unittest
 {
diff -r 6a92bcae44c5 d/phobos/internal/alloca.d
--- a/d/phobos/internal/alloca.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/alloca.d	Sat Jun 26 21:05:08 2010 +0100
@@ -35,27 +35,27 @@
 	push	EBX		;
 	push	EDI		;
 	push	ESI		;
-	}
- 
-     version (OSX)
-     {
-     asm
-     {
- 	add	EAX,15		;
- 	and	EAX,0xFFFFFFF0	; // round up to 16 byte boundary
-     }
-     }
-     else
-     {
-     asm
-     {
-  	add	EAX,3		;
-  	and	EAX,0xFFFFFFFC	; // round up to dword
-     }
-     }
- 
-     asm
-     {
+    }
+
+    version (OSX)
+    {
+    asm
+    {
+	add	EAX,15		;
+	and	EAX,0xFFFFFFF0	; // round up to 16 byte boundary
+    }
+    }
+    else
+    {
+    asm
+    {
+	add	EAX,3		;
+	and	EAX,0xFFFFFFFC	; // round up to dword
+    }
+    }
+
+    asm
+    {
 	jnz	Abegin		;
 	mov	EAX,4		; // allow zero bytes allocation, 0 rounded to dword is 4..
     Abegin:
diff -r 6a92bcae44c5 d/phobos/internal/arraycat.d
--- a/d/phobos/internal/arraycat.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/arraycat.d	Sat Jun 26 21:05:08 2010 +0100
@@ -3,35 +3,16 @@
  */
 
 /*
- *  Copyright (C) 2004-2007 by Digital Mars, www.digitalmars.com
+ *  http://www.digitalmars.com
  *  Written by Walter Bright
- *
- *  This software is provided 'as-is', without any express or implied
- *  warranty. In no event will the authors be held liable for any damages
- *  arising from the use of this software.
- *
- *  Permission is granted to anyone to use this software for any purpose,
- *  including commercial applications, and to alter it and redistribute it
- *  freely, in both source and binary form, subject to the following
- *  restrictions:
- *
- *  o  The origin of this software must not be misrepresented; you must not
- *     claim that you wrote the original software. If you use this software
- *     in a product, an acknowledgment in the product documentation would be
- *     appreciated but is not required.
- *  o  Altered source versions must be plainly marked as such, and must not
- *     be misrepresented as being the original software.
- *  o  This notice may not be removed or altered from any source
- *     distribution.
+ *  Placed in the Public Domain
  */
-
 /* NOTE: This file has been patched from the original DMD distribution to
    work with the GDC compiler.
 
    Modified by David Friedman, November 2006
 */
 
- 
 module arraycat;
 
 import object;
diff -r 6a92bcae44c5 d/phobos/internal/critical.c
--- a/d/phobos/internal/critical.c	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/critical.c	Sat Jun 26 21:05:08 2010 +0100
@@ -91,7 +91,7 @@
 #if linux || __APPLE__
 // while the _NP version is specific to Linux
 #ifndef PTHREAD_MUTEX_RECURSIVE
-#define PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_RECURSIVE_NP
+#    define PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_RECURSIVE_NP
 #endif
 #endif
 
@@ -104,8 +104,6 @@
  * Enter/exit critical section.
  */
 
-
-
 /* We don't initialize critical sections unless we actually need them.
  * So keep a linked list of the ones we do use, and in the static destructor
  * code, walk the list and release them.
@@ -139,7 +137,7 @@
 	    dcs->next = dcs_list;
 	    dcs_list = dcs;
 #ifndef PTHREAD_MUTEX_ALREADY_RECURSIVE
-	    pthread_mutex_init(&dcs->cs, & _criticals_attr);
+	    pthread_mutex_init(&dcs->cs, &_criticals_attr);
 #else
 	    pthread_mutex_init(&dcs->cs, NULL);
 #endif
diff -r 6a92bcae44c5 d/phobos/internal/deh.c
--- a/d/phobos/internal/deh.c	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/deh.c	Sat Jun 26 21:05:08 2010 +0100
@@ -271,66 +271,61 @@
         case STATUS_STACK_OVERFLOW:
             pti = _d_create_exception_object(&_Class_9Exception, "Stack Overflow");
             break;
-            
+
         case STATUS_DATATYPE_MISALIGNMENT:
-             pti = _d_create_exception_object(&_Class_9Exception, "Datatype Misalignment");
-             break;
- 
+            pti = _d_create_exception_object(&_Class_9Exception, "Datatype Misalignment");
+            break;
+
         case STATUS_ARRAY_BOUNDS_EXCEEDED:
-             pti = _d_create_exception_object(&_Class_9Exception, "Array Bounds Exceeded");
-             break;
-             
+            pti = _d_create_exception_object(&_Class_9Exception, "Array Bounds Exceeded");
+            break;
+  
         case STATUS_FLOAT_INVALID_OPERATION:
-             pti = _d_create_exception_object(&_Class_9Exception, "Invalid Floating Point Operation");
-             break;
- 
- 		case STATUS_FLOAT_DENORMAL_OPERAND:
-             pti = _d_create_exception_object(&_Class_9Exception, "Floating Point Denormal Operand");
-             break;
- 
- 		case STATUS_FLOAT_INEXACT_RESULT:
-             pti = _d_create_exception_object(&_Class_9Exception, "Floating Point Inexact Result");
-             break;
- 
- 		case STATUS_FLOAT_OVERFLOW:
-             pti = _d_create_exception_object(&_Class_9Exception, "Floating Point Overflow");
-             break;
- 
- 		case STATUS_FLOAT_UNDERFLOW:
-             pti = _d_create_exception_object(&_Class_9Exception, "Floating Point Underflow");
-             break;
- 
- 		case STATUS_FLOAT_STACK_CHECK:
-             pti = _d_create_exception_object(&_Class_9Exception, "Floating Point Stack Check");
-             break;
- 
- 		case STATUS_PRIVILEGED_INSTRUCTION:
-             #if 0 // doesn't compile
+            pti = _d_create_exception_object(&_Class_9Exception, "Invalid Floating Point Operation");
+            break;
+
+		case STATUS_FLOAT_DENORMAL_OPERAND:
+            pti = _d_create_exception_object(&_Class_9Exception, "Floating Point Denormal Operand");
+            break;
+
+		case STATUS_FLOAT_INEXACT_RESULT:
+            pti = _d_create_exception_object(&_Class_9Exception, "Floating Point Inexact Result");
+            break;
+
+		case STATUS_FLOAT_OVERFLOW:
+            pti = _d_create_exception_object(&_Class_9Exception, "Floating Point Overflow");
+            break;
+
+		case STATUS_FLOAT_UNDERFLOW:
+            pti = _d_create_exception_object(&_Class_9Exception, "Floating Point Underflow");
+            break;
+
+		case STATUS_FLOAT_STACK_CHECK:
+            pti = _d_create_exception_object(&_Class_9Exception, "Floating Point Stack Check");
+            break;
+
+		case STATUS_PRIVILEGED_INSTRUCTION:
             if (*((unsigned char *)(exception_record->ExceptionAddress))==0xF4) { // HLT
-                pti = _d_create_exception_object(&_Class_5Error, "assert(0) or HLT instruction");
+                pti = _d_create_exception_object(&_Class_9Exception, "assert(0) or HLT instruction");
             } else {
-                pti = _d_create_exception_object(&_Class_5Error, "Privileged Instruction");
+                pti = _d_create_exception_object(&_Class_9Exception, "Privileged Instruction");
             }
-				#else
-            pti = _d_create_exception_object(&_Class_9Exception, "Privileged Instruction");
-				#endif
-             break;
- 
- 		case STATUS_ILLEGAL_INSTRUCTION:
-             pti = _d_create_exception_object(&_Class_9Exception, "Illegal Instruction");
-             break;
- /*
- 		case STATUS_INTEGER_OVERFLOW: // not supported on any x86 processor
- 		case STATUS_IN_PAGE_ERROR:
- 		case STATUS_INVALID_DISPOSITION:
- 		case STATUS_NONCONTINUABLE_EXCEPTION:
- 		case STATUS_BREAKPOINT:
- 		case STATUS_SINGLE_STEP:
- 		// In DMC, but not in Microsoft docs
+            break;
+
+		case STATUS_ILLEGAL_INSTRUCTION:
+            pti = _d_create_exception_object(&_Class_9Exception, "Illegal Instruction");
+            break;
+/*
+		case STATUS_INTEGER_OVERFLOW: // not supported on any x86 processor
+		case STATUS_IN_PAGE_ERROR:
+		case STATUS_INVALID_DISPOSITION:
+		case STATUS_NONCONTINUABLE_EXCEPTION:
+		case STATUS_BREAKPOINT:
+		case STATUS_SINGLE_STEP:
+		// In DMC, but not in Microsoft docs
 		case STATUS_GUARD_PAGE_VIOLATION:
- 		case STATUS_INVALID_HANDLE:
- */
-
+		case STATUS_INVALID_HANDLE:
+*/
         // convert all other exception codes into a Win32Exception
         default:
             pti = _d_create_exception_object(&_Class_9Exception, "Win32 Exception");
diff -r 6a92bcae44c5 d/phobos/internal/deh2.d
--- a/d/phobos/internal/deh2.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/deh2.d	Sat Jun 26 21:05:08 2010 +0100
@@ -285,38 +285,37 @@
 		// accesses all items on the stack as relative to EBP.
 
 		void *blockaddr = phi.finally_code;
-		
+
 		version (OSX)
- 		{
- 		    asm
- 		    {
- 			sub	ESP,4		;
- 			push	EBX		;
- 			mov	EBX,blockaddr	;
- 			push	EBP		;
- 			mov	EBP,regebp	;
- 			call	EBX		;
- 			pop	EBP		;
- 			pop	EBX		;
- 			add	ESP,4		;
- 		    }
- 		}
- 		else
- 		{
-
-		asm
 		{
-		    push	EBX		;
-		    mov		EBX,blockaddr	;
-		    push	EBP		;
-		    mov		EBP,regebp	;
-		    call	EBX		;
-		    pop		EBP		;
-		    pop		EBX		;
+		    asm
+		    {
+			sub	ESP,4		;
+			push	EBX		;
+			mov	EBX,blockaddr	;
+			push	EBP		;
+			mov	EBP,regebp	;
+			call	EBX		;
+			pop	EBP		;
+			pop	EBX		;
+			add	ESP,4		;
+		    }
+		}
+		else
+		{
+		    asm
+		    {
+			push	EBX		;
+			mov	EBX,blockaddr	;
+			push	EBP		;
+			mov	EBP,regebp	;
+			call	EBX		;
+			pop	EBP		;
+			pop	EBX		;
+		    }
 		}
 	    }
 	}
     }
-    }
 }
 
diff -r 6a92bcae44c5 d/phobos/internal/dmain2.d
--- a/d/phobos/internal/dmain2.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/dmain2.d	Sat Jun 26 21:05:08 2010 +0100
@@ -61,30 +61,30 @@
     int myebx;
 
     version (OSX)
-     {	/* OSX does not provide a way to get at the top of the
+    {	/* OSX does not provide a way to get at the top of the
 	 * stack, except for the magic value 0xC0000000.
 	 * But as far as the gc is concerned, argv is at the top
 	 * of the main thread's stack, so save the address of that.
 	 */
- 	__osx_stack_end = cast(void*)&argv;
-     }
-     
-     version (FreeBSD)
+	__osx_stack_end = cast(void*)&argv;
+    }
+
+    version (FreeBSD)
     {	/* FreeBSD does not provide a way to get at the top of the
- 	 * stack.
- 	 * But as far as the gc is concerned, argv is at the top
- 	 * of the main thread's stack, so save the address of that.
- 	 */
- 	__libc_stack_end = cast(void*)&argv;
-    }
-    
-    version (Solaris)
-    {	/* As far as the gc is concerned, argv is at the top
-    	 * of the main thread's stack, so save the address of that.
+	 * stack.
+	 * But as far as the gc is concerned, argv is at the top
+	 * of the main thread's stack, so save the address of that.
 	 */
 	__libc_stack_end = cast(void*)&argv;
     }
- 
+
+    version (Solaris)
+    {	/* As far as the gc is concerned, argv is at the top
+	 * of the main thread's stack, so save the address of that.
+	 */
+	__libc_stack_end = cast(void*)&argv;
+    }
+
     version (Posix)
     {
 	_STI_monitor_staticctor();
diff -r 6a92bcae44c5 d/phobos/internal/gc/gc.d
--- a/d/phobos/internal/gc/gc.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/gc/gc.d	Sat Jun 26 21:05:08 2010 +0100
@@ -70,16 +70,16 @@
 void setV1_0()			      { _gc.setV1_0(); }
 
 // for gcosxc.c
- extern (C) void _d_gc_addrange(void *pbot, void *ptop)
- {
-     _gc.addRange(pbot, ptop);
- }
- 
- //for gcosxc.c
- extern (C) void _d_gc_removerange(void *pbot)
- {
-     _gc.removeRange(pbot);
- }
+extern (C) void _d_gc_addrange(void *pbot, void *ptop)
+{
+    _gc.addRange(pbot, ptop);
+}
+
+//for gcosxc.c
+extern (C) void _d_gc_removerange(void *pbot)
+{
+    _gc.removeRange(pbot);
+}
 
 void[] malloc(size_t nbytes)
 {
@@ -145,7 +145,6 @@
     void _d_osx_image_init();
 }
 
-
 void gc_init()
 {
     version (GCCLASS)
@@ -327,7 +326,8 @@
 	else*/
 	    size *= length;
 	auto p = _gc.malloc(size + 1);
-	debug(PRINTF) printf(" p = %p\n", p);
+	debug(PRINTF)
+	    printf(" p = %p, isize = %d\n", p, isize);
 	if (!(ti.next.flags() & 1))
 	    _gc.hasNoPointers(p);
 	if (isize == 1)
@@ -349,8 +349,7 @@
 	    }
 	}
 	result.length = length;
-	result.data = cast(byte*) p
-;
+	result.data = cast(byte*) p;
     }
     return result;
 
@@ -415,7 +414,6 @@
 	result = null;
     else
     {
-
 	void[] foo(TypeInfo ti, size_t* pdim, int ndims)
 	{
 	    size_t dim = *pdim;
diff -r 6a92bcae44c5 d/phobos/internal/gc/gcbits.d
--- a/d/phobos/internal/gc/gcbits.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/gc/gcbits.d	Sat Jun 26 21:05:08 2010 +0100
@@ -22,7 +22,6 @@
     version = bitops;
 }
 
-
 struct GCBits
 {
     const int BITS_PER_WORD = 32;
diff -r 6a92bcae44c5 d/phobos/internal/gc/gclinux.d
--- a/d/phobos/internal/gc/gclinux.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/gc/gclinux.d	Sat Jun 26 21:05:08 2010 +0100
@@ -4,7 +4,7 @@
 // Written by Walter Bright
 
 //import std.c.linux.linuxextern;
- 
+
 version (FreeBSD)
     import std.c.freebsd.freebsd;
 else version (Solaris)
@@ -125,11 +125,11 @@
     }
     else version (OSX)
     {
- 	/* A better method would be to set this value as the address
+	/* A better method would be to set this value as the address
 	 * of a local variable defined in extern(C) main().
 	 */
- 	//return cast(void*)0xC0000000;
- 	return __osx_stack_end;
+	//return cast(void*)0xC0000000;
+	return __osx_stack_end;
     }
     else
     {	// This doesn't resolve on all versions of Linux
@@ -144,31 +144,31 @@
 
 void os_query_staticdataseg(void **base, uint *nbytes)
 {
-	version (OSX)
-     {	/* These are probably wrong.
+    version (OSX)
+    {	/* These are probably wrong.
 	 * See http://www.manpagez.com/man/3/get_etext/
 	 * Should use dylib(3) instead.
 	 *
 	 * EDIT: should be handled by _d_osx_image_init() now. - SK
 	 */
- 	//*base = cast(void *)get_etext();
- 	//*nbytes = cast(byte *)get_end() - cast(byte *)get_etext();
- 	*base = null;
- 	*nbytes = 0;
-     }
-     else version (FreeBSD)
+	//*base = cast(void *)get_etext();
+	//*nbytes = cast(byte *)get_end() - cast(byte *)get_etext();
+	*base = null;
+	*nbytes = 0;
+    }
+    else version (FreeBSD)
     {
- 	*base = cast(void *)&etext;
- 	*nbytes = cast(byte *)&_end - cast(byte *)&etext;
+	*base = cast(void *)&etext;
+	*nbytes = cast(byte *)&_end - cast(byte *)&etext;
     }
     else version (Solaris)
     {
 	*base = cast(void *)&etext;
 	*nbytes = cast(byte *)&_end - cast(byte *)&etext;
     }
-     else
-     {
-    *base = cast(void *)&__data_start;
-    *nbytes = cast(byte *)&_end - cast(byte *)&__data_start;
+    else
+    {
+	*base = cast(void *)&__data_start;
+	*nbytes = cast(byte *)&_end - cast(byte *)&__data_start;
     }
 }
diff -r 6a92bcae44c5 d/phobos/internal/gc/gcold.d
--- a/d/phobos/internal/gc/gcold.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/gc/gcold.d	Sat Jun 26 21:05:08 2010 +0100
@@ -40,6 +40,7 @@
 {
     Array result;
 
+    //debug(PRINTF) printf("_d_newarrayi(length = %d, size = %d)\n", length, size);
     if (length && size)
     {
 	result.length = length;
diff -r 6a92bcae44c5 d/phobos/internal/gc/gcx.d
--- a/d/phobos/internal/gc/gcx.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/gc/gcx.d	Sat Jun 26 21:05:08 2010 +0100
@@ -357,6 +353,7 @@
 	//debug(PRINTF) printf("GC::malloc(size = %d, gcx = %p)\n", size, gcx);
 	assert(gcx);
 	//debug(PRINTF) printf("gcx.self = %x, pthread_self() = %x\n", gcx.self, pthread_self());
+
         size += SENTINEL_EXTRA;
 
         // Compute size bin
@@ -823,6 +820,7 @@
         }
     }
 
+
     //
     //
     //
@@ -1111,6 +1109,7 @@
 	gcx.conservative = 1;
     }
 
+
     /**
      * Retrieve statistics about garbage collection.
      * Useful for debugging and tuning.
@@ -1127,6 +1126,7 @@
         }
     }
 
+
     //
     //
     //
@@ -1377,7 +1377,6 @@
     /**
      *
      */
-
     void addRoot(void *p)
     {
 	if (nroots == rootdim)
@@ -1799,11 +1798,12 @@
 
 	    //if (log) debug(PRINTF) printf("\tmark %x\n", p);
 	    if (p >= minAddr && p < maxAddr)
-  	    {
- 		/* Skip page if we've already scanned it
- 		 */
+	    {
+		/* Skip page if we've already scanned it
+		 */
 		if ((cast(size_t)p & ~(PAGESIZE-1)) == pageCache)
 		    continue;
+
 		pool = findPool(p);
 		if (pool)
 		{
@@ -1832,9 +1832,9 @@
 			// Don't mark bits in B_FREE or B_UNCOMMITTED pages
 			continue;
 		    }
-		    
+
 		    if (bin >= B_PAGE)  // cache B_PAGE and B_PAGEPLUS lookups
- 			pageCache = cast(size_t)p & ~(PAGESIZE-1);
+			pageCache = cast(size_t)p & ~(PAGESIZE-1);
 
 		    //debug(PRINTF) printf("\t\tmark(x%x) = %d\n", biti, pool.mark.test(biti));
 		    if (!pool.mark.test(biti))
@@ -1860,7 +1860,6 @@
      */
     size_t fullcollectshell()
     {
-
 	// The purpose of the 'shell' is to ensure all the registers
 	// get put on the stack so they'll be scanned
 	void *sp;
@@ -1872,10 +1871,10 @@
 	}
 	else
 	{
-	    asm
-	    {
-		pushad		;
-		mov	sp[EBP],ESP	;
+    	    asm
+    	    {
+    		pushad		;
+    		mov	sp[EBP],ESP	;
 	    }
 	}
 	result = fullcollect(sp);
@@ -1885,10 +1884,10 @@
 	}
 	else
 	{
-	    asm
-	    {
-		popad		;
-	    }
+    	    asm
+    	    {
+    		popad		;
+    	    }
 	}
 	return result;
     }
@@ -1965,31 +1964,30 @@
 		    {
 			if (t.isSelf())
 			    t.stackTop = Thread.getESP();
-
-			//%%fry printf("top=%08x bot=%08x ext=%08x\n", t.stackTop, t.stackBottom, Thread.getESP());//%%try
+			debug (PRINTF) printf("top=%08x bot=%08x ext=%08x\n", t.stackTop, t.stackBottom, Thread.getESP()); //%try
 			version (STACKGROWSDOWN)
 			    mark(t.stackTop, t.stackBottom);
 			else
 			    mark(t.stackBottom, t.stackTop);
 		    }
 		    else version (OSX)
- 		    {
- 		        x86_thread_state32_t   state = void;
- 		        mach_msg_type_number_t count = x86_THREAD_STATE32_COUNT;
- 		        
- 		        if (thread_get_state(t.machid,
- 		                             x86_THREAD_STATE32,
- 		                             &state,
- 		                             &count) != KERN_SUCCESS)
- 		        {
- 		            assert(0);
- 		        }
- 		        debug (PRINTF) printf("mt scan stack bot = %x, top = %x\n", state.esp, t.stackBottom);
- 		        
- 			mark(cast(void *)state.esp, t.stackBottom);
- 			mark(&state.eax, &state.esp);
- 		    }
- 		    else version (Posix)
+		    {
+		        x86_thread_state32_t   state = void;
+		        mach_msg_type_number_t count = x86_THREAD_STATE32_COUNT;
+		        
+		        if (thread_get_state(t.machid,
+		                             x86_THREAD_STATE32,
+		                             &state,
+		                             &count) != KERN_SUCCESS)
+		        {
+		            assert(0);
+		        }
+		        debug (PRINTF) printf("mt scan stack bot = %x, top = %x\n", state.esp, t.stackBottom);
+		        
+			mark(cast(void *)state.esp, t.stackBottom);
+			mark(&state.eax, &state.esp);
+		    }
+		    else version (Posix)
 		    {
 			// The registers are already stored in the stack
 			//printf("Thread: ESP = x%x, stackBottom = x%x, isSelf = %d\n", Thread.getESP(), t.stackBottom, t.isSelf());
@@ -2060,9 +2058,6 @@
 		    *b = 0;
 
 		    o = pool.baseAddr + (b - bbase) * 32 * 16;
-		    /*		    version (BigEndian)
-			bitm = bswap(bitm);
-		    */
 		    if (!(bitm & 0xFFFF))
 		    {
 			bitm >>= 16;
@@ -2357,6 +2352,7 @@
 	    //debug(PRINTF) printf("-log_free()\n");
 	}
 
+
 	void log_collect()
 	{
 	    //debug(PRINTF) printf("+log_collect()\n");
@@ -2705,4 +2701,3 @@
     }
 }
 
-
diff -r 6a92bcae44c5 d/phobos/internal/gc/linux.mak
--- a/d/phobos/internal/gc/linux.mak	Tue Jun 22 15:17:14 2010 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,54 +0,0 @@
-
-# makefile to build linux D garbage collector
-
-#DMD=../../../dmd
-DMD=dmd
-CFLAGS=-g -m32
-#DFLAGS=-unittest -g -release
-DFLAGS=-release -O -inline -I../..
-#DFLAGS=-release -inline -O
-CC=gcc
-
-OBJS= gc.o gcx.o gcbits.o gclinux.o gcold.o
-
-SRC= gc.d gcx.d gcbits.d win32.d gclinux.d gcold.d testgc.d \
- 	win32.mak linux.mak osx.mak
-
-.c.o:
-	$(CC) -c $(CFLAGS) $*
-
-.d.o:
-	$(DMD) -c $(DFLAGS) $*
-
-targets : testgc dmgc.a
-
-testgc : testgc.o $(OBJS) linux.mak
-	$(DMD) -of$@ testgc.o gc.o gcx.o gcbits.o gclinux.o -g
-
-testgc.o : testgc.d
-	$(DMD) -c $(DFLAGS) testgc.d
-
-dmgc.a : $(OBJS) linux.mak
-	ar -r $@ $(OBJS)
-
-gc.o : gc.d
-	$(DMD) -c $(DFLAGS) gc.d
-
-gcold.o : gcold.d
-	$(DMD) -c $(DFLAGS) gcold.d
-
-gcx.o : gcx.d
-	$(DMD) -c $(DFLAGS) gcx.d gcbits.d
-
-#gcbits.o : gcbits.d
-#	$(DMD) -c $(DFLAGS) gcbits.d
-
-gclinux.o : gclinux.d
-	$(DMD) -c $(DFLAGS) gclinux.d
-
-zip : $(SRC)
-	$(RM) dmgc.zip
-	zip dmgc $(SRC)
-
-clean:
-	$(RM) $(OBJS) dmgc.a testgc testgc.o
diff -r 6a92bcae44c5 d/phobos/internal/gc/osx.mak
--- a/d/phobos/internal/gc/osx.mak	Tue Jun 22 15:17:14 2010 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,58 +0,0 @@
-
-# makefile to build linux D garbage collector
-
-#DMD=../../../dmd
-DMD=dmd
-CFLAGS=-g -m32
-#DFLAGS=-unittest -g -release
-DFLAGS=-release -O -inline -I../..
-#DFLAGS=-release -inline -O
-CC=gcc
-
-OBJS= gc.o gcx.o gcbits.o gclinux.o gcosxc.o gcold.o
-
-SRC= gc.d gcx.d gcbits.d win32.d gclinux.d gcosxc.c gcold.d testgc.d \
-	win32.mak linux.mak osx.mak
-
-.c.o:
-	$(CC) -c $(CFLAGS) $*
-
-.d.o:
-	$(DMD) -c $(DFLAGS) $*
-
-#targets : testgc dmgc.a
-targets : dmgc.a
-
-testgc : testgc.o $(OBJS) linux.mak
-	$(DMD) -of$@ testgc.o gc.o gcx.o gcbits.o gclinux.o gcosxc.o -g
-
-testgc.o : testgc.d
-	$(DMD) -c $(DFLAGS) testgc.d
-
-dmgc.a : $(OBJS) linux.mak
-	ar -r $@ $(OBJS)
-
-gc.o : gc.d
-	$(DMD) -c $(DFLAGS) gc.d
-
-gcold.o : gcold.d
-	$(DMD) -c $(DFLAGS) gcold.d
-
-gcx.o : gcx.d
-	$(DMD) -c $(DFLAGS) gcx.d gcbits.d
-
-#gcbits.o : gcbits.d
-#	$(DMD) -c $(DFLAGS) gcbits.d
-
-gclinux.o : gclinux.d
-	$(DMD) -c $(DFLAGS) gclinux.d
-
-gcosxc.o : gcosxc.c
-	$(CC) -c $(CFLAGS) gcosxc.c
-
-zip : $(SRC)
-	$(RM) dmgc.zip
-	zip dmgc $(SRC)
-
-clean:
-	$(RM) $(OBJS) dmgc.a testgc testgc.o
diff -r 6a92bcae44c5 d/phobos/internal/gc/win32.d
--- a/d/phobos/internal/gc/win32.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/gc/win32.d	Sat Jun 26 21:05:08 2010 +0100
@@ -42,7 +42,7 @@
 
 int os_mem_decommit(void *base, uint offset, uint nbytes)
 {
-    return cast(int)VirtualFree(base + offset, nbytes, MEM_DECOMMIT) == 0; 
+    return cast(int)(VirtualFree(base + offset, nbytes, MEM_DECOMMIT) == 0);
 }
 
 /***********************************
@@ -55,7 +55,7 @@
 
 int os_mem_unmap(void *base, uint nbytes)
 {
-    return cast(int)VirtualFree(base, 0, MEM_RELEASE) == 0; 
+    return cast(int)(VirtualFree(base, 0, MEM_RELEASE) == 0);
 }
 
 
diff -r 6a92bcae44c5 d/phobos/internal/gc/win32.mak
--- a/d/phobos/internal/gc/win32.mak	Tue Jun 22 15:17:14 2010 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,65 +0,0 @@
-
-# makefile to build D garbage collector under win32
-
-#DMD=..\..\..\dmd
-DMD=dmd
-
-#DFLAGS=-unittest -g -release
-#DFLAGS=-inline -O
-DFLAGS=-release -inline -O
-#DFLAGS=-g
-
-CC=dmc
-CFLAGS=-g -mn -6 -r -Igc
-
-.c.obj:
-	$(CC) -c $(CFLAGS) $*
-
-.cpp.obj:
-	$(CC) -c $(CFLAGS) $*
-
-.d.obj:
-	$(DMD) -c $(DFLAGS) $*
-
-.asm.obj:
-	$(CC) -c $*
-
-targets : testgc.exe dmgc.lib
-
-testgc.exe : testgc.obj dmgc.lib
-	$(DMD) testgc.obj dmgc.lib -g
-
-testgc.obj : testgc.d
-
-OBJS= gc.obj gcold.obj gcx.obj gcbits.obj win32.obj
-
-SRC= gc.d gcold.d gcx.d gcbits.d win32.d gclinux.d testgc.d win32.mak linux.mak
-
-#dmgc.lib : $(OBJS) win32.mak
-#	del dmgc.lib
-#	lib dmgc /c/noi +gc+gcold+gcx+gcbits+win32;
- 
-dmgc.lib : gc.d gcold.obj gcx.d gcbits.d win32.d
- 	$(DMD) $(DFLAGS) -I..\.. -lib -ofdmgc.lib gc.d gcold.obj gcx.d gcbits.d win32.d
-
-gc.obj : gc.d
-	$(DMD) -c $(DFLAGS) $*
-
-gcold.obj : gcold.d
-	$(DMD) -c $(DFLAGS) $*
-
-gcx.obj : gcx.d gcbits.d
-	$(DMD) -c $(DFLAGS) gcx gcbits
-
-#gcbits.obj : gcbits.d
-
-win32.obj : win32.d
-
-zip : $(SRC)
-	del dmgc.zip
-	zip32 dmgc $(SRC)
-
-clean:
-	del $(OBJS)
-	del dmgc.lib
-	del testgc.exe
diff -r 6a92bcae44c5 d/phobos/internal/llmath.d
--- a/d/phobos/internal/llmath.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/llmath.d	Sat Jun 26 21:05:08 2010 +0100
@@ -26,13 +26,13 @@
 	jz	uldiv		;
 
 	// if ECX > EDX, then quotient is 0 and remainder is [EDX,EAX]
- 	cmp	ECX,EDX		;
- 	ja	quo0		;
- 
- 	test	ECX,ECX		;
- 	js	Lleft		;
- 
- 	/* We have n>d, and know that n/d will fit in 32 bits.
+	cmp	ECX,EDX		;
+	ja	quo0		;
+
+	test	ECX,ECX		;
+	js	Lleft		;
+
+	/* We have n>d, and know that n/d will fit in 32 bits.
          * d will be left justified if we shift it left s bits.
 	 * [d1,d0] <<= s
 	 * [n2,n1,n0] = [n1,n0] << s
@@ -59,72 +59,72 @@
 	 *  r = ([[n2,n1]%d1,n0] + (q*[d1,0] - [d1 *(q-one),d0*(1-q)])) >> s
 	 *  r = ([[n2,n1]%d1,n0] + [d1 *one,d0*(one-q)])) >> s
 	 */
- 
-  	push	EBP		;
- 	push	ESI		;
+
+	push	EBP		;
+	push	ESI		;
 	push	EDI		;
 
 	mov	ESI,EDX		;
- 	mov	EDI,EAX		;
- 	mov	EBP,ECX		;
- 
- 	bsr	EAX,ECX		;	// EAX is now 30..0
- 	xor	EAX,0x1F	;	// EAX is now 1..31
- 	mov	CH,AL		;
- 	neg	EAX		;
- 	add	EAX,32		;
- 	mov	CL,AL		;
-  
- 	mov	EAX,EBX		;
- 	shr	EAX,CL		;
- 	xchg	CH,CL		;
- 	shl	EBP,CL		;
- 	or	EBP,EAX		;
- 	shl	EBX,CL		;
- 
- 	mov	EDX,ESI		;
- 	xchg	CH,CL		;
- 	shr	EDX,CL		;
- 
- 	mov	EAX,EDI		;
- 	shr	EAX,CL		;
- 	xchg	CH,CL		;
- 	shl	EDI,CL		;
- 	shl	ESI,CL		;
- 	or	EAX,ESI		;
-  
- 	div	EBP		;
- 	push	EBP		;
- 	mov	EBP,EAX		;
- 	mov	ESI,EDX		;
-  
- 	mul	EBX		;
- 	cmp	EDX,ESI		;
- 	ja	L1		;
- 	jb	L2		;
- 	cmp	EAX,EDI		;
- 	jbe	L2		;
- L1:	dec	EBP		;
- 	sub	EAX,EBX		;
- 	sbb	EDX,0[ESP]	;
- L2:
- 	add	ESP,4		;
- 	sub	EDI,EAX		;
- 	sbb	ESI,EDX		;
- 	mov	EAX,ESI		;
- 	xchg	CH,CL		;
- 	shl	EAX,CL		;
- 	xchg	CH,CL		;
- 	shr	EDI,CL		;
- 	or	EDI,EAX		;
- 	shr	ESI,CL		;
- 	mov	EBX,EDI		;
- 	mov	ECX,ESI		;
- 	mov	EAX,EBP		;
- 	xor	EDX,EDX		;
-  
- 	pop	EDI		;
- 	pop	ESI		;
+	mov	EDI,EAX		;
+	mov	EBP,ECX		;
+
+	bsr	EAX,ECX		;	// EAX is now 30..0
+	xor	EAX,0x1F	;	// EAX is now 1..31
+	mov	CH,AL		;
+	neg	EAX		;
+	add	EAX,32		;
+	mov	CL,AL		;
+
+	mov	EAX,EBX		;
+	shr	EAX,CL		;
+	xchg	CH,CL		;
+	shl	EBP,CL		;
+	or	EBP,EAX		;
+	shl	EBX,CL		;
+
+	mov	EDX,ESI		;
+	xchg	CH,CL		;
+	shr	EDX,CL		;
+
+	mov	EAX,EDI		;
+	shr	EAX,CL		;
+	xchg	CH,CL		;
+	shl	EDI,CL		;
+	shl	ESI,CL		;
+	or	EAX,ESI		;
+
+	div	EBP		;
+	push	EBP		;
+	mov	EBP,EAX		;
+	mov	ESI,EDX		;
+
+	mul	EBX		;
+	cmp	EDX,ESI		;
+	ja	L1		;
+	jb	L2		;
+	cmp	EAX,EDI		;
+	jbe	L2		;
+L1:	dec	EBP		;
+	sub	EAX,EBX		;
+	sbb	EDX,0[ESP]	;
+L2:
+	add	ESP,4		;
+	sub	EDI,EAX		;
+	sbb	ESI,EDX		;
+	mov	EAX,ESI		;
+	xchg	CH,CL		;
+	shl	EAX,CL		;
+	xchg	CH,CL		;
+	shr	EDI,CL		;
+	or	EDI,EAX		;
+	shr	ESI,CL		;
+	mov	EBX,EDI		;
+	mov	ECX,ESI		;
+	mov	EAX,EBP		;
+	xor	EDX,EDX		;
+
+	pop	EDI		;
+	pop	ESI		;
 	pop	EBP		;
 	ret			;
 
@@ -157,31 +157,31 @@
 	mov	EDX,ECX		;
 	xor	ECX,ECX		;
 	ret			;
-	
-	quo0:	// Quotient is 0
- 	// Remainder is [EDX,EAX]
- 	mov	EBX,EAX		;
- 	mov	ECX,EDX		;
- 	xor	EAX,EAX		;
- 	xor	EDX,EDX		;
- 	ret			;
- 
- Lleft:	// The quotient is 0 or 1 and EDX >= ECX
- 	cmp	EDX,ECX		;
- 	ja	quo1		;	// [EDX,EAX] > [ECX,EBX]
- 	// EDX == ECX
- 	cmp	EAX,EBX		;
- 	jb	quo0		;
- 
- quo1:	// Quotient is 1
- 	// Remainder is [EDX,EAX] - [ECX,EBX]
- 	sub	EAX,EBX		;
- 	sbb	EDX,ECX		;
- 	mov	EBX,EAX		;
- 	mov	ECX,EDX		;
- 	mov	EAX,1		;
- 	xor	EDX,EDX		;
- 	ret			;
+
+quo0:	// Quotient is 0
+	// Remainder is [EDX,EAX]
+	mov	EBX,EAX		;
+	mov	ECX,EDX		;
+	xor	EAX,EAX		;
+	xor	EDX,EDX		;
+	ret			;
+
+Lleft:	// The quotient is 0 or 1 and EDX >= ECX
+	cmp	EDX,ECX		;
+	ja	quo1		;	// [EDX,EAX] > [ECX,EBX]
+	// EDX == ECX
+	cmp	EAX,EBX		;
+	jb	quo0		;
+
+quo1:	// Quotient is 1
+	// Remainder is [EDX,EAX] - [ECX,EBX]
+	sub	EAX,EBX		;
+	sbb	EDX,ECX		;
+	mov	EBX,EAX		;
+	mov	ECX,EDX		;
+	mov	EAX,1		;
+	xor	EDX,EDX		;
+	ret			;
     }
 }
 
@@ -286,43 +286,43 @@
 
 real __U64_LDBL()
 {
-version (OSX)
-     {
- 	asm
- 	{   naked				;
- 	    push	EDX			;
- 	    push	EAX			;
- 	    and		dword ptr 4[ESP], 0x7FFFFFFF	;
- 	    fild	qword ptr [ESP]		;
- 	    test	EDX,EDX			;
- 	    jns		L1			;
- 	    push	0x0000403e		;
- 	    push	0x80000000		;
- 	    push	0			;
- 	    fld		real ptr [ESP]		; // adjust
- 	    add		ESP,12			;
- 	    faddp	ST(1), ST		;
- 	L1:					;
- 	    add		ESP, 8			;
- 	    ret					;
+    version (OSX)
+    {
+	asm
+	{   naked				;
+	    push	EDX			;
+	    push	EAX			;
+	    and		dword ptr 4[ESP], 0x7FFFFFFF	;
+	    fild	qword ptr [ESP]		;
+	    test	EDX,EDX			;
+	    jns		L1			;
+	    push	0x0000403e		;
+	    push	0x80000000		;
+	    push	0			;
+	    fld		real ptr [ESP]		; // adjust
+	    add		ESP,12			;
+	    faddp	ST(1), ST		;
+	L1:					;
+	    add		ESP, 8			;
+	    ret					;
 	}
     }
     else
     {
-    asm
-    {	naked					;
-	push	EDX				;
-	push	EAX				;
-	and	dword ptr 4[ESP], 0x7FFFFFFF	;
-	fild	qword ptr [ESP]			;
-	test	EDX,EDX				;
-	jns	L1				;
-	fld	real ptr adjust			;
-	faddp	ST(1), ST			;
-    L1:						;
-	add	ESP, 8				;
-	ret					;
-    }
+	asm
+	{   naked				;
+	    push	EDX			;
+	    push	EAX			;
+	    and		dword ptr 4[ESP], 0x7FFFFFFF	;
+	    fild	qword ptr [ESP]		;
+	    test	EDX,EDX			;
+	    jns		L1			;
+	    fld		real ptr adjust		;
+	    faddp	ST(1), ST		;
+	L1:					;
+	    add		ESP, 8			;
+	    ret					;
+	}
     }
 }
 
@@ -349,73 +349,73 @@
     // BUG: should handle NAN's and overflows
     version (OSX)
     {
- 	asm
- 	{   naked				;
- 	    push	0xFBF			; // roundTo0
- 	    push	0x0000403e		;
- 	    push	0x80000000		;
- 	    push	0			; // adjust
- 	    push	EDX			;
- 	    push	EAX			;
- 	    fld		double ptr [ESP]	;
- 	    sub		ESP,8			;
- 	    fld		real ptr 16[ESP]	; // adjust
- 	    fcomp				;
- 	    fstsw	AX			;
- 	    fstcw	8[ESP]			;
- 	    fldcw	28[ESP]			; // roundTo0
- 	    sahf				;
- 	    jae		L1			;
- 	    fld		real ptr 16[ESP]	; // adjust
- 	    fsubp	ST(1), ST		;
- 	    fistp	qword ptr [ESP]		;
- 	    pop		EAX			;
- 	    pop		EDX			;
- 	    fldcw	[ESP]			;
- 	    add		ESP,24			;
- 	    add		EDX,0x8000_0000		;
- 	    ret					;
- 	L1:					;
- 	    fistp	qword ptr [ESP]		;
- 	    pop		EAX			;
- 	    pop		EDX			;
- 	    fldcw	[ESP]			;
- 	    add		ESP,24			;
- 	    ret					;
+	asm
+	{   naked				;
+	    push	0xFBF			; // roundTo0
+	    push	0x0000403e		;
+	    push	0x80000000		;
+	    push	0			; // adjust
+	    push	EDX			;
+	    push	EAX			;
+	    fld		double ptr [ESP]	;
+	    sub		ESP,8			;
+	    fld		real ptr 16[ESP]	; // adjust
+	    fcomp				;
+	    fstsw	AX			;
+	    fstcw	8[ESP]			;
+	    fldcw	28[ESP]			; // roundTo0
+	    sahf				;
+	    jae		L1			;
+	    fld		real ptr 16[ESP]	; // adjust
+	    fsubp	ST(1), ST		;
+	    fistp	qword ptr [ESP]		;
+	    pop		EAX			;
+	    pop		EDX			;
+	    fldcw	[ESP]			;
+	    add		ESP,24			;
+	    add		EDX,0x8000_0000		;
+	    ret					;
+	L1:					;
+	    fistp	qword ptr [ESP]		;
+	    pop		EAX			;
+	    pop		EDX			;
+	    fldcw	[ESP]			;
+	    add		ESP,24			;
+	    ret					;
 	}
     }
     else
     {
-    asm
-    {	naked					;
-	push	EDX				;
-	push	EAX				;
-	fld	double ptr [ESP]		;
-	sub	ESP,8				;
-	fld	real ptr adjust			;
-	fcomp					;
-	fstsw	AX				;
-	fstcw	8[ESP]				;
-	fldcw	roundTo0			;
-	sahf					;
-	jae	L1				;
-	fld	real ptr adjust			;
-	fsubp	ST(1), ST			;
-	fistp	qword ptr [ESP]			;
-	pop	EAX				;
-	pop	EDX				;
-	fldcw	[ESP]				;
-	add	ESP,8				;
-	add	EDX,0x8000_0000			;
-	ret					;
-    L1:						;
-	fistp	qword ptr [ESP]			;
-	pop	EAX				;
-	pop	EDX				;
-	fldcw	[ESP]				;
-	add	ESP,8				;
-	ret					;
-    }
+	asm
+	{   naked				;
+	    push	EDX			;
+	    push	EAX			;
+	    fld		double ptr [ESP]	;
+	    sub		ESP,8			;
+	    fld		real ptr adjust		;
+	    fcomp				;
+	    fstsw	AX			;
+	    fstcw	8[ESP]			;
+	    fldcw	roundTo0		;
+	    sahf				;
+	    jae		L1			;
+	    fld		real ptr adjust		;
+	    fsubp	ST(1), ST		;
+	    fistp	qword ptr [ESP]		;
+	    pop		EAX			;
+	    pop		EDX			;
+	    fldcw	[ESP]			;
+	    add		ESP,8			;
+	    add		EDX,0x8000_0000		;
+	    ret					;
+	L1:					;
+	    fistp	qword ptr [ESP]		;
+	    pop		EAX			;
+	    pop		EDX			;
+	    fldcw	[ESP]			;
+	    add		ESP,8			;
+	    ret					;
+	}
     }
 }
 
@@ -426,101 +426,101 @@
     // BUG: should handle NAN's and overflows
     version (OSX)
     {
- 	asm
- 	{   naked				;
- 	    push	0xFBF			; // roundTo0
- 	    sub		ESP,12			;
- 	    fstcw	8[ESP]			;
- 	    fldcw	12[ESP]			; // roundTo0
- 	    fistp	qword ptr [ESP]		;
- 	    fldcw	8[ESP]			;
+	asm
+	{   naked				;
+	    push	0xFBF			; // roundTo0
+	    sub		ESP,12			;
+	    fstcw	8[ESP]			;
+	    fldcw	12[ESP]			; // roundTo0
+	    fistp	qword ptr [ESP]		;
+	    fldcw	8[ESP]			;
 	    pop		EAX			;
- 	    add		ESP,12			;
- 	    ret					;
- 	}
+	    add		ESP,12			;
+	    ret					;
+	}
     }
     else
     {
-    asm
-    {	naked					;
-	sub	ESP,16				;
-	fstcw	8[ESP]				;
-	fldcw	roundTo0			;
-	fistp	qword ptr [ESP]			;
-	fldcw	8[ESP]				;
-	pop	EAX				;
-	add	ESP,12				;
-	ret					;
-    }
+	asm
+	{   naked				;
+	    sub		ESP,16			;
+	    fstcw	8[ESP]			;
+	    fldcw	roundTo0		;
+	    fistp	qword ptr [ESP]		;
+	    fldcw	8[ESP]			;
+	    pop		EAX			;
+	    add		ESP,12			;
+	    ret					;
+	}
     }
 }
 
 // Convert real in ST0 to ulong
- 
+
 ulong __LDBLULLNG()
 {
     version (OSX)
     {
- 	asm
- 	{   naked				;
- 	    push	0xFBF			; // roundTo0
- 	    push	0x0000403e		;
- 	    push	0x80000000		;
- 	    push	0			; // adjust
- 	    sub		ESP,16			;
- 	    fld		real ptr 16[ESP]	; // adjust
- 	    fcomp				;
- 	    fstsw	AX			;
- 	    fstcw	8[ESP]			;
- 	    fldcw	28[ESP]			; // roundTo0
- 	    sahf				;
- 	    jae		L1			;
- 	    fld		real ptr 16[ESP]	; // adjust
- 	    fsubp	ST(1), ST		;
- 	    fistp	qword ptr [ESP]		;
- 	    pop		EAX			;
- 	    pop		EDX			;
- 	    fldcw	[ESP]			;
- 	    add		ESP,24			;
- 	    add		EDX,0x8000_0000		;
- 	    ret					;
- 	L1:					;
- 	    fistp	qword ptr [ESP]		;
- 	    pop		EAX			;
- 	    pop		EDX			;
- 	    fldcw	[ESP]			;
- 	    add		ESP,24			;
- 	    ret					;
- 	}
+	asm
+	{   naked				;
+	    push	0xFBF			; // roundTo0
+	    push	0x0000403e		;
+	    push	0x80000000		;
+	    push	0			; // adjust
+	    sub		ESP,16			;
+	    fld		real ptr 16[ESP]	; // adjust
+	    fcomp				;
+	    fstsw	AX			;
+	    fstcw	8[ESP]			;
+	    fldcw	28[ESP]			; // roundTo0
+	    sahf				;
+	    jae		L1			;
+	    fld		real ptr 16[ESP]	; // adjust
+	    fsubp	ST(1), ST		;
+	    fistp	qword ptr [ESP]		;
+	    pop		EAX			;
+	    pop		EDX			;
+	    fldcw	[ESP]			;
+	    add		ESP,24			;
+	    add		EDX,0x8000_0000		;
+	    ret					;
+	L1:					;
+	    fistp	qword ptr [ESP]		;
+	    pop		EAX			;
+	    pop		EDX			;
+	    fldcw	[ESP]			;
+	    add		ESP,24			;
+	    ret					;
+	}
     }
     else
     {
- 	asm
- 	{   naked				;
- 	    sub		ESP,16			;
- 	    fld		real ptr adjust		;
- 	    fcomp				;
- 	    fstsw	AX			;
- 	    fstcw	8[ESP]			;
- 	    fldcw	roundTo0		;
- 	    sahf				;
- 	    jae		L1			;
- 	    fld		real ptr adjust		;
- 	    fsubp	ST(1), ST		;
- 	    fistp	qword ptr [ESP]		;
- 	    pop		EAX			;
- 	    pop		EDX			;
- 	    fldcw	[ESP]			;
- 	    add		ESP,8			;
- 	    add		EDX,0x8000_0000		;
- 	    ret					;
- 	L1:					;
- 	    fistp	qword ptr [ESP]		;
- 	    pop		EAX			;
- 	    pop		EDX			;
- 	    fldcw	[ESP]			;
- 	    add		ESP,8			;
- 	    ret					;
+	asm
+	{   naked				;
+	    sub		ESP,16			;
+	    fld		real ptr adjust		;
+	    fcomp				;
+	    fstsw	AX			;
+	    fstcw	8[ESP]			;
+	    fldcw	roundTo0		;
+	    sahf				;
+	    jae		L1			;
+	    fld		real ptr adjust		;
+	    fsubp	ST(1), ST		;
+	    fistp	qword ptr [ESP]		;
+	    pop		EAX			;
+	    pop		EDX			;
+	    fldcw	[ESP]			;
+	    add		ESP,8			;
+	    add		EDX,0x8000_0000		;
+	    ret					;
+	L1:					;
+	    fistp	qword ptr [ESP]		;
+	    pop		EAX			;
+	    pop		EDX			;
+	    fldcw	[ESP]			;
+	    add		ESP,8			;
+	    ret					;
 	}
     }
 }
diff -r 6a92bcae44c5 d/phobos/internal/memset.d
--- a/d/phobos/internal/memset.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/memset.d	Sat Jun 26 21:05:08 2010 +0100
@@ -41,7 +41,7 @@
     short *ptop;
 
     for (ptop = &p[count]; p < ptop; p++)
-	*p = value;
+        *p = value;
     return pstart;
 }
 
@@ -51,13 +51,13 @@
 {
     asm
     {
-	mov	EDI,p		;
-	mov	EAX,value	;
-	mov	ECX,count	;
-	mov	EDX,EDI		;
-	rep			;
-	stosd			;
-	mov	EAX,EDX		;
+        mov     EDI,p           ;
+        mov     EAX,value       ;
+        mov     ECX,count       ;
+        mov     EDX,EDI         ;
+        rep                     ;
+        stosd                   ;
+        mov     EAX,EDX         ;
     }
 }
 else
@@ -66,7 +66,7 @@
     int *ptop;
 
     for (ptop = &p[count]; p < ptop; p++)
-	*p = value;
+        *p = value;
     return pstart;
 }
 }
@@ -77,7 +77,7 @@
     long *ptop;
 
     for (ptop = &p[count]; p < ptop; p++)
-	*p = value;
+        *p = value;
     return pstart;
 }
 
@@ -87,7 +87,7 @@
     cdouble *ptop;
 
     for (ptop = &p[count]; p < ptop; p++)
-	*p = value;
+        *p = value;
     return pstart;
 }
 
@@ -97,7 +97,7 @@
     real *ptop;
 
     for (ptop = &p[count]; p < ptop; p++)
-	*p = value;
+        *p = value;
     return pstart;
 }
 
@@ -107,7 +107,7 @@
     creal *ptop;
 
     for (ptop = &p[count]; p < ptop; p++)
-	*p = value;
+        *p = value;
     return pstart;
 }
 
@@ -117,8 +117,8 @@
 
     for (i = 0; i < count; i++)
     {
-	memcpy(p, value, sizelem);
-	p = cast(void *)(cast(char *)p + sizelem);
+        memcpy(p, value, sizelem);
+        p = cast(void *)(cast(char *)p + sizelem);
     }
     return pstart;
 }
diff -r 6a92bcae44c5 d/phobos/internal/monitor.c
--- a/d/phobos/internal/monitor.c	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/monitor.c	Sat Jun 26 21:05:08 2010 +0100
@@ -21,7 +21,7 @@
 
 #if _WIN32
 #elif linux || __APPLE__ || __FreeBSD__ || __sun&&__SVR4
-#define PHOBOS_USE_PTHREADS	1
+#define USE_PTHREADS	1
 #else
 #endif
 
@@ -29,7 +29,7 @@
 #include <windows.h>
 #endif
 
-#if PHOBOS_USE_PTHREADS
+#if USE_PTHREADS
 #include <pthread.h>
 #endif
 
@@ -44,7 +44,7 @@
     CRITICAL_SECTION mon;
 #endif
 
-#if PHOBOS_USE_PTHREADS
+#if USE_PTHREADS
     pthread_mutex_t mon;
 #endif
 } Monitor;
@@ -129,8 +129,7 @@
 
 /* =============================== linux ============================ */
 
-// needs to be else..
-#elif PHOBOS_USE_PTHREADS
+#elif USE_PTHREADS
 
 #if linux || __APPLE__
 #ifndef PTHREAD_MUTEX_RECURSIVE
@@ -138,6 +137,7 @@
 #endif
 #endif
 
+// Includes attribute fixes from David Friedman's GDC port
 #ifndef HAVE_PTHREAD_MUTEX_RECURSIVE
 #define PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_RECURSIVE_NP
 #endif
@@ -148,7 +148,7 @@
 void _STI_monitor_staticctor()
 {
     if (!inited)
-    {	
+    {
 #ifndef PTHREAD_MUTEX_ALREADY_RECURSIVE
 	pthread_mutexattr_init(&_monitors_attr);
 	pthread_mutexattr_settype(&_monitors_attr, PTHREAD_MUTEX_RECURSIVE);
diff -r 6a92bcae44c5 d/phobos/internal/object.d
--- a/d/phobos/internal/object.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/object.d	Sat Jun 26 21:05:08 2010 +0100
@@ -61,13 +61,6 @@
 
 alias size_t hash_t;
 
-/// Standard boolean type.
-alias bool bit;
-
-alias char[] string;
-alias wchar[] wstring;
-alias dchar[] dstring;
-
 extern (C)
 {   /// C's printf function.
     int printf(char *, ...);
@@ -82,6 +75,13 @@
     Object _d_newclass(ClassInfo ci);
 }
 
+/// Standard boolean type.
+alias bool bit;
+
+alias char[] string;
+alias wchar[] wstring;
+alias dchar[] dstring;
+
 /* *************************
  * Internal struct pointed to by the hidden .monitor member.
  */
@@ -102,8 +102,7 @@
      */
     void print()
     {
-	char[] s = toString();
-	printf("%.*s\n", cast(int) s.length, s.ptr);
+	printf("%.*s\n", toString());
     }
 
     /**
@@ -764,7 +763,7 @@
 
     hash_t getHash(void *p)
     {
- 	Object o = *cast(Object*)p;
+	Object o = *cast(Object*)p;
 	return o ? o.toHash() : 0;
     }
 
@@ -923,7 +922,7 @@
 		// GDC and DMD use different calling conventions
 		c = (*xopEquals)(p2, p1);
 	    else
-		c = (*xopEquals)(p1, p2);
+	    c = (*xopEquals)(p1, p2);
 	}
 	else
 	    // BUG: relies on the GC not moving objects
@@ -947,7 +946,7 @@
 			// GDC and DMD use different calling conventions
 			c = (*xopCmp)(p1, p2); //switched the dmd and gdc lines
 		    else
-			c = (*xopCmp)(p2, p1);
+		    c = (*xopCmp)(p2, p1);
 		}
 		else
 		    // BUG: relies on the GC not moving objects
@@ -1082,8 +1081,7 @@
 
     void print()
     {
-	char[] s = toString();
-	printf("%.*s\n", cast(int) s.length, s.ptr);
+	printf("%.*s\n", toString());
     }
 
     char[] toString() { return msg; }
diff -r 6a92bcae44c5 d/phobos/internal/trace.d
--- a/d/phobos/internal/trace.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/internal/trace.d	Sat Jun 26 21:05:08 2010 +0100
@@ -779,38 +779,37 @@
      *	dw	length
      *	ascii	string
      */
-     
-     version (OSX)
-   { // 16 byte align stack
-     asm
-     {	naked				;
- 	pushad				;
- 	mov	ECX,8*4[ESP]		;
- 	xor	EAX,EAX			;
- 	mov	AL,[ECX]		;
- 	cmp	AL,0xFF			;
- 	jne	L1			;
- 	cmp	byte ptr 1[ECX],0	;
- 	jne	L1			;
- 	mov	AX,2[ECX]		;
- 	add	8*4[ESP],3		;
- 	add	ECX,3			;
-     L1:	inc	EAX			;
- 	inc	ECX			;
- 	add	8*4[ESP],EAX		;
- 	dec	EAX			;
- 	sub	ESP,4			;
- 	push	ECX			;
- 	push	EAX			;
- 	call	trace_pro		;
- 	add	ESP,12			;
- 	popad				;
- 	ret				;
-     }
-   }
-   else
-   {
 
+  version (OSX)
+  { // 16 byte align stack
+    asm
+    {	naked				;
+	pushad				;
+	mov	ECX,8*4[ESP]		;
+	xor	EAX,EAX			;
+	mov	AL,[ECX]		;
+	cmp	AL,0xFF			;
+	jne	L1			;
+	cmp	byte ptr 1[ECX],0	;
+	jne	L1			;
+	mov	AX,2[ECX]		;
+	add	8*4[ESP],3		;
+	add	ECX,3			;
+    L1:	inc	EAX			;
+	inc	ECX			;
+	add	8*4[ESP],EAX		;
+	dec	EAX			;
+	sub	ESP,4			;
+	push	ECX			;
+	push	EAX			;
+	call	trace_pro		;
+	add	ESP,12			;
+	popad				;
+	ret				;
+    }
+  }
+  else
+  {
     asm
     {	naked				;
 	pushad				;
@@ -835,7 +834,7 @@
 	popad				;
 	ret				;
     }
-    }
+  }
 }
 
 /////////////////////////////////////////////
@@ -844,23 +843,23 @@
 
 void _trace_epi_n()
 {
-	version (OSX)
-    { // 16 byte align stack
-     asm
-     {	naked	;
- 	pushad	;
- 	sub	ESP,12	;
-     }
-     trace_epi();
-     asm
-     {
- 	add	ESP,12	;
- 	popad	;
- 	ret	;
-     }
-   }
-   else
-   {
+  version (OSX)
+  { // 16 byte align stack
+    asm
+    {	naked	;
+	pushad	;
+	sub	ESP,12	;
+    }
+    trace_epi();
+    asm
+    {
+	add	ESP,12	;
+	popad	;
+	ret	;
+    }
+  }
+  else
+  {
     asm
     {	naked	;
 	pushad	;
@@ -871,7 +870,7 @@
 	popad	;
 	ret	;
     }
-    }
+  }
 }
 
 
diff -r 6a92bcae44c5 d/phobos/object.d
--- a/d/phobos/object.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/object.d	Sat Jun 26 21:05:08 2010 +0100
@@ -168,11 +168,11 @@
 
 class Exception : Object
 {
-    char[] msg;
+    string msg;
 
-    this(char[] msg);
-    void print();
-    char[] toString();
+    this(string msg);
+    override void print();
+    override string toString();
 }
 
 // Non-recoverable errors
@@ -181,7 +181,7 @@
 {
     Error next;
 
-    this(char[] msg);
-    this(char[] msg, Error next);
+    this(string msg);
+    this(string msg, Error next);
 }
 
diff -r 6a92bcae44c5 d/phobos/osx.mak
--- a/d/phobos/osx.mak	Tue Jun 22 15:17:14 2010 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,626 +0,0 @@
-# Makefile to build OSX D runtime library libphobos.a.
-# Targets:
-#	make
-#		Same as make unittest
-#	make libphobos.a
-#		Build libphobos.a
-#	make clean
-#		Delete unneeded files created by build process
-#	make unittest
-#		Build libphobos.a, build and run unit tests
-
-LIB=libphobos.a
-
-MAKEFILE=osx.mak
-
-CFLAGS=-O -m32
-#CFLAGS=-g -m32
-
-DFLAGS=-O -release -w
-#DFLAGS=-unittest -w
-
-CC=gcc
-#DMD=/dmd/bin/dmd
-DMD=dmd
-
-.c.o:
-	$(CC) -c $(CFLAGS) $*.c
-
-.cpp.o:
-	g++ -c $(CFLAGS) $*.cpp
-
-.d.o:
-	$(DMD) -c $(DFLAGS) $*.d
-
-.asm.o:
-	$(CC) -c $*.asm
-
-targets : $(LIB)
-
-test.o : test.d
-	$(DMD) -c test -g
-
-test : test.o $(LIB)
-	$(CC) -o $@ test.o $(LIB) -lpthread -lm -g
-
-OBJS = asserterror.o deh2.o complex.o gcstats.o \
-	critical.o object.o monitor.o \
-	outofmemory.o file.o \
-	compiler.o system.o moduleinit.o md5.o base64.o \
-	path.o string.o math.o mmfile.o \
-	outbuffer.o ctype.o regexp.o random.o linux.o osx.o linuxsocket.o \
-	stream.o cstream.o switcherr.o array.o gc.o \
-	thread.o utf.o uri.o \
-	Dcrc32.o conv.o errno.o alloca.o cmath2.o \
-	process.o syserror.o metastrings.o \
-	socket.o socketstream.o stdarg.o stdio.o format.o \
-	perf.o openrj.o uni.o trace.o boxer.o \
-	demangle.o cover.o bitarray.o bind.o \
-	signals.o cpuid.o traits.o typetuple.o loader.o \
-	ti_wchar.o ti_uint.o ti_short.o ti_ushort.o \
-	ti_byte.o ti_ubyte.o ti_long.o ti_ulong.o ti_ptr.o \
-	ti_float.o ti_double.o ti_real.o ti_delegate.o \
-	ti_creal.o ti_ireal.o ti_cfloat.o ti_ifloat.o \
-	ti_cdouble.o ti_idouble.o \
-	ti_AC.o ti_Ag.o ti_Ashort.o \
-	ti_C.o ti_int.o ti_char.o ti_dchar.o \
-	ti_Aint.o ti_Along.o \
-	ti_Afloat.o ti_Adouble.o ti_Areal.o \
-	ti_Acfloat.o ti_Acdouble.o ti_Acreal.o \
-	ti_void.o \
-	date.o dateparse.o llmath.o math2.o Czlib.o Dzlib.o zip.o \
-	pthread.o
-
-SRCS= \
-        internal/aaA.d internal/adi.d \
-        internal/aApply.d internal/aApplyR.d internal/memset.d \
-        internal/arraycast.d internal/arraycat.d \
-        internal/switch.d internal/qsort.d internal/invariant.d \
-        internal/dmain2.d internal/cast.d internal/obj.d \
-        internal/arrayfloat.d internal/arraydouble.d internal/arrayreal.d \
-        internal/arraybyte.d internal/arrayshort.d internal/arrayint.d \
-
-
-ZLIB_OBJS = etc/c/zlib/adler32.o etc/c/zlib/compress.o \
-	etc/c/zlib/crc32.o etc/c/zlib/gzio.o \
-	etc/c/zlib/uncompr.o etc/c/zlib/deflate.o \
-	etc/c/zlib/trees.o etc/c/zlib/zutil.o \
-	etc/c/zlib/inflate.o etc/c/zlib/infback.o \
-	etc/c/zlib/inftrees.o etc/c/zlib/inffast.o
-
-GC_OBJS= internal/gc/gc.o internal/gc/gcold.o internal/gc/gcx.o \
-	internal/gc/gcbits.o internal/gc/gclinux.o internal/gc/gcosxc.o
-
-SRC=	errno.c object.d unittest.d crc32.d gcstats.d
-
-SRC_STD= std/zlib.d std/zip.d std/stdint.d std/conv.d std/utf.d std/uri.d \
-	std/gc.d std/math.d std/string.d std/path.d std/date.d \
-	std/ctype.d std/file.d std/compiler.d std/system.d std/moduleinit.d \
-	std/outbuffer.d std/math2.d std/thread.d std/md5.d std/base64.d \
-	std/asserterror.d std/dateparse.d std/outofmemory.d std/mmfile.d \
-	std/intrinsic.d std/array.d std/switcherr.d std/syserror.d \
-	std/regexp.d std/random.d std/stream.d std/process.d \
-	std/socket.d std/socketstream.d std/loader.d std/stdarg.d \
-	std/stdio.d std/format.d std/perf.d std/openrj.d std/uni.d \
-	std/boxer.d std/cstream.d std/demangle.d std/cover.d std/bitarray.d \
-	std/signals.d std/cpuid.d std/typetuple.d std/traits.d std/bind.d \
-	std/metastrings.d
-
-SRC_STD_C= std/c/process.d std/c/stdlib.d std/c/time.d std/c/stdio.d \
-	std/c/math.d std/c/stdarg.d std/c/stddef.d std/c/fenv.d std/c/string.d \
-	std/d/locale.d
-
-SRC_TI=	\
-	std/typeinfo/ti_wchar.d std/typeinfo/ti_uint.d \
-	std/typeinfo/ti_short.d std/typeinfo/ti_ushort.d \
-	std/typeinfo/ti_byte.d std/typeinfo/ti_ubyte.d \
-	std/typeinfo/ti_long.d std/typeinfo/ti_ulong.d \
-	std/typeinfo/ti_ptr.d \
-	std/typeinfo/ti_float.d std/typeinfo/ti_double.d \
-	std/typeinfo/ti_real.d std/typeinfo/ti_delegate.d \
-	std/typeinfo/ti_creal.d std/typeinfo/ti_ireal.d \
-	std/typeinfo/ti_cfloat.d std/typeinfo/ti_ifloat.d \
-	std/typeinfo/ti_cdouble.d std/typeinfo/ti_idouble.d \
-	std/typeinfo/ti_Adchar.d \
-	std/typeinfo/ti_Ashort.d \
-	std/typeinfo/ti_Ag.d \
-	std/typeinfo/ti_AC.d std/typeinfo/ti_C.d \
-	std/typeinfo/ti_int.d std/typeinfo/ti_char.d \
-	std/typeinfo/ti_Aint.d \
-	std/typeinfo/ti_Along.d \
-	std/typeinfo/ti_Afloat.d std/typeinfo/ti_Adouble.d \
-	std/typeinfo/ti_Areal.d \
-	std/typeinfo/ti_Acfloat.d std/typeinfo/ti_Acdouble.d \
-	std/typeinfo/ti_Acreal.d \
-	std/typeinfo/ti_void.d
-
-SRC_INT=	\
-	internal/switch.d internal/complex.c internal/critical.c \
-	internal/minit.asm internal/alloca.d internal/llmath.d internal/deh.c \
-	internal/arraycat.d internal/invariant.d internal/monitor.c \
-	internal/memset.d internal/arraycast.d internal/aaA.d internal/adi.d \
-	internal/dmain2.d internal/cast.d internal/qsort.d internal/deh2.d \
-	internal/cmath2.d internal/obj.d internal/mars.h internal/aApply.d \
-	internal/aApplyR.d internal/object.d internal/trace.d internal/qsort2.d
-
-SRC_STD_WIN= std/windows/registry.d \
-	std/windows/iunknown.d std/windows/charset.d
-
-SRC_STD_C_WIN= std/c/windows/windows.d std/c/windows/com.d \
-	std/c/windows/winsock.d std/c/windows/stat.d
-
-SRC_STD_C_LINUX= std/c/linux/linux.d std/c/linux/linuxextern.d \
-	std/c/linux/socket.d std/c/linux/pthread.d
-
-SRC_ETC=  etc/gamma.d
-
-SRC_ETC_C= etc/c/zlib.d
-
-SRC_ZLIB= etc/c/zlib/trees.h \
-	etc/c/zlib/inffixed.h \
-	etc/c/zlib/inffast.h \
-	etc/c/zlib/crc32.h \
-	etc/c/zlib/algorithm.txt \
-	etc/c/zlib/uncompr.c \
-	etc/c/zlib/compress.c \
-	etc/c/zlib/deflate.h \
-	etc/c/zlib/inftrees.h \
-	etc/c/zlib/infback.c \
-	etc/c/zlib/zutil.c \
-	etc/c/zlib/crc32.c \
-	etc/c/zlib/inflate.h \
-	etc/c/zlib/example.c \
-	etc/c/zlib/inffast.c \
-	etc/c/zlib/trees.c \
-	etc/c/zlib/inflate.c \
-	etc/c/zlib/gzio.c \
-	etc/c/zlib/zconf.h \
-	etc/c/zlib/zconf.in.h \
-	etc/c/zlib/minigzip.c \
-	etc/c/zlib/deflate.c \
-	etc/c/zlib/inftrees.c \
-	etc/c/zlib/zutil.h \
-	etc/c/zlib/zlib.3 \
-	etc/c/zlib/zlib.h \
-	etc/c/zlib/adler32.c \
-	etc/c/zlib/ChangeLog \
-	etc/c/zlib/README \
-	etc/c/zlib/win32.mak \
-	etc/c/zlib/linux.mak \
-	etc/c/zlib/osx.mak
-
-SRC_GC= internal/gc/gc.d \
-	internal/gc/gcold.d \
-	internal/gc/gcx.d \
-	internal/gc/gcstub.d \
-	internal/gc/gcbits.d \
-	internal/gc/win32.d \
-	internal/gc/gclinux.d \
-	internal/gc/gcosxc.c \
-	internal/gc/testgc.d \
-	internal/gc/win32.mak \
-	internal/gc/linux.mak \
-	internal/gc/osx.mak
-
-ALLSRCS = $(SRC) $(SRC_STD) $(SRC_STD_C) $(SRC_TI) $(SRC_INT) $(SRC_STD_WIN) \
-	$(SRC_STD_C_WIN) $(SRC_STD_C_LINUX) $(SRC_ETC) $(SRC_ETC_C) \
-	$(SRC_ZLIB) $(SRC_GC)
-
-
-$(LIB) : $(OBJS) $(GC_OBJS) $(ZLIB_OBJS) $(SRCS) $(MAKEFILE)
-#	rm -f $(LIB)
-#	ar -r $@ $(OBJS) $(ZLIB_OBJS) $(GC_OBJS)
-	$(DMD) -lib -of$(LIB) $(DFLAGS) $(SRCS) $(OBJS) $(ZLIB_OBJS) $(GC_OBJS)
-
-unittest :
-	$(DMD) $(DFLAGS) -unittest -version=Unittest unittest.d $(SRCS)
-	./unittest
-
-cov : $(SRCS) $(LIB)
-	$(DMD) -cov -unittest -ofcov unittest.d $(SRCS) $(LIB)
-	./cov
-
-
-###########################################################
-
-$(GC_OBJS):
-#	cd internal/gc
-#	make -f $(MAKEFILE) dmgc.a
-#	cd ../..
-	make DMD=$(DMD) -C ./internal/gc -f $(MAKEFILE)
-
-$(ZLIB_OBJS):
-#	cd etc/c/zlib
-#	make -f $(MAKEFILE)
-#	cd ../../..
-	make -C ./etc/c/zlib -f $(MAKEFILE)
-
-###
-
-Dcrc32.o : crc32.d
-	$(DMD) -c $(DFLAGS) crc32.d -ofDcrc32.o
-
-errno.o : errno.c
-
-gcstats.o : gcstats.d
-	$(DMD) -c $(DFLAGS) gcstats.d
-
-### internal
-
-aaA.o : internal/aaA.d
-	$(DMD) -c $(DFLAGS) internal/aaA.d
-
-aApply.o : internal/aApply.d
-	$(DMD) -c $(DFLAGS) internal/aApply.d
-
-aApplyR.o : internal/aApplyR.d
-	$(DMD) -c $(DFLAGS) internal/aApplyR.d
-
-adi.o : internal/adi.d
-	$(DMD) -c $(DFLAGS) internal/adi.d
-
-alloca.o : internal/alloca.d
-	$(DMD) -c $(DFLAGS) internal/alloca.d
-
-arraycast.o : internal/arraycast.d
-	$(DMD) -c $(DFLAGS) internal/arraycast.d
-
-arraycat.o : internal/arraycat.d
-	$(DMD) -c $(DFLAGS) internal/arraycat.d
-
-cast.o : internal/cast.d
-	$(DMD) -c $(DFLAGS) internal/cast.d
-
-cmath2.o : internal/cmath2.d
-	$(DMD) -c $(DFLAGS) internal/cmath2.d
-
-complex.o : internal/complex.c
-	$(CC) -c $(CFLAGS) internal/complex.c
-
-critical.o : internal/critical.c
-	$(CC) -c $(CFLAGS) internal/critical.c
-
-#deh.o : internal/mars.h internal/deh.cA
-#	$(CC) -c $(CFLAGS) internal/deh.c
-
-deh2.o : internal/deh2.d
-	$(DMD) -c $(DFLAGS) -release internal/deh2.d
-
-dmain2.o : internal/dmain2.d
-	$(DMD) -c $(DFLAGS) internal/dmain2.d
-
-invariant.o : internal/invariant.d
-	$(DMD) -c $(DFLAGS) internal/invariant.d
-
-llmath.o : internal/llmath.d
-	$(DMD) -c $(DFLAGS) internal/llmath.d
-
-memset.o : internal/memset.d
-	$(DMD) -c $(DFLAGS) internal/memset.d
-
-#minit.o : internal/minit.asm
-#	$(CC) -c internal/minit.asm
-
-monitor.o : internal/mars.h internal/monitor.c
-	$(CC) -c $(CFLAGS) internal/monitor.c
-
-obj.o : internal/obj.d
-	$(DMD) -c $(DFLAGS) internal/obj.d
-
-object.o : internal/object.d
-	$(DMD) -c $(DFLAGS) internal/object.d
-
-qsort.o : internal/qsort.d
-	$(DMD) -c $(DFLAGS) internal/qsort.d
-
-switch.o : internal/switch.d
-	$(DMD) -c $(DFLAGS) internal/switch.d
-
-trace.o : internal/trace.d
-	$(DMD) -c $(DFLAGS) internal/trace.d
-
-### std
-
-array.o : std/array.d
-	$(DMD) -c $(DFLAGS) std/array.d
-
-asserterror.o : std/asserterror.d
-	$(DMD) -c $(DFLAGS) std/asserterror.d
-
-base64.o : std/base64.d
-	$(DMD) -c $(DFLAGS) std/base64.d
-
-bind.o : std/bind.d
-	$(DMD) -c $(DFLAGS) std/bind.d
-
-bitarray.o : std/bitarray.d
-	$(DMD) -c $(DFLAGS) std/bitarray.d
-
-boxer.o : std/boxer.d
-	$(DMD) -c $(DFLAGS) std/boxer.d
-
-compiler.o : std/compiler.d
-	$(DMD) -c $(DFLAGS) std/compiler.d
-
-conv.o : std/conv.d
-	$(DMD) -c $(DFLAGS) std/conv.d
-
-cover.o : std/cover.d
-	$(DMD) -c $(DFLAGS) std/cover.d
-
-cpuid.o : std/cpuid.d
-	$(DMD) -c $(DFLAGS) std/cpuid.d
-
-cstream.o : std/cstream.d
-	$(DMD) -c $(DFLAGS) std/cstream.d
-
-ctype.o : std/ctype.d
-	$(DMD) -c $(DFLAGS) std/ctype.d
-
-date.o : std/dateparse.d std/date.d
-	$(DMD) -c $(DFLAGS) std/date.d
-
-dateparse.o : std/dateparse.d std/date.d
-	$(DMD) -c $(DFLAGS) std/dateparse.d
-
-demangle.o : std/demangle.d
-	$(DMD) -c $(DFLAGS) std/demangle.d
-
-file.o : std/file.d
-	$(DMD) -c $(DFLAGS) std/file.d
-
-format.o : std/format.d
-	$(DMD) -c $(DFLAGS) std/format.d
-
-gc.o : std/gc.d
-	$(DMD) -c $(DFLAGS) std/gc.d
-
-loader.o : std/loader.d
-	$(DMD) -c $(DFLAGS) std/loader.d
-
-math.o : std/math.d
-	$(DMD) -c $(DFLAGS) std/math.d
-
-math2.o : std/math2.d
-	$(DMD) -c $(DFLAGS) std/math2.d
-
-md5.o : std/md5.d
-	$(DMD) -c $(DFLAGS) std/md5.d
-
-metastrings.o : std/metastrings.d
-	$(DMD) -c $(DFLAGS) std/metastrings.d
-
-mmfile.o : std/mmfile.d
-	$(DMD) -c $(DFLAGS) std/mmfile.d
-
-moduleinit.o : std/moduleinit.d
-	$(DMD) -c $(DFLAGS) std/moduleinit.d
-
-openrj.o : std/openrj.d
-	$(DMD) -c $(DFLAGS) std/openrj.d
-
-outbuffer.o : std/outbuffer.d
-	$(DMD) -c $(DFLAGS) std/outbuffer.d
-
-outofmemory.o : std/outofmemory.d
-	$(DMD) -c $(DFLAGS) std/outofmemory.d
-
-path.o : std/path.d
-	$(DMD) -c $(DFLAGS) std/path.d
-
-perf.o : std/perf.d
-	$(DMD) -c $(DFLAGS) std/perf.d
-
-process.o : std/process.d
-	$(DMD) -c $(DFLAGS) std/process.d
-
-random.o : std/random.d
-	$(DMD) -c $(DFLAGS) std/random.d
-
-regexp.o : std/regexp.d
-	$(DMD) -c $(DFLAGS) std/regexp.d
-
-signals.o : std/signals.d
-	$(DMD) -c $(DFLAGS) std/signals.d
-
-socket.o : std/socket.d
-	$(DMD) -c $(DFLAGS) std/socket.d
-
-socketstream.o : std/socketstream.d
-	$(DMD) -c $(DFLAGS) std/socketstream.d
-
-stdio.o : std/stdio.d
-	$(DMD) -c $(DFLAGS) std/stdio.d
-
-stream.o : std/stream.d
-	$(DMD) -c $(DFLAGS) -d std/stream.d
-
-string.o : std/string.d
-	$(DMD) -c $(DFLAGS) std/string.d
-
-switcherr.o : std/switcherr.d
-	$(DMD) -c $(DFLAGS) std/switcherr.d
-
-system.o : std/system.d
-	$(DMD) -c $(DFLAGS) std/system.d
-
-syserror.o : std/syserror.d
-	$(DMD) -c $(DFLAGS) std/syserror.d
-
-thread.o : std/thread.d
-	$(DMD) -c $(DFLAGS) std/thread.d
-
-traits.o : std/traits.d
-	$(DMD) -c $(DFLAGS) std/traits.d
-
-typetuple.o : std/typetuple.d
-	$(DMD) -c $(DFLAGS) std/typetuple.d
-
-uri.o : std/uri.d
-	$(DMD) -c $(DFLAGS) std/uri.d
-
-uni.o : std/uni.d
-	$(DMD) -c $(DFLAGS) std/uni.d
-
-utf.o : std/utf.d
-	$(DMD) -c $(DFLAGS) std/utf.d
-
-Dzlib.o : std/zlib.d
-	$(DMD) -c $(DFLAGS) std/zlib.d -ofDzlib.o
-
-zip.o : std/zip.d
-	$(DMD) -c $(DFLAGS) std/zip.d
-
-### std/c
-
-stdarg.o : std/c/stdarg.d
-	$(DMD) -c $(DFLAGS) std/c/stdarg.d
-
-### std/c/linux
-
-linux.o : std/c/linux/linux.d
-	$(DMD) -c $(DFLAGS) std/c/linux/linux.d
-
-linuxsocket.o : std/c/linux/socket.d
-	$(DMD) -c $(DFLAGS) std/c/linux/socket.d -oflinuxsocket.o
-	
-pthread.o : std/c/linux/pthread.d
-	$(DMD) -c $(DFLAGS) std/c/linux/pthread.d	
-	
-### std/c/osx
-
-osx.o : std/c/osx/osx.d
-	$(DMD) -c $(DFLAGS) std/c/osx/osx.d	
-
-### etc
-
-### etc/c
-
-Czlib.o : etc/c/zlib.d
-	$(DMD) -c $(DFLAGS) etc/c/zlib.d -ofCzlib.o
-
-### std/typeinfo
-
-ti_void.o : std/typeinfo/ti_void.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_void.d
-
-ti_wchar.o : std/typeinfo/ti_wchar.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_wchar.d
-
-ti_dchar.o : std/typeinfo/ti_dchar.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_dchar.d
-
-ti_uint.o : std/typeinfo/ti_uint.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_uint.d
-
-ti_short.o : std/typeinfo/ti_short.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_short.d
-
-ti_ushort.o : std/typeinfo/ti_ushort.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_ushort.d
-
-ti_byte.o : std/typeinfo/ti_byte.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_byte.d
-
-ti_ubyte.o : std/typeinfo/ti_ubyte.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_ubyte.d
-
-ti_long.o : std/typeinfo/ti_long.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_long.d
-
-ti_ulong.o : std/typeinfo/ti_ulong.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_ulong.d
-
-ti_ptr.o : std/typeinfo/ti_ptr.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_ptr.d
-
-ti_float.o : std/typeinfo/ti_float.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_float.d
-
-ti_double.o : std/typeinfo/ti_double.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_double.d
-
-ti_real.o : std/typeinfo/ti_real.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_real.d
-
-ti_delegate.o : std/typeinfo/ti_delegate.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_delegate.d
-
-ti_creal.o : std/typeinfo/ti_creal.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_creal.d
-
-ti_ireal.o : std/typeinfo/ti_ireal.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_ireal.d
-
-ti_cfloat.o : std/typeinfo/ti_cfloat.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_cfloat.d
-
-ti_ifloat.o : std/typeinfo/ti_ifloat.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_ifloat.d
-
-ti_cdouble.o : std/typeinfo/ti_cdouble.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_cdouble.d
-
-ti_idouble.o : std/typeinfo/ti_idouble.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_idouble.d
-
-ti_AC.o : std/typeinfo/ti_AC.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_AC.d
-
-ti_Ag.o : std/typeinfo/ti_Ag.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_Ag.d
-
-ti_Abit.o : std/typeinfo/ti_Abit.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_Abit.d
-
-ti_Ashort.o : std/typeinfo/ti_Ashort.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_Ashort.d
-
-ti_Aint.o : std/typeinfo/ti_Aint.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_Aint.d
-
-ti_Along.o : std/typeinfo/ti_Along.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_Along.d
-
-ti_Afloat.o : std/typeinfo/ti_Afloat.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_Afloat.d
-
-ti_Adouble.o : std/typeinfo/ti_Adouble.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_Adouble.d
-
-ti_Areal.o : std/typeinfo/ti_Areal.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_Areal.d
-
-ti_Acfloat.o : std/typeinfo/ti_Acfloat.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_Acfloat.d
-
-ti_Acdouble.o : std/typeinfo/ti_Acdouble.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_Acdouble.d
-
-ti_Acreal.o : std/typeinfo/ti_Acreal.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_Acreal.d
-
-ti_C.o : std/typeinfo/ti_C.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_C.d
-
-ti_char.o : std/typeinfo/ti_char.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_char.d
-
-ti_int.o : std/typeinfo/ti_int.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_int.d
-
-ti_bit.o : std/typeinfo/ti_bit.d
-	$(DMD) -c $(DFLAGS) std/typeinfo/ti_bit.d
-
-
-##########################################################
-
-zip : $(ALLSRCS) osx.mak linux.mak win32.mak phoboslicense.txt
-	$(RM) phobos.zip
-	zip phobos $(ALLSRCS) osx.mak linux.mak win32.mak phoboslicense.txt
-
-clean:
-	$(RM) $(LIB) $(OBJS) unittest unittest.o
-	make -C ./internal/gc -f $(MAKEFILE) clean
-	make -C ./etc/c/zlib -f $(MAKEFILE) clean
-
diff -r 6a92bcae44c5 d/phobos/std/array.d
--- a/d/phobos/std/array.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/array.d	Sat Jun 26 21:05:08 2010 +0100
@@ -18,8 +18,7 @@
 
 	char[] buffer = new char[19 + filename.length + linnum.sizeof * 3 + 1];
 	int len;
-	len = sprintf(buffer.ptr, "ArrayBoundsError %.*s(%u)",
-	    cast(int) filename.length, filename.ptr, linnum);
+	len = sprintf(buffer.ptr, "ArrayBoundsError %.*s(%u)", filename, linnum);
 	super(buffer[0..len]);
     }
 }
diff -r 6a92bcae44c5 d/phobos/std/asserterror.d
--- a/d/phobos/std/asserterror.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/asserterror.d	Sat Jun 26 21:05:08 2010 +0100
@@ -36,7 +36,7 @@
 	{
 	    version (Win32) alias _snprintf snprintf;
 	    count = snprintf(buffer, len, "AssertError Failure %.*s(%u) %.*s",
-		cast(int) filename.length, filename.ptr, linnum, msg);
+		filename, linnum, msg);
 	    if (count >= len || count == -1)
 	    {	super("AssertError internal failure");
 		std.c.stdlib.free(buffer);
diff -r 6a92bcae44c5 d/phobos/std/bind.d
--- a/d/phobos/std/bind.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/bind.d	Sat Jun 26 21:05:08 2010 +0100
@@ -214,7 +214,7 @@
 	
 	
 	string toString() {
- 		auto res = "(" ~ stdFormat(value[0]);
+		auto res = "(" ~ stdFormat(value[0]);
 		foreach (x; value[1..$]) {
 			res ~= stdFormat(", ", x);
 		}
diff -r 6a92bcae44c5 d/phobos/std/boxer.d
--- a/d/phobos/std/boxer.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/boxer.d	Sat Jun 26 21:05:08 2010 +0100
@@ -53,6 +53,11 @@
  *	Burton Radons
  * License:
  *	Public Domain
+ * Bugs:
+ *	$(UL
+ *	$(LI $(BUGZILLA 309))
+ *	$(LI $(BUGZILLA 1968))
+ *	)
  * Macros:
  *	WIKI=Phobos/StdBoxer
  */
@@ -70,6 +75,7 @@
 private import std.format;
 private import std.string;
 private import std.utf;
+
 version (GNU)
     private import std.stdarg;
 
@@ -165,7 +171,7 @@
         void* p_longData; /**< An array of the contained object. */
         void[8] p_shortData; /**< Data used when the object is small. */
     }
-
+    
     private static TypeClass findTypeClass(TypeInfo type)
     {
         if (cast(TypeInfo_Class) type)
@@ -203,7 +209,6 @@
                 default: return TypeClass.Other;
             }
         }
-	//assert(0);
     }
     
     /** Return whether this value could be unboxed as the given type without throwing. */
@@ -296,7 +301,7 @@
 	    std.format.doFormatPtr(&putc, arguments, dummy, args.ptr);
 	}
 	else
-	    std.format.doFormat(&putc, arguments, args.ptr);
+    	    std.format.doFormat(&putc, arguments, args.ptr);
         delete args;
         
         return string;
@@ -423,10 +428,10 @@
     version (GNU)
     {
 	// Help for promoted types
-	TypeInfo ti_orig = _arguments[0]; 
+        TypeInfo ti_orig = _arguments[0];
 	TypeInfo ti = ti_orig;
 	TypeInfo_Typedef ttd;
-	
+
 	while ( (ttd = cast(TypeInfo_Typedef) ti) !is null )
 	    ti = ttd.base;
 
@@ -500,15 +505,15 @@
     return array;
 }
 
- /**
-  * Box each argument passed to the function, returning an array of boxes.
-  */    
+/**
+ * Box each argument passed to the function, returning an array of boxes.
+ */    
 Box[] boxArray(...)
 {
     version (GNU)
     {
 	Box[] array = new Box[_arguments.length];
-	
+
 	foreach(size_t index, TypeInfo ti_orig; _arguments)
 	{
 	    TypeInfo ti = ti_orig;
@@ -544,12 +549,12 @@
 	return array;
     }
     else
-	return boxArray(_arguments, cast(void *) _argptr);
+	return boxArray(_arguments, cast(void*) _argptr);
 }
 
- /**
-  * Convert an array of boxes into an array of arguments.
-  */    
+/**
+ * Convert an array of boxes into an array of arguments.
+ */    
 void boxArrayToArguments(Box[] arguments, out TypeInfo[] types, out void* data)
 {
     size_t dataLength;
diff -r 6a92bcae44c5 d/phobos/std/c/fenv.d
--- a/d/phobos/std/c/fenv.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/c/fenv.d	Sat Jun 26 21:05:08 2010 +0100
@@ -14,7 +14,7 @@
 version (Windows)
 {
     /// Entire floating point environment
- 
+
     struct fenv_t
     {
 	ushort status;
@@ -23,36 +23,36 @@
 	ushort reserved[2];
     }
     extern fenv_t _FE_DFL_ENV;
- 
-     /// Default floating point environment
-     fenv_t* FE_DFL_ENV = &_FE_DFL_ENV;
- 
-     alias int fexcept_t;	/// Floating point status flags
- 
-     int fetestexcept(int excepts);		///
-     int feraiseexcept(int excepts);		///
-     int feclearexcept(int excepts);		///
-     //int fegetexcept(fexcept_t *flagp,int excepts);	///
-     //int fesetexcept(fexcept_t *flagp,int excepts);	///
-     int fegetround();			///
-     int fesetround(int round);		///
-     int fegetprec();			///
-     int fesetprec(int prec);		///
-     int fegetenv(fenv_t *envp);		///
-     int fesetenv(fenv_t *envp);		///
-     //void feprocentry(fenv_t *envp);	///
-     //void feprocexit(const fenv_t *envp);	///
- 
-     int fegetexceptflag(fexcept_t *flagp,int excepts);	///
-     int fesetexceptflag(fexcept_t *flagp,int excepts);	///
-     int feholdexcept(fenv_t *envp);		///
-     int feupdateenv(fenv_t *envp);		///
- 
- }
- else version (linux)
- {
-     /// Entire floating point environment
- 
+
+    /// Default floating point environment
+    fenv_t* FE_DFL_ENV = &_FE_DFL_ENV;
+
+    alias int fexcept_t;	/// Floating point status flags
+
+    int fetestexcept(int excepts);		///
+    int feraiseexcept(int excepts);		///
+    int feclearexcept(int excepts);		///
+    //int fegetexcept(fexcept_t *flagp,int excepts);	///
+    //int fesetexcept(fexcept_t *flagp,int excepts);	///
+    int fegetround();			///
+    int fesetround(int round);		///
+    int fegetprec();			///
+    int fesetprec(int prec);		///
+    int fegetenv(fenv_t *envp);		///
+    int fesetenv(fenv_t *envp);		///
+    //void feprocentry(fenv_t *envp);	///
+    //void feprocexit(const fenv_t *envp);	///
+
+    int fegetexceptflag(fexcept_t *flagp,int excepts);	///
+    int fesetexceptflag(fexcept_t *flagp,int excepts);	///
+    int feholdexcept(fenv_t *envp);		///
+    int feupdateenv(fenv_t *envp);		///
+
+}
+else version (linux)
+{
+    /// Entire floating point environment
+
     struct fenv_t
     {
 	ushort __control_word;
@@ -81,7 +81,7 @@
     //int fegetexcept(fexcept_t *flagp,int excepts);	///
     //int fesetexcept(fexcept_t *flagp,int excepts);	///
     int fegetround();			///
-   int fesetround(int round);		///
+    int fesetround(int round);		///
     int fegetprec();			///
     int fesetprec(int prec);		///
     int fegetenv(fenv_t *envp);		///
@@ -96,10 +96,10 @@
 }
 else version (OSX)
 {
-  /// Entire floating point environment
+    /// Entire floating point environment
 
-   struct fenv_t
-   {
+    struct fenv_t
+    {
 	ushort __control;
 	ushort __status;
 	uint __mxcsr;
@@ -138,15 +138,15 @@
 
     struct fenv_t
     {
-		struct X87
-		{
-		    uint __control;
-		    uint __status;
-		    uint __tag;
-		    char[16] other;
-	   }
-	   X87 __x87;
-		uint __mxcsr;
+	struct X87
+	{
+	    uint __control;
+	    uint __status;
+	    uint __tag;
+	    char[16] other;
+	}
+	X87 __x87;
+	uint __mxcsr;
     }
 
     extern fenv_t __fe_defl_env;
@@ -202,7 +202,8 @@
 {
     static assert(0);
 }
-}
+
+
 
 /// The various floating point exceptions
 enum
diff -r 6a92bcae44c5 d/phobos/std/c/freebsd/freebsd.d
--- a/d/phobos/std/c/freebsd/freebsd.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/c/freebsd/freebsd.d	Sat Jun 26 21:05:08 2010 +0100
@@ -23,16 +23,16 @@
     int   dlclose(void* handle);
     void* dlsym(void* handle, char* name);
     char* dlerror();
-
-	extern
+    
+    extern
     {
-		void* __libc_stack_end;
-		int __data_start;
-		int _end;
-		int timezone;
+	void* __libc_stack_end;
+	int __data_start;
+	int _end;
+	int timezone;
 	
-		void *_deh_beg;
-		void *_deh_end;
+	void *_deh_beg;
+	void *_deh_end;
     }
 }
 
diff -r 6a92bcae44c5 d/phobos/std/c/linux/linux.d
--- a/d/phobos/std/c/linux/linux.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/c/linux/linux.d	Sat Jun 26 21:05:08 2010 +0100
@@ -18,17 +18,17 @@
 	public import std.c.dirent;
 	public import std.c.linux.linuxextern;
 
-	extern (C)
-	{
-	    /* From <dlfcn.h>
-	     * See http://www.opengroup.org/onlinepubs/007908799/xsh/dlsym.html
-	     */
+extern (C)
+{
+    /* From <dlfcn.h>
+     * See http://www.opengroup.org/onlinepubs/007908799/xsh/dlsym.html
+     */
 
-	    const int RTLD_NOW = 0x00002;	// Correct for Red Hat 8
+    const int RTLD_NOW = 0x00002;	// Correct for Red Hat 8
 
-	    void* dlopen(in char* file, int mode);
-	    int   dlclose(void* handle);
-	    void* dlsym(void* handle, char* name);
-	    char* dlerror();
-	}
+    void* dlopen(in char* file, int mode);
+    int   dlclose(void* handle);
+    void* dlsym(void* handle, char* name);
+    char* dlerror();
 }
+}
diff -r 6a92bcae44c5 d/phobos/std/c/linux/linuxextern.d
--- a/d/phobos/std/c/linux/linuxextern.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/c/linux/linuxextern.d	Sat Jun 26 21:05:08 2010 +0100
@@ -1,6 +1,6 @@
 
 /* Written by Walter Bright.
- * http://www.digitalmars.com/d/
+ * www.digitalmars.com
  * Placed into public domain.
  * Linux(R) is the registered trademark of Linus Torvalds in the U.S. and other
  * countries.
diff -r 6a92bcae44c5 d/phobos/std/c/linux/pthread.d.orig-dmd
--- a/d/phobos/std/c/linux/pthread.d.orig-dmd	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/c/linux/pthread.d.orig-dmd	Sat Jun 26 21:05:08 2010 +0100
@@ -1,30 +1,31 @@
 /* Written by Walter Bright, Christopher E. Miller, and many others.
- * www.digitalmars.com
+ * http://www.digitalmars.com
  * Placed into public domain.
  */
 
 module std.c.linux.pthread;
 
-extern (C)
+version (FreeBSD)
+{
+    public import std.c.freebsd.pthread;
+}
+else version (Solaris)
+{
+    public import std.c.solaris.pthread;
+}
+else
+{
+
+import std.c.linux.linux;
+
+extern (C):
+
+version(linux)
 {
     /*  pthread declarations taken from pthread headers and
         http://svn.dsource.org/projects/bindings/trunk/pthreads.d
     */
 
-    /* from bits/types.h
-    */
-
-    typedef int __time_t;
-
-    /* from time.h
-    */
-
-    struct timespec
-    {
-        __time_t tv_sec;    /* seconds   */
-        int tv_nsec;        /* nanosecs. */
-    }
-
     /* from bits/pthreadtypes.h
     */
 
@@ -52,7 +53,7 @@
 
     typedef long __pthread_cond_align_t;
 
-    struct pthread_cond_t 
+    struct pthread_cond_t
     {
         _pthread_fastlock __c_lock;
         _pthread_descr    __c_waiting;
@@ -141,6 +142,138 @@
 	int __rw_kind;
 	int __rw_pshared;
     }
+    
+    enum
+    {
+	PTHREAD_CANCEL_ENABLE,
+	PTHREAD_CANCEL_DISABLE
+    }
+
+    enum
+    {
+	PTHREAD_CANCEL_DEFERRED,
+	PTHREAD_CANCEL_ASYNCHRONOUS
+    }    
+}
+
+version(OSX)
+{
+    /* from bits/types.h
+    */
+
+    // in std.c.linux.linux
+    //typedef int __time_t;
+
+    /* from time.h
+    */
+
+    /* from bits/pthreadtypes.h
+    */
+    private struct _opaque_pthread_t
+    {
+        int       __sig;
+        void*     __cleanup_stack;
+        byte[596] __opaque;
+    }
+
+    alias _opaque_pthread_t* pthread_t;
+
+    alias uint pthread_key_t;
+
+    struct pthread_once_t
+    {
+        int     __sig;
+        byte[4] __opaque;
+    }
+
+    //alias int clockid_t;
+    //alias int pthread_spinlock_t;	// volatile
+
+    struct pthread_cond_t
+    {
+        int      __sig;
+        byte[24] __opaque;
+    }
+
+    struct pthread_condattr_t
+    {
+        int     __sig;
+        byte[4] __opaque;
+    }
+
+    struct pthread_mutex_t
+    {
+        int      __sig;
+        byte[40] __opaque;
+    }
+
+    struct pthread_mutexattr_t
+    {
+        int     __sig;
+        byte[8] __opaque;
+    }
+
+    /* from pthread.h
+    */
+
+    struct _pthread_cleanup_buffer
+    {
+        void function(void*)     __routine;
+        void*                    __arg;
+        _pthread_cleanup_buffer* __next;
+    }
+
+    struct __sched_param
+    {
+        int     sched_priority;
+        byte[4] opaque;
+    }
+
+    struct pthread_attr_t
+    {
+        int      __sig;
+        byte[36] __opaque;
+    }
+
+    /+
+    struct pthread_barrier_t
+    {
+	_pthread_fastlock __ba_lock;
+	int __ba_required;
+	int __ba_present;
+	_pthread_descr __ba_waiting;
+    }
+
+    struct pthread_barrierattr_t
+    {
+	int __pshared;
+    }
+    +/
+
+    struct pthread_rwlockattr_t
+    {
+        int      __sig;
+        byte[12] __opaque;
+    }
+
+    struct pthread_rwlock_t
+    {
+        int       __sig;
+        byte[124] __opaque;
+    }
+    
+    enum
+    {
+	PTHREAD_CANCEL_ENABLE = 1,
+	PTHREAD_CANCEL_DISABLE = 0
+    }
+
+    enum
+    {
+	PTHREAD_CANCEL_DEFERRED = 2,
+	PTHREAD_CANCEL_ASYNCHRONOUS = 0
+    }    
+}
 
     int pthread_mutex_init(pthread_mutex_t*, pthread_mutexattr_t*);
     int pthread_mutex_destroy(pthread_mutex_t*);
@@ -178,6 +311,8 @@
     int pthread_attr_setstacksize(pthread_attr_t*, size_t);
     int pthread_attr_getstacksize(pthread_attr_t*, size_t*);
 
+version(linux)
+{
     int pthread_barrierattr_init(pthread_barrierattr_t*);
     int pthread_barrierattr_getpshared(pthread_barrierattr_t*, int*);
     int pthread_barrierattr_destroy(pthread_barrierattr_t*);
@@ -186,6 +321,7 @@
     int pthread_barrier_init(pthread_barrier_t*, pthread_barrierattr_t*, uint);
     int pthread_barrier_destroy(pthread_barrier_t*);
     int pthread_barrier_wait(pthread_barrier_t*);
+}
 
     int pthread_condattr_init(pthread_condattr_t*);
     int pthread_condattr_destroy(pthread_condattr_t*);
@@ -196,7 +332,11 @@
     void pthread_exit(void*);
     int pthread_getattr_np(pthread_t, pthread_attr_t*);
     int pthread_getconcurrency();
+
+version(linux)
+{
     int pthread_getcpuclockid(pthread_t, clockid_t*);
+}
 
     int pthread_mutexattr_getpshared(pthread_mutexattr_t*, int*);
     int pthread_mutexattr_setpshared(pthread_mutexattr_t*, int);
@@ -222,11 +362,14 @@
     int pthread_rwlockattr_getkind_np(pthread_rwlockattr_t*, int*);
     int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t*, int);
 
+version(linux)
+{
     int pthread_spin_init(pthread_spinlock_t*, int);
     int pthread_spin_destroy(pthread_spinlock_t*);
     int pthread_spin_lock(pthread_spinlock_t*);
     int pthread_spin_trylock(pthread_spinlock_t*);
     int pthread_spin_unlock(pthread_spinlock_t*);
+}
 
     int pthread_cancel(pthread_t);
     void pthread_testcancel();
@@ -237,6 +380,7 @@
     pthread_t pthread_self();
     int pthread_equal(pthread_t, pthread_t);
     int pthread_atfork(void function(), void function(), void function());
+    int pthread_kill(pthread_t, int);
     void pthread_kill_other_threads_np();
     int pthread_setschedparam(pthread_t, int, __sched_param*);
     int pthread_getschedparam(pthread_t, int*, __sched_param*);
@@ -253,5 +397,5 @@
     void _pthread_cleanup_push_defer(_pthread_cleanup_buffer*, void function(void*), void*);
     void _pthread_cleanup_pop(_pthread_cleanup_buffer*, int);
     void _pthread_cleanup_pop_restore(_pthread_cleanup_buffer*, int);
+
 }
-
diff -r 6a92bcae44c5 d/phobos/std/c/linux/socket.d
--- a/d/phobos/std/c/linux/socket.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/c/linux/socket.d	Sat Jun 26 21:05:08 2010 +0100
@@ -16,16 +16,16 @@
 }
 else
 {
+
 private import std.stdint;
 private import std.c.linux.linux;
 
-
 extern(C):
 
 version (linux)
 {
-	alias int socklen_t;
- 
+    alias int socklen_t;
+
     enum: int
     {
 	AF_UNSPEC =     0,
@@ -42,16 +42,15 @@
 	PF_IPX =        AF_IPX,
 	PF_APPLETALK =  AF_APPLETALK,
 	PF_INET6 =      AF_INET6,
-}
+    }
 
-enum: int
-{
+    enum: int
+    {
 	SOL_SOCKET =  1,
-}
+    }
 
-
-enum: int
-{
+    enum: int
+    {
 	SO_DEBUG =       1,
 	SO_BROADCAST =   6,
 	SO_REUSEADDR =   2,
@@ -97,7 +96,7 @@
 	IPV6_LEAVE_ANYCAST =   28,
 	IPV6_IPSEC_POLICY =    34,
 	IPV6_XFRM_POLICY =     35,
-}
+    }
 
     enum: int
     {
@@ -148,7 +147,7 @@
 	char* ai_canonname;
 	addrinfo* ai_next;
     }
-  }
+}
 else version (OSX)
 {
     alias uint socklen_t;
@@ -423,6 +422,7 @@
 	IPPROTO_MAX =   256,
 }
 
+
 enum: uint
 {
 	INADDR_ANY =        0,
@@ -504,6 +504,7 @@
 const uint INET_ADDRSTRLEN = 16;
 const uint INET6_ADDRSTRLEN = 46;
 
+
 struct hostent
 {
 	char* h_name;
diff -r 6a92bcae44c5 d/phobos/std/c/stddef.d
--- a/d/phobos/std/c/stddef.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/c/stddef.d	Sat Jun 26 21:05:08 2010 +0100
@@ -1,10 +1,10 @@
 
 /**
- * C's &lt;stdarg.h&gt;
- * Authors: Hauke Duden and Walter Bright, Digital Mars, http://www.digitalmars.com
+ * C's &lt;stddef.h&gt;
+ * Authors: Walter Bright, Digital Mars, http://www.digitalmars.com
  * License: Public Domain
  * Macros:
- *	WIKI=Phobos/StdCStdarg
+ *	WIKI=Phobos/StdCStddef
  */
 
 module std.c.stddef;
diff -r 6a92bcae44c5 d/phobos/std/c/stdio.d
--- a/d/phobos/std/c/stdio.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/c/stdio.d	Sat Jun 26 21:05:08 2010 +0100
@@ -1,7 +1,7 @@
 
 /**
- * C's &lt;stdio.h&gt;
- * Authors: Walter Bright, Digital Mars, www.digitalmars.com
+ * C's &lt;stdio.h&gt; for the D programming language
+ * Authors: Walter Bright, Digital Mars, http://www.digitalmars.com
  * License: Public Domain
  * Macros:
  *	WIKI=Phobos/StdCStdio
@@ -11,8 +11,7 @@
    work with the GDC compiler.
 
    Modified by David Friedman, September 2004
-*/
-
+ */
 
 
 module std.c.stdio;
@@ -23,18 +22,9 @@
 
 extern (C):
 
-version (GNU)
-{
-    private import gcc.builtins;
-    private import gcc.config.libc;
-    alias gcc.config.libc.EOF EOF;
-    alias gcc.config.libc.FOPEN_MAX FOPEN_MAX;
-    alias gcc.config.libc.FILENAME_MAX FILENAME_MAX;
-    alias gcc.config.libc.TMP_MAX TMP_MAX;
-    alias gcc.config.libc.L_tmpnam L_tmpnam;
-}
-else version (Win32)
-{
+version (Win32)
+{   // Meaning Digital Mars C for Win32
+
     const int _NFILE = 60;	///
     const int BUFSIZ = 0x4000;	///
     const int EOF = -1;		///
@@ -44,23 +34,11 @@
     const int _SYS_OPEN = 20;	///
     const int SYS_OPEN = _SYS_OPEN;	///
     const wchar WEOF = 0xFFFF;		///
-}
-else version (linux)
-{
-    const int EOF = -1;
-    const int FOPEN_MAX = 16;
-    const int FILENAME_MAX = 4095;
-    const int TMP_MAX = 238328;
-    const int L_tmpnam = 20;
-}
 
-enum { SEEK_SET, SEEK_CUR, SEEK_END }
+    struct _iobuf
+    {
+	align (1):
 
-struct _iobuf
-{
-    align (1):
-    version (Win32)
-    {
 	char	*_ptr;
 	int	_cnt;
 	char	*_base;
@@ -70,8 +48,99 @@
 	int	_bufsiz;
 	int	__tmpnum;
     }
-    else version (linux)
+
+    enum { SEEK_SET, SEEK_CUR, SEEK_END }
+
+    alias _iobuf FILE;	///
+
+    enum
     {
+	_F_RDWR = 0x0003,
+	_F_READ = 0x0001,
+	_F_WRIT = 0x0002,
+	_F_BUF  = 0x0004,
+	_F_LBUF = 0x0008,
+	_F_ERR  = 0x0010,
+	_F_EOF  = 0x0020,
+	_F_BIN  = 0x0040,
+	_F_IN   = 0x0080,
+	_F_OUT  = 0x0100,
+	_F_TERM = 0x0200,
+    }
+
+    version (GNU) {
+	extern export FILE _iob[5];
+    } else {
+    	extern FILE _iob[_NFILE];
+	extern void function() _fcloseallp;
+	extern ubyte __fhnd_info[_NFILE];
+
+	enum
+	{
+	    FHND_APPEND	= 0x04,
+    	    FHND_DEVICE	= 0x08,
+    	    FHND_TEXT	= 0x10,
+    	    FHND_BYTE	= 0x20,
+    	    FHND_WCHAR	= 0x40,
+    	}
+    }
+
+    enum
+    {
+	_IOREAD	= 1,
+	_IOWRT	= 2,
+	_IONBF	= 4,
+	_IOMYBUF = 8,
+	_IOEOF	= 0x10,
+	_IOERR	= 0x20,
+	_IOLBF	= 0x40,
+	_IOSTRG	= 0x40,
+	_IORW	= 0x80,
+	_IOFBF	= 0,
+	_IOAPP	= 0x200,
+	_IOTRAN	= 0x100,
+    }
+
+    const FILE *stdin  = &_iob[0];	///
+    const FILE *stdout = &_iob[1];	///
+    const FILE *stderr = &_iob[2];	///
+    const FILE *stdaux = &_iob[3];	///
+    const FILE *stdprn = &_iob[4];	///
+
+    const char[] _P_tmpdir = "\\";
+    const wchar[] _wP_tmpdir = "\\";
+    version (GNU) { }
+    else
+    {
+    	const int L_tmpnam = _P_tmpdir.length + 12;
+    }
+
+    ///
+    int  ferror(FILE *fp)	{ return fp._flag&_IOERR;	}
+    ///
+    int  feof(FILE *fp)	{ return fp._flag&_IOEOF;	}
+    ///
+    void clearerr(FILE *fp)	{ fp._flag &= ~(_IOERR|_IOEOF); }
+    ///
+    void rewind(FILE *fp)	{ fseek(fp,0L,SEEK_SET); fp._flag&=~_IOERR; }
+    int  _bufsize(FILE *fp)	{ return fp._bufsiz; }
+    ///
+    int  fileno(FILE *fp)	{ return fp._file; }
+    int  _snprintf(char *,size_t,char *,...);
+    int  _vsnprintf(char *,size_t,char *,va_list);
+}
+else version (linux)
+{
+    const int EOF = -1;
+    const int FOPEN_MAX = 16;
+    const int FILENAME_MAX = 4095;
+    const int TMP_MAX = 238328;
+    const int L_tmpnam = 20;
+
+    struct _iobuf
+    {
+	align (1):
+
 	char*	_read_ptr;
 	char*	_read_end;
 	char*	_read_base;
@@ -93,158 +162,432 @@
 	char[1]	_shortbuf;
 	void*	_lock;
     }
-    else version (GNU) {
-	byte[gcc.config.libc.FILE_struct_size] opaque;
-    }
-    
-}
 
-alias _iobuf FILE;	///
+    enum { SEEK_SET, SEEK_CUR, SEEK_END }
 
-enum
-{
-    _F_RDWR = 0x0003,
-    _F_READ = 0x0001,
-    _F_WRIT = 0x0002,
-    _F_BUF  = 0x0004,
-    _F_LBUF = 0x0008,
-    _F_ERR  = 0x0010,
-    _F_EOF  = 0x0020,
-    _F_BIN  = 0x0040,
-    _F_IN   = 0x0080,
-    _F_OUT  = 0x0100,
-    _F_TERM = 0x0200,
-}
+    alias _iobuf FILE;	///
 
-version (Win32)
-{
-    version (GNU) {
-	// _NFILE is not defined anywhere
-	extern export FILE _iob[5];
-    } else {
-	extern FILE _iob[_NFILE];
-	extern void function() _fcloseallp;
-	extern ubyte __fhnd_info[_NFILE];
-
-	enum
-	{
-	    FHND_APPEND	= 0x04,
-	    FHND_DEVICE	= 0x08,
-	    FHND_TEXT	= 0x10,
-	    FHND_BYTE	= 0x20,
-	    FHND_WCHAR	= 0x40,
-	}
-    }
-}
-
-version (Win32)
-{
     enum
     {
-	    _IOREAD	= 1,
-	    _IOWRT	= 2,
-	    _IONBF	= 4,
-	    _IOMYBUF	= 8,
-	    _IOEOF	= 0x10,
-	    _IOERR	= 0x20,
-	    _IOLBF	= 0x40,
-	    _IOSTRG	= 0x40,
-	    _IORW	= 0x80,
-	    _IOFBF	= 0,
-	    _IOAPP	= 0x200,
-	    _IOTRAN	= 0x100,
+	_F_RDWR = 0x0003,
+	_F_READ = 0x0001,
+	_F_WRIT = 0x0002,
+	_F_BUF  = 0x0004,
+	_F_LBUF = 0x0008,
+	_F_ERR  = 0x0010,
+	_F_EOF  = 0x0020,
+	_F_BIN  = 0x0040,
+	_F_IN   = 0x0080,
+	_F_OUT  = 0x0100,
+	_F_TERM = 0x0200,
     }
-}
 
-version (linux)
-{
     enum
     {
-	    _IOFBF = 0,
-	    _IOLBF = 1,
-	    _IONBF = 2,
+	_IOFBF = 0,
+	_IOLBF = 1,
+	_IONBF = 2,
     }
-}
 
-
-version (GNU_CBridge_Stdio)
-{
-    extern FILE * _d_gnu_cbridge_stdin;
-    extern FILE * _d_gnu_cbridge_stdout;
-    extern FILE * _d_gnu_cbridge_stderr;
-
-    /* Call from dgccmain2.  Can't use a static constructor here
-       because std.c.stdio is not compiled. */
-    extern void _d_gnu_cbridge_init_stdio();
-    
-    alias _d_gnu_cbridge_stdin stdin;
-    alias _d_gnu_cbridge_stdout stdout;
-    alias _d_gnu_cbridge_stderr stderr;
-}
-else version (Win32)
-{
-    // This works for DMD/DMC and MinGW/msvcrt
-    const FILE *stdin  = &_iob[0];	///
-    const FILE *stdout = &_iob[1];	///
-    const FILE *stderr = &_iob[2];	///
-    const FILE *stdaux = &_iob[3];	///
-    const FILE *stdprn = &_iob[4];	///
-}
-else version (aix)
-{
-    // 32- and 64-bit
-    extern FILE _iob[16];
-    const FILE *stdin  = &_iob[0];
-    const FILE *stdout = &_iob[1];
-    const FILE *stderr = &_iob[2];
-}
-else version (darwin)
-{
-    static if (size_t.sizeof == 4)
-    {
-	static assert(gcc.config.libc.FILE_struct_size != 0);
-	extern FILE __sF[3];
-	const FILE * stdin  = &__sF[0];
-	const FILE * stdout = &__sF[1];
-	const FILE * stderr = &__sF[2];
-    }
-    else static if (size_t.sizeof == 8)
-    {
-	extern FILE *__stdinp;
-	extern FILE *__stdoutp;
-	extern FILE *__stderrp;
-	alias __stdinp  stdin;
-	alias __stdoutp stdout;
-	alias __stderrp stderr;
-    }
-}
-else version (linux)
-{
     extern FILE *stdin;
     extern FILE *stdout;
     extern FILE *stderr;
-}
 
-version (Win32)
-{
-    const char[] _P_tmpdir = "\\";
-    const wchar[] _wP_tmpdir = "\\";
-    version (GNU) { }
+    FILE * fopen64(in char *,in char *);	///
+
+    version (PPC)
+    {
+	private import std.c.linux.ldblcompat;
+
+	extern (C) int ferror(FILE *);
+	extern (C) int feof(FILE *);
+	extern (C) void clearerr(FILE *);
+	extern (C) void rewind(FILE *);
+	extern (C) int _bufsize(FILE *);
+	extern (C) int fileno(FILE *);
+
+	int snprintf(char *, size_t, char *, ...);
+	int vsnprintf(char *, size_t, char *, va_list);
+
+	// printf is declared in object, but it won't be fixed unless std.c.stdio is imported...
+	pragma(GNU_asm,printf,__LDBL_COMPAT_PFX ~ "printf");
+	pragma(GNU_asm,fprintf,__LDBL_COMPAT_PFX ~ "fprintf");
+	pragma(GNU_asm,vfprintf,__LDBL_COMPAT_PFX ~ "vfprintf");
+	pragma(GNU_asm,vprintf,__LDBL_COMPAT_PFX ~ "vprintf");
+	pragma(GNU_asm,sprintf,__LDBL_COMPAT_PFX ~ "sprintf");
+	pragma(GNU_asm,vsprintf,__LDBL_COMPAT_PFX ~ "vsprintf");
+	pragma(GNU_asm,scanf,__LDBL_COMPAT_PFX ~ "scanf");
+	pragma(GNU_asm,fscanf,__LDBL_COMPAT_PFX ~ "fscanf");
+	pragma(GNU_asm,sscanf,__LDBL_COMPAT_PFX ~ "sscanf");
+	pragma(GNU_asm,snprintf,__LDBL_COMPAT_PFX ~ "snprintf");
+	pragma(GNU_asm,vsnprintf,__LDBL_COMPAT_PFX ~ "vsnprintf");
+    }
     else
     {
-	const int L_tmpnam = _P_tmpdir.length + 12;
+    	int  ferror(FILE *fp);
+    	int  feof(FILE *fp);
+    	void clearerr(FILE *fp);
+    	void rewind(FILE *fp);
+    	int  _bufsize(FILE *fp);
+    	int  fileno(FILE *fp);
+    	int  snprintf(char *,size_t,char *,...);
+    	int  vsnprintf(char *,size_t,char *,va_list);
     }
 }
+else version (OSX)
+{
+    const int EOF = -1;
+    const int BUFSIZ = 1024;
+    const int FOPEN_MAX = 20;
+    const int FILENAME_MAX = 1024;
+    const int TMP_MAX = 308915776;
+    const int L_tmpnam = 1024;
 
+    struct __sbuf
+    {
+	char* _base;
+	int _size;
+    }
+
+    struct _iobuf
+    {
+	align (1):
+
+	char* _p;
+	int _r;
+	int _w;
+	short _flags;
+	short _file;
+	__sbuf _bf;
+	int _lbfsize;
+	void* _cookie;
+	int function(void*) _close;
+	int function(void*, char*, int) _read;
+	fpos_t function(void*, fpos_t, int) _seek;
+	int function(void*, char*, int) _write;
+	__sbuf _ub;
+	void* _extra;
+	int _ur;
+	char[3] _ubuf;
+	char[1] _nbuf;
+	__sbuf _lb;
+	int _blksize;
+	fpos_t _offset;
+    }
+
+    enum { SEEK_SET, SEEK_CUR, SEEK_END }
+
+    alias _iobuf FILE;	///
+
+    enum
+    {
+	_F_RDWR = 0x0003,
+	_F_READ = 0x0001,
+	_F_WRIT = 0x0002,
+	_F_BUF  = 0x0004,
+	_F_LBUF = 0x0008,
+	_F_ERR  = 0x0010,
+	_F_EOF  = 0x0020,
+	_F_BIN  = 0x0040,
+	_F_IN   = 0x0080,
+	_F_OUT  = 0x0100,
+	_F_TERM = 0x0200,
+    }
+
+    enum
+    {
+	_IOFBF = 0,
+	_IOLBF = 1,
+	_IONBF = 2,
+    }
+
+    extern FILE *__stdinp;
+    extern FILE *__stdoutp;
+    extern FILE *__stderrp;
+
+    alias __stdinp stdin;
+    alias __stdoutp stdout;
+    alias __stderrp stderr;
+
+    int  ferror(FILE *fp);
+    int  feof(FILE *fp);
+    void clearerr(FILE *fp);
+    void rewind(FILE *fp);
+    int  _bufsize(FILE *fp);
+    int  fileno(FILE *fp);
+    int  snprintf(char *,size_t,char *,...);
+    int  vsnprintf(char *,size_t,char *,va_list);
+}
+else version (FreeBSD)
+{
+    const int EOF = -1;
+    const int BUFSIZ = 1024;
+    const int FOPEN_MAX = 20;
+    const int FILENAME_MAX = 1024;
+    const int TMP_MAX = 308915776;
+    const int L_tmpnam = 1024;
+
+    struct __sbuf
+    {
+	char* _base;
+	int _size;
+    }
+
+    struct _iobuf
+    {
+	align (1):
+
+	char* _p;
+	int _r;
+	int _w;
+	short _flags;
+	short _file;
+	__sbuf _bf;
+	int _lbfsize;
+	void* _cookie;
+	int function(void*) _close;
+	int function(void*, char*, int) _read;
+	fpos_t function(void*, fpos_t, int) _seek;
+	int function(void*, char*, int) _write;
+	__sbuf _ub;
+	void* _extra;
+	int _ur;
+	char[3] _ubuf;
+	char[1] _nbuf;
+	__sbuf _lb;
+	int _blksize;
+	fpos_t _offset;
+    }
+
+    enum { SEEK_SET, SEEK_CUR, SEEK_END }
+
+    alias _iobuf FILE;	///
+
+    enum
+    {
+	_F_RDWR = 0x0003,
+	_F_READ = 0x0001,
+	_F_WRIT = 0x0002,
+	_F_BUF  = 0x0004,
+	_F_LBUF = 0x0008,
+	_F_ERR  = 0x0010,
+	_F_EOF  = 0x0020,
+	_F_BIN  = 0x0040,
+	_F_IN   = 0x0080,
+	_F_OUT  = 0x0100,
+	_F_TERM = 0x0200,
+    }
+
+    enum
+    {
+	_IOFBF = 0,
+	_IOLBF = 1,
+	_IONBF = 2,
+    }
+
+    extern FILE *__stdinp;
+    extern FILE *__stdoutp;
+    extern FILE *__stderrp;
+
+    alias __stdinp stdin;
+    alias __stdoutp stdout;
+    alias __stderrp stderr;
+
+    int  ferror(FILE *fp);
+    int  feof(FILE *fp);
+    void clearerr(FILE *fp);
+    void rewind(FILE *fp);
+    int  _bufsize(FILE *fp);
+    int  fileno(FILE *fp);
+    int  snprintf(char *,size_t,char *,...);
+    int  vsnprintf(char *,size_t,char *,va_list);
+}
+else version (Solaris)
+{
+    const int EOF = -1;
+    const int BUFSIZ = 1024;
+    const int FOPEN_MAX = 20;
+    const int FILENAME_MAX = 1024;
+    const int TMP_MAX = 17576;
+    const int L_tmpnam = 25;
+    const int _NFILE = 20;
+
+    struct __sbuf
+    {
+       char* _base;
+       int _size;
+    }
+
+    struct _iobuf
+    {
+       align (1):
+
+       int _cnt;
+       ubyte* _ptr;
+       ubyte* _base;
+       ubyte _flag;
+       ubyte _magic;
+       ubyte[2] __bitflags;
+    }
+
+    enum { SEEK_SET, SEEK_CUR, SEEK_END }
+
+    alias _iobuf FILE; ///
+
+    enum
+    {
+       _IOFBF = 0000,
+       _IOLBF = 0100,
+       _IONBF = 0200,
+    }
+
+    extern FILE _iob[_NFILE];
+
+    const FILE *stdin  = &_iob[0];     ///
+    const FILE *stdout = &_iob[1];     ///
+    const FILE *stderr = &_iob[2];     ///
+
+    int  ferror(FILE *fp);
+    int  feof(FILE *fp);
+    void clearerr(FILE *fp);
+    void rewind(FILE *fp);
+    int  _bufsize(FILE *fp);
+    int  fileno(FILE *fp);
+    int  snprintf(char *,size_t,char *,...);
+    int  vsnprintf(char *,size_t,char *,va_list);
+}
+else version (GNU)
+{
+    private import gcc.builtins;
+    private import gcc.config.libc;
+    alias gcc.config.libc.EOF EOF;
+    alias gcc.config.libc.FOPEN_MAX FOPEN_MAX;
+    alias gcc.config.libc.FILENAME_MAX FILENAME_MAX;
+    alias gcc.config.libc.TMP_MAX TMP_MAX;
+    alias gcc.config.libc.L_tmpnam L_tmpnam;
+
+    struct _iobuf
+    {
+	align (1):
+
+	byte[gcc.config.libc.FILE_struct_size] opaque;
+    }
+
+    enum { SEEK_SET, SEEK_CUR, SEEK_END }
+
+    alias _iobuf FILE;      ///
+
+    enum
+    {
+	_F_RDWR = 0x0003,
+	_F_READ = 0x0001,
+	_F_WRIT = 0x0002,
+	_F_BUF  = 0x0004,
+    	_F_LBUF = 0x0008,
+    	_F_ERR  = 0x0010,
+    	_F_EOF  = 0x0020,
+    	_F_BIN  = 0x0040,
+    	_F_IN   = 0x0080,
+    	_F_OUT  = 0x0100,
+    	_F_TERM = 0x0200,
+    }
+
+    version (GNU_CBridge_Stdio)
+    {
+	extern FILE * _d_gnu_cbridge_stdin;
+	extern FILE * _d_gnu_cbridge_stdout;
+	extern FILE * _d_gnu_cbridge_stderr;
+
+	/* Call from dgccmain2.  Can't use a static constructor here
+	   because std.c.stdio is not compiled. */
+	extern void _d_gnu_cbridge_init_stdio();
+
+	alias _d_gnu_cbridge_stdin stdin;
+	alias _d_gnu_cbridge_stdout stdout;
+	alias _d_gnu_cbridge_stderr stderr;
+    }
+    else version (aix)
+    {
+	// 32- and 64-bit
+	extern FILE _iob[16];
+	const FILE *stdin  = &_iob[0];
+	const FILE *stdout = &_iob[1];
+	const FILE *stderr = &_iob[2];
+    }
+    else version (darwin)
+    {
+	static if (size_t.sizeof == 4)
+	{
+	    static assert(gcc.config.libc.FILE_struct_size != 0);
+	    extern FILE __sF[3];
+	    const FILE * stdin  = &__sF[0];
+	    const FILE * stdout = &__sF[1];
+	    const FILE * stderr = &__sF[2];
+	}
+	else static if (size_t.sizeof == 8)
+	{
+	    extern FILE *__stdinp;
+	    extern FILE *__stdoutp;
+	    extern FILE *__stderrp;
+	    alias __stdinp  stdin;
+	    alias __stdoutp stdout;
+	    alias __stderrp stderr;
+	}
+    }
+
+    version (darwin)
+    {
+	private import std.c.darwin.ldblcompat;
+
+	extern (C) int ferror(FILE *);
+	extern (C) int feof(FILE *);
+	extern (C) void clearerr(FILE *);
+	extern (C) void rewind(FILE *);
+	extern (C) int _bufsize(FILE *);
+	extern (C) int fileno(FILE *);
+
+	int snprintf(char *, size_t, char *, ...);
+	int vsnprintf(char *, size_t, char *, va_list);
+
+	// printf is declared in object, but it won't be fixed unless std.c.stdio is imported...
+	pragma(GNU_asm,printf,"printf" ~ __DARWIN_LDBL_COMPAT);
+	pragma(GNU_asm,fprintf,"fprintf" ~ __DARWIN_LDBL_COMPAT);
+	pragma(GNU_asm,vfprintf,"vfprintf" ~ __DARWIN_LDBL_COMPAT);
+	pragma(GNU_asm,vprintf,"vprintf" ~ __DARWIN_LDBL_COMPAT);
+	pragma(GNU_asm,sprintf,"sprintf" ~ __DARWIN_LDBL_COMPAT);
+	pragma(GNU_asm,vsprintf,"vsprintf" ~ __DARWIN_LDBL_COMPAT);
+	pragma(GNU_asm,scanf,"scanf" ~ __DARWIN_LDBL_COMPAT);
+	pragma(GNU_asm,fscanf,"fscanf" ~ __DARWIN_LDBL_COMPAT);
+	pragma(GNU_asm,sscanf,"sscanf" ~ __DARWIN_LDBL_COMPAT);
+	pragma(GNU_asm,snprintf,"snprintf" ~ __DARWIN_LDBL_COMPAT);
+	pragma(GNU_asm,vsnprintf,"vsnprintf" ~ __DARWIN_LDBL_COMPAT);
+    }
+    else
+    {
+	extern (C) int ferror(FILE *);
+	extern (C) int feof(FILE *);
+	extern (C) void clearerr(FILE *);
+	extern (C) void rewind(FILE *);
+	extern (C) int _bufsize(FILE *);
+	extern (C) int fileno(FILE *);
+
+	alias __builtin_snprintf snprintf;
+	alias __builtin_vsnprintf vsnprintf;
+    }
+}
+else
+{
+    static assert(0);
+}
 
 alias gcc.config.libc.fpos_t fpos_t;
 
 char *	 tmpnam(char *);	///
-FILE *	 fopen(char *,char *);	///
-FILE *	 _fsopen(char *,char *,int );	///
-FILE *	 freopen(char *,char *,FILE *);	///
+FILE *	 fopen(in char *,in char *);	///
+FILE *	 _fsopen(in char *,in char *,int );	///
+FILE *	 freopen(in char *,in char *,FILE *);	///
 int	 fseek(FILE *,Clong_t,int);	///
-Clong_t  ftell(FILE *);	///
+Clong_t	 ftell(FILE *);	///
 char *	 fgets(char *,int,FILE *);	///
 int	 fgetc(FILE *);	///
 int	 _fgetchar();	///
@@ -282,108 +625,14 @@
 int  getw(FILE *FHdl);	///
 int  putw(int Word, FILE *FilePtr);	///
 
-int  getchar(); ///
-int  putchar(int c); ///
-int  getc(FILE *fp); ///
-int  putc(int c,FILE *fp); ///
-
-version(PPC)
-    version(Linux)
-	version=PPCLinux;
-
-version (Win32)
-{
-    ///
-    int  ferror(FILE *fp)	{ return fp._flag&_IOERR;	}
-    ///
-    int  feof(FILE *fp)	{ return fp._flag&_IOEOF;	}
-    ///
-    void clearerr(FILE *fp)	{ fp._flag &= ~(_IOERR|_IOEOF); }
-    ///
-    void rewind(FILE *fp)	{ fseek(fp,0L,SEEK_SET); fp._flag&=~_IOERR; }
-    int  _bufsize(FILE *fp)	{ return fp._bufsiz; }
-    ///
-    int  fileno(FILE *fp)	{ return fp._file; }
-    int  _snprintf(char *,size_t,char *,...);
-    int  _vsnprintf(char *,size_t,char *,va_list);
-}
-else version (darwin)
-{
-    private import std.c.darwin.ldblcompat;
-    
-    extern (C) int ferror(FILE *);
-    extern (C) int feof(FILE *);
-    extern (C) void clearerr(FILE *);
-    extern (C) void rewind(FILE *);
-    extern (C) int _bufsize(FILE *);
-    extern (C) int fileno(FILE *);
-   
-    int snprintf(char *, size_t, char *, ...);
-    int vsnprintf(char *, size_t, char *, va_list);
-
-    // printf is declared in object, but it won't be fixed unless std.c.stdio is imported...
-    pragma(GNU_asm,printf,"printf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,fprintf,"fprintf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,vfprintf,"vfprintf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,vprintf,"vprintf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,sprintf,"sprintf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,vsprintf,"vsprintf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,scanf,"scanf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,fscanf,"fscanf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,sscanf,"sscanf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,snprintf,"snprintf" ~ __DARWIN_LDBL_COMPAT);
-    pragma(GNU_asm,vsnprintf,"vsnprintf" ~ __DARWIN_LDBL_COMPAT);
-}
-else version (PPCLinux)
-{
-    private import std.c.linux.ldblcompat;
-    
-    extern (C) int ferror(FILE *);
-    extern (C) int feof(FILE *);
-    extern (C) void clearerr(FILE *);
-    extern (C) void rewind(FILE *);
-    extern (C) int _bufsize(FILE *);
-    extern (C) int fileno(FILE *);
-   
-    int snprintf(char *, size_t, char *, ...);
-    int vsnprintf(char *, size_t, char *, va_list);
-
-    // printf is declared in object, but it won't be fixed unless std.c.stdio is imported...
-    pragma(GNU_asm,printf,__LDBL_COMPAT_PFX ~ "printf");
-    pragma(GNU_asm,fprintf,__LDBL_COMPAT_PFX ~ "fprintf");
-    pragma(GNU_asm,vfprintf,__LDBL_COMPAT_PFX ~ "vfprintf");
-    pragma(GNU_asm,vprintf,__LDBL_COMPAT_PFX ~ "vprintf");
-    pragma(GNU_asm,sprintf,__LDBL_COMPAT_PFX ~ "sprintf");
-    pragma(GNU_asm,vsprintf,__LDBL_COMPAT_PFX ~ "vsprintf");
-    pragma(GNU_asm,scanf,__LDBL_COMPAT_PFX ~ "scanf");
-    pragma(GNU_asm,fscanf,__LDBL_COMPAT_PFX ~ "fscanf");
-    pragma(GNU_asm,sscanf,__LDBL_COMPAT_PFX ~ "sscanf");
-    pragma(GNU_asm,snprintf,__LDBL_COMPAT_PFX ~ "snprintf");
-    pragma(GNU_asm,vsnprintf,__LDBL_COMPAT_PFX ~ "vsnprintf");
-}
-else version (GNU)
-{
-    extern (C) int ferror(FILE *);
-    extern (C) int feof(FILE *);
-    extern (C) void clearerr(FILE *);
-    extern (C) void rewind(FILE *);
-    extern (C) int _bufsize(FILE *);
-    extern (C) int fileno(FILE *);
-
-    alias __builtin_snprintf snprintf;
-    alias __builtin_vsnprintf vsnprintf;
-}
-else version (linux)
-{
-    int  ferror(FILE *fp);
-    int  feof(FILE *fp);
-    void clearerr(FILE *fp);
-    void rewind(FILE *fp);
-    int  _bufsize(FILE *fp);
-    int  fileno(FILE *fp);
-    int  snprintf(char *,size_t,char *,...);
-    int  vsnprintf(char *,size_t,char *,va_list);
-}
+///
+int  getchar()		{ return getc(stdin);		}
+///
+int  putchar(int c)	{ return putc(c,stdout);	}
+///
+int  getc(FILE *fp)	{ return fgetc(fp);		}
+///
+int  putc(int c,FILE *fp) { return fputc(c,fp);		}
 
 int      unlink(char *);	///
 FILE *	 fdopen(int, char *);	///
@@ -426,10 +675,13 @@
 wchar_t  _fputwchar_t(wchar_t);
 wchar_t  ungetwc(wchar_t, FILE *);	///
 
-wchar_t	 getwchar_t(); ///
-wchar_t	 putwchar_t(wchar_t c); ///
-wchar_t	 getwc(FILE *fp); ///
-wchar_t	 putwc(wchar_t c, FILE *fp) ///
-;
+///
+wchar_t	 getwchar_t()		{ return fgetwc(stdin); }
+///
+wchar_t	 putwchar_t(wchar_t c)	{ return fputwc(c,stdout); }
+///
+wchar_t	 getwc(FILE *fp)	{ return fgetwc(fp); }
+///
+wchar_t	 putwc(wchar_t c, FILE *fp)	{ return fputwc(c, fp); }
 
 int fwide(FILE* fp, int mode);	///
diff -r 6a92bcae44c5 d/phobos/std/c/stdlib.d
--- a/d/phobos/std/c/stdlib.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/c/stdlib.d	Sat Jun 26 21:05:08 2010 +0100
@@ -1,6 +1,7 @@
 /**
  * C's &lt;stdlib.h&gt;
- * Authors: Walter Bright, Digital Mars, www.digitalmars.com
+ * D Programming Language runtime library
+ * Authors: Walter Bright, Digital Mars, http://www.digitalmars.com
  * License: Public Domain
  * Macros:
  *	WIKI=Phobos/StdCStdlib
@@ -22,13 +23,13 @@
 
 version (Windows)
 {
-     enum
-     {
-    _MAX_PATH   = 260,
-    _MAX_DRIVE  = 3,
-    _MAX_DIR    = 256,
-    _MAX_FNAME  = 256,
-    _MAX_EXT    = 256,
+    enum
+    {
+	_MAX_PATH   = 260,
+	_MAX_DRIVE  = 3,
+	_MAX_DIR    = 256,
+	_MAX_FNAME  = 256,
+	_MAX_EXT    = 256,
     }
 }
 
@@ -94,7 +95,7 @@
 	alias gcc.config.errno.ERANGE ERANGE;
     }
     else
-	const int ERANGE = 34;	// on Windows, linux and OSX
+const int ERANGE = 34;	// on Windows, linux and OSX
 
 double atof(char *);	///
 int    atoi(char *);	/// ditto
@@ -112,7 +113,7 @@
 version (darwin_strtold)
 {
     private import std.c.darwin.ldblcompat;
-    real strtold(char *, char **);	/// ditto
+real   strtold(char *,char **);	/// ditto
     pragma(GNU_asm,strtold,"strtold"~__DARWIN_LDBL_COMPAT);
 }
 else version (PPCLinux)
@@ -139,9 +140,9 @@
 
 Clong_t  strtol(char *,char **,int);	/// ditto
 Culong_t strtoul(char *,char **,int);	/// ditto
-long     atoll(char *);	/// ditto
-long     strtoll(char *,char **,int);	/// ditto
-ulong    strtoull(char *,char **,int);	/// ditto
+long   atoll(char *);	/// ditto
+long   strtoll(char *,char **,int);	/// ditto
+ulong  strtoull(char *,char **,int);	/// ditto
 
 char* itoa(int, char*, int);
 char* ultoa(Culong_t, char*, int);
diff -r 6a92bcae44c5 d/phobos/std/c/string.d
--- a/d/phobos/std/c/string.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/c/string.d	Sat Jun 26 21:05:08 2010 +0100
@@ -21,22 +21,22 @@
 version (GNU)
 {
     private import gcc.builtins;
-    alias __builtin_memcpy memcpy;	///
-    alias __builtin_strcpy strcpy;	///
-    alias __builtin_strncpy strncpy;	///
-    alias __builtin_strncat strncat;	///
-    alias __builtin_strncmp strncmp;	///
-    alias __builtin_strchr strchr;	///
-    alias __builtin_strcspn strcspn;	///
-    alias __builtin_strpbrk strpbrk;	///
-    alias __builtin_strrchr strrchr;	///
-    alias __builtin_strspn strspn;	///
-    alias __builtin_strstr strstr;	///
-    alias __builtin_memset memset;	///
-    alias __builtin_strlen strlen;	///
-    alias __builtin_strcmp strcmp;	///
-    alias __builtin_strcat strcat;	///
-    alias __builtin_memcmp memcmp;	///
+    alias __builtin_memcpy memcpy;      ///
+    alias __builtin_strcpy strcpy;      ///
+    alias __builtin_strncpy strncpy;    ///
+    alias __builtin_strncat strncat;    ///
+    alias __builtin_strncmp strncmp;    ///
+    alias __builtin_strchr strchr;      ///
+    alias __builtin_strcspn strcspn;    ///
+    alias __builtin_strpbrk strpbrk;    ///
+    alias __builtin_strrchr strrchr;    ///
+    alias __builtin_strspn strspn;      ///
+    alias __builtin_strstr strstr;      ///
+    alias __builtin_memset memset;      ///
+    alias __builtin_strlen strlen;      ///
+    alias __builtin_strcmp strcmp;      ///
+    alias __builtin_strcat strcat;      ///
+    alias __builtin_memcmp memcmp;      ///
 }
 else
 {
diff -r 6a92bcae44c5 d/phobos/std/c/time.d
--- a/d/phobos/std/c/time.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/c/time.d	Sat Jun 26 21:05:08 2010 +0100
@@ -39,26 +39,28 @@
 version (Windows)
 {   const clock_t CLOCKS_PER_SEC = 1000;
     const clock_t CLK_TCK        = 1000;
+
     struct tm
-     {  int     tm_sec,
-                tm_min,
-                tm_hour,
-                tm_mday,
-                tm_mon,
-                tm_year,
-                tm_wday,
-                tm_yday,
-                tm_isdst;
-     }
+    {  int     tm_sec,
+               tm_min,
+               tm_hour,
+               tm_mday,
+               tm_mon,
+               tm_year,
+               tm_wday,
+               tm_yday,
+               tm_isdst;
+    }
 }
 else version (linux)
 {   const clock_t CLOCKS_PER_SEC = 1000000;
-   extern (C) int sysconf(int);
-   extern clock_t CLK_TCK;
-   /*static this()
-   {
-CLK_TCK = cast(clock_t) sysconf(2);
-   }*/
+    extern (C) int sysconf(int);
+    extern clock_t CLK_TCK;
+    /*static this()
+    {
+	CLK_TCK = cast(clock_t) sysconf(2);
+    }*/
+
     struct tm
     {  int     tm_sec,
                tm_min,
diff -r 6a92bcae44c5 d/phobos/std/c/windows/windows.d
--- a/d/phobos/std/c/windows/windows.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/c/windows/windows.d	Sat Jun 26 21:05:08 2010 +0100
@@ -250,8 +250,11 @@
     FILE_VOLUME_IS_COMPRESSED       = 0x00008000,  
 }
 
-const DWORD MAILSLOT_NO_MESSAGE = cast(DWORD)-1;
-const DWORD MAILSLOT_WAIT_FOREVER = cast(DWORD)-1; 
+enum
+{
+    MAILSLOT_NO_MESSAGE = cast(DWORD)-1,
+    MAILSLOT_WAIT_FOREVER = cast(DWORD)-1, 
+}
 
 enum : uint
 {
@@ -275,8 +278,12 @@
 }
 
 const HANDLE INVALID_HANDLE_VALUE = cast(HANDLE)-1;
-const DWORD INVALID_SET_FILE_POINTER = cast(DWORD)-1;
-const DWORD INVALID_FILE_SIZE = cast(DWORD)0xFFFFFFFF;
+
+enum : DWORD
+{
+    INVALID_SET_FILE_POINTER = cast(DWORD)-1,
+    INVALID_FILE_SIZE = cast(DWORD)0xFFFFFFFF,
+}
 
 struct OVERLAPPED {
     DWORD   Internal;
@@ -326,6 +333,13 @@
     wchar  cAlternateFileName[ 14 ];
 }
 
+enum
+{
+	STD_INPUT_HANDLE =    cast(DWORD)-10,
+	STD_OUTPUT_HANDLE =   cast(DWORD)-11,
+	STD_ERROR_HANDLE =    cast(DWORD)-12,
+}
+
 export
 {
 BOOL SetCurrentDirectoryA(LPCSTR lpPathName);
@@ -428,8 +442,11 @@
 // Key creation/open disposition
 //
 
-const int REG_CREATED_NEW_KEY =         0x00000001;   // New Registry Key created
-const int REG_OPENED_EXISTING_KEY =     0x00000002;   // Existing Key opened
+enum : int
+{
+	REG_CREATED_NEW_KEY =         0x00000001,   // New Registry Key created
+	REG_OPENED_EXISTING_KEY =     0x00000002,   // Existing Key opened
+}
 
 
 //
@@ -1102,6 +1119,7 @@
 export HANDLE GetCurrentThread();
 export BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
 export HANDLE GetCurrentProcess();
+export DWORD GetCurrentProcessId();
 export BOOL DuplicateHandle (HANDLE sourceProcess, HANDLE sourceThread,
         HANDLE targetProcessHandle, HANDLE *targetHandle, DWORD access, 
         BOOL inheritHandle, DWORD options);
@@ -2083,11 +2101,15 @@
 	COLOR_BTNHILIGHT =        COLOR_BTNHIGHLIGHT,
 }
 
-const int CW_USEDEFAULT = cast(int)0x80000000;
+enum : int
+{
+	CW_USEDEFAULT = cast(int)0x80000000
+}
+
 /*
  * Special value for CreateWindow, et al.
  */
-const HWND HWND_DESKTOP = (cast(HWND)0);
+const HWND HWND_DESKTOP = cast(HWND)0;
 
 
 export ATOM RegisterClassA(WNDCLASSA *lpWndClass);
@@ -2713,10 +2735,328 @@
 export int wsprintfA(LPSTR, LPCSTR, ...);
 export int wsprintfW(LPWSTR, LPCWSTR, ...);
 
-const uint INFINITE = uint.max;
-const uint WAIT_OBJECT_0 = 0;
+enum : uint
+{
+	INFINITE = uint.max,
+	WAIT_OBJECT_0 = 0,
+}
 
 export HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCTSTR lpName);
 export HANDLE OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);
 export BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
+
+struct COORD {
+    SHORT X;
+    SHORT Y;
 }
+alias COORD *PCOORD;
+
+struct SMALL_RECT {
+    SHORT Left;
+    SHORT Top;
+    SHORT Right;
+    SHORT Bottom;
+}
+alias SMALL_RECT *PSMALL_RECT;
+
+struct KEY_EVENT_RECORD {
+    BOOL bKeyDown;
+    WORD wRepeatCount;
+    WORD wVirtualKeyCode;
+    WORD wVirtualScanCode;
+    union {
+        WCHAR UnicodeChar;
+        CHAR   AsciiChar;
+    }
+    DWORD dwControlKeyState;
+}
+alias KEY_EVENT_RECORD *PKEY_EVENT_RECORD;
+
+//
+// ControlKeyState flags
+//
+
+enum
+{
+	RIGHT_ALT_PRESSED =     0x0001, // the right alt key is pressed.
+	LEFT_ALT_PRESSED =      0x0002, // the left alt key is pressed.
+	RIGHT_CTRL_PRESSED =    0x0004, // the right ctrl key is pressed.
+	LEFT_CTRL_PRESSED =     0x0008, // the left ctrl key is pressed.
+	SHIFT_PRESSED =         0x0010, // the shift key is pressed.
+	NUMLOCK_ON =            0x0020, // the numlock light is on.
+	SCROLLLOCK_ON =         0x0040, // the scrolllock light is on.
+	CAPSLOCK_ON =           0x0080, // the capslock light is on.
+	ENHANCED_KEY =          0x0100, // the key is enhanced.
+}
+
+struct MOUSE_EVENT_RECORD {
+    COORD dwMousePosition;
+    DWORD dwButtonState;
+    DWORD dwControlKeyState;
+    DWORD dwEventFlags;
+}
+alias MOUSE_EVENT_RECORD *PMOUSE_EVENT_RECORD;
+
+//
+// ButtonState flags
+//
+enum
+{
+	FROM_LEFT_1ST_BUTTON_PRESSED =    0x0001,
+	RIGHTMOST_BUTTON_PRESSED =        0x0002,
+	FROM_LEFT_2ND_BUTTON_PRESSED =    0x0004,
+	FROM_LEFT_3RD_BUTTON_PRESSED =    0x0008,
+	FROM_LEFT_4TH_BUTTON_PRESSED =    0x0010,
+}
+
+//
+// EventFlags
+//
+
+enum
+{
+	MOUSE_MOVED =   0x0001,
+	DOUBLE_CLICK =  0x0002,
+}
+
+struct WINDOW_BUFFER_SIZE_RECORD {
+    COORD dwSize;
+}
+alias WINDOW_BUFFER_SIZE_RECORD *PWINDOW_BUFFER_SIZE_RECORD;
+
+struct MENU_EVENT_RECORD {
+    UINT dwCommandId;
+}
+alias MENU_EVENT_RECORD *PMENU_EVENT_RECORD;
+
+struct FOCUS_EVENT_RECORD {
+    BOOL bSetFocus;
+}
+alias FOCUS_EVENT_RECORD *PFOCUS_EVENT_RECORD;
+
+struct INPUT_RECORD {
+    WORD EventType;
+    union {
+        KEY_EVENT_RECORD KeyEvent;
+        MOUSE_EVENT_RECORD MouseEvent;
+        WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
+        MENU_EVENT_RECORD MenuEvent;
+        FOCUS_EVENT_RECORD FocusEvent;
+    }
+}
+alias INPUT_RECORD *PINPUT_RECORD;
+
+//
+//  EventType flags:
+//
+
+enum
+{
+	KEY_EVENT =         0x0001, // Event contains key event record
+	MOUSE_EVENT =       0x0002, // Event contains mouse event record
+	WINDOW_BUFFER_SIZE_EVENT = 0x0004, // Event contains window change event record
+	MENU_EVENT = 0x0008, // Event contains menu event record
+	FOCUS_EVENT = 0x0010, // event contains focus change
+}
+
+struct CHAR_INFO {
+    union {
+        WCHAR UnicodeChar;
+        CHAR   AsciiChar;
+    }
+    WORD Attributes;
+}
+alias CHAR_INFO *PCHAR_INFO;
+
+//
+// Attributes flags:
+//
+
+enum
+{
+	FOREGROUND_BLUE =      0x0001, // text color contains blue.
+	FOREGROUND_GREEN =     0x0002, // text color contains green.
+	FOREGROUND_RED =       0x0004, // text color contains red.
+	FOREGROUND_INTENSITY = 0x0008, // text color is intensified.
+	BACKGROUND_BLUE =      0x0010, // background color contains blue.
+	BACKGROUND_GREEN =     0x0020, // background color contains green.
+	BACKGROUND_RED =       0x0040, // background color contains red.
+	BACKGROUND_INTENSITY = 0x0080, // background color is intensified.
+}
+
+struct CONSOLE_SCREEN_BUFFER_INFO {
+    COORD dwSize;
+    COORD dwCursorPosition;
+    WORD  wAttributes;
+    SMALL_RECT srWindow;
+    COORD dwMaximumWindowSize;
+}
+alias CONSOLE_SCREEN_BUFFER_INFO *PCONSOLE_SCREEN_BUFFER_INFO;
+
+struct CONSOLE_CURSOR_INFO {
+    DWORD  dwSize;
+    BOOL   bVisible;
+}
+alias CONSOLE_CURSOR_INFO *PCONSOLE_CURSOR_INFO;
+
+enum
+{
+	ENABLE_PROCESSED_INPUT = 0x0001,
+	ENABLE_LINE_INPUT =      0x0002,
+	ENABLE_ECHO_INPUT =      0x0004,
+	ENABLE_WINDOW_INPUT =    0x0008,
+	ENABLE_MOUSE_INPUT =     0x0010,
+}
+
+enum
+{
+	ENABLE_PROCESSED_OUTPUT =    0x0001,
+	ENABLE_WRAP_AT_EOL_OUTPUT =  0x0002,
+}
+
+BOOL PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
+BOOL PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
+BOOL ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
+BOOL ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
+BOOL WriteConsoleInputA(HANDLE hConsoleInput, INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten);
+BOOL WriteConsoleInputW(HANDLE hConsoleInput, INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten);
+BOOL ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion);
+BOOL ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion);
+BOOL WriteConsoleOutputA(HANDLE hConsoleOutput, CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion);
+BOOL WriteConsoleOutputW(HANDLE hConsoleOutput, CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion);
+BOOL ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead);
+BOOL ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead);
+BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead);
+BOOL WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
+BOOL WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
+BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, WORD *lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten);
+BOOL FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD  nLength, COORD  dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
+BOOL FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD  nLength, COORD  dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
+BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD   wAttribute, DWORD  nLength, COORD  dwWriteCoord, LPDWORD lpNumberOfAttrsWritten);
+BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
+BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents);
+BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);
+COORD GetLargestConsoleWindowSize( HANDLE hConsoleOutput);
+BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo);
+BOOL GetNumberOfConsoleMouseButtons( LPDWORD lpNumberOfMouseButtons);
+BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode);
+BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput);
+BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput);
+BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize);
+BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition);
+BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, CONSOLE_CURSOR_INFO *lpConsoleCursorInfo);
+BOOL ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, SMALL_RECT *lpScrollRectangle, SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, CHAR_INFO *lpFill);
+BOOL ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, SMALL_RECT *lpScrollRectangle, SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, CHAR_INFO *lpFill);
+BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, SMALL_RECT *lpConsoleWindow);
+BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes);
+alias BOOL(*PHANDLER_ROUTINE)(DWORD CtrlType);
+BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add);
+BOOL GenerateConsoleCtrlEvent( DWORD dwCtrlEvent, DWORD dwProcessGroupId);
+BOOL AllocConsole();
+BOOL FreeConsole();
+DWORD GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize);
+DWORD GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize);
+BOOL SetConsoleTitleA(LPCSTR lpConsoleTitle);
+BOOL SetConsoleTitleW(LPCWSTR lpConsoleTitle);
+BOOL ReadConsoleA(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, LPVOID lpReserved);
+BOOL ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, LPVOID lpReserved);
+BOOL WriteConsoleA(HANDLE hConsoleOutput,  void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
+BOOL WriteConsoleW(HANDLE hConsoleOutput,  void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
+HANDLE CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData);
+UINT GetConsoleCP();
+BOOL SetConsoleCP( UINT wCodePageID);
+UINT GetConsoleOutputCP();
+BOOL SetConsoleOutputCP(UINT wCodePageID);
+
+enum : int
+{
+	CONSOLE_TEXTMODE_BUFFER = 1,
+}
+
+enum
+{
+	SM_CXSCREEN =             0,
+	SM_CYSCREEN =             1,
+	SM_CXVSCROLL =            2,
+	SM_CYHSCROLL =            3,
+	SM_CYCAPTION =            4,
+	SM_CXBORDER =             5,
+	SM_CYBORDER =             6,
+	SM_CXDLGFRAME =           7,
+	SM_CYDLGFRAME =           8,
+	SM_CYVTHUMB =             9,
+	SM_CXHTHUMB =             10,
+	SM_CXICON =               11,
+	SM_CYICON =               12,
+	SM_CXCURSOR =             13,
+	SM_CYCURSOR =             14,
+	SM_CYMENU =               15,
+	SM_CXFULLSCREEN =         16,
+	SM_CYFULLSCREEN =         17,
+	SM_CYKANJIWINDOW =        18,
+	SM_MOUSEPRESENT =         19,
+	SM_CYVSCROLL =            20,
+	SM_CXHSCROLL =            21,
+	SM_DEBUG =                22,
+	SM_SWAPBUTTON =           23,
+	SM_RESERVED1 =            24,
+	SM_RESERVED2 =            25,
+	SM_RESERVED3 =            26,
+	SM_RESERVED4 =            27,
+	SM_CXMIN =                28,
+	SM_CYMIN =                29,
+	SM_CXSIZE =               30,
+	SM_CYSIZE =               31,
+	SM_CXFRAME =              32,
+	SM_CYFRAME =              33,
+	SM_CXMINTRACK =           34,
+	SM_CYMINTRACK =           35,
+	SM_CXDOUBLECLK =          36,
+	SM_CYDOUBLECLK =          37,
+	SM_CXICONSPACING =        38,
+	SM_CYICONSPACING =        39,
+	SM_MENUDROPALIGNMENT =    40,
+	SM_PENWINDOWS =           41,
+	SM_DBCSENABLED =          42,
+	SM_CMOUSEBUTTONS =        43,
+
+
+	SM_CXFIXEDFRAME =         SM_CXDLGFRAME,
+	SM_CYFIXEDFRAME =         SM_CYDLGFRAME,
+	SM_CXSIZEFRAME =          SM_CXFRAME,
+	SM_CYSIZEFRAME =          SM_CYFRAME,
+
+	SM_SECURE =               44,
+	SM_CXEDGE =               45,
+	SM_CYEDGE =               46,
+	SM_CXMINSPACING =         47,
+	SM_CYMINSPACING =         48,
+	SM_CXSMICON =             49,
+	SM_CYSMICON =             50,
+	SM_CYSMCAPTION =          51,
+	SM_CXSMSIZE =             52,
+	SM_CYSMSIZE =             53,
+	SM_CXMENUSIZE =           54,
+	SM_CYMENUSIZE =           55,
+	SM_ARRANGE =              56,
+	SM_CXMINIMIZED =          57,
+	SM_CYMINIMIZED =          58,
+	SM_CXMAXTRACK =           59,
+	SM_CYMAXTRACK =           60,
+	SM_CXMAXIMIZED =          61,
+	SM_CYMAXIMIZED =          62,
+	SM_NETWORK =              63,
+	SM_CLEANBOOT =            67,
+	SM_CXDRAG =               68,
+	SM_CYDRAG =               69,
+	SM_SHOWSOUNDS =           70,
+	SM_CXMENUCHECK =          71,
+	SM_CYMENUCHECK =          72,
+	SM_SLOWMACHINE =          73,
+	SM_MIDEASTENABLED =       74,
+	SM_CMETRICS =             75,
+}
+
+int GetSystemMetrics(int nIndex);
+
+}
diff -r 6a92bcae44c5 d/phobos/std/conv.d
--- a/d/phobos/std/conv.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/conv.d	Sat Jun 26 21:05:08 2010 +0100
@@ -105,7 +105,7 @@
 	goto Lerr;
 
     int sign = 0;
-    uint v = 0;
+    int v = 0;
 
     for (int i = 0; i < length; i++)
     {
@@ -133,13 +133,13 @@
     }
     if (sign == -1)
     {
-	if (v > 0x80000000)
+	if (cast(uint)v > 0x80000000)
 	    goto Loverflow;
 	v = -v;
     }
     else
     {
-	if (v > 0x7FFFFFFF)
+	if (cast(uint)v > 0x7FFFFFFF)
 	    goto Loverflow;
     }
     return v;
@@ -325,7 +325,7 @@
 	goto Lerr;
 
     int sign = 0;
-    ulong v = 0;
+    long v = 0;
 
     for (int i = 0; i < length; i++)
     {
@@ -353,13 +353,13 @@
     }
     if (sign == -1)
     {
-	if (v > 0x8000000000000000)
+	if (cast(ulong)v > 0x8000000000000000)
 	    goto Loverflow;
 	v = -v;
     }
     else
     {
-	if (v > 0x7FFFFFFFFFFFFFFF)
+	if (cast(ulong)v > 0x7FFFFFFFFFFFFFFF)
 	    goto Loverflow;
     }
     return v;
diff -r 6a92bcae44c5 d/phobos/std/cover.d
--- a/d/phobos/std/cover.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/cover.d	Sat Jun 26 21:05:08 2010 +0100
@@ -108,7 +108,7 @@
 	// Generate source file name
 	string srcfilename = std.path.join(srcpath, c.filename);
 
-	string buf = cast(char[])std.file.read(srcfilename);
+	string buf = cast(string)std.file.read(srcfilename);
 	string[] lines = std.string.splitlines(buf);
 
 	// Generate listing file name
@@ -116,7 +116,7 @@
 
 	if (merge && exists(lstfilename) && isfile(lstfilename))
 	{
-	    string lst = cast(char[])std.file.read(lstfilename);
+	    string lst = cast(string)std.file.read(lstfilename);
 	    string[] lstlines = std.string.splitlines(lst);
 
 	    for (size_t i = 0; i < lstlines.length; i++)
diff -r 6a92bcae44c5 d/phobos/std/date.d
--- a/d/phobos/std/date.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/date.d	Sat Jun 26 21:05:08 2010 +0100
@@ -413,7 +413,7 @@
 {
     return (t == d_time_nan)
 	? d_time_nan
-	/* BUGZILLA 1752 says this line should be:
+/* BUGZILLA 1752 says this line should be:
  *	: t - LocalTZA - DaylightSavingTA(t);
  */
 	: t - LocalTZA - DaylightSavingTA(t - LocalTZA);
@@ -428,13 +428,13 @@
 	   ms * TicksPerMs;
 }
 
-/******************************
-  * Params:
-  *	month = 0..11
-  *	date = day of month, 1..31
-  * Returns:
-  *	number of days since start of epoch
-  */
+/* *****************************
+ * Params:
+ *	month = 0..11
+ *	date = day of month, 1..31
+ * Returns:
+ *	number of days since start of epoch
+ */
 
 d_time MakeDay(d_time year, d_time month, d_time date)
 {   d_time t;
@@ -487,7 +487,7 @@
  * Returns:
  *	the date in the month, 1..31, of the nth weekday
  */
- 
+
 int DateFromNthWeekdayOfMonth(int year, int month, int weekday, int n)
 in
 {
@@ -517,10 +517,10 @@
     {	assert(n == 5);
 	mday -= 7;
     }
- 
+
     return mday;
 }
- 
+
 unittest
 {
     assert(DateFromNthWeekdayOfMonth(2003,  3, 0, 5) == 30);
@@ -528,13 +528,13 @@
     assert(DateFromNthWeekdayOfMonth(2004,  3, 0, 5) == 28);
     assert(DateFromNthWeekdayOfMonth(2004, 10, 0, 5) == 31);
 }
- 
+
 /**************************************
  * Determine the number of days in a month, 1..31.
  * Params:
  *	month = 1..12
  */
- 
+
 int DaysInMonth(int year, int month)
 {
     switch (month)
@@ -558,7 +558,7 @@
 	    assert(0);
     }
 }
-  
+
 unittest
 {
     assert(DaysInMonth(2003, 2) == 28);
@@ -838,11 +838,11 @@
 	     * wDayOfWeek is weekday 0..6 corresponding to Sunday..Saturday
 	     * wDay is the nth time, 1..5, that wDayOfWeek occurs
 	     */
-  
- 	    auto year = YearFromTime(t);
- 	    auto mday = DateFromNthWeekdayOfMonth(year, st.wMonth, st.wDay, st.wDayOfWeek);
- 	    day = MakeDay(year, st.wMonth - 1, mday);
- 	    time = MakeTime(st.wHour, st.wMinute, 0, 0);
+
+	    auto year = YearFromTime(t);
+	    auto mday = DateFromNthWeekdayOfMonth(year, st.wMonth, st.wDay, st.wDayOfWeek);
+	    day = MakeDay(year, st.wMonth - 1, mday);
+	    time = MakeTime(st.wHour, st.wMinute, 0, 0);
 	}
 	n = MakeDate(day,time);
 	n = TimeClip(n);
@@ -949,9 +949,9 @@
     }
 
     private extern (C) time_t _d_gnu_cbridge_tza();
-    
+
     d_time getLocalTZA()
-    {
+      {
 	return _d_gnu_cbridge_tza() * TicksPerSecond;
     }
 
@@ -975,9 +975,9 @@
 		if (tmp.tm_isdst > 0)
 		    dst = TicksPerHour;	// BUG: Assume daylight savings time is plus one hour.
 	    }
-	    else	// out of range for system time, use our own calculation
+	    else // out of range for system time, use our own calculation
 	    {
- 		/* BUG: this works for the US, but not other timezones.
+		/* BUG: this works for the US, but not other timezones.
 		 */
 
 		dt -= LocalTZA;
@@ -987,32 +987,32 @@
 		/* Compute time given year, month 1..12,
 		 * week in month, weekday, hour
 		 */
- 		d_time dstt(int year, int month, int week, int weekday, int hour)
- 		{
- 		    auto mday = DateFromNthWeekdayOfMonth(year,  month, weekday, week);
- 		    return TimeClip(MakeDate(
- 			MakeDay(year, month - 1, mday),
- 			MakeTime(hour, 0, 0, 0)));
- 		}
- 
- 		d_time start;
- 		d_time end;
- 		if (year < 2007)
- 		{   // Daylight savings time goes from 2 AM the first Sunday
- 		    // in April through 2 AM the last Sunday in October
- 		    start = dstt(year,  4, 1, 0, 2);
- 		    end   = dstt(year, 10, 5, 0, 2);
- 		}
- 		else
- 		{
- 		    // the second Sunday of March to
- 		    // the first Sunday in November
- 		    start = dstt(year,  3, 2, 0, 2);
- 		    end   = dstt(year, 11, 1, 0, 2);
- 		}
-  
- 		if (start <= dt && dt < end)
- 			dst = TicksPerHour;
+		d_time dstt(int year, int month, int week, int weekday, int hour)
+		{
+		    auto mday = DateFromNthWeekdayOfMonth(year,  month, weekday, week);
+		    return TimeClip(MakeDate(
+			MakeDay(year, month - 1, mday),
+			MakeTime(hour, 0, 0, 0)));
+		}
+
+		d_time start;
+		d_time end;
+		if (year < 2007)
+		{   // Daylight savings time goes from 2 AM the first Sunday
+		    // in April through 2 AM the last Sunday in October
+		    start = dstt(year,  4, 1, 0, 2);
+		    end   = dstt(year, 10, 5, 0, 2);
+		}
+		else
+		{
+		    // the second Sunday of March to
+		    // the first Sunday in November
+		    start = dstt(year,  3, 2, 0, 2);
+		    end   = dstt(year, 11, 1, 0, 2);
+		}
+
+		if (start <= dt && dt < end)
+		    dst = TicksPerHour;
 		//writefln("start = %s, dt = %s, end = %s, dst = %s", start, dt, end, dst);
 	    }
 	}
@@ -1105,7 +1105,7 @@
 	    }
 	}
 	return dst;
-    }
+}
 
 }
 else version (NoSystem)
diff -r 6a92bcae44c5 d/phobos/std/dateparse.d
--- a/d/phobos/std/dateparse.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/dateparse.d	Sat Jun 26 21:05:08 2010 +0100
@@ -52,8 +52,7 @@
 	//else
 	    //buffer = new char[s.length];
 
-	debug(dateparse) printf("DateParse.parse('%.*s')\n",
-	    cast(int) s.length, s.ptr);
+	debug(dateparse) printf("DateParse.parse('%.*s')\n", s);
 	if (!parseString(s))
 	{
 	    goto Lerror;
diff -r 6a92bcae44c5 d/phobos/std/demangle.d
--- a/d/phobos/std/demangle.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/demangle.d	Sat Jun 26 21:05:08 2010 +0100
@@ -424,7 +424,7 @@
 			    {	char c;
 
 				c = cast(char)((ascii2hex(name[ni + i * 2]) << 4) +
- 				     ascii2hex(name[ni + i * 2 + 1]));
+				     ascii2hex(name[ni + i * 2 + 1]));
 				result ~= c;
 			    }
 			    ni += n * 2;
@@ -520,8 +520,8 @@
 	}
 	string r = demangle(name[0]);
 	//writefln("%d, [ \"%s\", \"%s\" ],", i, name[0], r);
-	assert(r == name[1],
-	    "table entry #" ~ toString(i) ~ ": '" ~ name[0] ~ "' demangles as '" ~ r ~ "' but is expected to be '" ~ name[1] ~ "'");
+        assert(r == name[1],
+            "table entry #" ~ toString(i) ~ ": '" ~ name[0] ~ "' demangles as '" ~ r ~ "' but is expected to be '" ~ name[1] ~ "'");
 
     }
 }
diff -r 6a92bcae44c5 d/phobos/std/file.d
--- a/d/phobos/std/file.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/file.d	Sat Jun 26 21:05:08 2010 +0100
@@ -68,7 +68,6 @@
 
 class FileException : Exception
 {
-
     uint errno;			// operating system error code
 
     this(string name)
@@ -98,7 +97,7 @@
  *	FileException on error.
  */
 
-void[] read(string name)
+void[] read(char[] name)
 {
     DWORD numread;
     HANDLE h;
@@ -151,7 +150,7 @@
  * Throws: FileException on error.
  */
 
-void write(string name, void[] buffer)
+void write(char[] name, void[] buffer)
 {
     HANDLE h;
     DWORD numwritten;
@@ -176,7 +175,7 @@
 
     if (buffer.length != numwritten)
 	goto err2;
-    
+
     if (!CloseHandle(h))
 	goto err;
     return;
@@ -193,7 +192,7 @@
  * Throws: FileException on error.
  */
 
-void append(string name, void[] buffer)
+void append(char[] name, void[] buffer)
 {
     HANDLE h;
     DWORD numwritten;
@@ -220,7 +219,7 @@
 
     if (buffer.length != numwritten)
 	goto err2;
-    
+
     if (!CloseHandle(h))
 	goto err;
     return;
@@ -237,7 +236,7 @@
  * Throws: FileException on error.
  */
 
-void rename(string from, string to)
+void rename(char[] from, char[] to)
 {
     BOOL result;
 
@@ -255,7 +254,7 @@
  * Throws: FileException on error.
  */
 
-void remove(string name)
+void remove(char[] name)
 {
     BOOL result;
 
@@ -273,7 +272,7 @@
  * Throws: FileException on error.
  */
 
-ulong getSize(string name)
+ulong getSize(char[] name)
 {
     HANDLE findhndl;
     uint resulth;
@@ -309,7 +308,7 @@
  * Throws: FileException on error.
  */
 
-void getTimes(string name, out d_time ftc, out d_time fta, out d_time ftm)
+void getTimes(char[] name, out d_time ftc, out d_time fta, out d_time ftm)
 {
     HANDLE findhndl;
 
@@ -345,7 +344,7 @@
  * Return 1 if it does, 0 if not.
  */
 
-int exists(string name)
+int exists(char[] name)
 {
     uint result;
 
@@ -383,7 +382,7 @@
  * Throws: FileException if name[] doesn't exist.
  */
 
-int isfile(string name)
+int isfile(char[] name)
 {
     return (getAttributes(name) & FILE_ATTRIBUTE_DIRECTORY) == 0;
 }
@@ -393,7 +392,7 @@
  * Throws: FileException if name[] doesn't exist.
  */
 
-int isdir(string name)
+int isdir(char[] name)
 {
     return (getAttributes(name) & FILE_ATTRIBUTE_DIRECTORY) != 0;
 }
@@ -403,7 +402,7 @@
  * Throws: FileException on error.
  */
 
-void chdir(string pathname)
+void chdir(char[] pathname)
 {   BOOL result;
 
     if (useWfuncs)
@@ -422,7 +421,7 @@
  * Throws: FileException on error.
  */
 
-void mkdir(string pathname)
+void mkdir(char[] pathname)
 {   BOOL result;
 
     if (useWfuncs)
@@ -441,7 +440,7 @@
  * Throws: FileException on error.
  */
 
-void rmdir(string pathname)
+void rmdir(char[] pathname)
 {   BOOL result;
 
     if (useWfuncs)
@@ -460,7 +459,7 @@
  * Throws: FileException on error.
  */
 
-string getcwd()
+char[] getcwd()
 {
     if (useWfuncs)
     {
@@ -508,7 +507,7 @@
 
     void init(string path, WIN32_FIND_DATA *fd)
     {
-	wstring wbuf;
+	wchar[] wbuf;
 	size_t clength;
 	size_t wlength;
 	size_t n;
@@ -584,13 +583,13 @@
 string[] listdir(string pathname)
 {
     string[] result;
-    
+
     bool listing(string filename)
     {
 	result ~= filename;
 	return true; // continue
     }
-    
+
     listdir(pathname, &listing);
     return result;
 }
@@ -639,7 +638,7 @@
 
 string[] listdir(string pathname, string pattern)
 {   string[] result;
-    
+
     bool callback(DirEntry* de)
     {
 	if (de.isdir)
@@ -650,7 +649,7 @@
 	}
 	return true; // continue
     }
-    
+
     listdir(pathname, &callback);
     return result;
 }
@@ -659,7 +658,7 @@
 
 string[] listdir(string pathname, RegExp r)
 {   string[] result;
-    
+
     bool callback(DirEntry* de)
     {
 	if (de.isdir)
@@ -670,7 +669,7 @@
 	}
 	return true; // continue
     }
-    
+
     listdir(pathname, &callback);
     return result;
 }
@@ -796,7 +795,7 @@
 		{
 		    // Skip "." and ".."
 		    if (std.c.string.strcmp(fileinfo.cFileName.ptr, ".") == 0 ||
- 			std.c.string.strcmp(fileinfo.cFileName.ptr, "..") == 0)
+			std.c.string.strcmp(fileinfo.cFileName.ptr, "..") == 0)
 			continue;
 
 		    de.init(pathname, &fileinfo);
@@ -863,7 +862,6 @@
 
 class FileException : Exception
 {
-
     uint errno;			// operating system error code
 
     this(string name)
@@ -914,52 +912,51 @@
 	goto err2;
 
     if (size > int.max)
- 	goto err2;
- 
+	goto err2;
+
     void[] buf;
     if (size == 0)
     {	/* The size could be 0 if the file is a device or a procFS file,
 	 * so we just have to try reading it.
 	 */
- 	int readsize = 1024;
- 	while (1)
- 	{
- 	    buf = std.gc.realloc(buf.ptr, cast(int)size + readsize);
- 
- 	    auto toread = readsize;
- 	    while (toread)
- 	    {
+	int readsize = 1024;
+	while (1)
+	{
+	    buf = std.gc.realloc(buf.ptr, cast(int)size + readsize);
+
+	    auto toread = readsize;
+	    while (toread)
+	    {
  		auto numread = unix.read(fd, buf.ptr + size, toread);
- 		if (numread == -1)
- 		    goto err2;
- 		size += numread;
- 		if (numread == 0)
- 		{   if (size == 0)			// it really was 0 size
- 			delete buf;			// don't need the buffer
- 		    else
- 			std.gc.hasNoPointers(buf.ptr);
- 		    goto Leof;				// end of file
- 		}
- 		toread -= numread;
- 	    }
- 	}
+		if (numread == -1)
+		    goto err2;
+		size += numread;
+		if (numread == 0)
+		{   if (size == 0)			// it really was 0 size
+			delete buf;			// don't need the buffer
+		    else
+			std.gc.hasNoPointers(buf.ptr);
+		    goto Leof;				// end of file
+		}
+		toread -= numread;
+	    }
+	}
     }
     else
     {
- 	buf = std.gc.malloc(cast(int)size);
-    if (buf.ptr)
-	std.gc.hasNoPointers(buf.ptr);
+	buf = std.gc.malloc(cast(int)size);
+	if (buf.ptr)
+	    std.gc.hasNoPointers(buf.ptr);
 
     auto numread = unix.read(fd, buf.ptr, cast(int)size); //auto numread = std.c.linux.linux.read(fd, buf.ptr, cast(int)size);
-    if (numread != size)
-    {
-        //printf("\tread error, errno = %d\n",getErrno());
-        goto err2;
+	if (numread != size)
+	{
+	    //printf("\tread error, errno = %d\n",getErrno());
+	    goto err2;
+	}
     }
-    }
-  
-   Leof:
 
+  Leof:
     if (unix.close(fd) == -1)
     {
 	//printf("\tclose error, errno = %d\n",getErrno());
@@ -982,8 +979,8 @@
     version (linux)
     {	// A file with "zero" length that doesn't have 0 length at all
 	char[] s = cast(char[])std.file.read("/proc/sys/kernel/osrelease");
- 	assert(s.length > 0);
- 	//writefln("'%s'", s);
+	assert(s.length > 0);
+	//writefln("'%s'", s);
     }
 }
 
@@ -1156,21 +1153,21 @@
     }
 	else version (linux)
     {
-    ftc = cast(d_time)statbuf.st_ctime * std.date.TicksPerSecond;
-    fta = cast(d_time)statbuf.st_atime * std.date.TicksPerSecond;
-    ftm = cast(d_time)statbuf.st_mtime * std.date.TicksPerSecond;
+	ftc = cast(d_time)statbuf.st_ctime * std.date.TicksPerSecond;
+	fta = cast(d_time)statbuf.st_atime * std.date.TicksPerSecond;
+	ftm = cast(d_time)statbuf.st_mtime * std.date.TicksPerSecond;
     }
-     else version (OSX)
-     {	// BUG: should add in tv_nsec field
- 	ftc = cast(d_time)statbuf.st_ctimespec.tv_sec * std.date.TicksPerSecond;
- 	fta = cast(d_time)statbuf.st_atimespec.tv_sec * std.date.TicksPerSecond;
- 	ftm = cast(d_time)statbuf.st_mtimespec.tv_sec * std.date.TicksPerSecond;
-     }
-     else version (FreeBSD)
+    else version (OSX)
     {	// BUG: should add in tv_nsec field
- 	ftc = cast(d_time)statbuf.st_ctimespec.tv_sec * std.date.TicksPerSecond;
- 	fta = cast(d_time)statbuf.st_atimespec.tv_sec * std.date.TicksPerSecond;
- 	ftm = cast(d_time)statbuf.st_mtimespec.tv_sec * std.date.TicksPerSecond;
+	ftc = cast(d_time)statbuf.st_ctimespec.tv_sec * std.date.TicksPerSecond;
+	fta = cast(d_time)statbuf.st_atimespec.tv_sec * std.date.TicksPerSecond;
+	ftm = cast(d_time)statbuf.st_mtimespec.tv_sec * std.date.TicksPerSecond;
+    }
+    else version (FreeBSD)
+    {	// BUG: should add in tv_nsec field
+	ftc = cast(d_time)statbuf.st_ctimespec.tv_sec * std.date.TicksPerSecond;
+	fta = cast(d_time)statbuf.st_atimespec.tv_sec * std.date.TicksPerSecond;
+	ftm = cast(d_time)statbuf.st_mtimespec.tv_sec * std.date.TicksPerSecond;
     }
     else version (Solaris)
     {  // BUG: should add in *nsec fields
@@ -1178,10 +1175,10 @@
        fta = cast(d_time)statbuf.st_atime * std.date.TicksPerSecond;
        ftm = cast(d_time)statbuf.st_mtime * std.date.TicksPerSecond;
     }
-     else
-     {
- 	static assert(0);
-     }
+    else
+    {
+	static assert(0);
+    }
 }
 
 
@@ -1189,7 +1186,7 @@
  * Does file/directory exist?
  */
 
-int exists(string name)
+int exists(char[] name)
 {
     return access(toStringz(name),0) == 0;
 
@@ -1245,7 +1242,7 @@
  * Make directory.
  */
 
-void mkdir(string pathname)
+void mkdir(char[] pathname)
 {
     if (unix.mkdir(toStringz(pathname), 0777))
     {
@@ -1295,7 +1292,7 @@
     buf[] = p[0 .. len];
     std.c.stdlib.free(p);
     return buf;
-    }	    
+}
 
 }
 
@@ -1313,7 +1310,7 @@
     version (GNU)
 	typeof(struct_stat.st_mode) _st_mode;
     else
-	ubyte d_type;
+    ubyte d_type;
     ubyte didstat;			// done lazy evaluation of stat()
 
     void init(string path, dirent *fd)
@@ -1322,11 +1319,11 @@
 	version(GNU)
 	    { }
 	else
-	    d_type = fd.d_type;
-	    // Some platforms, like Solaris, don't have this member.
-        // TODO: Bug: d_type is never set on Solaris (see bugzilla 2838 for fix.)
-        static if (is(fd.d_type))
-            d_type = fd.d_type;
+	d_type = fd.d_type;
+       // Some platforms, like Solaris, don't have this member.
+       // TODO: Bug: d_type is never set on Solaris (see bugzilla 2838 for fix.)
+       static if (is(fd.d_type))
+           d_type = fd.d_type;
 	didstat = 0;
     }
 
@@ -1339,7 +1336,7 @@
 	    return (_st_mode & S_IFMT) == S_IFDIR;
 	}
 	else
-	    return d_type & DT_DIR;
+	return d_type & DT_DIR;
     }
 
     int isfile()
@@ -1351,7 +1348,7 @@
 	    return (_st_mode & S_IFMT) == S_IFREG;
 	}
 	else
-	    return d_type & DT_REG;
+	return d_type & DT_REG;
     }
 
     ulong size()
@@ -1406,33 +1403,33 @@
 	_lastWriteTime = cast(d_time)statbuf.st_mtime * std.date.TicksPerSecond;
 	}
  	else version (linux)
- 	{
-	_creationTime = cast(d_time)statbuf.st_ctime * std.date.TicksPerSecond;
-	_lastAccessTime = cast(d_time)statbuf.st_atime * std.date.TicksPerSecond;
-	_lastWriteTime = cast(d_time)statbuf.st_mtime * std.date.TicksPerSecond;
+	{
+	    _creationTime = cast(d_time)statbuf.st_ctime * std.date.TicksPerSecond;
+	    _lastAccessTime = cast(d_time)statbuf.st_atime * std.date.TicksPerSecond;
+	    _lastWriteTime = cast(d_time)statbuf.st_mtime * std.date.TicksPerSecond;
 	}
- 	else version (OSX)
- 	{
- 	    _creationTime =   cast(d_time)statbuf.st_ctimespec.tv_sec * std.date.TicksPerSecond;
- 	    _lastAccessTime = cast(d_time)statbuf.st_atimespec.tv_sec * std.date.TicksPerSecond;
- 	    _lastWriteTime =  cast(d_time)statbuf.st_mtimespec.tv_sec * std.date.TicksPerSecond;
- 	}
- 	else version (FreeBSD)
- 	{
- 	    _creationTime =   cast(d_time)statbuf.st_ctimespec.tv_sec * std.date.TicksPerSecond;
- 	    _lastAccessTime = cast(d_time)statbuf.st_atimespec.tv_sec * std.date.TicksPerSecond;
+	else version (OSX)
+	{
+	    _creationTime =   cast(d_time)statbuf.st_ctimespec.tv_sec * std.date.TicksPerSecond;
+	    _lastAccessTime = cast(d_time)statbuf.st_atimespec.tv_sec * std.date.TicksPerSecond;
 	    _lastWriteTime =  cast(d_time)statbuf.st_mtimespec.tv_sec * std.date.TicksPerSecond;
- 	}
- 	else version (Solaris)
- 	{
- 	    _creationTime   = cast(d_time)statbuf.st_ctime * std.date.TicksPerSecond;
- 	    _lastAccessTime = cast(d_time)statbuf.st_atime * std.date.TicksPerSecond;
- 	    _lastWriteTime  = cast(d_time)statbuf.st_mtime * std.date.TicksPerSecond;
- 	}
- 	else
- 	{
- 	    static assert(0);
- 	}
+	}
+	else version (FreeBSD)
+	{
+	    _creationTime =   cast(d_time)statbuf.st_ctimespec.tv_sec * std.date.TicksPerSecond;
+	    _lastAccessTime = cast(d_time)statbuf.st_atimespec.tv_sec * std.date.TicksPerSecond;
+	    _lastWriteTime =  cast(d_time)statbuf.st_mtimespec.tv_sec * std.date.TicksPerSecond;
+	}
+	else version (Solaris)
+	{
+	    _creationTime   = cast(d_time)statbuf.st_ctime * std.date.TicksPerSecond;
+	    _lastAccessTime = cast(d_time)statbuf.st_atime * std.date.TicksPerSecond;
+	    _lastWriteTime  = cast(d_time)statbuf.st_mtime * std.date.TicksPerSecond;
+	}
+	else
+	{
+	    static assert(0);
+	}
 	_st_mode = statbuf.st_mode;
 	didstat = 1;
     }
@@ -1452,7 +1449,7 @@
 	result ~= filename;
 	return true; // continue
     }
-    
+
     listdir(pathname, &listing);
     return result;
 }
@@ -1477,7 +1474,7 @@
 
 string[] listdir(string pathname, RegExp r)
 {   string[] result;
-    
+
     bool callback(DirEntry* de)
     {
 	if (de.isdir)
@@ -1488,7 +1485,7 @@
 	}
 	return true; // continue
     }
-    
+
     listdir(pathname, &callback);
     return result;
 }
@@ -1518,7 +1515,7 @@
 	    {
 		// Skip "." and ".."
 		if (!std.c.string.strcmp(fdata.d_name.ptr, ".") ||
- 		    !std.c.string.strcmp(fdata.d_name.ptr, ".."))
+		    !std.c.string.strcmp(fdata.d_name.ptr, ".."))
 			continue;
 
 		de.init(pathname, fdata);
@@ -1629,8 +1626,8 @@
     }
     else version (FreeBSD)
     {
- 	utim.actime = cast(__time_t)statbuf.st_atimespec.tv_sec;
- 	utim.modtime = cast(__time_t)statbuf.st_mtimespec.tv_sec;
+	utim.actime = cast(__time_t)statbuf.st_atimespec.tv_sec;
+	utim.modtime = cast(__time_t)statbuf.st_mtimespec.tv_sec;
     }
     else version (Solaris)
     {
diff -r 6a92bcae44c5 d/phobos/std/format.d
--- a/d/phobos/std/format.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/format.d	Sat Jun 26 21:05:08 2010 +0100
@@ -455,7 +455,7 @@
 }
 
 void doFormatPtr(void delegate(dchar) putc, TypeInfo[] arguments, va_list argptr,
-	      void * p_args)
+		 void * p_args)
 {   int j;
     TypeInfo ti;
     Mangle m;
@@ -616,7 +616,7 @@
 		    version (GNU_MinGW_MSVCRT)
 			n = snprintf(fbuf.ptr, sl, format.ptr, field_width, precision, cast(double) v);
 		    else
-			n = snprintf(fbuf.ptr, sl, format.ptr, field_width, precision, v);
+		    n = snprintf(fbuf.ptr, sl, format.ptr, field_width, precision, v);
 		    //printf("format = '%s', n = %d\n", cast(char*)format, n);
 		    if (n >= 0 && n < sl)
 		    {	sl = n;
@@ -974,8 +974,8 @@
 		}
 		else
 		{
-		    s = tis.xtoString(argptr);
-		    argptr += (tis.tsize() + 3) & ~3;
+		s = tis.xtoString(argptr);
+		argptr += (tis.tsize() + 3) & ~3;
 		}
 		goto Lputstr;
 	    }
@@ -985,151 +985,155 @@
 	}
 	else
 	{
-	    switch (m)
-	    {
-		case Mangle.Tbool:
-		    vbit = *cast(bool*)(p_args); p_args += bool.sizeof; // int.sizeof, etc.?
-		    if (fc != 's')
-		    {   vnumber = vbit;
-			goto Lnumber;
-		    }
-		    putstr(vbit ? "true" : "false");
-		    return;
-    
-    
-		case Mangle.Tchar:
-		    vchar = *cast(char*)(p_args); p_args += char.sizeof;
-		    if (fc != 's')
-		    {   vnumber = vchar;
-			goto Lnumber;
-		    }
+    	    switch (m)
+    	    {
+    		case Mangle.Tbool:
+    		    vbit = *cast(bool*)(p_args); p_args += bool.sizeof; // int.sizeof, etc.?
+    		    if (fc != 's')
+    		    {   vnumber = vbit;
+    			goto Lnumber;
+    		    }
+    		    putstr(vbit ? "true" : "false");
+    		    return;
+
+
+    		case Mangle.Tchar:
+    		    vchar = *cast(char*)(p_args); p_args += char.sizeof;
+    		    if (fc != 's')
+    		    {   vnumber = vchar;
+    			goto Lnumber;
+    		    }
 		PL2: // there is goto L2 outside of thise switch; it's okay to do that
-		    putstr((&vchar)[0 .. 1]);
-		    return;
-    
-		case Mangle.Twchar:
-		    vdchar = *cast(wchar*)(p_args); p_args += wchar.sizeof;
-		    goto PL1;
-    
-		case Mangle.Tdchar:
-		    vdchar = *cast(dchar*)(p_args); p_args += dchar.sizeof;
+    		    putstr((&vchar)[0 .. 1]);
+    		    return;
+
+    		case Mangle.Twchar:
+    		    vdchar = *cast(wchar*)(p_args); p_args += wchar.sizeof;
+    		    goto PL1;
+
+    		case Mangle.Tdchar:
+    		    vdchar = *cast(dchar*)(p_args); p_args += dchar.sizeof;
 		PL1:
-		    if (fc != 's')
-		    {   vnumber = vdchar;
-			goto Lnumber;
-		    }
-		    if (vdchar <= 0x7F)
-		    {   vchar = cast(char)vdchar;
-			goto PL2;
-		    }
-		    else
-		    {   if (!isValidDchar(vdchar))
+    		    if (fc != 's')
+    		    {   vnumber = vdchar;
+    			goto Lnumber;
+    		    }
+    		    if (vdchar <= 0x7F)
+    		    {   vchar = cast(char)vdchar;
+    			goto PL2;
+    		    }
+    		    else
+    		    {   if (!isValidDchar(vdchar))
 			    throw new UtfException("invalid dchar in format", 0);
-			char[4] vbuf;
-			putstr(toUTF8(vbuf, vdchar));
-		    }
-		    return;
-    
-    
-		case Mangle.Tbyte:
-		    signed = 1;
-		    vnumber = *cast(byte*)p_args; p_args += byte.sizeof;
-		    goto Lnumber;
-    
-		case Mangle.Tubyte:
-		    vnumber = *cast(ubyte*)p_args; p_args += ubyte.sizeof;
-		    goto Lnumber;
-    
-		case Mangle.Tshort:
-		    signed = 1;
-		    vnumber = *cast(short*)p_args; p_args += short.sizeof;
-		    goto Lnumber;
-    
-		case Mangle.Tushort:
-		    vnumber = *cast(ushort*)p_args; p_args += ushort.sizeof;
-		    goto Lnumber;
-    
-		case Mangle.Tint:
-		    signed = 1;
-		    vnumber = *cast(int*)p_args; p_args += int.sizeof;
-		    goto Lnumber;
-    
-		case Mangle.Tuint:
+    			char[4] vbuf;
+    			putstr(toUTF8(vbuf, vdchar));
+    		    }
+    		    return;
+
+
+    		case Mangle.Tbyte:
+    		    signed = 1;
+    		    vnumber = *cast(byte*)p_args; p_args += byte.sizeof;
+    		    goto Lnumber;
+
+    		case Mangle.Tubyte:
+    		    vnumber = *cast(ubyte*)p_args; p_args += ubyte.sizeof;
+    		    goto Lnumber;
+
+    		case Mangle.Tshort:
+    		    signed = 1;
+    		    vnumber = *cast(short*)p_args; p_args += short.sizeof;
+    		    goto Lnumber;
+
+    		case Mangle.Tushort:
+    		    vnumber = *cast(ushort*)p_args; p_args += ushort.sizeof;
+    		    goto Lnumber;
+
+    		case Mangle.Tint:
+    		    signed = 1;
+    		    vnumber = *cast(int*)p_args; p_args += int.sizeof;
+    		    goto Lnumber;
+
+    		case Mangle.Tuint:
 		PLuint:
-		    vnumber = *cast(uint*)p_args; p_args += uint.sizeof;
-		    goto Lnumber;
-    
-		case Mangle.Tlong:
-		    signed = 1;
-		    vnumber = cast(ulong)*cast(long*)p_args; p_args += long.sizeof;
-		    goto Lnumber;
-    
-		case Mangle.Tulong:
+    		    vnumber = *cast(uint*)p_args; p_args += uint.sizeof;
+    		    goto Lnumber;
+
+    		case Mangle.Tlong:
+    		    signed = 1;
+    		    vnumber = cast(ulong)*cast(long*)p_args; p_args += long.sizeof;
+    		    goto Lnumber;
+
+    		case Mangle.Tulong:
 		PLulong:
-		    vnumber = *cast(ulong*)p_args; p_args += ulong.sizeof;
-		    goto Lnumber;
-    
-		case Mangle.Tclass:
-		    vobject = *cast(Object*)p_args; p_args += Object.sizeof;
-		    s = vobject.toString();
-		    goto Lputstr;
-    
-		case Mangle.Tpointer:
-		    alias void * void_ponter_t;
-		    vnumber = cast(size_t)*cast(void**)p_args; p_args += void_ponter_t.sizeof;
-		    uc = 1;
-		    flags |= FL0pad;
-		    if (!(flags & FLprecision))
-		    {   flags |= FLprecision;
-			precision = (void*).sizeof;
-		    }
-		    base = 16;
-		    goto Lnumber;
-    
-    
-		case Mangle.Tfloat:
-		case Mangle.Tifloat:
-		    if (fc == 'x' || fc == 'X')
-			goto PLuint;
-		    vreal = *cast(float*)p_args; p_args += float.sizeof;
-		    goto Lreal;
-    
-		case Mangle.Tdouble:
-		case Mangle.Tidouble:
-		    if (fc == 'x' || fc == 'X')
-			goto PLulong;
-		    vreal = *cast(double*)p_args; p_args += double.sizeof;
-		    goto Lreal;
-    
-		case Mangle.Treal:
-		case Mangle.Tireal:
-		    vreal = *cast(real*)p_args; p_args += real.sizeof;
-		    goto Lreal;
-    
-    
-		case Mangle.Tcfloat:
-		    vcreal = *cast(cfloat*)p_args; p_args += cfloat.sizeof;
-		    goto Lcomplex;
-    
-		case Mangle.Tcdouble:
-		    vcreal = *cast(cdouble*)p_args; p_args += cdouble.sizeof;
-		    goto Lcomplex;
-    
-		case Mangle.Tcreal:
-		    vcreal = *cast(creal*)p_args; p_args += creal.sizeof;
-		    goto Lcomplex;
-    
-		case Mangle.Tsarray:
-		    putArray(p_args, (cast(TypeInfo_StaticArray)ti).len, (cast(TypeInfo_StaticArray)ti).next);
-		    p_args += ti.tsize();
-		    return;
+    		    vnumber = *cast(ulong*)p_args; p_args += ulong.sizeof;
+    		    goto Lnumber;
 
-		case Mangle.Tarray:
+    		case Mangle.Tclass:
+    		    vobject = *cast(Object*)p_args; p_args += Object.sizeof;
+    		    if (vobject is null)
+    			s = "null";
+    		    else
+    			s = vobject.toString();
+    		    goto Lputstr;
+
+    		case Mangle.Tpointer:
+		    alias void * void_pointer_t;
+    		    vnumber = cast(size_t)*cast(void**)p_args; p_args += void_pointer_t.sizeof;
+    		    if (fc != 'x' && fc != 'X')
+			uc = 1;
+    		    flags |= FL0pad;
+    		    if (!(flags & FLprecision))
+    		    {   flags |= FLprecision;
+    			precision = (void*).sizeof;
+    		    }
+    		    base = 16;
+    		    goto Lnumber;
+
+
+    		case Mangle.Tfloat:
+    		case Mangle.Tifloat:
+    		    if (fc == 'x' || fc == 'X')
+    			goto PLuint;
+    		    vreal = *cast(float*)p_args; p_args += float.sizeof;
+    		    goto Lreal;
+
+    		case Mangle.Tdouble:
+    		case Mangle.Tidouble:
+    		    if (fc == 'x' || fc == 'X')
+    			goto PLulong;
+    		    vreal = *cast(double*)p_args; p_args += double.sizeof;
+    		    goto Lreal;
+
+    		case Mangle.Treal:
+    		case Mangle.Tireal:
+    		    vreal = *cast(real*)p_args; p_args += real.sizeof;
+    		    goto Lreal;
+
+
+    		case Mangle.Tcfloat:
+    		    vcreal = *cast(cfloat*)p_args; p_args += cfloat.sizeof;
+    		    goto Lcomplex;
+
+    		case Mangle.Tcdouble:
+    		    vcreal = *cast(cdouble*)p_args; p_args += cdouble.sizeof;
+    		    goto Lcomplex;
+
+    		case Mangle.Tcreal:
+    		    vcreal = *cast(creal*)p_args; p_args += creal.sizeof;
+    		    goto Lcomplex;
+
+    		case Mangle.Tsarray:
+    		    putArray(p_args, (cast(TypeInfo_StaticArray)ti).len, (cast(TypeInfo_StaticArray)ti).next);
+    		    p_args += ti.tsize();
+    		    return;
+
+    		case Mangle.Tarray:
 		    alias void[] array_t;
-		    int mi = 10;
-		    if (ti.classinfo.name.length == 14 &&
+    		    int mi = 10;
+    		    if (ti.classinfo.name.length == 14 &&
 			ti.classinfo.name[9..14] == "Array") 
-		    { // array of non-primitive types
+    		    { // array of non-primitive types
 		      TypeInfo tn = (cast(TypeInfo_Array)ti).next;
 		      tn = skipCI(tn);
 		      switch (cast(Mangle)tn.classinfo.name[9])
@@ -1145,7 +1149,7 @@
 		      return;
 		    }
 		    if (ti.classinfo.name.length == 25 &&
-			ti.classinfo.name[9..25] == "AssociativeArray") 
+    			ti.classinfo.name[9..25] == "AssociativeArray")
 		    { // associative array
 		      ubyte[long] vaa = *cast(ubyte[long]*)p_args; p_args += vaa.sizeof;
 		      putAArray(vaa,
@@ -1154,62 +1158,62 @@
 		      return;
 		    }
 
-		    while (1)
-		    {
-			m2 = cast(Mangle)ti.classinfo.name[mi];
-			switch (m2)
-			{
-			    case Mangle.Tchar:
+    		    while (1)
+    		    {
+    			m2 = cast(Mangle)ti.classinfo.name[mi];
+    			switch (m2)
+    			{
+    			    case Mangle.Tchar:
 			    LarrayChar_p:
-				s = *cast(char[]*)p_args; p_args += array_t.sizeof;
-				goto PLputstr;
+    				s = *cast(char[]*)p_args; p_args += array_t.sizeof;
+    				goto PLputstr;
 
-			    case Mangle.Twchar:
+    			    case Mangle.Twchar:
 			    LarrayWchar_p:
-				wchar[] sw = *cast(wchar[]*)p_args; p_args += array_t.sizeof;
-				s = toUTF8(sw);
-				goto PLputstr;
+    				wchar[] sw = *cast(wchar[]*)p_args; p_args += array_t.sizeof;
+    				s = toUTF8(sw);
+    				goto PLputstr;
 
-			    case Mangle.Tdchar:
+    			    case Mangle.Tdchar:
 			    LarrayDchar_p:
-				dchar[] sd = *cast(dchar[]*)p_args; p_args += array_t.sizeof;
-				s = toUTF8(sd);
+    				dchar[] sd = *cast(dchar[]*)p_args; p_args += array_t.sizeof;
+    				s = toUTF8(sd);
 			    PLputstr:
-				if (fc != 's')
-				    throw new FormatError("string");
-				if (flags & FLprecision && precision < s.length)
-				    s = s[0 .. precision];
-				putstr(s);
-				break;
+    				if (fc != 's')
+    				    throw new FormatError("string");
+    				if (flags & FLprecision && precision < s.length)
+    				    s = s[0 .. precision];
+    				putstr(s);
+    				break;
 
-			    case Mangle.Tconst:
-			    case Mangle.Tinvariant:
-				mi++;
-				continue;
+    			    case Mangle.Tconst:
+    			    case Mangle.Tinvariant:
+    				mi++;
+    				continue;
 
-			    default:
-				TypeInfo ti2 = primitiveTypeInfo(m2);
-				if (!ti2)
-				  goto Lerror;
-				void[] va = *cast(void[]*)p_args; p_args += array_t.sizeof;
-				putArray(va.ptr, va.length, ti2);
-			}
-			return;
-		    }
-    
-		case Mangle.Ttypedef:
-		    ti = (cast(TypeInfo_Typedef)ti).base;
-		    m = cast(Mangle)ti.classinfo.name[9];
-		    formatArg(fc);
-		    return;
-    
-		case Mangle.Tenum:
+    			    default:
+    				TypeInfo ti2 = primitiveTypeInfo(m2);
+    				if (!ti2)
+      				  goto Lerror;
+    				void[] va = *cast(void[]*)p_args; p_args += array_t.sizeof;
+    				putArray(va.ptr, va.length, ti2);
+    			}
+    			return;
+    		    }
+
+    		case Mangle.Ttypedef:
+    		    ti = (cast(TypeInfo_Typedef)ti).base;
+    		    m = cast(Mangle)ti.classinfo.name[9];
+    		    formatArg(fc);
+    		    return;
+
+    		case Mangle.Tenum:
 		    ti = (cast(TypeInfo_Enum)ti).base;
 		    m = cast(Mangle)ti.classinfo.name[9];
 		    formatArg(fc);
-		    return;
-		    
-		case Mangle.Tstruct:
+    		    return;
+
+    		case Mangle.Tstruct:
 		{   TypeInfo_Struct tis = cast(TypeInfo_Struct)ti;
 		    if (tis.xtoString is null)
 			throw new FormatError("Can't convert " ~ tis.toString() ~ " to string: \"string toString()\" not defined");
@@ -1218,9 +1222,9 @@
 		    goto Lputstr;
 		}
 
-		default:
-		    goto Lerror;
-	    }
+    		default:
+    		    goto Lerror;
+    	    }
 	}
 
     Lnumber:
@@ -1428,31 +1432,31 @@
 	    else
 	    {
 		alias void[] array_t;
-		switch (m2)
-		{
-		    case Mangle.Tchar:
-			fmt = *cast(char[]*)p_args; p_args += array_t.sizeof;
-			break;
+    		switch (m2)
+    		{
+    		    case Mangle.Tchar:
+    			fmt = *cast(char[]*)p_args; p_args += array_t.sizeof;
+    			break;
 
-		    case Mangle.Twchar:
-			wfmt = *cast(wchar[]*)p_args; p_args += array_t.sizeof;
-			fmt = toUTF8(wfmt);
-			break;
+    		    case Mangle.Twchar:
+    			wfmt = *cast(wchar[]*)p_args; p_args += array_t.sizeof;
+    			fmt = toUTF8(wfmt);
+    			break;
 
-		    case Mangle.Tdchar:
-			dfmt = *cast(dchar[]*)p_args; p_args += array_t.sizeof;
-			fmt = toUTF8(dfmt);
-			break;
+    		    case Mangle.Tdchar:
+    			dfmt = *cast(dchar[]*)p_args; p_args += array_t.sizeof;
+    			fmt = toUTF8(dfmt);
+    			break;
 
-		    case Mangle.Tconst:
-		    case Mangle.Tinvariant:
-			mi++;
-			goto L1;
+    		    case Mangle.Tconst:
+    		    case Mangle.Tinvariant:
+    			mi++;
+    			goto L1;
 
-		    default:
-			formatArg('s');
-			continue;
-		}
+    		    default:
+    			formatArg('s');
+    			continue;
+    		}
 	    }
 
 	    for (size_t i = 0; i < fmt.length; )
@@ -1881,10 +1885,8 @@
 
     char[5][int] aa = ([3:"hello", 4:"betty"]);
     r = std.string.format("%s", aa.values);
-    writefln(aa);
     assert(r == "[[h,e,l,l,o],[b,e,t,t,y]]");
     r = std.string.format("%s", aa);
-    writefln(aa);
     assert(r == "[3:[h,e,l,l,o],4:[b,e,t,t,y]]");
 
     static const dchar[] ds = ['a','b'];
@@ -1899,7 +1901,8 @@
 
     r = std.string.format(">%14d<, ", 15, [1,2,3]);
     assert(r == ">            15<, [1,2,3]");
+
     assert(std.string.format("%8s", "bar") == "     bar");
-   assert(std.string.format("%8s", "b\u00e9ll\u00f4") == "   b\u00e9ll\u00f4");
+    assert(std.string.format("%8s", "b\u00e9ll\u00f4") == "   b\u00e9ll\u00f4");
 }
 
diff -r 6a92bcae44c5 d/phobos/std/intrinsic.d
--- a/d/phobos/std/intrinsic.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/intrinsic.d	Sat Jun 26 21:05:08 2010 +0100
@@ -19,10 +19,10 @@
 	integrated in with intrinsic functions, bringing to bear
 	their full power on them.
 	This can result in some surprising speedups.
-  *
-  * Copyright: Public Domain
-  * License:   Public Domain
-  * Authors:   Walter Bright
+ *
+ * Copyright: Public Domain
+ * License:   Public Domain
+ * Authors:   Walter Bright
  * Macros:
  *	WIKI=Phobos/StdIntrinsic
  */
@@ -48,7 +48,7 @@
 	return i; // supposed to be undefined
     }
 else
-    int bsf(uint v);
+int bsf(uint v);
 
 /**
  * Scans the bits in v from the most significant bit
@@ -91,7 +91,7 @@
     return i; // supposed to be undefined
 }
 else
-    int bsr(uint v);
+int bsr(uint v);
 
 /**
  * Tests the bit.
@@ -102,7 +102,7 @@
     return (p[bitnum / (uint.sizeof*8)] & (1<<(bitnum & ((uint.sizeof*8)-1)))) ? -1 : 0 ;
 }
 else
-    int bt(in uint *p, uint bitnum);
+int bt(in uint *p, uint bitnum);
 
 /**
  * Tests and complements the bit.
@@ -132,7 +132,7 @@
     return result ? -1 : 0;
 }
 else
-    int btr(uint *p, uint bitnum);
+int btr(uint *p, uint bitnum);
 
 /**
  * Tests and sets the bit.
@@ -201,7 +201,7 @@
     return result ? -1 : 0;
 }
 else
-    int bts(uint *p, uint bitnum);
+int bts(uint *p, uint bitnum);
 
 
 /**
@@ -215,7 +215,7 @@
     return ((v&0xFF)<<24)|((v&0xFF00)<<8)|((v&0xFF0000)>>>8)|((v&0xFF000000)>>>24);
 }
 else
-    uint bswap(uint v);
+uint bswap(uint v);
 
 
 /**
@@ -224,7 +224,7 @@
 version (GNU)
     ubyte  inp(uint p) { return 0; }
 else
-    ubyte  inp(uint port_address);
+ubyte  inp(uint port_address);
 
 /**
  * ditto
@@ -232,7 +232,7 @@
 version (GNU)
     ushort inpw(uint p) { return 0; }
 else
-    ushort inpw(uint port_address);
+ushort inpw(uint port_address);
 
 /**
  * ditto
@@ -240,7 +240,7 @@
 version (GNU)
     uint   inpl(uint p) { return 0; }
 else
-    uint   inpl(uint port_address);
+uint   inpl(uint port_address);
 
 
 /**
@@ -249,7 +249,7 @@
 version (GNU)
     ubyte  outp(uint p, ubyte v) { return v; }
 else
-    ubyte  outp(uint port_address, ubyte value);
+ubyte  outp(uint port_address, ubyte value);
 
 /**
  * ditto
@@ -257,7 +257,7 @@
 version (GNU)
     ushort outpw(uint p, ushort v) { return v; }
 else
-    ushort outpw(uint port_address, ushort value);
+ushort outpw(uint port_address, ushort value);
 
 /**
  * ditto
@@ -265,6 +265,6 @@
 version (GNU)
     uint   outpl(uint p, uint v) { return v; }
 else
-    uint   outpl(uint port_address, uint value);
+uint   outpl(uint port_address, uint value);
 
 
diff -r 6a92bcae44c5 d/phobos/std/loader.d
--- a/d/phobos/std/loader.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/loader.d	Sat Jun 26 21:05:08 2010 +0100
@@ -434,11 +434,11 @@
     private void ExeModule_Uninit_()
     {
         if(0 == --s_init)
-	    {
+        {
         }
     }
 
-    private HXModule ExeModule_Load_(in char[] moduleName)
+    private HXModule ExeModule_Load_(in string moduleName)
     in
     {
         assert(null !is moduleName);
@@ -647,8 +647,8 @@
         {
             return (++(*p_mi).m_cRefs, cast(HXModule)*p_mi);
         }
-        else
-        {
+else
+{
             NSModule handle = null;
             NSObjectFileImage fileImage = null;
             char * filename = toStringz(moduleName);
@@ -903,10 +903,10 @@
 	    {
 		m_hModule = ExeModule_AddRef(hModule);
 	    }
-        else version (darwin)
-        {
-        m_hModule = ExeModule_AddRef(hModule);
-        }
+	    else version (darwin)
+	    {
+		m_hModule = ExeModule_AddRef(hModule);
+	    }
 	    else
 		static assert(0);
         }
@@ -931,12 +931,12 @@
 	    if (null is m_hModule)
 		throw new ExeModuleException(ExeModule_Error());
 	}
-    else version (darwin)
-    {
-        m_hModule = ExeModule_Load(moduleName);
-        if (null is m_hModule)
-        throw new ExeModuleException(ExeModule_Error());
-    }
+	else version (darwin)
+	{
+	    m_hModule = ExeModule_Load(moduleName);
+	    if (null is m_hModule)
+		throw new ExeModuleException(ExeModule_Error());
+	}
 	else
 	{
 	    static assert(0);		// unsupported system
@@ -968,10 +968,10 @@
 	    {
 		ExeModule_Release(m_hModule);
 	    }
-        else version (darwin)
-        {
-        ExeModule_Release(m_hModule);
-        }
+	    else version (darwin)
+	    {
+		ExeModule_Release(m_hModule);
+	    }
 	    else
 		static assert(0);
         }
@@ -1005,15 +1005,15 @@
 		throw new ExeModuleException(ExeModule_Error());
 	    }
 	}
-    else version (darwin)
-    {
-        void *symbol = ExeModule_GetSymbol(m_hModule, symbolName);
+	else version (darwin)
+	{
+	    void *symbol = ExeModule_GetSymbol(m_hModule, symbolName);
 
-        if(null is symbol)
-        {
-        throw new ExeModuleException(ExeModule_Error());
-        }
-    }
+	    if(null is symbol)
+	    {
+		throw new ExeModuleException(ExeModule_Error());
+	    }
+	}
 	else
 	{
 	    static assert(0);
@@ -1065,10 +1065,10 @@
 	{
 	    return ExeModule_GetPath_(m_hModule);
 	}
-    else version (darwin)
-    {
-        return ExeModule_GetPath_(m_hModule);
-    }
+	else version (darwin)
+	{
+	    return ExeModule_GetPath_(m_hModule);
+	}
 	else
 	    static assert(0);
     }
@@ -1097,8 +1097,7 @@
             {
                 auto ExeModule xmod =   new ExeModule(moduleName);
 
-                printf("\"%.*s\" is loaded\n", cast(int) moduleName.length,
-		    moduleName.ptr);
+                printf("\"%.*s\" is loaded\n", moduleName);
 
                 void    *symbol =   xmod.getSymbol(symbolName);
 
diff -r 6a92bcae44c5 d/phobos/std/math.d
--- a/d/phobos/std/math.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/math.d	Sat Jun 26 21:05:08 2010 +0100
@@ -101,7 +101,7 @@
 }
 
 version(DigitalMars){
-     version=INLINE_YL2X;	// x87 has opcodes for these
+    version=INLINE_YL2X;	// x87 has opcodes for these
 }
 
 private:
@@ -116,7 +116,7 @@
  * Non-IEEE 128 bit Big-endian 'doubledouble' (eg PowerPC) has partial support
  */
 version(LittleEndian) {
-    static assert(real.mant_dig == 53 || real.mant_dig==64 
+    static assert(real.mant_dig == 53 || real.mant_dig==64
                || real.mant_dig == 113,
       "Only 64-bit, 80-bit, and 128-bit reals"
       " are supported for LittleEndian CPUs");
@@ -141,7 +141,7 @@
     const uint EXPMASK_INT = 0x7F80_0000;
     const uint MANTISSAMASK_INT = 0x007F_FFFF;
     const real POW2MANTDIG = 0x1p+24;
-    version(LittleEndian) {        
+    version(LittleEndian) {
       const EXPPOS_SHORT = 1;
     } else {
       const EXPPOS_SHORT = 0;
@@ -162,7 +162,7 @@
  } else static if (T.mant_dig == 64) { // real80
     const ushort EXPMASK = 0x7FFF;
     const ushort EXPBIAS = 0x3FFE;
-    const real POW2MANTDIG = 0x1p+63;    
+    const real POW2MANTDIG = 0x1p+63;
     version(LittleEndian) {
       const EXPPOS_SHORT = 4;
       const SIGNPOS_BYTE = 9;
@@ -197,7 +197,7 @@
 // These apply to all floating-point types
 version(LittleEndian) {
     const MANTISSA_LSB = 0;
-    const MANTISSA_MSB = 1;    
+    const MANTISSA_MSB = 1;
 } else {
     const MANTISSA_LSB = 1;
     const MANTISSA_MSB = 0;
@@ -278,7 +278,6 @@
     return fabs(y.im);
 }
 
-
 unittest
 {
     assert(isIdentical(abs(-0.0L), 0.0L));
@@ -346,7 +345,7 @@
  */
 
 version(GNU) alias std.c.math.sinl sin; else
-real sin(real x);	/* intrinsic */
+real sin(real x);       /* intrinsic */
 
 
 /***********************************
@@ -369,7 +368,7 @@
   return cosh(y.im)*1i;
 }
 
-unittest 
+unittest
 {
   assert(sin(0.0+0.0i) == 0.0);
   assert(sin(2.0+0.0i) == sin(2.0L) );
@@ -383,15 +382,15 @@
 creal cos(creal z)
 {
   creal cs = expi(z.re);
-  return cs.re * cosh(z.im) + cs.im * sinh(z.im) * 1i;
+  return cs.re * cosh(z.im) - cs.im * sinh(z.im) * 1i;
 }
- 
+
 /** ditto */
 real cos(ireal y)
 {
   return cosh(y.im);
 }
- 
+
 unittest{
   assert(cos(0.0+0.0i)==1.0);
   assert(cos(1.3L+0.0i)==cos(1.3L));
@@ -412,7 +411,7 @@
 version(GNU) alias std.c.math.tanl tan; else
 real tan(real x)
 {
-	version(Naked_D_InlineAsm_X86) {
+    version(Naked_D_InlineAsm_X86) {
     asm
     {
         fld     x[EBP]                  ; // load theta
@@ -444,10 +443,10 @@
     return real.nan;
 
 Lret:
-    ;
+    ;    
     } else {
-         return stdc.math.tanl(x);
-     }
+        return stdc.math.tanl(x);
+    }
 }
 
 unittest
@@ -642,7 +641,7 @@
  *    $(SV  1,      0       )
  *    $(SV  +$(INFIN),+$(INFIN))
  *  )
- */   
+ */
 real acosh(real x)
 {
     if (x > 1/real.epsilon)
@@ -676,7 +675,7 @@
  *    )
  */
 real asinh(real x)
-{   
+{
     if (fabs(x) > 1 / real.epsilon) {   // beyond this point, x*x + 1 == x*x
             return copysign(LN2 + log(fabs(x)), x);
     } else {
@@ -697,9 +696,9 @@
 /***********************************
  * Calculates the inverse hyperbolic tangent of x,
  * returning a value from ranging from -1 to 1.
- *  
+ *
  * Mathematically, atanh(x) = log( (1+x)/(1-x) ) / 2
- *  
+ *
  *
  * $(TABLE_DOMRG
  *  $(DOMAIN -$(INFIN)..$(INFIN))
@@ -710,7 +709,7 @@
  *    $(SV  $(PLUSMN)0, $(PLUSMN)0)
  *    $(SV  -$(INFIN), -0)
  * )
- */   
+ */
 real atanh(real x)
 {
     // log( (1+x)/(1-x) ) == log ( 1 + (2*x)/(1-x) )
@@ -722,7 +721,7 @@
     assert(isIdentical(atanh(0.0), 0.0));
     assert(isIdentical(atanh(-0.0),-0.0));
     assert(isnan(atanh(real.nan)));
-    assert(isnan(atanh(-real.infinity))); 
+    assert(isnan(atanh(-real.infinity)));
 }
 
 /*****************************************
@@ -802,15 +801,15 @@
 }
 
 /**
-   * Calculates e$(SUP x).
-   *
-   *  $(TABLE_SV
-   *    $(TR $(TH x)             $(TH e$(SUP x)) )
-   *    $(TD +$(INFIN))          $(TD +$(INFIN)) )
-   *    $(TD -$(INFIN))          $(TD +0.0)      )
-   *    $(TR $(TD $(NAN))        $(TD $(NAN))    )
-   *  )
-   */
+ * Calculates e$(SUP x).
+ *
+ *  $(TABLE_SV
+ *    $(TR $(TH x)             $(TH e$(SUP x)) )
+ *    $(TD +$(INFIN))          $(TD +$(INFIN)) )
+ *    $(TD -$(INFIN))          $(TD +0.0)      )
+ *    $(TR $(TD $(NAN))        $(TD $(NAN))    )
+ *  )
+ */
 real exp(real x) {
     version(Naked_D_InlineAsm_X86) {
    //  e^x = 2^(LOG2E*x)
@@ -821,7 +820,7 @@
         return std.c.math.exp(x);        
     }    
 }
- 
+
 version (GNU_Need_exp2_log2) real exp2(real x) { return std.c.math.powl(2, x); } else
 //real exp2(real x)               { return std.c.math.exp2l(x); }
 
@@ -829,16 +828,16 @@
  * Calculates the value of the natural logarithm base (e)
  * raised to the power of x, minus 1.
  *
- * For very small x, expm1(x) is more accurate 
- * than exp(x)-1. 
+ * For very small x, expm1(x) is more accurate
+ * than exp(x)-1.
  *
- *      $(TABLE_SV
+ *  $(TABLE_SV
  *    $(TR $(TH x)             $(TH e$(SUP x)-1)  )
  *    $(TR $(TD $(PLUSMN)0.0)  $(TD $(PLUSMN)0.0) )
  *    $(TD +$(INFIN))          $(TD +$(INFIN))    )
  *    $(TD -$(INFIN))          $(TD -1.0)         )
  *    $(TR $(TD $(NAN))        $(TD $(NAN))       )
- *      )
+ *  )
  */
 real expm1(real x) 
 {
@@ -1199,14 +1198,14 @@
 
 unittest
 {
-    static real vals[][3] =	// x,frexp,exp
+    static real vals[][3] =     // x,frexp,exp
     [
         [0.0,   0.0,    0],
         [-0.0,  -0.0,   0],
         [1.0,   .5,     1],
         [-1.0,  -.5,    1],
         [2.0,   .5,     2],
-        [double.min/2.0, .5, -1022],
+    [double.min/2.0, .5, -1022],
         [real.infinity,real.infinity,int.max],
         [-real.infinity,-real.infinity,int.min],
         [real.nan,real.nan,int.min],
@@ -1223,13 +1222,13 @@
         int exp = cast(int)vals[i][2];
         int eptr;
         real v = frexp(x, eptr);
-//        printf("frexp(%La) = %La, should be %La, eptr = %d, should be %d\n", 
+//        printf("frexp(%La) = %La, should be %La, eptr = %d, should be %d\n",
 //                x, v, e, eptr, exp);
         assert(isIdentical(e, v));
         assert(exp == eptr);
 
     }
-    static if (real.mant_dig == 64) {
+   static if (real.mant_dig == 64) {
      static real extendedvals[][3] = [ // x,frexp,exp
         [0x1.a5f1c2eb3fe4efp+73L, 0x1.A5F1C2EB3FE4EFp-1L,   74],    // normal
         [0x1.fa01712e8f0471ap-1064L,  0x1.fa01712e8f0471ap-1L,     -1063],
@@ -1245,6 +1244,7 @@
         real v = frexp(x, eptr);
         assert(isIdentical(e, v));
         assert(exp == eptr);
+
     }
     }
 }
@@ -1294,7 +1294,7 @@
     else
 	return std.c.math.logl(x);
 }
- 
+
 unittest
 {
     assert(log(E) == 1);
@@ -1314,22 +1314,22 @@
 real log10(real x)
 {
     version (INLINE_YL2X)
- 	return yl2x(x, LOG2);
+	return yl2x(x, LOG2);
     else
 	return std.c.math.log10l(x);
 }
- 
+
 unittest
 {
-	//printf("%Lg\n", log10(1000) - 3);
+    //printf("%Lg\n", log10(1000) - 3);
     assert(fabs(log10(1000) - 3) < .000001);
 }
 
 /******************************************
  *      Calculates the natural logarithm of 1 + x.
  *
- *      For very small x, log1p(x) will be more accurate than 
- *      log(1 + x). 
+ *      For very small x, log1p(x) will be more accurate than
+ *      log(1 + x).
  *
  *  $(TABLE_SV
  *  $(TR $(TH x)            $(TH log1p(x))     $(TH divide by 0?) $(TH invalid?))
@@ -1362,13 +1362,14 @@
 	return std.c.math.log2l(x);
 }
 
+
 /*****************************************
  * Extracts the exponent of x as a signed integral value.
  *
  * If x is subnormal, it is treated as if it were normalized.
- * For a positive, finite x: 
+ * For a positive, finite x:
  *
- * 1 $(LT)= $(I x) * FLT_RADIX$(SUP -logb(x)) $(LT) FLT_RADIX 
+ * 1 $(LT)= $(I x) * FLT_RADIX$(SUP -logb(x)) $(LT) FLT_RADIX
  *
  *      $(TABLE_SV
  *      $(TR $(TH x)                 $(TH logb(x))   $(TH divide by 0?) )
@@ -1381,8 +1382,8 @@
 /************************************
  * Calculates the remainder from the calculation x/y.
  * Returns:
- * The value of x - i * y, where i is the number of times that y can 
- * be completely subtracted from x. The result has the same sign as x. 
+ * The value of x - i * y, where i is the number of times that y can
+ * be completely subtracted from x. The result has the same sign as x.
  *
  * $(TABLE_SV
  *  $(TR $(TH x)              $(TH y)             $(TH modf(x, y))   $(TH invalid?))
@@ -1397,8 +1398,8 @@
 /*************************************
  * Efficiently calculates x * 2$(SUP n).
  *
- * scalbn handles underflow and overflow in 
- * the same fashion as the basic arithmetic operators. 
+ * scalbn handles underflow and overflow in
+ * the same fashion as the basic arithmetic operators.
  *
  *      $(TABLE_SV
  *      $(TR $(TH x)                 $(TH scalb(x)))
@@ -1452,9 +1453,9 @@
 
 
 /***********************************************************************
- * Calculates the length of the 
- * hypotenuse of a right-angled triangle with sides of length x and y. 
- * The hypotenuse is the value of the square root of 
+ * Calculates the length of the
+ * hypotenuse of a right-angled triangle with sides of length x and y.
+ * The hypotenuse is the value of the square root of
  * the sums of the squares of x and y:
  *
  *      sqrt($(POW x, 2) + $(POW y, 2))
@@ -1657,11 +1658,11 @@
 real floor(real x)              { return std.c.math.floorl(x); }
 
 /******************************************
- * Rounds x to the nearest integer value, using the current rounding 
+ * Rounds x to the nearest integer value, using the current rounding
  * mode.
  *
- * Unlike the rint functions, nearbyint does not raise the 
- * FE_INEXACT exception. 
+ * Unlike the rint functions, nearbyint does not raise the
+ * FE_INEXACT exception.
  */
 version (GNU_Need_nearbyint)
 {
@@ -1712,7 +1713,7 @@
 /*******************************************
  * Return the value of x rounded to the nearest integer.
  * If the fractional part of x is exactly 0.5, the return value is rounded to
- * the even integer. 
+ * the even integer.
  */
 version (GNU_Need_round)
 {
@@ -1765,9 +1766,9 @@
 }
 
 /****************************************************
- * Returns the integer portion of x, dropping the fractional portion. 
+ * Returns the integer portion of x, dropping the fractional portion.
  *
- * This is also known as "chop" rounding. 
+ * This is also known as "chop" rounding.
  */
 version (GNU_Need_trunc)
 {
@@ -1792,7 +1793,7 @@
 /****************************************************
  * Calculate the remainder x REM y, following IEC 60559.
  *
- * REM is the value of x - y * n, where n is the integer nearest the exact 
+ * REM is the value of x - y * n, where n is the integer nearest the exact
  * value of x / y.
  * If |n - x / y| == 0.5, n is even.
  * If the result is zero, it has the same sign as x.
@@ -1835,7 +1836,7 @@
   alias floatTraits!(real) F;
   static if (real.mant_dig==53) { // double
         ulong*  p = cast(ulong *)&x;
-        return (*p & 0x7FF0_0000_0000_0000 == 0x7FF0_0000_0000_0000) 
+        return (*p & 0x7FF0_0000_0000_0000 == 0x7FF0_0000_0000_0000)
              && *p & 0x000F_FFFF_FFFF_FFFF;
   } else static if (real.mant_dig==64) {     // real80
         // Prevent a ridiculous warning
@@ -1913,7 +1914,7 @@
 int isnormal(X)(X x)
 {
     alias floatTraits!(X) F;
-    
+
     static if(real.mant_dig==106) { // doubledouble
         // doubledouble is normal if the least significant part is normal.
         return isnormal((cast(double*)&x)[MANTISSA_LSB]);
@@ -1994,7 +1995,7 @@
     alias floatTraits!(real) F;
     static if (real.mant_dig == 53) { // double
         return issubnormal(cast(double)x);
-    } else static if (real.mant_dig == 113) { // quadruple        
+    } else static if (real.mant_dig == 113) { // quadruple
         ushort e = F.EXPMASK & (cast(ushort *)&x)[F.EXPPOS_SHORT];
         long*   ps = cast(long *)&x;
         return (e == 0 &&
@@ -2033,10 +2034,10 @@
                 == 0x7FF8_0000_0000_0000;
     } else static if(real.mant_dig == 106) { //doubledouble
         return (((cast(ulong *)&x)[MANTISSA_MSB]) & 0x7FFF_FFFF_FFFF_FFFF)
-                    == 0x7FF8_0000_0000_0000;   
-    } else static if (real.mant_dig == 113) { // quadruple   
+                    == 0x7FF8_0000_0000_0000;
+    } else static if (real.mant_dig == 113) { // quadruple
         long*   ps = cast(long *)&x;
-        return (ps[MANTISSA_LSB] == 0) 
+        return (ps[MANTISSA_LSB] == 0)
          && (ps[MANTISSA_MSB] & 0x7FFF_FFFF_FFFF_FFFF) == 0x7FFF_0000_0000_0000;
     } else { // real80
         ushort e = cast(ushort)(F.EXPMASK & (cast(ushort *)&x)[F.EXPPOS_SHORT]);
@@ -2046,7 +2047,7 @@
    }
 }
 */
-    
+
 unittest
 {
     assert(isinf(float.infinity));
@@ -2114,7 +2115,7 @@
 {
     ubyte* pto   = cast(ubyte *)&to;
     ubyte* pfrom = cast(ubyte *)&from;
-    
+
     alias floatTraits!(real) F;
     pto[F.SIGNPOS_BYTE] &= 0x7F;
     pto[F.SIGNPOS_BYTE] |= pfrom[F.SIGNPOS_BYTE] & 0x80;
@@ -2183,7 +2184,7 @@
         if (e == F.EXPMASK) { // NaN or Infinity
              if (x == -real.infinity) return -real.max;
              return x; // +Inf and NaN are unchanged.
-        }     
+        }
         ulong*   ps = cast(ulong *)&e;
         if (ps[MANTISSA_LSB] & 0x8000_0000_0000_0000)  { // Negative number
             if (ps[MANTISSA_LSB] == 0
@@ -2200,7 +2201,7 @@
             if (ps[MANTISSA_LSB]==0) ++ps[MANTISSA_MSB];
         }
         return x;
-          
+
     } else static if(real.mant_dig==64){ // real80
         // For 80-bit reals, the "implied bit" is a nuisance...
         ushort *pe = cast(ushort *)&x;
@@ -2664,9 +2665,9 @@
 {
     /* Public Domain. Author: Don Clugston, 18 Aug 2005.
      */
-  static assert(is(X==real) || is(X==double) || is(X==float), 
+  static assert(is(X==real) || is(X==double) || is(X==float),
         "Only float, double, and real are supported by feqrel");
-  
+
   static if (X.mant_dig == 106) { // doubledouble.
      if (cast(double*)(&x)[MANTISSA_MSB] == cast(double*)(&y)[MANTISSA_MSB]) {
          return double.mant_dig
@@ -2677,7 +2678,7 @@
                        cast(double*)(&y)[MANTISSA_MSB]);
      }
   } else static if (X.mant_dig==64 || X.mant_dig==113 || X.mant_dig==53) {
-      
+
     if (x == y) return X.mant_dig; // ensure diff!=0, cope with INF.
 
     X diff = fabs(x - y);
@@ -2699,12 +2700,12 @@
     // they could have 0 or 1 bits in common.
 
  static if (X.mant_dig==64 || X.mant_dig==113) { // real80 or quadruple
-    int bitsdiff = ( ((pa[F.EXPPOS_SHORT]&0x7FFF) 
-                    + (pb[F.EXPPOS_SHORT]&0x7FFF)-1)>>1) 
+    int bitsdiff = ( ((pa[F.EXPPOS_SHORT]&0x7FFF)
+                    + (pb[F.EXPPOS_SHORT]&0x7FFF)-1)>>1)
                     - pd[F.EXPPOS_SHORT];
  } else static if (X.mant_dig==53) { // double
-    int bitsdiff = (( ((pa[F.EXPPOS_SHORT]&0x7FF0) 
-                     + (pb[F.EXPPOS_SHORT]&0x7FF0)-0x10)>>1) 
+    int bitsdiff = (( ((pa[F.EXPPOS_SHORT]&0x7FF0)
+                     + (pb[F.EXPPOS_SHORT]&0x7FF0)-0x10)>>1)
                      - (pd[F.EXPPOS_SHORT]&0x7FF0))>>4;
  }
     if (pd[F.EXPPOS_SHORT] == 0)
@@ -2718,16 +2719,16 @@
 
     if (bitsdiff > 0)
         return bitsdiff + 1; // add the 1 we subtracted before
-        
-    // Avoid out-by-1 errors when factor is almost 2.    
-     static if (X.mant_dig==64 || X.mant_dig==113) { // real80 or quadruple    
+
+    // Avoid out-by-1 errors when factor is almost 2.
+     static if (X.mant_dig==64 || X.mant_dig==113) { // real80 or quadruple
         return (bitsdiff == 0) ? (pa[F.EXPPOS_SHORT] == pb[F.EXPPOS_SHORT]) : 0;
      } else static if (X.mant_dig==53) { // double
-        if (bitsdiff == 0 
+        if (bitsdiff == 0
           && !((pa[F.EXPPOS_SHORT] ^ pb[F.EXPPOS_SHORT])& F.EXPMASK)) {
               return 1;
         } else return 0;
-     }  
+     }
  } else {
     throw new NotImplemented("feqrel");
  }
@@ -2752,9 +2753,9 @@
    assert(feqrel(1.5+real.epsilon,1.5L)==real.mant_dig-1);
    assert(feqrel(1.5-real.epsilon,1.5L)==real.mant_dig-1);
    assert(feqrel(1.5-real.epsilon,1.5+real.epsilon)==real.mant_dig-2);
-   
+
    assert(feqrel(real.min/8,real.min/17)==3);;
-   
+
    // Numbers that are close
    assert(feqrel(0x1.Bp+84, 0x1.B8p+84)==5);
    assert(feqrel(0x1.8p+10, 0x1.Cp+10)==2);
@@ -2802,7 +2803,7 @@
 T ieeeMean(T)(T x, T y)
 in {
     // both x and y must have the same sign, and must not be NaN.
-    assert(signbit(x) == signbit(y)); 
+    assert(signbit(x) == signbit(y));
     assert(x<>=0 && y<>=0);
 }
 body {
@@ -2848,8 +2849,8 @@
         ulong *ul = cast(ulong *)&u;
         ulong *xl = cast(ulong *)&x;
         ulong *yl = cast(ulong *)&y;
-        // Multi-byte add, then multi-byte right shift.        
-        ulong mh = ((xl[MANTISSA_MSB] & 0x7FFF_FFFF_FFFF_FFFFL) 
+        // Multi-byte add, then multi-byte right shift.
+        ulong mh = ((xl[MANTISSA_MSB] & 0x7FFF_FFFF_FFFF_FFFFL)
                   + (yl[MANTISSA_MSB] & 0x7FFF_FFFF_FFFF_FFFFL));
         // Discard the lowest bit (to avoid overflow)
         ulong ml = (xl[MANTISSA_LSB]>>>1) + (yl[MANTISSA_LSB]>>>1);
@@ -2905,7 +2906,7 @@
 
 public:
 
-    
+
 // The space allocated for real varies across targets.
 version (D_InlineAsm_X86)
 {
@@ -2918,11 +2919,11 @@
 /***********************************
  * Evaluate polynomial A(x) = $(SUB a, 0) + $(SUB a, 1)x + $(SUB a, 2)&sup2;
  *                          + $(SUB a,3)x&sup3; ...
- * Uses Horner's rule A(x) = $(SUB a, 0) + x($(SUB a, 1) + x($(SUB a, 2) 
+ * Uses Horner's rule A(x) = $(SUB a, 0) + x($(SUB a, 1) + x($(SUB a, 2)
  *                         + x($(SUB a, 3) + ...)))
  * Params:
  *      A =     array of coefficients $(SUB a, 0), $(SUB a, 1), etc.
- */ 
+ */
 real poly(real x, real[] A)
 in
 {
@@ -2931,62 +2932,62 @@
 body
 {
     version (poly_10)
-    {
+        {
         // BUG: This code assumes a frame pointer in EBP.
-        asm    // assembler by W. Bright
+            asm // assembler by W. Bright
+            {
+                // EDX = (A.length - 1) * real.sizeof
+                mov     ECX,A[EBP]              ; // ECX = A.length
+                dec     ECX                     ;
+                lea     EDX,[ECX][ECX*8]        ;
+                add     EDX,ECX                 ;
+                add     EDX,A+4[EBP]            ;
+                fld     real ptr [EDX]          ; // ST0 = coeff[ECX]
+                jecxz   return_ST               ;
+                fld     x[EBP]                  ; // ST0 = x
+                fxch    ST(1)                   ; // ST1 = x, ST0 = r
+                align   4                       ;
+        L2:     fmul    ST,ST(1)                ; // r *= x
+                fld     real ptr -10[EDX]       ;
+                sub     EDX,10                  ; // deg--
+                faddp   ST(1),ST                ;
+                dec     ECX                     ;
+                jne     L2                      ;
+                fxch    ST(1)                   ; // ST1 = r, ST0 = x
+                fstp    ST(0)                   ; // dump x
+                align   4                       ;
+        return_ST:                              ;
+                ;
+            }
+        }
+        else version (poly_12)
         {
-            // EDX = (A.length - 1) * real.sizeof
-            mov     ECX,A[EBP]              ; // ECX = A.length
-            dec     ECX                     ;
-            lea     EDX,[ECX][ECX*8]        ;
-            add     EDX,ECX                 ;
-            add     EDX,A+4[EBP]            ;
-            fld     real ptr [EDX]          ; // ST0 = coeff[ECX]
-            jecxz   return_ST               ;
-            fld     x[EBP]                  ; // ST0 = x
-            fxch    ST(1)                   ; // ST1 = x, ST0 = r
-            align   4                       ;
-            L2:     fmul    ST,ST(1)        ; // r *= x
-            fld     real ptr -10[EDX]       ;
-            sub     EDX,10                  ; // deg--
-            faddp   ST(1),ST                ;
-            dec     ECX                     ;
-            jne     L2                      ;
-            fxch    ST(1)                   ; // ST1 = r, ST0 = x
-            fstp    ST(0)                   ; // dump x
-            align   4                       ;
-            return_ST:                      ;
-            ;
-        }
-    }
-    else version (poly_12)
-    {
-        asm    // above code with modifications for GCC
-        {
-            // EDX = (A.length - 1) * real.sizeof
-            mov     ECX,A[EBP]              ; // ECX = A.length
-            dec     ECX                     ;
+            asm // above code with modifications for GCC
+            {
+                // EDX = (A.length - 1) * real.sizeof
+                mov     ECX,A[EBP]              ; // ECX = A.length
+                dec     ECX                     ;
             lea     EDX,[ECX][ECX*2]        ;
             lea     EDX,[EDX*4]             ;
-            add     EDX,A+4[EBP]            ;
-            fld     real ptr [EDX]          ; // ST0 = coeff[ECX]
-            jecxz   return_ST               ;
+                add     EDX,A+4[EBP]            ;
+                fld     real ptr [EDX]          ; // ST0 = coeff[ECX]
+                jecxz   return_ST               ;
             fld     x                       ; // ST0 = x
-            fxch    ST(1)                   ; // ST1 = x, ST0 = r
-            align   4                       ;
-        L2:     fmul    ST,ST(1)            ; // r *= x
-            fld     real ptr -12[EDX]       ;
-            sub     EDX,12                  ; // deg--
-            faddp   ST(1),ST                ;
-            dec     ECX                     ;
-            jne     L2                      ;
-            fxch    ST(1)                   ; // ST1 = r, ST0 = x
-            fstp    ST(0)                   ; // dump x
-            align   4                       ;
-        return_ST:                          ;
-            ;
+                fxch    ST(1)                   ; // ST1 = x, ST0 = r
+                align   4                       ;
+        L2:     fmul    ST,ST(1)                ; // r *= x
+                fld     real ptr -12[EDX]       ;
+                sub     EDX,12                  ; // deg--
+                faddp   ST(1),ST                ;
+                dec     ECX                     ;
+                jne     L2                      ;
+                fxch    ST(1)                   ; // ST1 = r, ST0 = x
+                fstp    ST(0)                   ; // dump x
+                align   4                       ;
+        return_ST:                              ;
+                ;
+            }
         }
-    }
     else
     {
         ptrdiff_t i = A.length - 1;
@@ -3021,7 +3022,7 @@
 {
     version (INLINE_YL2X)
     {
- 	assert(yl2x(1024, 1) == 10);
- 	assert(yl2xp1(1023, 1) == 10);
+	assert(yl2x(1024, 1) == 10);
+	assert(yl2xp1(1023, 1) == 10);
     }
 }
diff -r 6a92bcae44c5 d/phobos/std/math2.d
--- a/d/phobos/std/math2.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/math2.d	Sat Jun 26 21:05:08 2010 +0100
@@ -13,7 +13,7 @@
  * the suitability of this software for any purpose. It is provided
  * "as is" without express or implied warranty.
  */
-
+ 
 /* NOTE: This file has been patched from the original DMD distribution to
    work with the GDC compiler.
 
@@ -103,18 +103,18 @@
 }
 else
 {
-    real trunc(real n)
-    {
-	    ushort cw;
-	    asm
-	    {
-		    fstcw cw;
-		    fldcw fp_cw_chop;
-		    fld n;
-		    frndint;
-		    fldcw cw;
-	    }	
-    }
+real trunc(real n)
+{
+	ushort cw;
+	asm
+	{
+		fstcw cw;
+		fldcw fp_cw_chop;
+		fld n;
+		frndint;
+		fldcw cw;
+	}	
+}
 }
 
 unittest
@@ -554,7 +554,7 @@
 		fdivrp;
 		fwait;
 	}
-    }
+}
 }
 
 unittest
@@ -579,7 +579,7 @@
 		fdivrp;
 		fwait;
 	}
-    }
+}
 }
 
 
@@ -601,7 +601,7 @@
 		fdivrp;
 		fwait;
 	}
-    }
+}
 }
 
 /*********************************************
@@ -636,7 +636,7 @@
 done:
 		fwait;
 	}
-    }
+}
 }
 
 unittest
diff -r 6a92bcae44c5 d/phobos/std/md5.d
--- a/d/phobos/std/md5.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/md5.d	Sat Jun 26 21:05:08 2010 +0100
@@ -194,16 +194,16 @@
 		}
 	    }
 	    else
-	    {
-		asm
-		{   naked			;
-		    mov	ECX,EAX		;
-		    mov	EAX,4[ESP]	;
-		    rol	EAX,CL		;
-		    ret	4		;
-		}
+	{
+	    asm
+	    {   naked			;
+		mov	ECX,EAX		;
+		mov	EAX,4[ESP]	;
+		rol	EAX,CL		;
+		ret	4		;
 	    }
 	}
+	}
 	else
 	{
 	    return (x << n) | (x >> (32-n));
diff -r 6a92bcae44c5 d/phobos/std/mmfile.d
--- a/d/phobos/std/mmfile.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/mmfile.d	Sat Jun 26 21:05:08 2010 +0100
@@ -1,4 +1,6 @@
-/* Copyright 2004-2005 by Digital Mars
+// Written in the D programming language
+
+/* Copyright 2004-2008 by Digital Mars
  * Written by Walter Bright and Matthew Wilson
  *
  * This software is provided 'as-is', without any express or implied
@@ -64,9 +66,9 @@
 
 	    version = unix_mm;
 	    private const bool Have_MMFile = true;
-	}
+}
 	else
-	{
+{
 	    private const bool Have_MMFile = false;
 	}
 
@@ -105,7 +107,7 @@
      * Throws:
      *	std.file.FileException
      */
-    this(char[] filename)
+    this(string filename)
     {
 		this(filename, Mode.Read, 0, null);
     }
@@ -128,7 +130,7 @@
      * Throws:
      *	std.file.FileException
      */
-    this(char[] filename, Mode mode, ulong size, void* address,
+    this(string filename, Mode mode, ulong size, void* address,
 			size_t window = 0)
     {
 		this.filename = filename;
@@ -329,11 +331,11 @@
 			else
 			{
 				fd = -1;
-				version (linux)			flags |= MAP_ANONYMOUS;
-				else version (OSX)		flags |= MAP_ANON;
-				else version (FreeBSD)		flags |= MAP_ANON;
-				else version (Solaris)		flags |= MAP_ANON;
- 				else				static assert(0);
+version (linux)			flags |= MAP_ANONYMOUS;
+else version (OSX)		flags |= MAP_ANON;
+else version (FreeBSD)		flags |= MAP_ANON;
+else version (Solaris)		flags |= MAP_ANON;
+else				static assert(0);
 			}
 			this.size = size;
 			size_t initial_map = (window && 2*window<size)? 2*window : cast(size_t)size;
@@ -369,7 +371,7 @@
 				errNo();
 			hFileMap = null;
 
-			if (hFile != INVALID_HANDLE_VALUE && CloseHandle(hFile) != TRUE)
+			if (hFile && hFile != INVALID_HANDLE_VALUE && CloseHandle(hFile) != TRUE)
 				errNo();
 			hFile = INVALID_HANDLE_VALUE;
 		}
@@ -561,7 +563,7 @@
 	}
 
 	private:
-	char[] filename;
+	string filename;
 	void[] data;
 	ulong  start;
 	size_t window;
@@ -643,5 +645,8 @@
 	assert( data2[length-1] == 'b' );
 	delete mf;
 	std.file.remove("testing.txt");
+
+	// Create anonymous mapping
+	auto test = new MmFile(null, MmFile.Mode.ReadWriteNew, 1024*1024, null);
     }
 }
diff -r 6a92bcae44c5 d/phobos/std/moduleinit.d
--- a/d/phobos/std/moduleinit.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/moduleinit.d	Sat Jun 26 21:05:08 2010 +0100
@@ -97,10 +97,10 @@
     // into the .ctor list by the compiler.
     struct ModuleReference
     {
- 	ModuleReference* next;
- 	ModuleInfo mod;
+	ModuleReference* next;
+	ModuleInfo mod;
     }
- 
+
     extern (C) ModuleReference *_Dmodule_ref;	// start of linked list
 }
 else version (Solaris)
@@ -116,13 +116,14 @@
     extern (C) ModuleReference *_Dmodule_ref;  // start of linked list
 }
 
-/*version (OSX)
+/+version (OSX)
 {
-   extern (C)   {
- 	extern void* _minfo_beg;
- 	extern void* _minfo_end;
-   }
-}*/
+    extern (C)
+    {
+	extern void* _minfo_beg;
+	extern void* _minfo_end;
+    }
+}+/
 
 ModuleInfo[] _moduleinfo_dtors;
 uint _moduleinfo_dtors_i;
@@ -153,17 +154,17 @@
     }
     else version (FreeBSD)
     {
- 	int len = 0;
- 	ModuleReference *mr;
+	int len = 0;
+	ModuleReference *mr;
 
- 	for (mr = _Dmodule_ref; mr; mr = mr.next)
- 	    len++;
- 	_moduleinfo_array = new ModuleInfo[len];
- 	len = 0;
- 	for (mr = _Dmodule_ref; mr; mr = mr.next)
- 	{   _moduleinfo_array[len] = mr.mod;
- 	    len++;
- 	}
+	for (mr = _Dmodule_ref; mr; mr = mr.next)
+	    len++;
+	_moduleinfo_array = new ModuleInfo[len];
+	len = 0;
+	for (mr = _Dmodule_ref; mr; mr = mr.next)
+	{   _moduleinfo_array[len] = mr.mod;
+	    len++;
+	}
     }
     else version (Solaris)
     {
@@ -179,23 +180,24 @@
            len++;
        }
     }
-    
+
     /+version (OSX)
-     {	/* The ModuleInfo references are stored in the special segment
- 	 * __minfodata, which is bracketed by the segments __minfo_beg
- 	 * and __minfo_end. The variables _minfo_beg and _minfo_end
- 	 * are of zero size and are in the two bracketing segments,
- 	 * respectively.
- 	 */ 	size_t length = cast(ModuleInfo*)&_minfo_end - cast(ModuleInfo*)&_minfo_beg;
- 	_moduleinfo_array = (cast(ModuleInfo*)&_minfo_beg)[0 .. length];
- 	debug printf("moduleinfo: ptr = %p, length = %d\n", _moduleinfo_array.ptr, _moduleinfo_array.length);
- 
- 	debug foreach (m; _moduleinfo_array)
- 	{
- 	    //printf("\t%p\n", m);
- 	    printf("\t%.*s\n", m.name);
- 	}
-     }+/
+    {	/* The ModuleInfo references are stored in the special segment
+	 * __minfodata, which is bracketed by the segments __minfo_beg
+	 * and __minfo_end. The variables _minfo_beg and _minfo_end
+	 * are of zero size and are in the two bracketing segments,
+	 * respectively.
+	 */
+	size_t length = cast(ModuleInfo*)&_minfo_end - cast(ModuleInfo*)&_minfo_beg;
+	_moduleinfo_array = (cast(ModuleInfo*)&_minfo_beg)[0 .. length];
+	debug printf("moduleinfo: ptr = %p, length = %d\n", _moduleinfo_array.ptr, _moduleinfo_array.length);
+
+	debug foreach (m; _moduleinfo_array)
+	{
+	    //printf("\t%p\n", m);
+	    printf("\t%.*s\n", m.name);
+	}
+    }+/
 
     version (Win32)
     {
@@ -231,11 +233,10 @@
 	debug printf("\tmodule[%d] = '%p'\n", i, m);
 	if (!m)
 	    continue;
-	debug printf("\tmodule[%d] = '%.*s'\n", i, cast(int) m.name.length,
-	    m.name.ptr);
+	debug printf("\tmodule[%d] = '%.*s'\n", i, m.name);
 	if (m.flags & MIctordone)
 	    continue;
-    debug printf("\tmodule[%d] = '%.*s', m = x%x, m.flags = x%x\n", i, m.name, m, m.flags);
+	debug printf("\tmodule[%d] = '%.*s', m = x%x, m.flags = x%x\n", i, m.name, m, m.flags);
 
 	if (m.ctor || m.dtor)
 	{
@@ -280,8 +281,7 @@
     {
 	ModuleInfo m = _moduleinfo_dtors[i];
 
-	debug printf("\tmodule[%d] = '%.*s', x%x\n", i,
-	    cast(int) m.name.length, m.name.ptr, m);
+	debug printf("\tmodule[%d] = '%.*s', x%x\n", i, m.name, m);
 	if (m.dtor)
 	{
 	    (*m.dtor)();
@@ -304,8 +304,7 @@
 	if (!m)
 	    continue;
 
-	debug printf("\tmodule[%d] = '%.*s'\n", i,
-	    cast(int) m.name.length, m.name.ptr);
+	debug printf("\tmodule[%d] = '%.*s'\n", i, m.name);
 	if (m.unitTest)
 	{
 	    (*m.unitTest)();
diff -r 6a92bcae44c5 d/phobos/std/openrj.d
--- a/d/phobos/std/openrj.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/openrj.d	Sat Jun 26 21:05:08 2010 +0100
@@ -1067,8 +1067,7 @@
             try
             {
                 printf( "std.openrj test:\n\tmodule:      \t%.*s\n\tdescription: \t%.*s\n\tversion:     \t%d.%d.%d.%d\n"
-                    ,   cast(int) std.openrj.VERSION.name.length
-                    ,   std.openrj.VERSION.name.ptr
+                    ,   std.openrj.VERSION.name
                     ,   std.openrj.VERSION.description
                     ,   std.openrj.VERSION.major
                     ,   std.openrj.VERSION.minor
@@ -1113,18 +1112,14 @@
                     printf("  Record\n");
                     foreach(Field field; record.fields)
                     {
-                        printf("    Field: %.*s=%.*s\n",
-			    cast(int) field.name.length, field.name.ptr,
-			    cast(int) field.value.length, field.value.ptr);
+                        printf("    Field: %.*s=%.*s\n", field.name, field.value);
                     }
                 }
 
                 printf("Fields (%u)\n", database.numFields);
                 foreach(Field field; database)
                 {
-                        printf("    Field: %.*s=%.*s\n",
-			    cast(int) field.name.length, field.name.ptr,
-			    cast(int) field.value.length, field.value.ptr);
+                        printf("    Field: %.*s=%.*s\n", field.name, field.value);
                 }
 
                 Record[]    records =   database.getRecordsContainingField("Name");
@@ -1134,16 +1129,13 @@
                     printf("  Record\n");
                     foreach(Field field; record.fields)
                     {
-                        printf("    Field: %.*s=%.*s\n",
-			    cast(int) field.name.length, field.name.ptr,
-			    cast(int) field.value.length, field.value.ptr);
+                        printf("    Field: %.*s=%.*s\n", field.name, field.value);
                     }
                 }
             }
             catch(Exception x)
             {
-                char[] s = x.toString();
-                printf("Exception: %.*s\n", cast(int) s.length, s.ptr);
+                printf("Exception: %.*s\n", x.toString());
             }
         }
 
diff -r 6a92bcae44c5 d/phobos/std/outbuffer.d
--- a/d/phobos/std/outbuffer.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/outbuffer.d	Sat Jun 26 21:05:08 2010 +0100
@@ -317,11 +317,11 @@
 	}
 	else
 	{
-	    va_list ap;
-	    ap = cast(va_list)&format;
-	    ap += format.sizeof;
-	    vprintf(format, ap);
-	}
+	va_list ap;
+	ap = cast(va_list)&format;
+	ap += format.sizeof;
+	vprintf(format, ap);
+    }
     }
 
     /*****************************************
diff -r 6a92bcae44c5 d/phobos/std/path.d
--- a/d/phobos/std/path.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/path.d	Sat Jun 26 21:05:08 2010 +0100
@@ -147,7 +147,7 @@
 unittest
 {
     debug(path) printf("path.getExt.unittest\n");
-    char[] result;
+    string result;
 
     version (Win32)
 	result = getExt("d:\\path\\foo.bat");
@@ -213,7 +213,7 @@
  * -----
  */
 
-char[] getName(char[] fullname)
+string getName(string fullname)
 {
     size_t i = fullname.length;
     while (i > 0)
@@ -238,7 +238,7 @@
 unittest
 {
     debug(path) printf("path.getName.unittest\n");
-    char[] result;
+    string result;
 
     result = getName("foo.bar");
     auto i = cmp(result, "foo");
@@ -278,7 +278,7 @@
  * -----
  */
 
-char[] getBaseName(char[] fullname)
+string getBaseName(string fullname)
     out (result)
     {
 	assert(result.length <= fullname.length);
@@ -286,7 +286,7 @@
     body
     {
 	auto i = fullname.length;
- 	for (; i > 0; i--)
+	for (; i > 0; i--)
 	{
 	    version(Win32)
 	    {
@@ -306,7 +306,7 @@
 {
     debug(path) printf("path.getBaseName.unittest\n");
     int i;
-    char[] result;
+    string result;
 
     version (Windows)
 	result = getBaseName("d:\\path\\foo.bat");
@@ -346,7 +346,7 @@
  * version(Win32)
  * {
  *     getDirName(r"d:\path\foo.bat") => "d:\path"
- *     getDirName(getDirName(r"d:\path\foo.bat")) => "d:\"
+ *     getDirName(getDirName(r"d:\path\foo.bat")) => r"d:\"
  * }
  * version(linux)
  * {
@@ -356,7 +356,7 @@
  * -----
  */
 
-char[] getDirName(char[] fullname)
+string getDirName(string fullname)
     out (result)
     {
 	assert(result.length <= fullname.length);
@@ -371,7 +371,7 @@
 	    {
 		if (fullname[i - 1] == ':')
 		    break;
-		if (fullname[i - 1] == '\\')
+		if (fullname[i - 1] == '\\' || fullname[i - 1] == '/')
 		{   i--;
 		    break;
 		}
@@ -387,6 +387,12 @@
 	return fullname[0 .. i];
     }
 
+unittest
+{
+    string filename = "foo/bar";
+    auto d = getDirName(filename);
+    assert(d == "foo");
+}
 
 /********************************
  * Extracts the drive letter of a path.
@@ -406,7 +412,7 @@
  * -----
  */
 
-char[] getDrive(char[] fullname)
+string getDrive(string fullname)
     out (result)
     {
 	assert(result.length <= fullname.length);
@@ -415,7 +421,6 @@
     {
 	version(Win32)
 	{
-
 	    for (size_t i = 0; i < fullname.length; i++)
 	    {
 		if (fullname[i] == ':')
@@ -450,9 +455,9 @@
  * -----
  */
 
-char[] defaultExt(char[] filename, char[] ext)
+string defaultExt(string filename, string ext)
 {
-    char[] existing;
+    string existing;
 
     existing = getExt(filename);
     if (existing.length == 0)
@@ -490,9 +495,9 @@
  * -----
  */
 
-char[] addExt(char[] filename, char[] ext)
+string addExt(string filename, string ext)
 {
-    char[] existing;
+    string existing;
 
     existing = getExt(filename);
     if (existing.length == 0)
@@ -536,9 +541,9 @@
  * -----
  */
 
-int isabs(char[] path)
+int isabs(string path)
 {
-    char[] d = getDrive(path);
+    string d = getDrive(path);
 
     version (Windows)
     {
@@ -591,15 +596,15 @@
  * -----
  */
 
-char[] join(char[] p1, char[] p2)
+string join(string p1, string p2)
 {
     if (!p2.length)
 	return p1;
     if (!p1.length)
 	return p2;
 
-    char[] p;
-    char[] d1;
+    string p;
+    string d1;
 
     version(Win32)
     {
@@ -655,7 +660,7 @@
 {
     debug(path) printf("path.join.unittest\n");
 
-    char[] p;
+    string p;
     int i;
 
     p = join("foo", "bar");
@@ -831,7 +836,7 @@
  * -----
  */
 
-int fnmatch(char[] filename, char[] pattern)
+int fnmatch(string filename, string pattern)
     in
     {
 	// Verify that pattern[] is valid
@@ -997,9 +1002,9 @@
  * -----
  * import std.path;
  *
- * void process_file(char[] filename)
+ * void process_file(string filename)
  * {
- *     char[] path = expandTilde(filename);
+ *     string path = expandTilde(filename);
  *     ...
  * }
  * -----
@@ -1007,10 +1012,10 @@
  * -----
  * import std.path;
  *
- * const char[] RESOURCE_DIR_TEMPLATE = "~/.applicationrc";
- * char[] RESOURCE_DIR;    // This gets expanded in main().
+ * const string RESOURCE_DIR_TEMPLATE = "~/.applicationrc";
+ * string RESOURCE_DIR;    // This gets expanded in main().
  *
- * int main(char[][] args)
+ * int main(string[] args)
  * {
  *     RESOURCE_DIR = expandTilde(RESOURCE_DIR_TEMPLATE);
  *     ...
@@ -1020,7 +1025,7 @@
  * Authors: Grzegorz Adam Hankiewicz, Thomas Khne.
  */
 
-char[] expandTilde(char[] inputPath)
+string expandTilde(string inputPath)
 {
     version(Unix)
     {
@@ -1094,7 +1099,7 @@
 /**
  * Replaces the tilde from path with the environment variable HOME.
  */
-private char[] expandFromEnvironment(char[] path)
+private string expandFromEnvironment(string path)
 {
     assert(path.length >= 1);
     assert(path[0] == '~');
@@ -1115,7 +1120,7 @@
  * is joined to path[char_pos .. length] if char_pos is smaller
  * than length, otherwise path is not appended to c_path.
  */
-private char[] combineCPathWithDPath(char* c_path, char[] path, int char_pos)
+private string combineCPathWithDPath(char* c_path, string path, int char_pos)
 {
     assert(c_path != null);
     assert(path.length > 0);
@@ -1129,7 +1134,7 @@
 	end--;
 
     // Create our own copy, as lifetime of c_path is undocumented
-    char[] cp = c_path[0 .. end].dup;
+    string cp = c_path[0 .. end].dup;
 
     // Do we append something from path?
     if (char_pos < path.length)
diff -r 6a92bcae44c5 d/phobos/std/perf.d
--- a/d/phobos/std/perf.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/perf.d	Sat Jun 26 21:05:08 2010 +0100
@@ -97,20 +97,20 @@
 	private import std.c.unix.unix;
     }
     else version (Posix) {
-	extern (C)
+    extern (C)
+    {
+	private struct timeval
 	{
-	    private struct timeval
-	    {
-		int tv_sec;    /*!< The number of seconds, since Jan. 1, 1970, in the time value. */
-		int tv_usec;   /*!< The number of microseconds in the time value. */
-	    };
-	    private struct timezone
-	    {
-		int tz_minuteswest; /*!< minutes west of Greenwich. */
-		int tz_dsttime;     /*!< type of dst corrections to apply. */
-	    };
-	    private void gettimeofday(timeval *tv, timezone *tz);
-	}
+	    int tv_sec;    /*!< The number of seconds, since Jan. 1, 1970, in the time value. */
+	    int tv_usec;   /*!< The number of microseconds in the time value. */
+	};
+	private struct timezone
+	{
+	    int tz_minuteswest; /*!< minutes west of Greenwich. */
+	    int tz_dsttime;     /*!< type of dst corrections to apply. */
+	};
+	private void gettimeofday(timeval *tv, timezone *tz);
+    }
     }
 
     /* ////////////////////////////////////////////////////////////////////////// */
diff -r 6a92bcae44c5 d/phobos/std/process.d
--- a/d/phobos/std/process.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/process.d	Sat Jun 26 21:05:08 2010 +0100
@@ -1,6 +1,7 @@
 // Written in the D programming language
+
 /*
- *  Copyright (C) 2003-2009 by Digital Mars, www.digitalmars.com
+ *  Copyright (C) 2003-2009 by Digital Mars, http://www.digitalmars.com
  *  Written by Matthew Wilson and Walter Bright
  *
  *  Incorporating idea (for execvpe() on Linux) from Russ Lewis
@@ -35,7 +36,6 @@
  *	WIKI=Phobos/StdProcess
  */
 
-
 module std.process;
 
 private import std.c.stdlib;
@@ -160,7 +160,7 @@
 bool exited(int status)     { return cast(bool)((status & 0x7f) == 0); }
 int  exitstatus(int status) { return (status & 0xff00) >> 8; }
 }   // private
-}   // version(Posix)
+}   // version (Posix)
 
 /* ========================================================== */
 
@@ -205,7 +205,7 @@
 /** ditto */
 int execvpe(string pathname, string[] argv, string[] envp)
 {
-version(Posix)
+version (GNU_Need_execvpe)
 {
     // Is pathname rooted?
     if(pathname[0] == '/')
@@ -216,7 +216,7 @@
     else
     {
         // No, so must traverse PATHs, looking for first match
-        string[]    envPaths    =   std.string.split(std.string.toString(std.c.stdlib.getenv("PATH")), ":");
+	string[]    envPaths    =   std.string.split(std.string.toString(std.c.stdlib.getenv("PATH")), ":");
         int         iRet        =   0;
 
         // Note: if any call to execve() succeeds, this process will cease 
@@ -225,7 +225,7 @@
 
         foreach(string pathDir; envPaths)
         {
-            string  composite   =   pathDir ~ "/" ~ pathname;
+            string  composite   =  pathDir ~ "/" ~ pathname;
 
             iRet = execve(composite, argv, envp);
         }
@@ -237,7 +237,7 @@
         return iRet;
     }
 }
-else version(Windows)
+else // GNU system either has execvpe() or it doesn't.
 {
     auto argv_ = cast(char**)alloca((char*).sizeof * (1 + argv.length));
     auto envp_ = cast(char**)alloca((char*).sizeof * (1 + envp.length));
@@ -246,10 +246,6 @@
     toAStringz(envp, envp_);
 
     return std.c.process.execvpe(toStringz(pathname), argv_, envp_);
-}
-else
-{
-  static assert(0);
 } // version
 }
 
diff -r 6a92bcae44c5 d/phobos/std/random.d
--- a/d/phobos/std/random.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/random.d	Sat Jun 26 21:05:08 2010 +0100
@@ -1,3 +1,5 @@
+// Written in the D programming language
+
 /**
  * Macros:
  *	WIKI = Phobos/StdRandom
diff -r 6a92bcae44c5 d/phobos/std/regexp.d
--- a/d/phobos/std/regexp.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/regexp.d	Sat Jun 26 21:05:08 2010 +0100
@@ -270,10 +270,7 @@
 	    pattern == slice)				// simple pattern (exact match, no special characters) 
 	{
 	    debug(regexp)
-		printf("pattern: %.*s, slice: %.*s, replacement: %.*s\n",
-		    cast(int) pattern.length, pattern.ptr,
-		    cast(int) (eo-so), result.ptr + offset,
-		    cast(int) replacement.length, replacement.ptr);
+		printf("pattern: %.*s, slice: %.*s, replacement: %.*s\n",pattern,result[offset + so .. offset + eo],replacement);
 	    result = std.string.replace(result,slice,replacement);
 	    break;
 	}
@@ -1061,11 +1058,7 @@
 	   format == replacement)		// simple format, not $ formats
 	{
 	    debug(regexp)
-		printf("pattern: %.*s, slice: %.*s, format: %.*s, replacement: %.*s\n",
-		    cast(int) pattern.length, pattern.ptr,
-		    cast(int) (eo-so), result.ptr + offset,
-		    cast(int) format.length, format.ptr,
-		    cast(int) replacement.length, replacement.ptr);
+		printf("pattern: %.*s, slice: %.*s, format: %.*s, replacement: %.*s\n",pattern,result[offset + so .. offset + eo],format,replacement);
 	    result = std.string.replace(result,slice,replacement);
 	    break;
 	}
@@ -1116,8 +1109,7 @@
 
 public rchar[][] exec(rchar[] string)
 {
-    debug(regexp) printf("regexp.exec(string = '%.*s')\n",
-	cast(int) string.length, string.ptr);
+    debug(regexp) printf("regexp.exec(string = '%.*s')\n", string);
     input = string;
     pmatch[0].rm_so = 0;
     pmatch[0].rm_eo = 0;
@@ -1203,8 +1195,7 @@
     uint si;
 
     input = string;
-    debug (regexp) printf("RegExp.test(input[] = '%.*s', startindex = %d)\n",
-	cast(int) input.length, input.ptr, startindex);
+    debug (regexp) printf("RegExp.test(input[] = '%.*s', startindex = %d)\n", input, startindex);
     pmatch[0].rm_so = 0;
     pmatch[0].rm_eo = 0;
     if (startindex < 0 || startindex > input.length)
@@ -1288,7 +1279,6 @@
     uint m;
     ushort *pu;
     uint *puint;
-    ubyte[] s;
 
     printf("printProgram()\n");
     for (pc = 0; pc < prog.length; )
@@ -1325,17 +1315,15 @@
 
 	    case REstring:
 		len = *cast(uint *)&prog[pc + 1];
-		s = (&prog[pc + 1 + uint.sizeof])[0 .. len];
 		printf("\tREstring x%x, '%.*s'\n", len,
-		    cast(int) s.length, s.ptr);
+			(&prog[pc + 1 + uint.sizeof])[0 .. len]);
 		pc += 1 + uint.sizeof + len * rchar.sizeof;
 		break;
 
 	    case REistring:
 		len = *cast(uint *)&prog[pc + 1];
-		s = (&prog[pc + 1 + uint.sizeof])[0 .. len];
 		printf("\tREistring x%x, '%.*s'\n", len,
-		    cast(int) s.length, s.ptr);
+			(&prog[pc + 1 + uint.sizeof])[0 .. len]);
 		pc += 1 + uint.sizeof + len * rchar.sizeof;
 		break;
 
@@ -1411,8 +1399,8 @@
 		len = puint[0];
 		n = puint[1];
 		m = puint[2];
-		printf("\tREnm%s len=%d, n=%u, m=%u, pc=>%d\n",
-		    (prog[pc] == REnmq) ? cast(char*)"q" : cast(char*)" ",
+		printf("\tREnm%.*s len=%d, n=%u, m=%u, pc=>%d\n",
+		    (prog[pc] == REnmq) ? "q" : " ",
 		    len, n, m, pc + 1 + uint.sizeof * 3 + len);
 		pc += 1 + uint.sizeof * 3;
 		break;
@@ -1505,11 +1493,8 @@
     uint* puint;
 
     debug(regexp)
-    {
-	char[] s = input[src .. input.length];
 	printf("RegExp.trymatch(pc = %d, src = '%.*s', pcend = %d)\n",
-	    pc, cast(int) s.length, s.ptr, pcend);
-    }
+	    pc, input[src .. input.length], pcend);
     srcsave = src;
     psave = null;
     for (;;)
@@ -1593,12 +1578,8 @@
 
 	    case REstring:
 		len = *cast(uint *)&program[pc + 1];
-		debug(regexp)
-		{
-		    char[] s = (&program[pc + 1 + uint.sizeof])[0 .. len];
-		    printf("\tREstring x%x, '%.*s'\n", len,
-			cast(int) s.length, s.ptr);
-		}
+		debug(regexp) printf("\tREstring x%x, '%.*s'\n", len,
+			(&program[pc + 1 + uint.sizeof])[0 .. len]);
 		if (src + len > input.length)
 		    goto Lnomatch;
 		if (memcmp(&program[pc + 1 + uint.sizeof], &input[src], len * rchar.sizeof))
@@ -1609,12 +1590,8 @@
 
 	    case REistring:
 		len = *cast(uint *)&program[pc + 1];
-		debug(regexp)
-		{
-		    char[] s = (&program[pc + 1 + uint.sizeof])[0 .. len];
-		    printf("\tREistring x%x, '%.*s'\n", len,
-			cast(int) s.length, s.ptr);
-		}
+		debug(regexp) printf("\tREistring x%x, '%.*s'\n", len,
+			(&program[pc + 1 + uint.sizeof])[0 .. len]);
 		if (src + len > input.length)
 		    goto Lnomatch;
 		version (Win32)
@@ -2417,7 +2394,7 @@
 		maxb = b;
 		// %% moved array recreate out of this condition
 		bits.ptr = cast(uint*)this.base;
- 	    }
+	    }
 	    //bits = (cast(bit*)this.base)[0 .. maxc + 1];
 	    bits.len = maxc + 1;
 	}
@@ -2628,7 +2605,7 @@
 void error(char[] msg)
 {
     errors++;
-    debug(regexp) printf("error: %.*s\n", cast(int) msg.length, msg.ptr);
+    debug(regexp) printf("error: %.*s\n", msg);
 //assert(0);
 //*(char*)0=0;
     throw new RegExpException(msg);
diff -r 6a92bcae44c5 d/phobos/std/socket.d
--- a/d/phobos/std/socket.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/socket.d	Sat Jun 26 21:05:08 2010 +0100
@@ -2,15 +2,15 @@
 
 /*
 	Copyright (C) 2004-2005 Christopher E. Miller
-	
+
 	This software is provided 'as-is', without any express or implied
 	warranty.  In no event will the authors be held liable for any damages
 	arising from the use of this software.
-	
+
 	Permission is granted to anyone to use this software for any purpose,
 	including commercial applications, and to alter it and redistribute it
 	freely, subject to the following restrictions:
-	
+
 	1. The origin of this software must not be misrepresented; you must not
 	   claim that you wrote the original software. If you use this software
 	   in a product, an acknowledgment in the product documentation would be
@@ -19,10 +19,10 @@
 	   be misrepresented as being the original software.
 	3. This notice may not be removed or altered from any source
 	   distribution.
-	
+
 	socket.d 1.3
 	Jan 2005
-	
+
 	Thanks to Benjamin Herr for his assistance.
 */
 
@@ -33,9 +33,9 @@
 */
 
 /**
- * Notes: For Win32 systems, link with ws2_32.lib. 
+ * Notes: For Win32 systems, link with ws2_32.lib.
  * Example: See /dmd/samples/d/listener.d.
- * Authors: Christopher E. Miller 
+ * Authors: Christopher E. Miller
  * Macros:
  *	WIKI=Phobos/StdSocket
  */
@@ -65,14 +65,14 @@
 version(Win32)
 {
 	pragma (lib, "wsock32.lib");
-	
+
 	private import std.c.windows.windows, std.c.windows.winsock;
 	private alias std.c.windows.winsock.timeval _ctimeval;
-	
+
 	typedef SOCKET socket_t = INVALID_SOCKET;
 	private const int _SOCKET_ERROR = SOCKET_ERROR;
-	
-	
+
+
 	private int _lasterr()
 	{
 		return WSAGetLastError();
@@ -83,17 +83,17 @@
 	version (Unix)
 	{
 		version (FreeBSD)
-		{
+	{
 			// private import std.c.freebsd.socket;
 		}
 		private import std.c.unix.unix;
 		private alias std.c.unix.unix.timeval _ctimeval;
 	}
-	
+
 	typedef int32_t socket_t = -1;
 	private const int _SOCKET_ERROR = -1;
-	
-	
+
+
 	private int _lasterr()
 	{
 		return getErrno();
@@ -109,67 +109,67 @@
 class SocketException: Exception
 {
 	int errorCode; /// Platform-specific error code.
-	
+
 	this(string msg, int err = 0)
 	{
-		errorCode = err;
-		
+	    errorCode = err;
+
 		version(Unix)
+	    {
+		if(errorCode > 0)
 		{
-			if(errorCode > 0)
-			{
-				char[80] buf;
+		    char[80] buf;
 				auto cs = _d_gnu_cbridge_strerror(errorCode, buf.ptr, buf.length);
 				//char* cs;
 	 		    /+version (linux)
-	 		    {
+		    {
 	 			 cs = _d_gnu_cbridge_strerror(errorCode, buf.ptr, buf.length);
-			    }
-	 		    else version (OSX)
-	 		    {
+		    }
+		    else version (OSX)
+		    {
 	 			 auto errs = _d_gnu_cbridge_strerror(errorCode, buf.ptr, buf.length);
-	 			 if (errs == 0)
-	 			    cs = buf.ptr;
-	 			 else
-	 			 {
-				    cs = "Unknown error";
-	 			 }
-	 		    }
-	 		    else version (FreeBSD)
-	 		    {
-	 			auto errs = strerror_r(errorCode, buf.ptr, buf.length);
-	 			if (errs == 0)
-	 			    cs = buf.ptr;
-	 			else
-	 			{
-	 			    cs = "Unknown error";
-	 			}
-	 		    }
-	 		    else version (Solaris)
-             {
-                 auto errs = strerror_r(errorCode, buf.ptr, buf.length);
-                 if (errs == 0)
-                     cs = buf.ptr;
-                 else
-                 {
-                     cs = "Unknown error";
-                 }
-             }
-	 		    else
-	 		    {
-	 			static assert(0);
+			if (errs == 0)
+			    cs = buf.ptr;
+			else
+			{
+			    cs = "Unknown error";
+			}
+		    }
+		    else version (FreeBSD)
+		    {
+			auto errs = strerror_r(errorCode, buf.ptr, buf.length);
+			if (errs == 0)
+			    cs = buf.ptr;
+			else
+			{
+			    cs = "Unknown error";
+			}
+		    }
+                    else version (Solaris)
+                    {
+                        auto errs = strerror_r(errorCode, buf.ptr, buf.length);
+                        if (errs == 0)
+                            cs = buf.ptr;
+                        else
+                        {
+                            cs = "Unknown error";
+                        }
+                    }
+		    else
+		    {
+			static assert(0);
 	 		    }+/
-				auto len = strlen(cs);
-				
-				if(cs[len - 1] == '\n')
-					len--;
-				if(cs[len - 1] == '\r')
-					len--;
-				msg = msg ~ ": " ~ cs[0 .. len];
-			}
+		    auto len = strlen(cs);
+
+		    if(cs[len - 1] == '\n')
+			    len--;
+		    if(cs[len - 1] == '\r')
+			    len--;
+		    msg = msg ~ ": " ~ cs[0 .. len];
 		}
-		
-		super(msg);
+	    }
+
+	    super(msg);
 	}
 }
 
@@ -179,7 +179,7 @@
 	version(Win32)
 	{
 		WSADATA wd;
-		
+
 		// Winsock will still load if an older version is present.
 		// The version is just a request.
 		int val;
@@ -250,27 +250,27 @@
 	ProtocolType type;	/// These members are populated when one of the following functions are called without failure:
 	string name;		/// ditto
 	string[] aliases;	/// ditto
-	
-	
+
+
 	void populate(protoent* proto)
 	{
 		type = cast(ProtocolType)proto.p_proto;
 		name = std.string.toString(proto.p_name).dup;
-		
+
 		int i;
 		for(i = 0;; i++)
 		{
 			if(!proto.p_aliases[i])
 				break;
 		}
-		
+
 		if(i)
 		{
 			aliases = new string[i];
 			for(i = 0; i != aliases.length; i++)
 			{
-				aliases[i] =
- 				std.string.toString(proto.p_aliases[i]).dup;
+			    aliases[i] =
+				std.string.toString(proto.p_aliases[i]).dup;
 			}
 		}
 		else
@@ -278,7 +278,7 @@
 			aliases = null;
 		}
 	}
-	
+
 	/** Returns false on failure */
 	bool getProtocolByName(string name)
 	{
@@ -289,8 +289,8 @@
 		populate(proto);
 		return true;
 	}
-	
-	
+
+
 	/** Returns false on failure */
 	// Same as getprotobynumber().
 	bool getProtocolByType(ProtocolType type)
@@ -303,7 +303,7 @@
 			return false;
 		populate(proto);
 		return true;
-	    }
+	}
 	    else
 		return false;
 	}
@@ -314,11 +314,10 @@
 {
 	Protocol proto = new Protocol;
 	assert(proto.getProtocolByType(ProtocolType.TCP));
-	printf("About protocol TCP:\n\tName: %.*s\n",
-	    cast(int) proto.name.length, proto.name.ptr);
+	printf("About protocol TCP:\n\tName: %.*s\n", proto.name);
 	foreach(string s; proto.aliases)
 	{
-	        printf("\tAlias: %.*s\n", cast(int) s.length, s.ptr);
+		printf("\tAlias: %.*s\n", s);
 	}
 }
 
@@ -333,28 +332,28 @@
 	string[] aliases;	/// ditto
 	ushort port;		/// ditto
 	string protocolName;	/// ditto
-	
-	
+
+
 	void populate(servent* serv)
 	{
 		name = std.string.toString(serv.s_name).dup;
 		port = ntohs(cast(ushort)serv.s_port);
 		protocolName = std.string.toString(serv.s_proto).dup;
-		
+
 		int i;
 		for(i = 0;; i++)
 		{
 			if(!serv.s_aliases[i])
 				break;
 		}
-		
+
 		if(i)
 		{
 			aliases = new string[i];
 			for(i = 0; i != aliases.length; i++)
 			{
-				aliases[i] =
-                                 std.string.toString(serv.s_aliases[i]).dup;
+                            aliases[i] =
+                                std.string.toString(serv.s_aliases[i]).dup;
 			}
 		}
 		else
@@ -362,7 +361,7 @@
 			aliases = null;
 		}
 	}
-	
+
 	/**
 	 * If a protocol name is omitted, any protocol will be matched.
 	 * Returns: false on failure.
@@ -376,8 +375,8 @@
 		populate(serv);
 		return true;
 	}
-	
-	
+
+
 	// Any protocol name will be matched.
 	/// ditto
 	bool getServiceByName(string name)
@@ -389,8 +388,8 @@
 		populate(serv);
 		return true;
 	}
-	
-	
+
+
 	/// ditto
 	bool getServiceByPort(ushort port, string protocolName)
 	{
@@ -402,12 +401,12 @@
 			return false;
 		populate(serv);
 		return true;
-	    }
+	}
 	    else
 		return false;
 	}
-	
-	
+
+
 	// Any protocol name will be matched.
 	/// ditto
 	bool getServiceByPort(ushort port)
@@ -420,7 +419,7 @@
 			return false;
 		populate(serv);
 		return true;
-	    }
+	}
 	    else
 		return false;
 	}
@@ -433,11 +432,10 @@
 	if(serv.getServiceByName("epmap", "tcp"))
 	{
 		printf("About service epmap:\n\tService: %.*s\n\tPort: %d\n\tProtocol: %.*s\n",
-		        cast(int) serv.name.length, serv.name.ptr, serv.port,
-		        cast(int) serv.protocolName.length, serv.protocolName.ptr);
-		foreach(char[] s; serv.aliases)
+			serv.name, serv.port, serv.protocolName);
+		foreach(string s; serv.aliases)
 		{
-		        printf("\tAlias: %.*s\n", cast(int) s.length, s.ptr);
+			printf("\tAlias: %.*s\n", s);
 		}
 	}
 	else
@@ -453,8 +451,8 @@
 class HostException: Exception
 {
 	int errorCode;	/// Platform-specific error code.
-	
-	
+
+
 	this(string msg, int err = 0)
 	{
 		errorCode = err;
@@ -471,49 +469,50 @@
 	string name;
 	string[] aliases;	/// ditto
 	uint32_t[] addrList;	/// ditto
-	
-	
+
+
 	void validHostent(hostent* he)
 	{
 		if(he.h_addrtype != cast(int)AddressFamily.INET || he.h_length != 4)
 			throw new HostException("Address family mismatch", _lasterr());
 	}
-	
-	
+
+
 	void populate(hostent* he)
 	{
 		int i;
 		char* p;
-		
+
 		name = std.string.toString(he.h_name).dup;
-		
+
 		for(i = 0;; i++)
 		{
 			p = he.h_aliases[i];
 			if(!p)
 				break;
 		}
-		
+
 		if(i)
 		{
 			aliases = new string[i];
 			for(i = 0; i != aliases.length; i++)
 			{
-				aliases[i] = std.string.toString(he.h_aliases[i]).dup;
+                            aliases[i] =
+                                std.string.toString(he.h_aliases[i]).dup;
 			}
 		}
 		else
 		{
 			aliases = null;
 		}
-		
+
 		for(i = 0;; i++)
 		{
 			p = he.h_addr_list[i];
 			if(!p)
 				break;
 		}
-		
+
 		if(i)
 		{
 			addrList = new uint32_t[i];
@@ -527,10 +526,10 @@
 			addrList = null;
 		}
 	}
-	
+
 	/**
 	 * Resolve host name. Returns false if unable to resolve.
-	 */	
+	 */
 	bool getHostByName(string name)
 	{
 		hostent* he;
@@ -541,11 +540,11 @@
 		populate(he);
 		return true;
 	}
-	
-	
+
+
 	/**
 	 * Resolve IPv4 address number. Returns false if unable to resolve.
-	 */	
+	 */
 	bool getHostByAddr(uint addr)
 	{
 		uint x = htonl(addr);
@@ -557,13 +556,13 @@
 		populate(he);
 		return true;
 	}
-	
-	
+
+
 	/**
 	 * Same as previous, but addr is an IPv4 address string in the
 	 * dotted-decimal form $(I a.b.c.d).
 	 * Returns false if unable to resolve.
-	 */	
+	 */
 	bool getHostByAddr(string addr)
 	{
 		uint x = inet_addr(std.string.toStringz(addr));
@@ -585,21 +584,19 @@
 	printf("addrList.length = %d\n", ih.addrList.length);
 	assert(ih.addrList.length);
 	InternetAddress ia = new InternetAddress(ih.addrList[0], InternetAddress.PORT_ANY);
-	char[] sia = ia.toAddrString();
-	printf("IPaddress = %.*s\nname = %.*s\n", cast(int) sia.length, sia.ptr,
-	    cast(int) ih.name.length, ih.name.ptr);
+	printf("IP address = %.*s\nname = %.*s\n", ia.toAddrString(), ih.name);
 	foreach(int i, string s; ih.aliases)
 	{
-	        printf("aliases[%d] = %.*s\n", i, cast(int) s.length, s.ptr);
+		printf("aliases[%d] = %.*s\n", i, s);
 	}
-	
+
 	printf("---\n");
-	
+
 	assert(ih.getHostByAddr(ih.addrList[0]));
-	printf("name = %.*s\n", cast(int) ih.name.length, ih.name.ptr);
+	printf("name = %.*s\n", ih.name);
 	foreach(int i, string s; ih.aliases)
 	{
-	        printf("aliases[%d] = %.*s\n", i, cast(int) s.length, s.ptr);
+		printf("aliases[%d] = %.*s\n", i, s);
 	}
 }
 
@@ -634,27 +631,27 @@
 {
 	protected:
 	sockaddr sa;
-	
-	
+
+
 	sockaddr* name()
 	{
 		return &sa;
 	}
-	
-	
+
+
 	int nameLen()
 	{
 		return sa.sizeof;
 	}
-	
-	
+
+
 	public:
 	AddressFamily addressFamily()
 	{
 		return cast(AddressFamily)sa.sa_family;
 	}
-	
-	
+
+
 	string toString()
 	{
 		return "Unknown";
@@ -676,42 +673,42 @@
 	{
 		return cast(sockaddr*)&sin;
 	}
-	
-	
+
+
 	int nameLen()
 	{
 		return sin.sizeof;
 	}
-	
-	
+
+
 	this()
 	{
 	}
-	
-	
+
+
 	public:
 	const uint ADDR_ANY = INADDR_ANY;	/// Any IPv4 address number.
 	const uint ADDR_NONE = INADDR_NONE;	/// An invalid IPv4 address number.
 	const ushort PORT_ANY = 0;		/// Any IPv4 port number.
-	
+
 	/// Overridden to return AddressFamily.INET.
 	AddressFamily addressFamily()
 	{
 		return cast(AddressFamily)AddressFamily.INET;
 	}
-	
+
 	/// Returns the IPv4 port number.
 	ushort port()
 	{
 		return ntohs(sin.sin_port);
 	}
-	
+
 	/// Returns the IPv4 address number.
 	uint addr()
 	{
 		return ntohl(sin.sin_addr.s_addr);
 	}
-	
+
 	/**
 	 * Params:
 	 *   addr = an IPv4 address string in the dotted-decimal form a.b.c.d,
@@ -727,13 +724,14 @@
 			InternetHost ih = new InternetHost;
 			if(!ih.getHostByName(addr))
 				//throw new AddressException("Invalid internet address");
-				throw new AddressException("Unable to resolve host '" ~ addr ~ "'");
+                            throw new AddressException(
+                                 "Unable to resolve host '" ~ addr ~ "'");
 			uiaddr = ih.addrList[0];
 		}
 		sin.sin_addr.s_addr = htonl(uiaddr);
 		sin.sin_port = htons(port);
 	}
-	
+
 	/**
 	 * Construct a new Address. addr may be ADDR_ANY (default) and port may
 	 * be PORT_ANY, and the actual numbers may not be known until a connection
@@ -744,32 +742,32 @@
 		sin.sin_addr.s_addr = htonl(addr);
 		sin.sin_port = htons(port);
 	}
-	
-	/// ditto	
+
+	/// ditto
 	this(ushort port)
 	{
 		sin.sin_addr.s_addr = 0; //any, "0.0.0.0"
 		sin.sin_port = htons(port);
 	}
-	
-	/// Human readable string representing the IPv4 address in dotted-decimal form.	
+
+	/// Human readable string representing the IPv4 address in dotted-decimal form.
 	string toAddrString()
 	{
 		return std.string.toString(inet_ntoa(sin.sin_addr)).dup;
 	}
-	
+
 	/// Human readable string representing the IPv4 port.
 	string toPortString()
 	{
 		return std.string.toString(port());
 	}
-	
+
 	/// Human readable string representing the IPv4 address and port in the form $(I a.b.c.d:e).
 	string toString()
 	{
-		return toAddrString() ~ ":" ~ toPortString();
+            return toAddrString() ~ ":" ~ toPortString();
 	}
-	
+
 	/**
 	 * Parse an IPv4 address string in the dotted-decimal form $(I a.b.c.d)
 	 * and return the number.
@@ -811,8 +809,8 @@
 /// Flags may be OR'ed together:
 enum SocketFlags: int
 {
-	NONE =       0,             /// no flags specified 
-	
+	NONE =       0,             /// no flags specified
+
 	OOB =        MSG_OOB,       /// out-of-band stream data
 	PEEK =       MSG_PEEK,      /// peek at incoming data without removing it from the queue, only for receiving
 	DONTROUTE =  MSG_DONTROUTE, /// data should not be subject to routing; this flag may be ignored. Only for sending
@@ -826,7 +824,7 @@
 	// D interface
 	int seconds;		/// Number of seconds.
 	int microseconds;	/// Number of additional microseconds.
-	
+
 	// C interface
 	deprecated
 	{
@@ -842,8 +840,8 @@
 	private:
 	uint maxsockets; /// max desired sockets, the fd_set might be capable of holding more
 	fd_set set;
-	
-	
+
+
 	version(Win32)
 	{
 		uint count()
@@ -856,8 +854,8 @@
 		int maxfd;
 		uint count;
 	}
-	
-	
+
+
 	public:
 
 	/// Set the maximum amount of sockets that may be added.
@@ -866,26 +864,26 @@
 		maxsockets = max;
 		reset();
 	}
-	
+
 	/// Uses the default maximum for the system.
 	this()
 	{
 		this(FD_SETSIZE);
 	}
-	
-	/// Reset the SocketSet so that there are 0 Sockets in the collection.	
+
+	/// Reset the SocketSet so that there are 0 Sockets in the collection.
 	void reset()
 	{
 		FD_ZERO(&set);
-		
+
 		version(BsdSockets)
- 		{
- 			maxfd = -1;
+		{
+			maxfd = -1;
 			count = 0;
- 		}
+		}
 	}
-	
-	
+
+
 	void add(socket_t s)
 	in
 	{
@@ -900,14 +898,14 @@
 			}
 			else
 			{
-				assert(FDELT(s) < (FD_SETSIZE / NFDBITS));
-			}
+			assert(FDELT(s) < (FD_SETSIZE / NFDBITS));
 		}
 	}
+	}
 	body
 	{
 		FD_SET(s, &set);
-		
+
 		version(BsdSockets)
 		{
 			++count;
@@ -915,13 +913,13 @@
 				maxfd = s;
 		}
 	}
-	
+
 	/// Add a Socket to the collection. Adding more than the maximum has dangerous side affects.
 	void add(Socket s)
 	{
 		add(s.sock);
 	}
-	
+
 	void remove(socket_t s)
 	{
 		FD_CLR(s, &set);
@@ -931,40 +929,40 @@
 			// note: adjusting maxfd would require scanning the set, not worth it
 		}
 	}
-	
-	
+
+
 	/// Remove this Socket from the collection.
 	void remove(Socket s)
 	{
 		remove(s.sock);
 	}
-	
+
 	int isSet(socket_t s)
 	{
 		return FD_ISSET(s, &set);
 	}
-	
-	
+
+
 	/// Returns nonzero if this Socket is in the collection.
 	int isSet(Socket s)
 	{
 		return isSet(s.sock);
 	}
-	
+
 
 	/// Return maximum amount of sockets that can be added, like FD_SETSIZE.
 	uint max()
 	{
 		return maxsockets;
 	}
-	
-	
+
+
 	fd_set* toFd_set()
 	{
 		return &set;
 	}
-	
-	
+
+
 	int selectn()
 	{
 		version(Win32)
@@ -1021,11 +1019,11 @@
 		}
 		else
 		{
-		    int32_t on;
-		    int32_t time;
-		}
+		int32_t on;
+		int32_t time;
 	}
-	
+	}
+
 	// C interface
 	deprecated
 	{
@@ -1046,10 +1044,10 @@
 	SNDBUF =               SO_SNDBUF,	/// send buffer size
 	RCVBUF =               SO_RCVBUF,	/// receive buffer size
 	DONTROUTE =            SO_DONTROUTE,	/// do not route
-	
+
 	// SocketOptionLevel.TCP:
 	TCP_NODELAY =          .TCP_NODELAY,	/// disable the Nagle algorithm for send coalescing
-	
+
 	// SocketOptionLevel.IPV6:
 	IPV6_UNICAST_HOPS =    .IPV6_UNICAST_HOPS,	///
 	IPV6_MULTICAST_IF =    .IPV6_MULTICAST_IF,	///
@@ -1068,17 +1066,17 @@
 	private:
 	socket_t sock;
 	AddressFamily _family;
-	
+
 	version(Win32)
 	    bool _blocking = false;	/// Property to get or set whether the socket is blocking or nonblocking.
-	
-	
+
+
 	// For use with accepting().
 	protected this()
 	{
 	}
-	
-	
+
+
 	public:
 
 	/**
@@ -1093,8 +1091,8 @@
 			throw new SocketException("Unable to create socket", _lasterr());
 		_family = af;
 	}
-	
-	
+
+
 	// A single protocol exists to support this socket type within the
 	// protocol family, so the ProtocolType is assumed.
 	/// ditto
@@ -1102,8 +1100,8 @@
 	{
 		this(af, type, cast(ProtocolType)0); // Pseudo protocol number.
 	}
-	
-	
+
+
 	/// ditto
 	this(AddressFamily af, SocketType type, string protocolName)
 	{
@@ -1113,14 +1111,14 @@
 			throw new SocketException("Unable to find the protocol", _lasterr());
 		this(af, type, cast(ProtocolType)proto.p_proto);
 	}
-	
-	
+
+
 	~this()
 	{
 		close();
 	}
-	
-	
+
+
 	/// Get underlying socket handle.
 	socket_t handle()
 	{
@@ -1132,7 +1130,7 @@
 	 *
 	 * When a socket is blocking, calls to receive(), accept(), and send()
 	 * will block and wait for data/action.
-	 * A non-blocking socket will immediately return instead of blocking. 
+	 * A non-blocking socket will immediately return instead of blocking.
 	 */
 	bool blocking()
 	{
@@ -1145,7 +1143,7 @@
 			return !(fcntl(handle, F_GETFL, 0) & O_NONBLOCK);
 		}
 	}
-	
+
 	/// ditto
 	void blocking(bool byes)
 	{
@@ -1169,32 +1167,32 @@
 				goto err;
 		}
 		return; // Success.
-		
+
 		err:
 		throw new SocketException("Unable to set socket blocking", _lasterr());
 	}
-	
 
-	/// Get the socket's address family.	
+
+	/// Get the socket's address family.
 	AddressFamily addressFamily() // getter
 	{
 		return _family;
 	}
-	
+
 	/// Property that indicates if this is a valid, alive socket.
 	bool isAlive() // getter
 	{
 		int type, typesize = type.sizeof;
 		return !getsockopt(sock, SOL_SOCKET, SO_TYPE, cast(char*)&type, &typesize);
 	}
-	
+
 	/// Associate a local address with this socket.
 	void bind(Address addr)
 	{
 		if(_SOCKET_ERROR == .bind(sock, addr.name(), addr.nameLen()))
 			throw new SocketException("Unable to bind socket", _lasterr());
 	}
-	
+
 	/**
 	 * Establish a connection. If the socket is blocking, connect waits for
 	 * the connection to be made. If the socket is nonblocking, connect
@@ -1206,7 +1204,7 @@
 		{
 			int err;
 			err = _lasterr();
-			
+
 			if(!blocking)
 			{
 				version(Win32)
@@ -1227,7 +1225,7 @@
 			throw new SocketException("Unable to connect socket", err);
 		}
 	}
-	
+
 	/**
 	 * Listen for an incoming connection. bind must be called before you can
 	 * listen. The backlog is a request of how many pending incoming
@@ -1238,7 +1236,7 @@
 		if(_SOCKET_ERROR == .listen(sock, backlog))
 			throw new SocketException("Unable to listen on socket", _lasterr());
 	}
-	
+
 	/**
 	 * Called by accept when a new Socket must be created for a new
 	 * connection. To use a derived class, override this method and return an
@@ -1251,7 +1249,7 @@
 	{
 		return new Socket;
 	}
-	
+
 	/**
 	 * Accept an incoming connection. If the socket is blocking, accept
 	 * waits for a connection request. Throws SocketAcceptException if unable
@@ -1265,13 +1263,13 @@
 		newsock = cast(socket_t)topaccept(sock, null, null);
 		if(socket_t.init == newsock)
 			throw new SocketAcceptException("Unable to accept socket connection", _lasterr());
-		
+
 		Socket newSocket;
 		try
 		{
 			newSocket = accepting();
 			assert(newSocket.sock == socket_t.init);
-			
+
 			newSocket.sock = newsock;
 			version(Win32)
 				newSocket._blocking = _blocking; //inherits blocking mode
@@ -1282,17 +1280,17 @@
 			_close(newsock);
 			throw o;
 		}
-		
+
 		return newSocket;
 	}
-	
+
 	/// Disables sends and/or receives.
 	void shutdown(SocketShutdown how)
 	{
 		.shutdown(sock, cast(int)how);
 	}
-	
-	
+
+
 	private static void _close(socket_t sock)
 	{
 		version(Win32)
@@ -1304,7 +1302,7 @@
 			.close(sock);
 		}
 	}
-	
+
 
 	/**
 	 * Immediately drop any connections and release socket resources.
@@ -1318,8 +1316,8 @@
 		_close(sock);
 		sock = socket_t.init;
 	}
-	
-	
+
+
 	private Address newFamilyObject()
 	{
 		Address result;
@@ -1328,14 +1326,14 @@
 			case cast(AddressFamily)AddressFamily.INET:
 				result = new InternetAddress;
 				break;
-			
+
 			default:
 				result = new UnknownAddress;
 		}
 		return result;
 	}
-	
-	
+
+
 	/// Returns the local machine's host name. Idea from mango.
 	static string hostName() // getter
 	{
@@ -1344,7 +1342,7 @@
 			throw new SocketException("Unable to obtain host name", _lasterr());
 		return std.string.toString(cast(char*)result).dup;
 	}
-	
+
 	/// Remote endpoint Address.
 	Address remoteAddress()
 	{
@@ -1355,7 +1353,7 @@
 		assert(addr.addressFamily() == _family);
 		return addr;
 	}
-	
+
 	/// Local endpoint Address.
 	Address localAddress()
 	{
@@ -1366,10 +1364,10 @@
 		assert(addr.addressFamily() == _family);
 		return addr;
 	}
-	
+
 	/// Send or receive error code.
 	const int ERROR = _SOCKET_ERROR;
-	
+
 	/**
 	 * Send data on the connection. Returns the number of bytes actually
 	 * sent, or ERROR on failure. If the socket is blocking and there is no
@@ -1382,13 +1380,13 @@
 		int sent = .send(sock, buf.ptr, buf.length, cast(int)flags);
 		return sent;
 	}
-	
+
 	/// ditto
 	int send(void[] buf)
 	{
 		return send(buf, SocketFlags.NOSIGNAL);
 	}
-	
+
 	/**
 	 * Send data to a specific destination Address. If the destination address is not specified, a connection must have been made and that address is used. If the socket is blocking and there is no buffer space left, sendTo waits.
 	 */
@@ -1398,14 +1396,14 @@
 		int sent = .sendto(sock, buf.ptr, buf.length, cast(int)flags, to.name(), to.nameLen());
 		return sent;
 	}
-	
+
 	/// ditto
 	int sendTo(void[] buf, Address to)
 	{
 		return sendTo(buf, SocketFlags.NONE, to);
 	}
-	
-	
+
+
 	//assumes you connect()ed
 	/// ditto
 	int sendTo(void[] buf, SocketFlags flags)
@@ -1414,15 +1412,15 @@
 		int sent = .sendto(sock, buf.ptr, buf.length, cast(int)flags, null, 0);
 		return sent;
 	}
-	
-	
+
+
 	//assumes you connect()ed
 	/// ditto
 	int sendTo(void[] buf)
 	{
 		return sendTo(buf, SocketFlags.NONE);
 	}
-	
+
 
 	/**
 	 * Receive data on the connection. Returns the number of bytes actually
@@ -1439,13 +1437,13 @@
 		// if(!read) //connection closed
 		return read;
 	}
-	
+
 	/// ditto
 	int receive(void[] buf)
 	{
 		return receive(buf, SocketFlags.NONE);
 	}
-	
+
 	/**
 	 * Receive data and get the remote endpoint Address.
 	 * If the socket is blocking, receiveFrom waits until there is data to
@@ -1464,15 +1462,15 @@
 		// if(!read) //connection closed
 		return read;
 	}
-	
-	
+
+
 	/// ditto
 	int receiveFrom(void[] buf, out Address from)
 	{
 		return receiveFrom(buf, SocketFlags.NONE, from);
 	}
-	
-	
+
+
 	//assumes you connect()ed
 	/// ditto
 	int receiveFrom(void[] buf, SocketFlags flags)
@@ -1483,17 +1481,17 @@
 		// if(!read) //connection closed
 		return read;
 	}
-	
-	
+
+
 	//assumes you connect()ed
 	/// ditto
 	int receiveFrom(void[] buf)
 	{
 		return receiveFrom(buf, SocketFlags.NONE);
 	}
-	
 
-	/// Get a socket option. Returns the number of bytes written to result.	
+
+	/// Get a socket option. Returns the number of bytes written to result.
 	//returns the length, in bytes, of the actual result - very different from getsockopt()
 	int getOption(SocketOptionLevel level, SocketOption option, void[] result)
 	{
@@ -1502,30 +1500,30 @@
 			throw new SocketException("Unable to get socket option", _lasterr());
 		return len;
 	}
-	
 
-	/// Common case of getting integer and boolean options.	
+
+	/// Common case of getting integer and boolean options.
 	int getOption(SocketOptionLevel level, SocketOption option, out int32_t result)
 	{
 		return getOption(level, option, (&result)[0 .. 1]);
 	}
 
 
-	/// Get the linger option.	
+	/// Get the linger option.
 	int getOption(SocketOptionLevel level, SocketOption option, out linger result)
 	{
 		//return getOption(cast(SocketOptionLevel)SocketOptionLevel.SOCKET, SocketOption.LINGER, (&result)[0 .. 1]);
-		return getOption(level, option, (&result)[0 .. 1]); 
+		return getOption(level, option, (&result)[0 .. 1]);
 	}
-	
+
 	// Set a socket option.
 	void setOption(SocketOptionLevel level, SocketOption option, void[] value)
 	{
 		if(_SOCKET_ERROR == .setsockopt(sock, cast(int)level, cast(int)option, value.ptr, value.length))
 			throw new SocketException("Unable to set socket option", _lasterr());
 	}
-	
-	
+
+
 	/// Common case for setting integer and boolean options.
 	void setOption(SocketOptionLevel level, SocketOption option, int32_t value)
 	{
@@ -1539,7 +1537,7 @@
 		//setOption(cast(SocketOptionLevel)SocketOptionLevel.SOCKET, SocketOption.LINGER, (&value)[0 .. 1]);
 		setOption(level, option, (&value)[0 .. 1]);
 	}
-	
+
 
 	/**
 	 * Wait for a socket to change status. A wait timeout timeval or int microseconds may be specified; if a timeout is not specified or the timeval is null, the maximum timeout is used. The timeval timeout has an unspecified value when select returns. Returns the number of sockets with status changes, 0 on timeout, or -1 on interruption. If the return value is greater than 0, the SocketSets are updated to only contain the sockets having status changes. For a connecting socket, a write status change means the connection is established and it's able to send. For a listening socket, a read status change means there is an incoming connection request and it's able to accept.
@@ -1567,7 +1565,7 @@
 	{
 		fd_set* fr, fw, fe;
 		int n = 0;
-		
+
 		version(Win32)
 		{
 			// Windows has a problem with empty fd_set`s that aren't null.
@@ -1586,7 +1584,7 @@
 			{
 				fr = null;
 			}
-			
+
 			if(checkWrite)
 			{
 				fw = checkWrite.toFd_set();
@@ -1599,7 +1597,7 @@
 			{
 				fw = null;
 			}
-			
+
 			if(checkError)
 			{
 				fe = checkError.toFd_set();
@@ -1613,9 +1611,9 @@
 				fe = null;
 			}
 		}
-		
+
 		int result = .select(n, fr, fw, fe, cast(_ctimeval*)tv);
-		
+
 		version(Win32)
 		{
 			if(_SOCKET_ERROR == result && WSAGetLastError() == WSAEINTR)
@@ -1630,10 +1628,10 @@
 		{
 			static assert(0);
 		}
-		
+
 		if(_SOCKET_ERROR == result)
 			throw new SocketException("Socket select error", _lasterr());
-		
+
 		return result;
 	}
 
@@ -1641,21 +1639,21 @@
 	/// ditto
 	static int select(SocketSet checkRead, SocketSet checkWrite, SocketSet checkError, int microseconds)
 	{
-		timeval tv;
-		tv.seconds = microseconds / 1_000_000;
- 	    tv.microseconds = microseconds % 1_000_000;
-		return select(checkRead, checkWrite, checkError, &tv);
+	    timeval tv;
+	    tv.seconds = microseconds / 1_000_000;
+	    tv.microseconds = microseconds % 1_000_000;
+	    return select(checkRead, checkWrite, checkError, &tv);
 	}
-	
-	
+
+
 	/// ditto
 	//maximum timeout
 	static int select(SocketSet checkRead, SocketSet checkWrite, SocketSet checkError)
 	{
 		return select(checkRead, checkWrite, checkError, null);
 	}
-	
-	
+
+
 	/+
 	bool poll(events)
 	{
@@ -1674,14 +1672,14 @@
 	{
 		super(family, SocketType.STREAM, ProtocolType.TCP);
 	}
-	
+
 	/// Constructs a blocking TCP Socket.
 	this()
 	{
 		this(cast(AddressFamily)AddressFamily.INET);
 	}
-	
-	
+
+
 	//shortcut
 	/// Constructs a blocking TCP Socket and connects to an InternetAddress.
 	this(Address connectTo)
@@ -1700,8 +1698,8 @@
 	{
 		super(family, SocketType.DGRAM, ProtocolType.UDP);
 	}
-	
-	
+
+
 	/// Constructs a blocking UDP Socket.
 	this()
 	{
diff -r 6a92bcae44c5 d/phobos/std/stdarg.d
--- a/d/phobos/std/stdarg.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/stdarg.d	Sat Jun 26 21:05:08 2010 +0100
@@ -14,13 +14,13 @@
 
 module std.stdarg;
 
-version (GNU) {
-    // va_list might be a pointer, but assuming so is not portable.
+version(GNU)
+{   // va_list might be a pointer, but assuming so is not portable.
     private import gcc.builtins;
     alias __builtin_va_list va_list;
-    
-    // va_arg is handled magically by the compiler
-} else {
+}
+else
+{   // va_arg is handled magically by the compiler
     alias void* va_list;
 }
 
@@ -39,5 +39,5 @@
 
 private import std.c.stdarg;
 /* The existence of std.stdarg.va_copy isn't standard.  Prevent
-   conflicts by using '__'. */
+      conflicts by using '__'. */
 alias std.c.stdarg.va_copy __va_copy;
diff -r 6a92bcae44c5 d/phobos/std/stdint.d
--- a/d/phobos/std/stdint.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/stdint.d	Sat Jun 26 21:05:08 2010 +0100
@@ -175,8 +175,8 @@
 }
 else
 {
-    alias int   intptr_t;
-    alias uint uintptr_t;
+alias int   intptr_t;
+alias uint uintptr_t;
 }
 
 /* Greatest width integer types */
diff -r 6a92bcae44c5 d/phobos/std/stdio.d
--- a/d/phobos/std/stdio.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/stdio.d	Sat Jun 26 21:05:08 2010 +0100
@@ -42,7 +42,7 @@
 	Have_fgetline;
 
     extern(C)
-    {
+{
 	char * fgetln(FILE *stream, size_t *len);
 	char * fgetline(FILE *stream, size_t *len);
 	int putc_unlocked(int, FILE*);
@@ -51,34 +51,34 @@
 	int getwc_unlocked(FILE*);
 	void flockfile(FILE*);
 	void funlockfile(FILE*);
-    }
-    
-    
+}
+
+
     static if (Have_getdelim)
-    {
+{
 	import gcc.config.unix;
 	extern(C) ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream);
-    }
+}
 
     static if (Have_Unlocked_Stdio)
-    {
-	alias flockfile FLOCK;
-	alias funlockfile FUNLOCK;
+{
+    alias flockfile FLOCK;
+    alias funlockfile FUNLOCK;
 	alias putc_unlocked FPUTC;
 	alias getc_unlocked FGETC;
 	static if (Have_Unlocked_Wide_Stdio)
-	{
+    {
 	    alias putwc_unlocked FPUTWC;
 	    alias getwc_unlocked FGETWC;
-	}
+    }
 	else
 	{
-	    alias fputwc FPUTWC;
-	    alias fgetwc FGETWC;
+    alias fputwc FPUTWC;
+    alias fgetwc FGETWC;
 	}
-    }
-    else
-    {
+}
+else
+{
 	private void fnop(FILE *) { }
 	alias fnop FLOCK;
 	alias fnop FUNLOCK;
@@ -86,7 +86,7 @@
 	alias fgetc FGETC;
 	alias fputwc FPUTWC;
 	alias fgetwc FGETWC;
-    }
+}
 }
 else
     static assert(0);
@@ -138,13 +138,13 @@
     {
 	static if (Have_Unlocked_Stdio)
 	{
-	    /* Do the file stream locking at the outermost level
-	     * rather than character by character.
-	     */
-	    FLOCK(fp);
-	    scope(exit) FUNLOCK(fp);
+    /* Do the file stream locking at the outermost level
+     * rather than character by character.
+     */
+    FLOCK(fp);
+    scope(exit) FUNLOCK(fp);
 	}
-	
+
 	void putc(dchar c)
 	{
 	    if (c <= 0x7F)
@@ -331,12 +331,12 @@
 	     * Read them and convert to chars.
 	     */
 	    static if (Have_fwide)
-	    {
+		    {
 
 	    static if (Have_Unlocked_Wide_Stdio)
-	    {
-		FLOCK(fp);
-		scope(exit) FUNLOCK(fp);
+		{
+	    FLOCK(fp);
+	    scope(exit) FUNLOCK(fp);
 	    }
 
 	    static if (wchar_t.sizeof == 2)
@@ -396,55 +396,55 @@
 	size_t s;
 	static if (Have_getdelim)
 	{
-	    size_t n = 0;
+	size_t n = 0;
 	    s = getdelim(&lineptr, &n, '\n', fp);
-	    scope(exit) free(lineptr);
+	scope(exit) free(lineptr);
 	    if (cast(ssize_t) s == -1)
-	    {
-		if (ferror(fp))
-		    StdioException();
-		buf.length = 0;		// end of file
-		return 0;
-	    }
+	{
+	    if (ferror(fp))
+		StdioException();
+	    buf.length = 0;		// end of file
+	    return 0;
+	}
 	}
 	else static if (Have_fgetln || Have_fgetline)
 	{
 	    static if (Have_fgetln)
 		lineptr = fgetln(fp, & s);
-	    else
+	else
 		lineptr = fgetline(fp, & s);
 	    if (lineptr is null)
-	    {
+	{
 		if (ferror(fp))
 		    StdioException();
 		buf.length = 0;		// end of file
 		return 0;
-	    }
-	}
-	else
-	{
-	    {
+    }
+		    }
+		    else
+		    {
+			{
 		static if (Have_Unlocked_Stdio)
-		{
+			    {
 		    FLOCK(fp);
 		    scope(exit) FUNLOCK(fp);
-		}
+	    }
 
 		buf.length = 0;
 		for (int c = void; (c = FGETC(fp)) != -1; )
 		{
-		    buf ~= c;
+			buf ~= c;
 		    if (c == '\n')
 			break;
 		}
 	    }
-	    if (ferror(fp))
-		StdioException();
-	    return buf.length;
-	}
+		if (ferror(fp))
+		    StdioException();
+		return buf.length;
+	    }
 	buf = buf.ptr[0 .. std.gc.capacity(buf.ptr)];
 	if (s <= buf.length)
-	{
+	    {
 	    buf.length = s;
 	    buf[] = lineptr[0 .. s];
 	}
diff -r 6a92bcae44c5 d/phobos/std/stream.d
--- a/d/phobos/std/stream.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/stream.d	Sat Jun 26 21:05:08 2010 +0100
@@ -191,6 +191,7 @@
 
   wchar[] readStringW(size_t length);
 
+
   /***
    * Read and return the next character in the stream.
    *
@@ -1889,7 +1890,7 @@
 			 out int share,
 			 out int createMode) {
     version (Win32) {
-    	share |= FILE_SHARE_READ | FILE_SHARE_WRITE;
+      share |= FILE_SHARE_READ | FILE_SHARE_WRITE;
       if (mode & FileMode.In) {
 	access |= GENERIC_READ;
 	createMode = OPEN_EXISTING;
@@ -1903,7 +1904,7 @@
       }
     }
     version (Unix) {
-    	share = 0666;
+      share = 0666;
       if (mode & FileMode.In) {
 	access = O_RDONLY;
       }
@@ -2397,7 +2398,7 @@
     writeBlock(bom.ptr, bom.length);
   }
 
-	override void write(byte x) { writeExact(&x, x.sizeof); }
+  override void write(byte x) { writeExact(&x, x.sizeof); }
   override void write(ubyte x) { writeExact(&x, x.sizeof); }
   void write(short x) { fixBO(&x,x.sizeof); writeExact(&x, x.sizeof); }
   void write(ushort x) { fixBO(&x,x.sizeof); writeExact(&x, x.sizeof); }
diff -r 6a92bcae44c5 d/phobos/std/string.d
--- a/d/phobos/std/string.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/string.d	Sat Jun 26 21:05:08 2010 +0100
@@ -48,6 +48,7 @@
 
 extern (C)
 {
+
     size_t wcslen(wchar *);
     int wcscmp(wchar *, wchar *);
 }
@@ -210,17 +211,22 @@
 
 /*********************************
  * Convert array of chars s[] to a C-style 0 terminated string.
+ * s[] must not contain embedded 0's.
  */
 
 char* toStringz(char[] s)
     in
     {
+	assert(memchr(s.ptr, 0, s.length) == null);
     }
     out (result)
     {
 	if (result)
-	{   assert(strlen(result) == s.length);
-	    assert(memcmp(result, s.ptr, s.length) == 0);
+	{
+	    auto slen = s.length;
+	    while (slen > 0 && s[slen-1] == '\0') --slen;
+	    assert(strlen(result) == slen);
+	    assert(memcmp(result, s.ptr, slen) == 0);
 	}
     }
     body
@@ -265,6 +271,14 @@
     char[] test = "";
     p = toStringz(test);
     assert(*p == 0);
+
+    test = "\0";
+    p = toStringz(test);
+    assert(*p == 0);
+
+    test = "foo\0";
+    p = toStringz(test);
+    assert(p[0] == 'f' && p[1] == 'o' && p[2] == 'o' && p[3] == 0);
 }
 
 /******************************************
diff -r 6a92bcae44c5 d/phobos/std/switcherr.d
--- a/d/phobos/std/switcherr.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/switcherr.d	Sat Jun 26 21:05:08 2010 +0100
@@ -16,8 +16,7 @@
 	this.filename = filename;
 
 	char[] buffer = new char[17 + filename.length + linnum.sizeof * 3 + 1];
-	int len = sprintf(buffer.ptr, "Switch Default %.*s(%u)",
-	    cast(int) filename.length, filename.ptr, linnum);
+	int len = sprintf(buffer.ptr, "Switch Default %.*s(%u)", filename, linnum);
 	super(buffer[0..len]);
     }
 
diff -r 6a92bcae44c5 d/phobos/std/system.d
--- a/d/phobos/std/system.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/system.d	Sat Jun 26 21:05:08 2010 +0100
@@ -50,12 +50,12 @@
 	Family family = Family.OSX;
     }
     else version (FreeBSD)
-     {
- 	Family family = Family.FreeBSD;
+    {
+	Family family = Family.FreeBSD;
     }
     else version (Solaris)
     {
- 	Family family = Family.Solaris;
+	Family family = Family.Solaris;
     }
     else version (NoSystem)
     {
diff -r 6a92bcae44c5 d/phobos/std/thread.d
--- a/d/phobos/std/thread.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/thread.d	Sat Jun 26 21:05:08 2010 +0100
@@ -60,6 +60,8 @@
 	stdfp start_addr, void* arglist, uint initflag,
 	thread_id* thrdaddr);
 
+private const uint  WAIT_TIMEOUT = 258;
+
 /**
  * The type of the thread handle used by the operating system.
  * For Windows, it is equivalent to a HANDLE from windows.d.
@@ -73,7 +75,7 @@
  */
 class ThreadError : Error
 {
-    this(char[] s)
+    this(string s)
     {
 	super("Thread error: " ~ s);
     }
@@ -138,11 +140,11 @@
      */
     void start()
     {
-	if (state != TS.INITIAL)
-	    error("already started");
-
 	synchronized (Thread.classinfo)
 	{
+	    if (state != TS.INITIAL)
+		error("already started");
+
 	    for (int i = 0; 1; i++)
 	    {
 		if (i == allThreads.length)
@@ -156,15 +158,17 @@
 		}
 	    }
 	    nthreads++;
-	}
 
-	state = TS.RUNNING;
-	hdl = _beginthreadex(null, cast(uint)stacksize, &threadstart, cast(void*)this, 0, &id);
-	if (hdl == cast(thread_hdl)0)
-	{   state = TS.FINISHED;
-	    synchronized (Thread.classinfo) allThreads[idx] = null;
-	    idx = -1;
-	    error("failed to start");
+	    state = TS.RUNNING;
+	    hdl = _beginthreadex(null, cast(uint)stacksize, &threadstart, cast(void*)this, 0, &id);
+	    if (hdl == cast(thread_hdl)0)
+	    {
+		allThreads[idx] = null;
+		nthreads--;
+		state = TS.FINISHED;
+		idx = -1;
+		error("failed to start");
+	    }
 	}
     }
 
@@ -203,8 +207,9 @@
 	}
     }
 
-    /*****************************
-     * Wait for this thread to terminate.
+    /******************************
+     * Wait for this thread to terminate or until milliseconds time has
+     * elapsed, whichever occurs first.
      * Simply returns if thread has already terminated.
      * Throws: $(B ThreadError) if the thread hasn't begun yet or
      * is called on itself.
@@ -217,9 +222,12 @@
 	{   DWORD dw;
 
 	    dw = WaitForSingleObject(hdl, milliseconds);
-            state = TS.FINISHED;
-            CloseHandle(hdl);
-            hdl = null;
+	    if (dw != WAIT_TIMEOUT)
+	    {
+		state = TS.FINISHED;
+		CloseHandle(hdl);
+		hdl = null;
+	    }
 	}
     }
 
@@ -250,7 +258,8 @@
 	INCREASE,	/// Increase thread priority
 	DECREASE,	/// Decrease thread priority
 	IDLE,		/// Assign thread low priority
-	CRITICAL	/// Assign thread high priority
+	CRITICAL,	/// Assign thread high priority
+	NORMAL,
     }
 
     /**
@@ -275,6 +284,9 @@
 	    case PRIORITY.CRITICAL:
 		nPriority = THREAD_PRIORITY_TIME_CRITICAL;
 		break;
+	    case PRIORITY.NORMAL:
+		nPriority = THREAD_PRIORITY_NORMAL;
+		break;
 	    default:
 		assert(0);
 	}
@@ -347,14 +359,14 @@
         {
             if (nthreads > 1)
             {
-                    thread_id thisid = GetCurrentThreadId();
+		thread_id thisid = GetCurrentThreadId();
 
-                for (int i = 0; i < allThreadsDim; i++)
-                    {
-                        Thread t = allThreads[i];
-                        if (t && t.id != thisid && t.state == TS.RUNNING)
-                        t.pause();
-                }
+		for (int i = 0; i < allThreadsDim; i++)
+		{
+		    Thread t = allThreads[i];
+		    if (t && t.id != thisid && t.state == TS.RUNNING)
+			t.pause();
+		}
             }
         }
     }
@@ -408,7 +420,7 @@
 
     int delegate() dg;
 
-    void error(char[] msg)
+    void error(string msg)
     {
 	throw new ThreadError(msg);
     }
@@ -436,12 +448,12 @@
 	}
 
 	debug (thread) printf("Ending thread %d\n", t.idx);
-	t.state = TS.TERMINATED;
         synchronized (Thread.classinfo)
         {
             allThreads[t.idx] = null;
+            nthreads--;
+	    t.state = TS.TERMINATED;
             t.idx = -1;
-            nthreads--;
         }
 	return result;
     }
@@ -563,7 +575,7 @@
 
 class ThreadError : Error
 {
-    this(char[] s)
+    this(string s)
     {
 	super("Thread error: " ~ s);
     }
@@ -799,40 +811,40 @@
 	if (state == TS.RUNNING)
 	{   
 	    version (GNU_pthread_suspend)
-	    {
+        {
 		if (pthread_suspend_np(id) != 0)
+                error("cannot pause");
+        }
+        else
+        {
+	        if (pthread_kill(id, SIGUSR1))
 		    error("cannot pause");
-	    }
-	    else
-	    {
-		if (pthread_kill(id, SIGUSR1))
-		    error("cannot pause");
-		else
+                else
 		    flagSuspend.wait();	// wait for acknowledgement
 	    }
-	}
-	else
-	    error("cannot pause");
-    }
+            }
+            else
+                error("cannot pause");
+        }
 
     void resume()
     {
 	if (state == TS.RUNNING)
-	{
+        {
 	    version (GNU_pthread_suspend)
 	    {
 		if (pthread_continue_np(id) != 0)
 		    error("cannot pause");
-	    }
+        }
+        else
+        {
+	        if (pthread_kill(id, SIGUSR2))
+		    error("cannot resume");
+            }
+	}
 	    else
-	    {
-		if (pthread_kill(id, SIGUSR2))
-		    error("cannot resume");
-	    }
+	        error("cannot resume");
 	}
-	else
-	    error("cannot resume");
-    }
 
     static void pauseAll()
     {
@@ -841,37 +853,37 @@
             if (nthreads > 1)
             {
                 pthread_t thisid = pthread_self();
-		int npause = 0;
+                int npause = 0;
 
-		for (int i = 0; i < allThreadsDim; i++)
-		{
-		    Thread t = allThreads[i];
-		    if (t && !pthread_equal(thisid, t.id) && t.state == TS.RUNNING)
-		    {
+                for (int i = 0; i < allThreadsDim; i++)
+                {
+                    Thread t = allThreads[i];
+                    if (t && !pthread_equal(thisid, t.id) && t.state == TS.RUNNING)
+                    {
 			version (GNU_pthread_suspend)
 			{
 			    if (pthread_suspend_np(id))
 				t.error("cannot pause");
 			}
-			else
+        		else
 			{
-			    if (pthread_kill(t.id, SIGUSR1))
-				t.error("cannot pause");
-			    else
-				npause++;	// count of paused threads
+                            if (pthread_kill(t.id, SIGUSR1))
+                        	t.error("cannot pause");
+                            else
+                            	npause++;	// count of paused threads
 			}
-		    }
-		}
+                    }
+                }
 
 		version (GNU_pthread_suspend)
 		    { }
 		else
 		{
-		    // Wait for each paused thread to acknowledge
-		    while (npause--)
-		    {
+                    // Wait for each paused thread to acknowledge
+                    while (npause--)
+                    {
 			flagSuspend.wait();
-		    }
+                    }
 		}
             }
         }
@@ -905,12 +917,12 @@
   private:
 
     static uint allThreadsDim;
- 
+
     // Set max to Windows equivalent for compatibility.
     // pthread_create will fail gracefully if stack limit
     // is reached prior to allThreads max.
     static Thread[0x400] allThreads;
- 
+
     version (GNU_pthread_suspend)
     {
 	// nothing
@@ -933,7 +945,7 @@
 
     int delegate() dg;
 
-    void error(char[] msg)
+    void error(string msg)
     {
 	throw new ThreadError(msg);
     }
@@ -971,7 +983,7 @@
 	// Need to set t.id here, because thread is off and running
 	// before pthread_create() sets it.
 	t.id = pthread_self();
-
+	
 	version(skyos)
 	    installSignalHandlers();
 
@@ -989,7 +1001,7 @@
 	}
 
 	debug (thread) printf("Ending thread %d\n", t.idx);
-	    t.state = TS.TERMINATED;
+	t.state = TS.TERMINATED;
         synchronized (Thread.classinfo)
         {
             allThreads[t.idx] = null;
@@ -1036,76 +1048,76 @@
     {
 	// nothing
     }
-    else
-    {
-    
+        else
+        {
+
 	private static void installSignalHandlers()
 	{
 	    int result;
 	    sigaction_t sigact;
 	    result = sigfillset(&sigact.sa_mask);
 	    if (result)
-		goto Lfail;
+	        goto Lfail;
 	    sigact.sa_handler = &pauseHandler;
 	    result = sigaction(SIGUSR1, &sigact, null);
 	    if (result)
-		goto Lfail;
+	        goto Lfail;
 	    sigact.sa_handler = &resumeHandler;
 	    result = sigaction(SIGUSR2, &sigact, null);
 	    if (result)
-		goto Lfail;
+	        goto Lfail;
 
 	    if (! flagSuspend.create())
-		goto Lfail;
+	        goto Lfail;
 
-	    return;
+	return;
 
-         Lfail:
+      Lfail:
 	    throw new ThreadError("cannot initialize threads");
-	}
+    }
 
 	
-	/**********************************
-	 * This gets called when a thread gets SIGUSR1.
-	 */
+        /**********************************
+         * This gets called when a thread gets SIGUSR1.
+         */
 
-	extern (C) static void pauseHandler(int sig)
-	{	int result;
+        extern (C) static void pauseHandler(int sig)
+        {	int result;
 
-	    // Save all registers on the stack so they'll be scanned by the GC
+    	// Save all registers on the stack so they'll be scanned by the GC
 	    __builtin_unwind_init();
 
 
-	    assert(sig == SIGUSR1);
+    	assert(sig == SIGUSR1);
 
-	    sigset_t sigmask;
-	    result = sigfillset(&sigmask);
-	    assert(result == 0);
-	    result = sigdelset(&sigmask, SIGUSR2);
-	    assert(result == 0);
+    	sigset_t sigmask;
+    	result = sigfillset(&sigmask);
+    	assert(result == 0);
+    	result = sigdelset(&sigmask, SIGUSR2);
+    	assert(result == 0);
 
-	    Thread t = getThis();
-	    t.stackTop = getESP();
-	    t.flags &= ~1;
+    	Thread t = getThis();
+    	t.stackTop = getESP();
+    	t.flags &= ~1;
 	    flagSuspend.signal();
-	    while (1)
-	    {
-		sigsuspend(&sigmask);	// suspend until SIGUSR2
-		if (t.flags & 1)		// ensure it was resumeHandler()
-		    break;
-	    }
-	}
+    	while (1)
+    	{
+    	    sigsuspend(&sigmask);	// suspend until SIGUSR2
+    	    if (t.flags & 1)		// ensure it was resumeHandler()
+    		break;
+    	}
+        }
 
-	/**********************************
-	 * This gets called when a thread gets SIGUSR2.
-	 */
+        /**********************************
+         * This gets called when a thread gets SIGUSR2.
+         */
 
-	extern (C) static void resumeHandler(int sig)
-	{
-	    Thread t = getThis();
+        extern (C) static void resumeHandler(int sig)
+        {
+    	Thread t = getThis();
 
-	    t.flags |= 1;
-	}
+    	t.flags |= 1;
+        }
     }
 
     public static void* getESP()
@@ -1115,8 +1127,8 @@
 	void * p = & dummy + 1; // +1 doesn't help much; also assume stack grows down
 	p = cast(void*)( (cast(size_t) p) & ~(size_t.sizeof - 1));
 	return p;
+	}
     }
-}
 
 
 }
@@ -1150,7 +1162,7 @@
 	TS getState()
 	{
 	    return TS.RUNNING;
-	}
+}
 
 	public static void* getESP()
 	{
diff -r 6a92bcae44c5 d/phobos/std/typeinfo/ti_C.d
--- a/d/phobos/std/typeinfo/ti_C.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/typeinfo/ti_C.d	Sat Jun 26 21:05:08 2010 +0100
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2004-2005 by Digital Mars, www.digitalmars.com
+ *  Copyright (C) 2004-2008 by Digital Mars, www.digitalmars.com
  *  Written by Walter Bright
  *
  *  This software is provided 'as-is', without any express or implied
@@ -30,8 +30,7 @@
     hash_t getHash(void *p)
     {
 	Object o = *cast(Object*)p;
-	assert(o);
-	return o.toHash();
+	return o ? o.toHash() : 0;
     }
 
     int equals(void *p1, void *p2)
diff -r 6a92bcae44c5 d/phobos/std/uni.d
--- a/d/phobos/std/uni.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/uni.d	Sat Jun 26 21:05:08 2010 +0100
@@ -614,7 +614,7 @@
 	assert(0);		// should have been in table
     }
     else
-    return 1;
+	return 1;
 }
 
 unittest
diff -r 6a92bcae44c5 d/phobos/std/uri.d
--- a/d/phobos/std/uri.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/uri.d	Sat Jun 26 21:05:08 2010 +0100
@@ -406,10 +406,10 @@
     char[] r;
 
     r = encode(s);
-    debug(uri) printf("r = '%.*s'\n", cast(int) r.length, r.ptr);
+    debug(uri) printf("r = '%.*s'\n", r);
     assert(r == t);
     r = decode(t);
-    debug(uri) printf("r = '%.*s'\n", cast(int) r.length, r.ptr);
+    debug(uri) printf("r = '%.*s'\n", r);
     assert(r == s);
 
     r = encode( decode("%E3%81%82%E3%81%82") );
diff -r 6a92bcae44c5 d/phobos/std/windows/charset.d
--- a/d/phobos/std/windows/charset.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/windows/charset.d	Sat Jun 26 21:05:08 2010 +0100
@@ -13,7 +13,6 @@
 private import std.utf;
 private import std.string;
 
-
 /******************************************
  * Converts the UTF-8 string s into a null-terminated string in a Windows
  * 8-bit character set.
diff -r 6a92bcae44c5 d/phobos/std/windows/registry.d
--- a/d/phobos/std/windows/registry.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/windows/registry.d	Sat Jun 26 21:05:08 2010 +0100
@@ -933,7 +933,7 @@
         catch(RegistryException x)
         {
             assert(x.error == code);
-            /+
+/+
             if(string != x.toString())
             {
                 printf( "UnitTest failure for RegistryException:\n"
@@ -942,7 +942,7 @@
                     ,   string.length, string);
             }
             assert(message == x.msg);
-            +/
++/
         }
     }
     catch(Exception /* x */)
diff -r 6a92bcae44c5 d/phobos/std/zip.d
--- a/d/phobos/std/zip.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/zip.d	Sat Jun 26 21:05:08 2010 +0100
@@ -1,4 +1,5 @@
 // Written in the D programming language.
+
 /**
  * Read/write data in the $(LINK2 http://www.info-_zip.org, zip archive) format.
  * Makes use of the etc.c.zlib compression library.
@@ -72,8 +73,8 @@
     {
     void print()
     {
-	printf("name = '%.*s'\n", cast(int) name.length, name.ptr);
-	printf("\tcomment = '%.*s'\n", cast(int) comment.length, comment.ptr);
+	printf("name = '%.*s'\n", name);
+	printf("\tcomment = '%.*s'\n", comment);
 	printf("\tmadeVersion = x%04x\n", madeVersion);
 	printf("\textractVersion = x%04x\n", extractVersion);
 	printf("\tflags = x%04x\n", flags);
@@ -125,7 +126,7 @@
 	printf("\tdiskStartDir = %u\n", diskStartDir);
 	printf("\tnumEntries = %u\n", numEntries);
 	printf("\ttotalEntries = %u\n", totalEntries);
-	printf("\tcomment = '%.*s'\n", cast(int) comment.length, comment.ptr);
+	printf("\tcomment = '%.*s'\n", comment);
     }
     }
 
@@ -320,7 +321,7 @@
 		endcommentlength = getUshort(i + 20);
 		if (i + 22 + endcommentlength > data.length)
 		    continue;
-		comment = cast(string)data[i + 22 .. i + 22 + endcommentlength];
+		comment = cast(string)(data[i + 22 .. i + 22 + endcommentlength]);
 		endrecOffset = i;
 		break;
 	    }
@@ -381,11 +382,11 @@
 	    if (i + namelen + extralen + commentlen > directoryOffset + directorySize)
 		throw new ZipException("invalid directory entry 2");
 
-	    de.name = cast(string)data[i .. i + namelen];
+	    de.name = cast(string)(data[i .. i + namelen]);
 	    i += namelen;
 	    de.extra = data[i .. i + extralen];
 	    i += extralen;
-	    de.comment = cast(string)data[i .. i + commentlen];
+	    de.comment = cast(string)(data[i .. i + commentlen]);
 	    i += commentlen;
 
 	    directory[de.name] = de;
diff -r 6a92bcae44c5 d/phobos/std/zlib.d
--- a/d/phobos/std/zlib.d	Tue Jun 22 15:17:14 2010 -0400
+++ b/d/phobos/std/zlib.d	Sat Jun 26 21:05:08 2010 +0100
@@ -18,7 +18,7 @@
 
 module std.zlib;
 
- //debug=zlib;		// uncomment to turn on debugging printf's
+//debug=zlib;		// uncomment to turn on debugging printf's
 
 private import etc.c.zlib, std.stdint;
 
